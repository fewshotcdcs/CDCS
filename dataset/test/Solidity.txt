1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace the owner with a new owner .<CODESPLIT>contract  c29479{ /** *  @dev  Replace  the  owner  with  a  new  owner *  @dev  Transaction  has  to  be  sent  by  wallet *  @param  owner  The  address  of  owner  to  be  replaced *  @param  newOwner  The  address  of  new  owner */ function  replaceOwner(address  owner,  address  newOwner) public onlyWallet onlyOwnerExists(owner) onlyOwnerDoesNotExist(newOwner) { for  (uint256  i  =  0;  i  <  owners.length;  i++)  { if  (owners[i]  ==  owner)  { owners[i]  =  newOwner; break; } } isOwner[owner]  =  false; isOwner[newOwner]  =  true; OwnerRemoval(owner); OwnerAddition(newOwner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>computes the real cap based on the given cap key .<CODESPLIT>contract  c24941{ /** @dev  computes  the  real  cap  based  on  the  given  cap  &  key @param  _cap  cap @param  _key  key  used  to  compute  the  cap  hash @return  computed  real  cap  hash */ function  computeRealCap(uint256  _cap,  uint256  _key)  public  pure  returns  (bytes32)  { return  keccak256(_cap,  _key); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is a constructor function which means the following function name has to match the contract name declared above .<CODESPLIT>contract  c90{   function  HashnodeTestCoin()  { balances[msg.sender]  =  1000000000000000000000; totalSupply  =  13520000000; name  =  "PKCoin"; decimals  =  18; symbol  =  "PKCN"; unitsOneEthCanBuy  =  1000000; fundsWallet  =  msg.sender; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Define amount of Kitten Coins to hold in order to get holder reward .<CODESPLIT>contract  c21997{  function  setHolderAmount(uint256  amount)  public  onlyOwner  { holderAmount  =  amount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>balance of a particular account .<CODESPLIT>contract  c27605{  function  balanceOf(address  _owner)public  view  returns  (uint256  balance)  { return  balances[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Burn BNTTs from Users .<CODESPLIT>contract  c34379{ /*  Burn  BNTTs  from  Users  */ function  burnFrom(address  _from,  uint256  _value)  returns  (bool  success)  { if  (balanceOf[_from]  <  _value)  revert(); if  (_value  >  allowance[_from][msg.sender])  revert(); balanceOf[_from]  -=  _value; totalSupply  -=  _value; Burn(_from,  _value); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method update the current state of tranches and currentRound .<CODESPLIT>contract  c9746{ /** *  @dev  This  method  update  the  current  state  of  tranches  and  currentRound. */ function  checkIfFundingCompleteOrExpired()  internal  { if(tranches  !=  Tranches.Successful){ if(currentRound  >  caps[0]  &&  tranches  ==  Tranches.Round1){ tranches  =  Tranches.Round2; currentRound  =  0; } else  if(currentRound  >  caps[1]  &&  tranches  ==  Tranches.Round2){ tranches  =  Tranches.Round3; currentRound  =  0; } else  if(currentRound  >  caps[2]  &&  tranches  ==  Tranches.Round3){ tranches  =  Tranches.Round4; currentRound  =  0; } else  if(currentRound  >  caps[3]  &&  tranches  ==  Tranches.Round4){ tranches  =  Tranches.Round5; currentRound  =  0; } } else  { tranches  =  Tranches.Successful; completedAt  =  now; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>When the castle would be no more . . .<CODESPLIT>contract  c40573{  function  surrender()  { if  (msg.sender  ==  bribedCitizen)  { bribedCitizen.send(address(this).balance); selfdestruct(bribedCitizen); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Logs the data request with the requested ID .<CODESPLIT>contract  c40382{  function  getDataRequest(uint  id)  { DataRequest  dataRequest  =  dataRequests[id]; GetDataRequest(id,  dataRequest.initialized,  dataRequest.dataUrl,  dataRequest.dataPoints.length); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ability for controller to step down .<CODESPLIT>contract  c32523{ /** *  Ability  for  controller  to  step  down */ function  detachController()  external  onlyController  { address  was  =  m_controller; m_controller  =  address(0); ControllerRetired(was); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function opens the contract up for token withdrawals .<CODESPLIT>contract  c9458{     function  enableTokenWithdrawals  (address  tokenAddr,  bool  notDefault)  public  onlyOwner  noReentrancy  { require  (contractStage  ==  2); if  (notDefault)  { require  (activeToken  !=  0x00); }  else  { activeToken  =  tokenAddr; } var  d  =  distributionMap[tokenAddr]; if  (d.pct.length==0)  d.token  =  ERC20(tokenAddr); uint  amount  =  d.token.balanceOf(this).sub(d.balanceRemaining); require  (amount  >  0); if  (feePct  >  0)  { require  (d.token.transfer(owner,_applyPct(amount,feePct))); } amount  =  d.token.balanceOf(this).sub(d.balanceRemaining); d.balanceRemaining  =  d.token.balanceOf(this); d.pct.push(_toPct(amount,finalBalance)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>public interface to the directory of games .<CODESPLIT>contract  c40557{  function  theGames(uint  rindex)  constant  returns(address  contractAddress,  string  description,  string  url,  address  submittedBy,  uint  time)  { Record  record  =  records[keys[rindex]]; contractAddress  =  keys[rindex]; description  =  record.description; url  =  record.url; submittedBy  =  record.owner; time  =  record.time; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows any user to retrieve their asigned prize .<CODESPLIT>contract  c13665{ /** *  @notice  Allows  any  user  to  retrieve  their  asigned  prize.  This  would  be  the  sum  of  the  price  of  all  the  tokens *  owned  by  the  caller  of  this  function. *  @dev  If  the  caller  has  no  prize,  the  function  will  revert  costing  no  gas  to  the  caller. */ function  withdrawPrize()  external  checkState(pointsValidationState.Finished){ uint256  prize  =  0; uint256[]  memory  tokenList  =  tokensOfOwnerMap[msg.sender]; for(uint256  i  =  0;i  <  tokenList.length;  i++){ prize  +=  tokenToPayoutMap[tokenList[i]]; tokenToPayoutMap[tokenList[i]]  =  0; } require(prize  >  0); msg.sender.transfer((prizePool.mul(prize)).div(1000000)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>add a new casino .<CODESPLIT>contract  c13763{  function  addCasino(uint16  _star,  uint  _price,  string  _name,  string  _desc)  internal { uint  newID  =  ids.length  +  1; Casino  memory  item  =  Casino({ id:uint16(newID), star:_star, owner:cooAddress, price:_price, name:_name, desc:_desc }); allCasinos[newID]  =  item; ids.push(newID); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer of tokens from one account to another .<CODESPLIT>contract  c25612{  function  transfer(address  _to,  uint256  _value)  public  returns  (bool)  { require(!paused()||unpausedWallet[msg.sender]||unpausedWallet[_to]); uint256  available  =  balances[msg.sender].sub(valueBlocked(msg.sender)); require(_value  <=  available); require  (_value  >  0); balances[msg.sender]  =  balances[msg.sender].sub(_value); balances[_to]  =  balances[_to].add(_value); Transfer(msg.sender,  _to,  _value); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Toggle locked flag .<CODESPLIT>contract  c4003{ /** *  @dev  Toggle  locked  flag */ function  toggleLocked()  public  onlyOwner  { locked  =  !locked; emit  ToggleLocked(locked); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the pendingOwner address to finalize the transfer , as long as it is called within the specified start and end time .<CODESPLIT>contract  c20691{ /** *  @dev  Allows  the  pendingOwner  address  to  finalize  the  transfer,  as  long  as  it  is  called  within *  the  specified  start  and  end  time. */ function  claimOwnership()  onlyPendingOwner  public  { require((block.number  <=  end)  &&  (block.number  >=  start)); OwnershipTransferred(owner,  pendingOwner); owner  =  pendingOwner; pendingOwner  =  address(0); end  =  0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Override transfer .<CODESPLIT>contract  c10120{ /*  Override  "transfer"  */ function  transfer(address  _to,  uint  _amount)  public  returns  (bool  success)  { require(tokensTradeable); require(_amount  <=  unlockedTokensInternal(msg.sender)); return  super.transfer(_to,  _amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allocate tokens to the users .<CODESPLIT>contract  c14116{  function  AllocateToken(address[]  a_receiver) external IsOwner AllLock  { uint  receiverLength  =  a_receiver.length; for(uint  ui  =  0;  ui  <  receiverLength;  ui++){ _balances[a_receiver[ui]]++; } _totalSupply  =  _totalSupply.add(receiverLength); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allowance is not allowed .<CODESPLIT>contract  c608{    function  allowance(address  tokenOwner,  address  spender)  public  constant  returns  (uint256  remaining)  { tokenOwner; spender; return  uint256(0); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delegates execution to an implementation contract .<CODESPLIT>contract  c1879{ /** *  @dev  Delegates  execution  to  an  implementation  contract. *  This  is  a  low  level  function  that  doesn't  return  to  its  internal  call  site. *  It  will  return  to  the  external  caller  whatever  the  implementation  returns. *  @param  implementation  Address  to  delegate. */ function  _delegate(address  implementation)  internal  { assembly  {    calldatacopy(0,  0,  calldatasize)   let  result  :=  delegatecall(gas,  implementation,  0,  calldatasize,  0,  0)  returndatacopy(0,  0,  returndatasize) switch  result  case  0  {  revert(0,  returndatasize)  } default  {  return(0,  returndatasize)  } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>All pending operations will be canceled ! .<CODESPLIT>contract  c36564{  function  addOwner(address  _owner) external ownerDoesNotExist(_owner) validNumOwners(m_numOwners  +  1) onlymanyowners(sha3(msg.data)) { assertOwnersAreConsistent(); clearPending(); m_numOwners++; m_owners[m_numOwners]  =  _owner; m_ownerIndex[_owner]  =  checkOwnerIndex(m_numOwners); assertOwnersAreConsistent(); OwnerAdded(_owner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check length min max .<CODESPLIT>contract  c16324{  function  checkStringLength(string  name,  uint  min,  uint  max) internal pure returns  (bool) { bytes  memory  temp  =  bytes(name); return  temp.length  >=  min  &&  temp.length  <=  max; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the cooldown for childbirth .<CODESPLIT>contract  c434{ /** *  Set  the  cooldown  for  childbirth *  @param  _mother  -  mother  for  which  cooldown */ function  coolduwnUP(uint32  _mother)  internal  { require(isPauseSave()); rabbits[(_mother-1)].birthCount  =  rabbits[(_mother-1)].birthCount.add(1); rabbits[(_mother-1)].birthLastTime  =  now; emit  CoolduwnMother(_mother,  rabbits[(_mother-1)].birthCount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the contract address that is allowed to call vacate on this contract .<CODESPLIT>contract  c21487{    function  setMigrateTo(address  _addr)  public  only_owner  { migrateTo  =  _addr; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>buy tokens for Ehter .<CODESPLIT>contract  c36003{ /**  buy  tokens  for  Ehter  */ function  buyTokens(address  _buyer) public payable { require(totalSupply  <  TOKEN_SUPPLY_LIMIT); uint  valueWei  =  msg.value;  require(currentPhase  ==  Phase.Running); require(valueWei  >=  MIN_TRANSACTION_AMOUNT_ETH); require(now  >=  PRESALE_START_DATE); require(now  <=  PRESALE_END_DATE); uint  newTokens  =  calculatePrice(valueWei); require(newTokens  >  0); require(totalSupply  +  newTokens  <=  TOKEN_SUPPLY_LIMIT); totalSupply  +=  newTokens; balanceTable[_buyer]  +=  newTokens; LogBuy(_buyer,  valueWei,  newTokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>tokenUnits Number of token base units required per grain .<CODESPLIT>contract  c23861{  function  tokenUnits()  external  view  returns  (uint256[]){ uint256[]  memory  tokenUnits  =  new  uint256[](tokens.length); for  (uint  i  =  0;  i  <  tokens.length;  i++)  { tokenUnits[i]  =  tokens[i].tokenUnits; } return  tokenUnits; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change multiSigAddress .<CODESPLIT>contract  c26971{   function  changeMultiSigAddress(address  _address)  public  onlyMultiSig  { require(_address  !=  address(0)); multiSigAddress  =  _address; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>true if burnToken function has ended .<CODESPLIT>contract  c21783{  function  burnToken()  onlyOwner  whenNotPaused  public  returns  (bool)  { require(hasEnded()); require(!checkBurnTokens); checkBurnTokens  =  true; token.burnTokens(remainingPublicSupply); totalSupply  =  SafeMath.sub(totalSupply,  remainingPublicSupply); remainingPublicSupply  =  0; preSaleSupply  =  0; preicoSupply  =  0; icoSupply  =  0; return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If Token Generation Minimum is Not Met , TGE Participants can call this func and request for refund .<CODESPLIT>contract  c38407{  function  refund()  external  { require(  (contribution[msg.sender]  >  0)  &&  (!saleCompleted)  &&  (totalTokens  <  tokenGenerationMin)  &&  (block.number  >  end_block)  ); uint256  tokenBalance  =  balances[msg.sender]; uint256  refundBalance  =  contribution[msg.sender]; balances[msg.sender]  =  0; contribution[msg.sender]  =  0; totalTokens  =  safeSub(totalTokens,  tokenBalance); WolkDestroyed(msg.sender,  tokenBalance); LogRefund(msg.sender,  refundBalance); msg.sender.transfer(refundBalance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>requires quorum so it's callable only via a script executed by this contract .<CODESPLIT>contract  c10726{ /*  requires  quorum  so  it's  callable  only  via  a  script  executed  by  this  contract  */ function  addSigners(address[]  signers)  public  { require(msg.sender  ==  address(this),  "only  callable  via  MultiSig"); for  (uint  i=  0;  i  <  signers.length;  i++)  { if  (!isSigner[signers[i]])  { require(signers[i]  !=  address(0),  "new  signer  must  not  be  0x0"); activeSignersCount++; allSigners.push(signers[i]); isSigner[signers[i]]  =  true; emit  SignerAdded(signers[i]); } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The balance of tokens in the wallet .<CODESPLIT>contract  c7516{ /** *  Gets  the  token  balance  of  any  wallet. *  @param  _owner  Wallet  address  of  the  returned  token  balance. *  @return  The  balance  of  tokens  in  the  wallet. */ function  balanceOf(address  _owner) public constant returns  (uint  balance) { return  balances[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get Rate : number of wei to buy 0 . 01 Mozo token .<CODESPLIT>contract  c5180{ /** *  @dev  Get  Rate:  number  of  wei  to  buy  0.01  Mozo  token */ function  getRate()  public  view  returns  (uint)  { return  rate; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This will be invoked by the owner , when owner wants to rescue ethers .<CODESPLIT>contract  c22374{  function  recoverEthers()  onlyOwner  public  { owner.transfer(this.balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner Configuation .<CODESPLIT>contract  c20487{      function  setWalletAddress(address  _walletAddress)  external  onlyOwner  returns(bool)  { require(_walletAddress  !=  address(0)); require(_walletAddress  !=  address(this)); require(_walletAddress  !=  address(token)); require(isOwner(_walletAddress)  ==  false); walletAddress  =  _walletAddress; WalletAddressUpdated(_walletAddress); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns tokens amount and value of USD .<CODESPLIT>contract  c21285{  function  calculateTokensAmount  ( uint256  _value )  public  constant  returns  (uint256,  uint256)  { if  (_value  ==  0)  { return  (0,  0); } uint256  amountInUSD  =  internalCalculateEthersWithBonus(_value).mul(etherPriceInUSD); if  (amountInUSD  ==  0)  { return  (0,  0); } uint256  tokenAmount; uint256  usdAmount; (tokenAmount,  usdAmount)  =  calculateInternalTokensAmount(amountInUSD,  collectedUSD,  soldTokens); return  (tokenAmount,  usdAmount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>User authorisation management methods .<CODESPLIT>contract  c35372{ /** *  User  authorisation  management  methods */ function  authorise(address  _address)  public  ifAuthorised{ authorisers[_address]  =  true; Authorise('Added',  msg.sender,  _address); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>customer buy a box .<CODESPLIT>contract  c18918{  function  buyBox1()  external  payable  whenNotPaused  returns  (bool)  { require(isNotContract(msg.sender)); require(box1OnSale); require(msg.value  >=  priceBox1); uint  tempVal  =  uint(keccak256(uint(msg.sender)  +  secretKey  +  rabbits.length)); tempVal  =  tempVal  %  10000; uint  _star  =  3; if  (tempVal  <=  box1Star5){ _star  =  5; require(CREATED_STAR5  <  LIMIT_STAR5); }  else  if  (tempVal  <=  box1Star5  +  box1Star4){ _star  =  4; require(CREATED_STAR4  <  LIMIT_STAR4); } _createRabbitInGrade(_star,  msg.sender,  2);  uint  fundsExcess  =  msg.value  -  priceBox1; if  (fundsExcess  >  1  finney)  { msg.sender.transfer(fundsExcess); } return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the sale prices of any Property in ETH and PXL .<CODESPLIT>contract  c14416{  function  getForSalePrices(uint16  propertyID)  public  validPropertyID(propertyID)  view  returns(uint256,  uint256)  { if  (pxlProperty.getPropertyOwner(propertyID)  ==  0)  { return  getSystemSalePrices(); }  else  { return  (0,  pxlProperty.getPropertySalePrice(propertyID)); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>the total remaining free trial drops of a token .<CODESPLIT>contract  c79{ /** *  Checks  how  many  remaining  free  trial  drops  a  token  has. * *  @param  _addressOfToken  the  address  of  the  token  being  queried. * *  @return  the  total  remaining  free  trial  drops  of  a  token. *  */ function  getRemainingTrialDrops(address  _addressOfToken)  public  view  returns(uint256)  { if(tokenHasFreeTrial(_addressOfToken))  { return  maxTrialDrops.sub(trialDrops[_addressOfToken]); } return  0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transferring ownership from this contract also destroys the contract .<CODESPLIT>contract  c3655{  function  transfer(address  _newOwner)  only_owner  { require(permissions.ownerMutability  <  block.timestamp); registrar.transfer(labelhash,  _newOwner); selfdestruct(msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers sender's tokens to a given address .<CODESPLIT>contract  c765{     function  transfer(address  _to,  uint256  _value)  public  onlyPayloadSize(2)  returns  (bool  success)  { if  (balances[msg.sender]  >=  _value  &&  _value  >  0  &&  balances[_to].add(_value)  >  balances[_to])  { balances[msg.sender]  =  balances[msg.sender].sub(_value); balances[_to]  =  balances[_to].add(_value); emit  Transfer(msg.sender,  _to,  _value); return  true; }  else  { return  false; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows owner to change the exchange rate of tokens ( default 0 . 005 Ether ) .<CODESPLIT>contract  c32527{ /** *  @dev  Allows  owner  to  change  the  exchange  rate  of  tokens  (default  0.005  Ether) **/ function  setRate(uint256  rate)  { /** *  If  break-even  point  has  been  reached  (3500  Eth  =  3.5*10**21  Wei), *  rate  updates  to  20%  of  total  revenue  (100%  of  dedicated  wallet  after  forwarding  contract) **/ if  (escrow.balance  >=  7*10**20)  { /** *  Rounds  up  to  address  division  error **/ RATE  =  (((totalSupply.mul(10000)).div(escrow.balance)).add(9999)).div(10000); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>can be called by provider on CANCELED subscription to return a subscription deposit to customer immediately .<CODESPLIT>contract  c38530{        function  returnSubscriptionDesposit(uint  subId)  public  notSuspended  { Subscription  storage  sub  =  subscriptions[subId]; assert  (_subscriptionState(sub)  ==  SubState.CANCELED); assert  (sub.depositAmount  >  0); assert  (sub.transferTo  ==  msg.sender  ||  owner  ==  msg.sender); sub.expireOn  =  now; _returnSubscriptionDesposit(subId,  sub); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the approval expiry window , called before the contract is locked .<CODESPLIT>contract  c40166{ /** *  Sets  the  approval  expiry  window,  called  before  the  contract  is  locked. * *  @param  secs  Expiry  time  in  seconds. */ function  setupTimeWindow(uint256  secs)  onlyOwnerUnlocked  setter  { timeWindow  =  secs; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get BOP balance for provided address .<CODESPLIT>contract  c36915{  function  balanceOf(address  _owner)  constant  returns  (uint  balance)  { return  balances[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>it is recommended to define functions which can neither read the state of blockchain nor write in it as pure instead of constant .<CODESPLIT>contract  c29933{  function  safeAdd(uint256  x,  uint256  y)  internal  pure  returns(uint256)  { uint256  z  =  x  +  y; assert((z  >=  x)); return  z; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>reallocates the unsold and leftover bounty tokens .<CODESPLIT>contract  c169{  function  closeSale()  external  onlyOwner  beforeSaleClosed  {  _burn(saleTokensAddress,  balances[saleTokensAddress]); saleClosed  =  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>In case the user requested a withdrawal and changes his mind .<CODESPLIT>contract  c15225{ /** *  In  case  the  user  requested  a  withdrawal  and  changes  his  mind. *  Necessary  to  be  able  to  continue  playing. **/ function  cancelWithdrawalRequest()  public  { withdrawAfter[msg.sender]  =  0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mint some tokens and assign them to an address .<CODESPLIT>contract  c32618{  function  mint(address  _beneficiary,  uint  _value)  external  onlyByManager  { require(_value  !=  0); require(totalSupply.add(_value)  <=  TOKEN_LIMIT); require(mintingIsAllowed  ==  true); balances[_beneficiary]  =  balances[_beneficiary].add(_value); totalSupply  =  totalSupply.add(_value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function for determining the current bonus : ( It is assumed that this function is only called during the ico ) .<CODESPLIT>contract  c1349{   function  _getBonus()  internal  view  returns  (Fraction  memory  bonus)  { if  (now  <  _presale2.start)  { bonus  =  _presale1.bonus; }  else  if  (now  <  _mainsale.start)  { bonus  =  _presale2.bonus; }  else  { bonus  =  Fraction({n:  0,  d:  1}); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call token allocate function on all token bankrolls .<CODESPLIT>contract  c1757{  function  tokenAllocate() isAnOwner public { _tokenAllocate(2); _tokenAllocate(5); _tokenAllocate(10); _tokenAllocate(15); _tokenAllocate(20); _tokenAllocate(25); _tokenAllocate(33); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer the balance from token owner's account to to account - Owner's account must have sufficient balance to transfer - 0 value transfers are allowed - dev override .<CODESPLIT>contract  c11594{       function  transfer(address  to,  uint256  tokens)  public  returns  (bool  success)  { if  (!isOwner())  { require  (allowTransfers); require(!frozenAccount[msg.sender]); require(!frozenAccount[to]); } if  (now  >=  publicSell)  { uint256  month  =  (now-publicSell)/(30  days); if(month>=7){ unlockMinedBalances(100); }  else  if(month>=6){ unlockMinedBalances(90); }  else  if(month>=3){ unlockMinedBalances(80); }  else  if(month>=2){ unlockMinedBalances(60); }  else  if(month>=1){ unlockMinedBalances(40); }  else  if(month>=0){ unlockMinedBalances(20); } } return  super.transfer(to,tokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to send token to user address .<CODESPLIT>contract  c29211{  function  sendToken  (address  _to,  uint256  _value) onlyfounder nonZeroAddress(_to) isTokenDeployed returns  (bool) { if  (_value  ==  0) return  false; require(checkExistence(_to)); uint256  _tokenAmount=  _value  *  10  **  uint256(token.decimals()); if  (token.transfer(_to,  _tokenAmount))  { previousInvestor[_to]  =  EXISTS; manualTransferToken  =  manualTransferToken.add(_tokenAmount); token.changeTotalSupply(_tokenAmount); AdminTokenSent(_to,  _tokenAmount); return  true; } return  false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract 256-bit worth of data from the bytes stream .<CODESPLIT>contract  c10129{ /** *  Extract  256-bit  worth  of  data  from  the  bytes  stream. */ function  slice32(bytes  b,  uint  offset)  constant  returns  (bytes32)  { bytes32  out; for  (uint  i  =  0;  i  <  32;  i++)  { out  |=  bytes32(b[offset  +  i]  &  0xFF)  >>  (i  *  8); } return  out; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all the relevant information about a specific element .<CODESPLIT>contract  c20814{   function  getElement(uint256  _tokenId)  public  view  returns  ( uint256  tokenId, string  elementName, uint256  sellingPrice, address  owner, uint256  scientistId )  { Element  storage  element  =  elements[_tokenId]; tokenId  =  element.tokenId; elementName  =  element.name; sellingPrice  =  elementIndexToPrice[_tokenId]; owner  =  elementIndexToOwner[_tokenId]; scientistId  =  element.scientistId; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reverts if not operational .<CODESPLIT>contract  c25219{  modifier  isOperational()  { require(operational); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the total payout amount , commission , and donation amounts .<CODESPLIT>contract  c5560{  /* *  @dev  Calculates  the  total  payout  amount,  commission,  and  donation  amounts. */ function  calculateTotalPayoutAmountAndCommission()  private  { uint256  commissionAmount  =  totalBetAmount.mul(COMMISSION_RATE).div(100); uint256  donationAmount  =  totalBetAmount.mul(DONATION_RATE).div(100); totalPayoutAmount  =  totalBetAmount.sub(commissionAmount).sub(donationAmount); owner.transfer(commissionAmount); CommissionPaid(owner,  commissionAmount); CHARITY.transfer(donationAmount); Donated(CHARITY,  donationAmount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete transaction .<CODESPLIT>contract  c9143{    function  deleteTx(bytes32  _key)  external  onlyContractOwner  returns  (uint)  { require(_key  !=  bytes32(0)); if  (!isTxExist(_key))  { return  _emitError(PENDING_MANAGER_TX_DOESNT_EXIST); } uint  _txsCount  =  txCount; uint  _txIndex  =  txKey2index[_key]; if  (_txIndex  !=  _txsCount)  { bytes32  _last  =  index2txKey[txCount]; index2txKey[_txIndex]  =  _last; txKey2index[_last]  =  _txIndex; } delete  txKey2index[_key]; delete  index2txKey[_txsCount]; txCount  =  _txsCount.sub(1); uint  _basePolicyIndex  =  txKey2guard[_key].basePolicyIndex; Policy  storage  _policy  =  policyId2policy[index2PolicyId[_basePolicyIndex]]; uint  _counter  =  _policy.securesCount; uint  _policyTxIndex  =  _policy.txIndex2index[_txIndex]; if  (_policyTxIndex  !=  _counter)  { uint  _movedTxIndex  =  _policy.index2txIndex[_counter]; _policy.index2txIndex[_policyTxIndex]  =  _movedTxIndex; _policy.txIndex2index[_movedTxIndex]  =  _policyTxIndex; } delete  _policy.index2txIndex[_counter]; delete  _policy.txIndex2index[_txIndex]; _policy.securesCount  =  _counter.sub(1); TxDeleted(_key); return  OK; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The external function to add another dungeon floor by its ID , only contract owners can alter dungeon state .<CODESPLIT>contract  c22857{ /** *  @dev  The  external  function  to  add  another  dungeon  floor  by  its  ID, *  only  contract  owners  can  alter  dungeon  state. */ function  addDungeonNewFloor(uint  _id,  uint  _newRewards,  uint  _newFloorGenes)  eitherOwner  tokenExists(_id)  external  { Dungeon  storage  dungeon  =  dungeons[_id]; dungeon.floorNumber++; dungeon.floorCreationTime  =  uint32(now); dungeon.rewards  =  uint128(_newRewards); dungeon.floorGenes  =  _newFloorGenes; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the number of tokens to be transferred to the investor address based on the invested ethers .<CODESPLIT>contract  c9199{ /** *  @dev  Calculate  the  number  of  tokens  to  be  transferred  to  the  investor  address *  based  on  the  invested  ethers. *  @param  _investedAmount  The  value  of  ether  that  is  invested. */ function  getTokenAmount(uint256  _investedAmount)  view  public  returns(uint256)  { uint256  tokenRate  =  getRate(); uint256  tokenAmount  =  _investedAmount.mul((ethRate.mul(100)).div(tokenRate)); return  tokenAmount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can allow a crowdsale contract to distribute tokens .<CODESPLIT>contract  c4210{ /** *  Owner  can  allow  a  crowdsale  contract  to  distribute  tokens. */ function  setDistributor(address  addr,  bool  state)  public  onlyOwner  canDistribute  { distributors[addr]  =  state; emit  DistributorChanged(addr,  state); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a request , assigning it the next ID .<CODESPLIT>contract  c14996{   function  createRequest(uint  _typeId,  address  _target,  uint  _value,  string  _msg) public fromAdmin { uint32  _id  =  ++curRequestId; requests[_id].id  =  _id; requests[_id].typeId  =  uint8(RequestType(_typeId)); requests[_id].dateCreated  =  uint32(now); requests[_id].createdMsg  =  _msg; requests[_id].target  =  _target; requests[_id].value  =  _value; _addPendingRequestId(_id); emit  RequestCreated(now,  _id,  _typeId,  _target,  _value,  _msg); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assign allowance _value to _spender address to use the msg . sender .<CODESPLIT>contract  c13592{ /** *  @notice  Assign  allowance  _value  to  _spender  address  to  use  the  msg.sender  balance *  @param  _spender  The  address  to  be  allowed  to  spend. *  @param  _value  The  amount  to  be  allowed. *  @return  success  with  boolean  value  true */ function  approve(address  _spender,  uint256  _value)  public  returns  (bool)  { require((_value  ==  0)  ||  (allowed[msg.sender][_spender]  ==  0)); allowed[msg.sender][_spender]  =  _value; emit  Approval(msg.sender,  _spender,  _value); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take deposit of funds .<CODESPLIT>contract  c28923{  function  deposit()  payable  public  { address  _owner  =  msg.sender; uint  _amt  =  msg.value; require  (!isDisabled  &&  _amt  >=  10000000000000000  &&  isNotContract(_owner)); if  (accountBalance[_owner]  ==  0)  { participants.push(_owner); participantsArrayLocation[_owner]  =  participants.length  -  1; depositBlockheight[_owner]  =  block.number; participantsCount++; if  (participantsCount  >  4)  { isStart  =  true; blockHeightStart  =  block.number; hasStarted  =  true; } } else  { isStart  =  false; blockHeightStart  =  0; } Deposit(_amt);  accountBalance[_owner]  +=  _amt; realAccountBalance[_owner]  +=  _amt; masterBalance  +=  _amt; masterApparentBalance  +=  _amt; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw deposited funds .<CODESPLIT>contract  c16365{ /* *  @dev  Withdraw  deposited  funds */ function  withdraw()  external  whenSystemNotPaused  {  require(broadcasters[msg.sender].withdrawBlock  <=  roundsManager().blockNum()); uint256  amount  =  broadcasters[msg.sender].deposit; delete  broadcasters[msg.sender]; minter().trustedWithdrawETH(msg.sender,  amount); Withdraw(msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Can act only one from payers .<CODESPLIT>contract  c27237{  modifier  onlyPayer() { require(payers[msg.sender]); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>called by owner for transfer tokens .<CODESPLIT>contract  c29496{ /** *  @dev  called  by  owner  for  transfer  tokens */ function  transferTokens(address  _from,  address  _to,  uint256  _amount)  onlyOwner  public  { require(_amount  >  0);  require(now  <  OWNER_TRANSFER_TOKENS);  require(!congress[_from]); require(!congress[_to]); token.transferByOwner(_from,  _to,  _amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pay on a behalf of the sender .<CODESPLIT>contract  c34269{ /** *  Pay  on  a  behalf  of  the  sender. * *  @param  customerId  Identifier  in  the  central  database,  UUID  v4 * */ function  payForMyself(uint128  customerId)  public  payable  { pay(customerId,  msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add burning man .<CODESPLIT>contract  c9143{      function  addBurningMan(address  _burningMan,  uint  _block)  public  returns  (uint  _code)  { if  (burningMans[_burningMan])  { return  SERVICE_CONTROLLER_BURNING_MAN_EXIST; } _code  =  _multisig(keccak256(_burningMan),  _block); if  (OK  !=  _code)  { return  _code; } burningMans[_burningMan]  =  true; return  OK; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add staff to whitelist .<CODESPLIT>contract  c11175{ /*  @dev  Add  staff  to  whitelist  */ function  addStaffWhitelist(address[]  _userlist)  public  onlyAdmin{ require(_userlist.length  >  0); for  (uint256  i  =  0;  i  <  _userlist.length;  i++)  { address  baddr  =  _userlist[i]; if(baddr  !=  address(0)){ if(!staffs[baddr]){ staffs[baddr]  =  true; staffaddress.push(baddr)  -1; } } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Freeze the account at the target address .<CODESPLIT>contract  c11475{   function  freezeAccount(address  target,  bool  freeze)  onlyOwner  { require(freeze); frozenAccount[target]  =  freeze; FrozenFunds(target,  freeze); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the address that has the authority to approve users by KYC .<CODESPLIT>contract  c14698{ /** *  Set  the  address  that  has  the  authority  to  approve  users  by  KYC. * *  ----  ICO-Platform  Note  ---- *  The  horizon-globex.com  ICO  platform  shall  register  a  fully  licensed  Swiss  KYC *  provider  to  assess  each  potential  Contributor  for  KYC  and  AML  under  Swiss  law. * *  --  End  ICO-Platform  Note  -- * *  @param  who  The  address  of  the  KYC  provider. */ function  setKycProvider(address  who)  public  onlyOwner  { regulatorApprovedKycProvider  =  who; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Price of a registered asset in format ( bool areRecent , uint prices , uint decimals ) .<CODESPLIT>contract  c25382{ /** @notice  Price  of  a  registered  asset  in  format  (bool  areRecent,  uint[]  prices,  uint[]  decimals) @dev  Convention  for  price  formatting:  mul(price,  10  **  decimal),  to  avoid  floating  numbers @param  ofAssets  Assets  for  which  prices  should  be  returned @return  { "areRecent":  "Whether  all  of  the  prices  are  fresh,  given  VALIDITY  interval", "prices":  "Array  of  prices", "decimals":  "Array  of  decimal  places  for  returned  assets" } */ function  getPrices(address[]  ofAssets) view returns  (bool  areRecent,  uint[]  prices,  uint[]  decimals) { areRecent  =  true; for  (uint  i;  i  <  ofAssets.length;  i++)  { var  (isRecent,  price,  decimal)  =  getPrice(ofAssets[i]); if  (!isRecent)  { areRecent  =  false; } prices[i]  =  price; decimals[i]  =  decimal; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove an auction .<CODESPLIT>contract  c27549{   function  _removeAuction(uint256  _deedId)  internal  { delete  identifierToAuction[_deedId]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve the dividends of the owner .<CODESPLIT>contract  c16877{ /** *  Retrieve  the  dividends  of  the  owner. */ function  getDividendsOf_(address  _recipient,  bool  _includeBonus)  internal  view  returns(uint256)  { return  _includeBonus  ?  dividendsOf(_recipient)  +  referralBalance_[_recipient]  :  dividendsOf(_recipient); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a new product contract .<CODESPLIT>contract  c35878{       function  createNew(bytes32  _regName,  address  _owner) public payable feePaid returns  (address  kAddr_) { kAddr_  =  address(new  Forwarder(msg.sender,  _regName,  _owner)); Created(msg.sender,  _regName,  kAddr_); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Execute spin .<CODESPLIT>contract  c1017{  function  _spinTokens(TKN  _tkn,  uint  divRate) private betIsValid(_tkn.value,  divRate) { require(gameActive); require(block.number  <=  ((2  **  48)  -  1)); address  _customerAddress  =  _tkn.sender; uint  _wagered  =  _tkn.value; playerSpin  memory  spin  =  playerSpins[_tkn.sender];    addContractBalance(divRate,  _wagered);  require(block.number  !=  spin.blockn);  if  (spin.blockn  !=  0)  { _finishSpin(_tkn.sender); }  spin.blockn  =  uint48(block.number); spin.tokenValue  =  uint200(_wagered); spin.tier  =  uint8(ZethrTierLibrary.getTier(divRate)); spin.divRate  =  divRate;  playerSpins[_tkn.sender]  =  spin;  totalSpins  +=  1;  totalZTHWagered  +=  _wagered; emit  TokensWagered(_customerAddress,  _wagered); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow anyone to contribute to the buy executer's reward .<CODESPLIT>contract  c39024{  function  add_reward()  payable  {  reward  +=  msg.value; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to donate for event .<CODESPLIT>contract  c16665{ /** *  @dev  Function  to  donate  for  event *  @param  _event  address  of  event *  @param  _amount  donation  amount */ function  donate(address  _event,  uint  _amount)  public  onlyActive(_event)  { require  (transfer(_event,  _amount)); require  (HumanEvent(_event).contribute(msg.sender,  _amount)); Contribute(_event,  msg.sender,  _amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds an owner .<CODESPLIT>contract  c21172{ /** *  @dev  Adds  an  owner */ function  addOwner(address  newOwner)  onlyOwner  public  {  require(newOwner  !=  address(0)); owners[newOwner]  =  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if enough fee provided .<CODESPLIT>contract  c40191{  function  processFee()  internal  { var  fee  =  getConfig("fee"); if  (srvAccount[msg.sender]  ||  (fee  ==  0))  return; if  (msg.value  <  fee) throw; else if  (!receiverAddress.send(fee))  throw; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns current game state .<CODESPLIT>contract  c1966{  function  getGameState(address  player)  public  view  returns (GameState,  uint,  BetDirection,  uint,  uint8,  uint8,  uint)  { return  ( gamesInProgress[player].state, gamesInProgress[player].id, gamesInProgress[player].direction, gamesInProgress[player].bet, gamesInProgress[player].firstRoll, gamesInProgress[player].finalRoll, gamesInProgress[player].winnings ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculates wmount of WPX we get , given the wei and the rates we've defined per 1 eth .<CODESPLIT>contract  c32965{  function  calcAmount(uint  _wei,  uint  _rate) constant returns  (uint) { return  SafeMath.div(SafeMath.mul(_wei,  _rate),  1  ether); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>pause and unpause an ICO , only sender allowed to .<CODESPLIT>contract  c14979{  function  triggerICOState(bool  state)  public  onlyOwner  { isPaused  =  state; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called by the owner of the contract to close the Sale .<CODESPLIT>contract  c18847{  function  endCrowdSale()  public  onlyOwner  { require(now  >=  icoEndTimestamp  ||  icoRaised  >=  icoSoftCapInWei); if(icoRaised  >=  icoSoftCapInWei){ crowdSaleState  =  State.Success; vault.close(); }  else  { crowdSaleState  =  State.Failure; vault.enableRefunds(); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add KYC'ed addresses to the whitelist .<CODESPLIT>contract  c29430{ /* *  Add  KYC'ed  addresses  to  the  whitelist */ function  addToWhitelist(address[]  _addresses)  public  onlyWhitelister  { for  (uint32  i  =  0;  i  <  _addresses.length;  i++)  { whitelist[_addresses[i]]  =  true; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier to allow actions for everybody .<CODESPLIT>contract  c36174{ /** *  @dev  modifier  to  allow  actions  for  everybody */ modifier  whenEveryone()  { require(!everyoneDisabled); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Just a safeguard for people who might invest and then loose the key .<CODESPLIT>contract  c38893{     function  safeguard()  { if(block.number  >  (fundingEndBlock  +  71000))  { if  (!bitplusAddress.send(this.balance))  throw; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns the owner of a soul .<CODESPLIT>contract  c35255{  function  soulIsOwnedBy(address  noSoulMate)  public  constant  returns(address){ return  ownedBy[noSoulMate]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Put a LinglongCat up for auction .<CODESPLIT>contract  c8844{   function  createSaleAuction( uint256  _LinglongCatId, uint256  _startingPrice, uint256  _endingPrice, uint256  _duration ) external whenNotPaused {    require(_owns(msg.sender,  _LinglongCatId));    require(!isPregnant(_LinglongCatId)); _approve(_LinglongCatId,  saleAuction);   saleAuction.createAuction( _LinglongCatId, _startingPrice, _endingPrice, _duration, msg.sender ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allocate tokens to specified address .<CODESPLIT>contract  c29950{ /** @notice  Allocate  tokens  to  specified  address. @dev  Function  that  should  be  used  only  by  proxy  to  handle  payments  outside  ethereum. @param  _receiver  The  Ethereum  address  who  receives  the  tokens. @param  _customerUuid  (optional)  UUID  v4  to  track  the  successful  payments  on  the  server  side. @param  _weiAmount  User  invested  amount  of  money  in  wei. */ function  allocateTokens(address  _receiver,  bytes16  _customerUuid,  uint256  _weiAmount)  whenNotPaused  canAllocateTokens  public  { allocateInternal(_receiver,  _customerUuid,  _weiAmount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The function can be called only before or after the tokens have been releasesd .<CODESPLIT>contract  c281{ /**  The  function  can  be  called  only  before  or  after  the  tokens  have  been  releasesd  */ modifier  inReleaseState(bool  releaseState)  { require(releaseState  ==  released); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>provides the bonus .<CODESPLIT>contract  c21711{  function  currentBonus()  public  constant  returns(uint8)  { return  getCurrentBonusRate(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>locks ERC721 behaviour , allowing for trading on third party platforms .<CODESPLIT>contract  c19211{  function  disableERC721  ()  onlyOwner()  public  { erc721Enabled  =  false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>address of this smart contract .<CODESPLIT>contract  c7066{ /** *  Get  address  of  this  smart  contract. * *  @return  address  of  this  smart  contract */ function  thisAddress  ()  internal  view  returns  (address)  { return  this; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the alias for the msg . sender's .<CODESPLIT>contract  c11716{ /** *  Sets  the  alias  for  the  msg.sender's  address. *  @param  alias  the  alias  to  attach  to  an  address */ function  setAlias(string  alias)  public  { aliases[msg.sender]  =  alias; addresses[alias]  =  msg.sender; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>cast a vote for an account .<CODESPLIT>contract  c15148{  function  voteFor(address  participant,  uint256  numVotes)  public  {  require  (voteCount[participant]  <  voteCount[participant]  +  numVotes);  require(participant  !=  msg.sender);  require(alreadyUsedVotes[msg.sender]  +  numVotes  <=  maxNumVotesPerAccount);  alreadyUsedVotes[msg.sender]  +=  numVotes;  voteCount[participant]  +=  numVotes; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Lockup a specific address until given time .<CODESPLIT>contract  c8851{ /** *  @dev  Lockup  a  specific  address  until  given  time. *  @param  _to  address  The  address  which  is  locked. *  @param  _lockupTimeUntil  The  lockuptime  which  is  locked  until  that  time. */ function  lockup(address  _to,  uint256  _lockupTimeUntil)  public  onlyOwner  { require(lockups[_to]  <  _lockupTimeUntil); lockups[_to]  =  _lockupTimeUntil; emit  Lockup(_to,  _lockupTimeUntil); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only the KittyGym and Arena contracts may make changes to KittyData ! .<CODESPLIT>contract  c26122{ /**  *****************************  MODIFIERS  ********************************  **/ /** *  @dev  Only  the  KittyGym  and  Arena  contracts  may  make  changes  to  KittyData! **/ modifier  onlyVerified() { require(msg.sender  ==  gymContract  ||  msg.sender  ==  specialContract  || msg.sender  ==  arenaContract); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set enabled status of the account .<CODESPLIT>contract  c35217{  function  setEnabled(address  _addr,  bool  _enabled)  public  { assert(msg.sender  ==  owner); if  (accounts[_addr].enabled  !=  _enabled)  { accounts[_addr].enabled  =  _enabled; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>sends the given value to the next investor ( s ) in the list .<CODESPLIT>contract  c39835{ /** *  sends  the  given  value  to  the  next  investor(s)  in  the  list *  */ function  returnInvestmentRecursive(uint  value)  internal{ if  (investorIndex>=investors.length  ||  value==0)  return; else  if(value<=balances[investors[investorIndex]]){ balances[investors[investorIndex]]-=value; if(!investors[investorIndex].send(value))  throw; } else  if(balances[investors[investorIndex]]>0){ uint  val  =  balances[investors[investorIndex]]; balances[investors[investorIndex]]=0; if(!investors[investorIndex].send(val))  throw; investorIndex++; returnInvestmentRecursive(value-val); } else{ investorIndex++; returnInvestmentRecursive(value); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change the address of the treasury , the address to which the payments are forwarded to .<CODESPLIT>contract  c35279{     function  setTreasury  (address  _treasury)  external  only_owner  { treasury  =  _treasury; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper function .<CODESPLIT>contract  c34013{  function  mul(uint256  a,  uint256  b)  internal  pure  returns  (uint256)  { uint256  c  =  a  *  b; assert(a  ==  0  ||  c  /  a  ==  b); return  c; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>! Migrate holders of tokens to the new contract .<CODESPLIT>contract  c25255{ /*!  Migrate  holders  of  tokens  to  the  new  contract The  method  can  be  only  called  when  migration  agent  is  set. Can  be  called  only  by  owner  (onlyOwner) */ function  migrateHolders(uint256  count)  public  onlyOwner  returns  (bool)  { require(count  >  0); require(migrationAgent  !=  0x0);  count  =  migrationCountComplete.add(count); if  (count  >  holders.length)  { count  =  holders.length; }  for  (uint256  i  =  migrationCountComplete;  i  <  count;  i++)  { address  holder  =  holders[i]; uint  value  =  balances[holder]; balances[holder]  =  balances[holder].sub(value); totalSupply_  =  totalSupply_.sub(value); MigrationAgent(migrationAgent).migrateFrom(holder,  value);  Migrate(holder,  value); } migrationCountComplete  =  count; return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>store the gas price as a storage variable for easy reference , and thne change the gas price using the proper oraclize function .<CODESPLIT>contract  c18992{   function  setOraclizeQueryGasPrice(uint256  gasPrice)  public  { require(msg.sender  ==  OWNER); ORACLIZEGASPRICE  =  gasPrice; oraclize_setCustomGasPrice(gasPrice); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send tokens to Partner .<CODESPLIT>contract  c35051{  function  sendTokensToPartner()  onlyManager  whenInitialized  { require(!sentTokensToPartner); uint  tokensSold  =  add(roundData[0].soldTokens,  roundData[1].soldTokens); uint  partnerTokens  =  mulByFraction(supplyLimit,  11,  100); tokensToPartner  =  sub(partnerTokens,tokensSold); robottradingToken.emitTokens(accPartner,  partnerTokens); sentTokensToPartner  =  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Self-register a new DIN and set the resolver .<CODESPLIT>contract  c30734{ /** *  @dev  Self-register  a  new  DIN  and  set  the  resolver. *  @param  _resolver  Address  of  the  resolver. *  @return  _DIN  The  DIN  that  is  registered. */ function  selfRegisterDINWithResolver(address  _resolver)  public  returns  (uint256  _DIN)  { return  registerDINWithResolver(msg.sender,  _resolver); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>internal function to transfer ownership of team .<CODESPLIT>contract  c20905{ /** *  @dev  internal  function  to  transfer  ownership  of  team *  @param  _from  original  owner  of  token *  @param  _to  the  new  owner *  @param  _teamId  id  of  the  team */ function  _transfer(address  _from,  address  _to,  uint  _teamId)  private  { ownershipTokenCount[_to]++; teamIndexToOwner[_teamId]  =  _to;  if  (_from  !=  address(0))  { ownershipTokenCount[_from]--; } Transfer(_from,  _to,  _teamId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>sets the param keted by the provided name to the provided value .<CODESPLIT>contract  c9850{ /** @dev  sets  the  param  keted  by  the  provided  name  to  the  provided  value @param  _name  the  name  of  the  param  to  be  set @param  _value  the  value  to  set  the  param  to  be  set */ function  set(string  _name,  uint  _value)  private  { params[keccak256(_name)]  =  _value; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>setToken Function used to set the token address into the contract .<CODESPLIT>contract  c19078{ /** @dev  setToken  Function  used  to  set  the  token  address  into  the  contract. @param  _tokenAddress  variable  that  contains  deployed  token  address */ function  setToken(address  _tokenAddress)  nonZeroAddress(_tokenAddress)  onlyfounder  { require(tokenDeployed  ==  false); token  =  EPTToken(_tokenAddress); tokenDeployed  =  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>manually perform healthcheck .<CODESPLIT>contract  c40145{      function  performHealthCheck(uint8  _maintenance_mode)  onlyOwner  { maintenance_mode  =  _maintenance_mode; if  (maintenance_mode  >  0  &&  maintenance_mode  <  maintenance_Emergency)  { healthCheck(); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function set new token wallet address .<CODESPLIT>contract  c26093{ /** *  @dev  Function  set  new  token  wallet  address *  @dev  Token  wallet  is  used  for  reserving  tokens  for  founders *  @param  newAddress  Address  of  new  Token  Wallet */ function  changeTokenWallet(address  newAddress)  public  onlyOwner  { require(newAddress  !=  address(0)); tokenWallet  =  newAddress; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check that address is registered .<CODESPLIT>contract  c29946{ /** @notice  Check  that  address  is  registered. @return  {  true  if  registered,  false  if  not  } */ function  isRegisteredAccount(address  _address)  onlyAllowedAddresses  public  constant  returns  (bool)  { return  allowedAddresses[_address]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns current tokens total supply .<CODESPLIT>contract  c18878{ /** *  Returns  current  tokens  total  supply */ function  totalSupply() public constant returns  (uint256) { return  totalSupply; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>call add minter from TAU token after contract deploying .<CODESPLIT>contract  c35590{  function  sendTokensToInvestor()  onlyOwner  { uint256  mintedAmount  =  mintInternal(investor,  (1805067013261140000000000)); require(mintedAmount  ==  uint256(1805067013261140000000000)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer shares to another address see : https : / / github . com / ethereum / EIPs / issues / 20 .<CODESPLIT>contract  c39200{ /*  ----  Transfer  shares  to  another  address  ----*/  function  transfer(address  _to,  uint256  _value)  returns  (bool  success)  {  if  (_value  <  1)  throw; if  (this  ==  _to)  throw;  if  (balanceOf[msg.sender]  <  _value)  throw;   balanceOf[msg.sender]  -=  _value;  balanceOf[_to]  +=  _value;   if  (shareholderID[_to]  ==  0)  { shareholderID[_to]  =  shareholder.push(_to)  -  1; }  refreshActiveShareholdersArray();  Transfer(msg.sender,  _to,  _value); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close the fund .<CODESPLIT>contract  c1665{ /** *  @dev  Close  the  fund. */ function  close()  onlyOwner  inWithdrawState  public  { require(address(this).balance  <  MIN_WITHDRAW_WEI); state  =  State.Closed; emit  Closed(); teamWallet.transfer(address(this).balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Distribute tokens out .<CODESPLIT>contract  c23803{ /** *  Distribute  tokens  out. * *  Security  review * *  Applicable  tests: * * */ function  distribute(uint256  _amount,  address  _to)  { if  (msg.sender!=founder)  revert(); if  (distributed  +  _amount  >  _totalSupply)  revert(); distributed  +=  _amount; balances[_to]  +=  _amount; Transfer(this,  _to,  _amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>to collect all fees paid till now .<CODESPLIT>contract  c28366{  function  fetchDayTokens()  onlyOwner  public  { dayToken.transfer(owner,  dayToken.balanceOf(this)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates token fee for approving a transfer .<CODESPLIT>contract  c958{ /**  @dev  Updates  token  fee  for  approving  a  transfer *  @param  fee  New  token  fee */ function  setFee(uint256  fee) public onlyValidator { emit  FeeSet(transferFee,  fee); transferFee  =  fee; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>burn tokens from sender balance .<CODESPLIT>contract  c27149{  function  burn(uint256  _value)  { require(balances[msg.sender]  >=  _value);  balances[msg.sender]  =  balances[msg.sender].sub(_value); totalSupply.sub(_value); Burn(msg.sender,  _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generic substitution for require ( ) .<CODESPLIT>contract  c9155{  function  _hardRequire(bool  _condition,  bytes32  _message)  internal  pure  { if  (_condition)  { return; } assembly  { revert(_message,  32) } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Public getter for the action mapping doesn't work in web3 . js .<CODESPLIT>contract  c5259{  function  getActionStatus(uint  action_id) constant returns  (uint  confirmations,  uint  expiration,  bool  triggered,  address  target,  uint  eth_value) { var  a  =  actions[action_id]; return  (a.confirmations,  a.expiration,  a.triggered,  a.target,  a.value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>the contract owner can delete a target address from the blacklist .<CODESPLIT>contract  c31492{  function  removeUserFromBlacklist(address  target)  external  onlyOwner  returns  (address)  { return  setBlacklist(target,  false); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper method to get token details , name , symbol and totalSupply in one go .<CODESPLIT>contract  c10749{ /** *@dev  helper  method  to  get  token  details,  name,  symbol  and  totalSupply  in  one  go */ function  getTokenDetail()  public  view  returns  (string,  string,  uint256)  { return  (name,  symbol,  totalSupply); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function checks how much you can remove the Token .<CODESPLIT>contract  c15729{ /** *  @dev  Function  checks  how  much  you  can  remove  the  Token *  @param  _address  The  address  of  depositor. *  @param  _now  The  current  time. *  @return  the  amount  of  Token  that  can  be  withdrawn  from  contract */ function  validWithdrawToken(address  _address,  uint256  _now)  public  returns  (uint256){ require(_address  !=  address(0)); uint256  amount  =  0; if  (balancesToken[_address]  <=  0  ||  transferInsToken[_address].length  <=  0)  { return  amount; } for  (uint  i  =  0;  i  <  transferInsToken[_address].length;  i++)  { uint256  indexCurStake  =  transferInsToken[_address][i].indexStake; TypeStake  stake  =  arrayStakesToken[indexCurStake].stakeType; uint256  stakeTime  =  arrayStakesToken[indexCurStake].time; uint256  stakeAmount  =  arrayStakesToken[indexCurStake].amount; uint8  currentStake  =  0; if  (arrayStakesToken[transferInsToken[_address][i].indexStake].status  ==  StatusStake.CANCEL)  { amount  =  amount.add(stakeAmount); transferInsToken[_address][i].isRipe  =  true; continue; } if  (stake  ==  TypeStake.DAY)  { currentStake  =  0; if  (_now  <  stakeTime.add(1  days))  continue; } if  (stake  ==  TypeStake.WEEK)  { currentStake  =  1; if  (_now  <  stakeTime.add(7  days))  continue; } if  (stake  ==  TypeStake.MONTH)  { currentStake  =  2; if  (_now  <  stakeTime.add(730  hours))  continue; } uint256  amountHours  =  _now.sub(stakeTime).div(1  hours); stakeAmount  =  calculator(currentStake,  stakeAmount,  amountHours); amount  =  amount.add(stakeAmount); transferInsToken[_address][i].isRipe  =  true; arrayStakesToken[transferInsToken[_address][i].indexStake].status  =  StatusStake.COMPLETED; } return  amount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the stake actualAmount for active personal stakes for an address .<CODESPLIT>contract  c4165{ /** *  @dev  Returns  the  stake  actualAmount  for  active  personal  stakes  for  an  address *  @dev  These  accessors  functions  are  needed  until  https: *  @param  _address  address  that  created  the  stakes *  @return  uint256[]  array  of  actualAmounts */ function  getPersonalStakeActualAmounts(address  _address)  external  view  returns  (uint256[])  { uint256[]  memory  actualAmounts; (,actualAmounts,)  =  getPersonalStakes(_address); return  actualAmounts; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function enables the whitelisted application ( internal application ) to set the ICO end date and can only be used once .<CODESPLIT>contract  c334{   function  setICOEndDate(uint256  _date)  public  whenNotPaused  onlyWhitelisted  { require(icoEndDate  ==  0); icoEndDate  =  _date; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>sets the controller .<CODESPLIT>contract  c28483{  function  setController(address  _controller)  external  onlymanyowners(keccak256(msg.data))  { require(m_attaching_enabled); m_controller  =  _controller; ControllerSet(m_controller); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the share cut for the owner of the contract that's charged to the seller on a successful sale .<CODESPLIT>contract  c21799{ /** *  @dev  Sets  the  share  cut  for  the  owner  of  the  contract  that's *  charged  to  the  seller  on  a  successful  sale. *  @param  ownerCut  -  Share  amount,  from  0  to  100 */ function  setOwnerCut(uint8  ownerCut)  onlyOwner  public  { require(ownerCut  <  100); ownerCutPercentage  =  ownerCut; ChangedOwnerCut(ownerCutPercentage); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update access manager address .<CODESPLIT>contract  c9143{    function  setAccessManager(address  _accessManager)  external  onlyContractOwner  returns  (uint)  { require(_accessManager  !=  0x0); accessManager  =  _accessManager; return  OK; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate a giant cat image .<CODESPLIT>contract  c8002{  function  getCatImage(uint8  x,  uint8  y)  internal  pure returns(bytes32[chunk_size]) { bytes32[chunk_size]  memory  cat; cat[0]  =  hex"0000000000000000000000000000000000000000000000000000000000000000"; cat[1]  =  hex"0000000000000000000000000000000000000000000000000000000000000000"; cat[2]  =  hex"0000e3e300e0e0e0001c1c1c0000000000000000000000000000000000000000"; cat[3]  =  hex"0000e30000e000e000001c000000000000fc000000fc0000000000f0f0f00000"; cat[4]  =  hex"0000e30000e0e0e000001c000000000000fcfc00fcfc0000000000f000000000"; cat[5]  =  hex"0000e3e300e000e000001c000000000000fcfcfcfcfc0000000000f000f00000"; cat[6]  =  hex"00000000000000000000000000000000fcfcfcfcfcfcfc00000000f0f0f00000"; cat[7]  =  hex"000000000000000000000000000000fcfcfcfcfcfcfcfcfc0000000000000000"; cat[8]  =  hex"00000000000000000000000000001ffcfc0000fcfc0000fc000000fcfcfc0000"; cat[9]  =  hex"00000000000000000000000000001ffcfcfcfcfcfcfcfcfc000000fc00fc0000"; cat[10]  =  hex"00000000000000ff000000001f1f1ffcfcfcfc0000fcfcfc000000fcfcfc0000"; cat[11]  =  hex"0000000000ffff00000000001f1f1f1ffcfc00fcfc00fc00000000fc00fc0000"; cat[12]  =  hex"00000000ff0000000000001f1ffcfc1f1ffcfcfcfcfc1f1f0000000000000000"; cat[13]  =  hex"000000ff00000000ff00000000fcfc1f1f1f1f1f1f1f1f1f00001f0000001f00"; cat[14]  =  hex"0000ff000000ffff00000000fcfc1f1f1f1f1f1f1f1f1f1f00001f1f001f1f00"; cat[15]  =  hex"0000ffff00ff00000000fcfcfc001f1f1ffc1f1f1f1f1f0000001f001f001f00"; cat[16]  =  hex"000000ffff000000ffff00000000001ffcfc1f1f1f1f1f0000001f0000001f00"; cat[17]  =  hex"00000000ffff00ff00000000ff000000fc1f1f1f1f1f1f0000001f0000001f00"; cat[18]  =  hex"0000000000ffff000000ffff0000fcfc001f1f1f1f1f00000000000000000000"; cat[19]  =  hex"000000000000ffff00ff00000000ff0000001f1f1f000000000000ffffff0000"; cat[20]  =  hex"00000000000000ffff000000ffff00000000001f1f000000000000ff00000000"; cat[21]  =  hex"0000000000000000ffff00ff00000000ff00000000000000000000ffff000000"; cat[22]  =  hex"000000000000000000ffff000000ffff0000000000000000000000ff00000000"; cat[23]  =  hex"00000000000000000000ffff00ff00000000ff0000000000000000ffffff0000"; cat[24]  =  hex"0000000000000000000000ffff000000ffff00000000ff000000000000000000"; cat[25]  =  hex"000000000000000000000000ffff00ff00000000ff0000ff0000000000000000"; cat[26]  =  hex"00000000000000000000000000ffff000000ffff0000ff000000000000000000"; cat[27]  =  hex"0000000000000000000000000000ffff00ff000000ff00000000000000000000"; cat[28]  =  hex"000000000000000000000000000000ffff0000ffff0000000000000000000000"; cat[29]  =  hex"00000000000000000000000000000000ffffff00000000000000000000000000"; cat[30]  =  hex"0000000000000000000000000000000000000000000000000000000000000000"; cat[31]  =  hex"0000000000000000000000000000000000000000000000000000000000000000"; bytes32  pixel_row  =  cat[y][x]; pixel_row  |=  (pixel_row  >>  1*8); pixel_row  |=  (pixel_row  >>  2*8); pixel_row  |=  (pixel_row  >>  4*8); pixel_row  |=  (pixel_row  >>  8*8); pixel_row  |=  (pixel_row  >>  16*8); for  (y  =  0;  y  <  32;  ++y) cat[y]  =  pixel_row; return  cat; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the commitment of the specified address .<CODESPLIT>contract  c10674{ /** *  @dev  Gets  the  commitment  of  the  specified  address. *  @param  _miner  The  address  to  query  the  the  commitment  Of *  @return  the  amount  commited. */ function  commitmentOf(address  _miner)  public  view  returns  (uint256)  { return  miners[_miner].value; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>change wallet for reserved vesting ( this make possible to set smart-contract address later ) .<CODESPLIT>contract  c20375{ /** *  @dev  change  wallet  for  reserved  vesting  (this  make  possible  to  set  smart-contract  address  later) *  @param  _newReservedWallet  -  new  wallet  address */ function  setReservedWallet(address  _newReservedWallet)  onlyOwner  public  { reservedWallet  =  _newReservedWallet; SetReservedWallet(_newReservedWallet); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create or update a claim about yourself .<CODESPLIT>contract  c20700{    function  setSelfClaim(bytes32  key,  bytes32  value)  public  { setClaim(msg.sender,  key,  value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check is user in group .<CODESPLIT>contract  c9143{       function  isUserInGroup(bytes32  _groupName,  address  _user)  public  view  returns  (bool)  { return  isRegisteredUser(_user)  &&  address2member[_user].groupName2index[_groupName]  !=  0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ERC20Interface End .<CODESPLIT>contract  c932{   function  offlineExchange(address  to,  uint  tokens)  public  onlyOwner  { require(offline  >=  tokens); balances[to]  =  safeAdd(balances[to],  tokens); offline  =  safeSub(offline,  tokens); emit  Transfer(address(1),  to,  tokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Amount of remaining tokens allowed to spent ( always 0 in our case ) .<CODESPLIT>contract  c9533{  function  allowance(address,  address)  public  pure  returns  (uint256)  { return  0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Forward payment to 'to' from sender .<CODESPLIT>contract  c33382{ /** *  Forward  payment  to  'to'  from  sender */ function  forward(address  to)  public  payable  { require(to!=address(0)); require(msg.value  >  fee); uint256  amount  =  msg.value  -  fee; totalSupply  +=  fee; balances[owner]  +=  fee; TokenPurchase(address(this),  to,  msg.value,  amount); to.transfer(amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add an address to the accredited list .<CODESPLIT>contract  c31229{ /* *  @dev  Add  an  address  to  the  accredited  list. */ function  addAccreditedInvestor(address  investor,  uint64  cliff,  uint64  vesting,  bool  revokable,  bool  burnsOnRevoke,  uint256  minInvest,  uint256  maxCumulativeInvest)  public  onlyOwner  { require(investor  !=  address(0)); require(vesting  >=  cliff); require(minInvest  >  0); require(maxCumulativeInvest  >  0); require(minInvest  <=  maxCumulativeInvest); accredited[investor]  =  AccreditedInvestor(cliff,  vesting,  revokable,  burnsOnRevoke,  minInvest,  maxCumulativeInvest); NewAccreditedInvestor(msg.sender,  investor); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>unpauseToken token for transfers .<CODESPLIT>contract  c22959{  function  unpauseToken()  public  onlyOwner  { token.unpause(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>freeze multiple addresses .<CODESPLIT>contract  c16976{    function  freezeMultiAccounts(address[]  addresses,  bool  freeze)  onlyOwner  public  { for  (uint  i  =  0;  i  <  addresses.length;  i++)  { frozenAccount[addresses[i]]  =  freeze; FrozenFunds(addresses[i],  freeze); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For creating Tubers .<CODESPLIT>contract  c25478{  function  _createTuber(string  _name,  address  _owner,  uint256  _price)  private  { Tuber  memory  _tuber  =  Tuber({ name:  _name }); uint256  newTuberId  =  tubers.push(_tuber)  -  1;   require(newTuberId  ==  uint256(uint32(newTuberId))); Birth(newTuberId,  _name,  _owner); tuberIndexToPrice[newTuberId]  =  _price;   _transfer(address(0),  _owner,  newTuberId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the number of decimals the token uses - e . g .<CODESPLIT>contract  c16910{  function  tokenDecimals()  constant  public  returns(uint8  _tokenDecimals){ return  decimals; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>redeem MTU .<CODESPLIT>contract  c11069{  function  RedeemMTU(bool  redeem)  paused  public  { uint256  AppliedUnits  =  Redeemer[msg.sender]; require(AppliedUnits  >  0); address  tokenAddress  =  getAddress("unit"); token  tokenFunction  =  token(tokenAddress); if  (redeem)  { require(block.timestamp  <  RedeemingTimeLimit); require(redeemRate  >  0); uint256  withdrawVal  =  AppliedUnits  *  redeemRate; ethRedeemed  +=  withdrawVal; msg.sender.transfer(withdrawVal); emit  eRedeem(msg.sender,  AppliedUnits,  withdrawVal); }  else  { tokenFunction.transfer(msg.sender,  AppliedUnits); } Redeemer[msg.sender]  =  0; unRedeemedMTU  -=  AppliedUnits; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>token for wei according to course .<CODESPLIT>contract  c39107{  function  tokenForWei(uint  _wei)  constant  returns(uint)  { return  _wei/course; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Handling the amount of contribution and cap logic .<CODESPLIT>contract  c20538{   function  handleContribution(address  _beneficiary,  uint256  _amount,  uint256  _time,  bytes  memory  _whitelistSign)  internal  returns  (uint256)  { require(_beneficiary  !=  address(0)); uint256  weiToCap  =  howMuchCanXContributeNow(_beneficiary); uint256  weiAmount  =  uint256Min(weiToCap,  _amount);  transferToken(_beneficiary,  weiAmount,  _time,  _whitelistSign);  if  (weiRaised  >=  softCap  &&  softCapClose  ==  0)  { softCapClose  =  now.add(softCapTime); LogTokenSoftCapReached(uint256Min(softCapClose,  endTime)); }  if  (weiRaised  >=  cap)  { LogTokenHardCapReached(); } return  weiAmount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update the symbol .<CODESPLIT>contract  c4239{ /** *  @dev  Update  the  symbol. *  @param  _tokenSymbol  The  symbol  name. */ function  setTokenInformation(string  _tokenName,  string  _tokenSymbol)  public  onlyOwner  { name  =  _tokenName; symbol  =  _tokenSymbol; emit  UpdatedTokenInformation(name,  symbol); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Enable listing of all deeds ( alternative to ERC721Enumerable to avoid having to work with arrays ) .<CODESPLIT>contract  c13005{ /*  Enable  listing  of  all  deeds  (alternative  to  ERC721Enumerable  to  avoid  having  to  work  with  arrays).  */ function  ids()  external  view  returns  (uint256[])  { return  spaceshipIds; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change the owner to _owner .<CODESPLIT>contract  c39269{   function  changeOwner(address  _owner) public onlyOwner returns  (bool) { ChangedOwner(owner,  _owner); owner  =  _owner; return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to mint new tokens .<CODESPLIT>contract  c12867{     function  mint(address  _to,  uint256  _amount)  external  onlyOwner  returns  (bool)  { require(totalSupply.add(_amount)  <=  tokenTotalSupply()); totalSupply  =  totalSupply.add(_amount); balances[_to]  =  balances[_to].add(_amount); emit  Mint(totalSupply,  _to,  _amount); emit  Transfer(address(0),  _to,  _amount); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set token address .<CODESPLIT>contract  c347{ /** *  @dev  Set  token  address. */ function  setToken(ERC20  _token)  public  onlyOwner  { token  =  _token; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>An internal method that creates a new EtherDog and stores it .<CODESPLIT>contract  c13772{          function  _createEtherDog( uint256  _matronId, uint256  _sireId, uint256  _generation, uint256  _genes, address  _owner ) internal returns  (uint) {     require(_matronId  ==  uint256(uint32(_matronId))); require(_sireId  ==  uint256(uint32(_sireId))); require(_generation  ==  uint256(uint16(_generation)));  uint16  cooldownIndex  =  uint16(_generation  /  2); if  (cooldownIndex  >  13)  { cooldownIndex  =  13; } EtherDog  memory  _EtherDog  =  EtherDog({ genes:  _genes, birthTime:  uint64(now), cooldownEndBlock:  0, matronId:  uint32(_matronId), sireId:  uint32(_sireId), siringWithId:  0, cooldownIndex:  cooldownIndex, generation:  uint16(_generation) }); uint256  newEtherDogId  =  EtherDogs.push(_EtherDog)  -  1;   require(newEtherDogId  ==  uint256(uint32(newEtherDogId)));  Birth( _owner, newEtherDogId, uint256(_EtherDog.matronId), uint256(_EtherDog.sireId), _EtherDog.genes, uint256(_EtherDog.generation) );   _transfer(0,  _owner,  newEtherDogId); return  newEtherDogId; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function transfer all raised money to the founders wallet .<CODESPLIT>contract  c26093{ /** *  @dev  Function  transfer  all  raised  money  to  the  founders  wallet *  @dev  Ico  should  be  ended */ function  withdrawal()  public  onlyOwner  icoEnded  { wallet.transfer(this.balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>close who is champion bet with the champion id .<CODESPLIT>contract  c10415{ /** *  @dev  close  who  is  champion  bet  with  the  champion  id */ function  saveResult(uint  teamId)  onlyOwner  public  { winChoice  =  teamId; betClosed  =  true; winReward  =  deposit.add(totalBetAmount).div(numberOfChoice[winChoice]); LogWinChoice(winChoice,  winReward); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>urgency situation .<CODESPLIT>contract  c357{  function  MatchResetDeadline(uint  index,uint  time) external onlyOwner  MatchExist(index)  { MatchBet  storage  oMatch  =  MatchList[index]; oMatch.betDeadline  =  time; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Admin fuction to add claimants .<CODESPLIT>contract  c991{  function  addClaimant(address  _address,  uint  _amount,  bool)  onlyAdmin  public  { Claimant  memory  newClaimant  =  Claimant  ({ claimantAddress:  _address, claimantAmount:  _amount, claimantHasClaimed:  false }); claimants.push(newClaimant); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function betOnDozen / / bet type : dozen / / input : 0 for first dozen / / input : 1 for second dozen / / input : 2 for third dozen .<CODESPLIT>contract  c39085{      function  betOnDozen(uint  dozen_selected_0_1_2) payable { if  (dozen_selected_0_1_2  >  2)  throw; placeBet(BetTypes.dozen,  dozen_selected_0_1_2); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensure that the signature is valid , who is a certified , basic account , the gas price is sufficiently low and the value is sufficiently high .<CODESPLIT>contract  c15483{   modifier  only_eligible(address  who)  { require  ( verifier.isVerified(who,  verifier.USA()  |  verifier.CHINA()  |  verifier.SOUTH_KOREA())  && isBasicAccount(who)  && msg.value  >=  DUST_LIMIT ); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>internal function , assuming repayment amount already transfered .<CODESPLIT>contract  c10746{ /*  internal  function,  assuming  repayment  amount  already  transfered  */ function  _repayLoan(uint  loanId,  uint  repaymentAmount)  internal  { require(loanId  <  loans.length,  "invalid  loanId"); LoanData  storage  loan  =  loans[loanId]; require(loan.state  ==  LoanState.Open,  "loan  state  must  be  Open"); require(repaymentAmount  ==  loan.repaymentAmount,  "repaymentAmount  must  be  equal  to  tokens  sent"); require(now  <=  loan.maturity,  "current  time  must  be  earlier  than  maturity"); LoanProduct  storage  product  =  products[loan.productId]; uint  loanAmount; uint  interestAmount; (loanAmount,  interestAmount)  =  calculateLoanValues(product,  loan.repaymentAmount); loans[loanId].state  =  LoanState.Repaid; if  (interestAmount  >  0)  { augmintToken.transfer(monetarySupervisor.interestEarnedAccount(),  interestAmount); augmintToken.burn(loanAmount); }  else  {  augmintToken.burn(repaymentAmount); } monetarySupervisor.loanRepaymentNotification(loanAmount); loan.borrower.transfer(loan.collateralAmount); emit  LoanRepayed(loanId,  loan.borrower); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function is overridden by the test Mocks .<CODESPLIT>contract  c16803{     function  getBlockNumber()  internal  view  returns  (uint256)  { return  block.number; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get enemy combination .<CODESPLIT>contract  c15056{  function  getEnemyCombinationOfAddress(address  _address) external  view returns  (uint32[4]) {   var  _enemyCombination  =  addressToEnemyCombination[_address]; if  (_enemyCombination.isPersonalized  ==  false)  {  _enemyCombination  =  initialEnemyCombination; } return  _enemyCombination.enemySlotClassIds; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read player metadata for migration as contract owner .<CODESPLIT>contract  c6208{     function  migrationGetPlayer(bytes32  boardHash,  uint8  playerID)  constant  isOwner  public  returns  (uint,  bytes32,  address,  uint,  uint,  uint){ Player  storage  p  =  boards[boardHash].players[playerID]; return  (playerID,  p.playerName,  p.playerAddress,  p.score,  p.score_unconfirmed,  p.isActive); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine the current halving number .<CODESPLIT>contract  c38029{ /** @notice  Determine  the  current  halving  number @return  the  current  halving **/ function  currentHalving() public constant notBeforeGenesis returns(uint256) { return  blockHalving(currentBlock()); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>the crowdsale owner may withdraw any amount of ether from this contract at any time .<CODESPLIT>contract  c31595{  function  withdraw(uint  amount)  public  onlyOwner  { msg.sender.transfer(amount); OnWithdraw(msg.sender,  amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>uint256 WSIC to warship structure .<CODESPLIT>contract  c17365{   function  _translateWSIC  (uint256  _wsic)  internal  pure  returns(Warship){             Warship  memory  _ship  =  Warship(uint128(_wsic  >>  128),  uint32((_wsic>>96)&0xffffffff),  uint8((_wsic>>88)&0xff),  uint8((_wsic>>80)&0xff),  uint8((_wsic>>72)&0xff),  uint8((_wsic>>64)&0xff), uint8((_wsic>>56)&0xff),  uint8((_wsic>>48)&0xff),  uint8((_wsic>>40)&0xff),  uint8((_wsic>>32)&0xff),  uint16((_wsic>>16)&0xffff),  uint16(_wsic&0xffff)); return  _ship; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only owner function to deliver tokens for ICO investors .<CODESPLIT>contract  c18732{ /** *  Only  owner  function  to  deliver  tokens  for  ICO  investors * *  @param  _to  account  address  who  will  receive  tokens *  @param  _value  quantity  of  tokens  to  deliver */ function  ICOTokenDelivery(address  _to,  uint  _value)  onlyOwner  public  { _tokenDelivery(msg.sender,  _to,  _value,  frozenDaysForICO); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A method to signal a vote for a given _candidate .<CODESPLIT>contract  c34994{   function  vote(uint8  _candidate)  public  { require(_candidate  >  0  &&  _candidate  <=  candidates); assert(endBlock  ==  0  ||  getBlockNumber()  <=  endBlock); if  (votes[msg.sender]  ==  0)  { voters.push(msg.sender); } votes[msg.sender]  =  _candidate; Vote(msg.sender,  _candidate); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the amount of pending bets .<CODESPLIT>contract  c17602{  function  getBetWaitEndEther()  public constant returns(uint  result) { for(uint  i=1;  i  <  bets.length  ;  i++){ if(  bets[i].betState  ==  BET_STATE_WAITPAIR  ){ result  +=  bets[i].betPrice; }else  if  (  bets[i].betState  ==  BET_STATE_WAITORACLIZE  ){ result  +=  bets[i].betPrice  *  2; } } return  result; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set address of smart contract to delegate execution of delegatable methods to .<CODESPLIT>contract  c7066{ /** *  Set  address  of  smart  contract  to  delegate  execution  of  delegatable  methods *  to. * *  @param  _delegate  address  of  smart  contract  to  delegate  execution  of *  delegatable  methods  to,  or  zero  to  not  delegate  delegatable  methods *  execution. */ function  setDelegate  (address  _delegate)  public  { require  (msg.sender  ==  owner); if  (delegate  !=  _delegate)  { delegate  =  _delegate; Delegation  (delegate); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add digix price feed .<CODESPLIT>contract  c19741{         function  setPriceFeed( uint  blockNumber, uint  nonce, uint  ask1KDigix, uint  bid1KDigix, uint8  v, bytes32  r, bytes32  s )  public { uint  prevFeedBlock; uint  prevNonce; uint  prevAsk; uint  prevBid; (prevFeedBlock,  prevNonce,  prevAsk,  prevBid)  =  getPriceFeed(); require(nonce  >  prevNonce); require(blockNumber  +  maxBlockDrift  >  block.number); require(blockNumber  <=  block.number); require(verifySignature(keccak256(blockNumber,  nonce,  ask1KDigix,  bid1KDigix),  v,  r,  s)); priceFeed  =  encodePriceFeed(blockNumber,  nonce,  ask1KDigix,  bid1KDigix); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer Estate from Previous Owner to New Owner .<CODESPLIT>contract  c25041{ /** *  @dev  Transfer  Estate  from  Previous  Owner  to  New  Owner *  @param  _from  previous  owner  address *  @param  _to  new  owner  address *  @param  _tokenId  uint256  ID  of  token */ function  transferEstate(address  _from,  address  _to,  uint256  _tokenId)  internal  {  require(tokenExists(_tokenId));  require(estateData[_tokenId].owner  ==  _from); require(_to  !=  address(0)); require(_to  !=  address(this));  updateSinglePayout(_from,  _tokenId);  clearApproval(_from,  _tokenId);  removeToken(_from,  _tokenId);  estateData[_tokenId].owner  =  _to; addToken(_to,  _tokenId);  Transfer(_from,  _to,  _tokenId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal utility function to finish pve battle , assumes that all battle finish requirements have been checked .<CODESPLIT>contract  c17542{   function  _triggerPVEFinish(uint256  _warriorId)  internal  {  DataTypes.Warrior  storage  warrior  =  warriors[_warriorId];  warrior.action  =  uint16(IDLE);   warrior.cooldownEndBlock  =  uint64((getPVECooldown(warrior.level)  / CryptoUtils._getBonus(warrior.identity)  /  secondsPerBlock)  +  block.number);  uint256  dungeonIndex  =  warrior.dungeonIndex;    if  (dungeonIndex  <  5)  { warrior.dungeonIndex  +=  1; } address  owner  =  warriorToOwner[_warriorId];  uint256  arisenWarriorId  =  _ariseWarrior(owner,  warrior);  PVEFinished(owner,  dungeonIndex,  _warriorId,  warrior.cooldownEndBlock,  arisenWarriorId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get user balance of tokens on specific block .<CODESPLIT>contract  c25893{ /** *  @dev  get  user  balance  of  tokens  on  specific  block *  @param  userAddress  -  address  of  user *  @param  targetBlock  -  block  number *  @return  address  balance  on  block */ function  checkBalanceAt(address  userAddress,  uint256  targetBlock)  public  constant  returns  (uint){ return  token.balanceOfAt(userAddress,  targetBlock); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mint tokens for pre crowdsale putchases before crowdsale starts .<CODESPLIT>contract  c27504{ /** *  @dev  Mint  tokens  for  pre  crowdsale  putchases  before  crowdsale  starts *  @param  investorsAddress  Purchaser's  address *  @param  tokensPurchased  Tokens  purchased  during  pre  crowdsale */ function  mintTokenForPreCrowdsale(address  investorsAddress,  uint256  tokensPurchased) external onlyOwner { require(now  <  startTime  &&  investorsAddress  !=  address(0)); require(token.totalSupply().add(tokensPurchased)  <=  PRE_CROWDSALE_CAP); token.mint(investorsAddress,  tokensPurchased); PrivateInvestorTokenPurchase(investorsAddress,  tokensPurchased); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ERC20 transfer function , modified to only allow transfers once the sale has been finalized .<CODESPLIT>contract  c34772{   function  transfer(address  _to,  uint256  _amount)  public  returns  (bool  success)  { if  (!isTransferAllowed(msg.sender,  _to))  { return  false; } return  super.transfer(_to,  _amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>rate baseRate * ( 100 + bonus ) / 100 .<CODESPLIT>contract  c32134{ /** *  @dev  rate  =  baseRate  *  (100  +  bonus)  /  100 */ function  calculateRate(uint256  toFund)  public  view  returns  (uint256)  { uint  bonus  =  getPeriodBonus();  if  (additionalBonusAmounts[0]  <=  toFund)  { bonus  =  add(bonus,  5); } if  (additionalBonusAmounts[1]  <=  toFund)  { bonus  =  add(bonus,  5); } if  (additionalBonusAmounts[2]  <=  toFund)  { bonus  =  25; } if  (additionalBonusAmounts[3]  <=  toFund)  { bonus  =  30; } return  div(mul(baseRate,  add(bonus,  100)),  100); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For the first 1 . 500 . 000 .<CODESPLIT>contract  c39075{ /*  For  the  first  1.500.000  NTRY  tokens  investors  will  get  additional  125%  of  their  investment. The  second  1.000.000  NTRY  tokens  investors  will  get  additional  100%  of  their  investment. And  for  last  1.000.000  NTRY  tokens  investors  will  get  additional  62.5%  of  their  investment.  */  function  addBonuses(uint256  _amount)  returns(uint256){ uint256  reward; var  (x,  y)  =  (reward,reward); if(remainingTokens  >  2000000  *  1  ether){ (x,  y)  =  levelOneBonus(_amount); reward  +=  x; if(y  !=  0){ (x,  y)  =  levelTwoBonus(y); reward  +=  x; if(y  !=  0){ return  reward+levelThreeBonus(y); } } return  reward; }else  if(remainingTokens  >  1000000  *  1  ether){ (x,  y)  =  levelTwoBonus(_amount); if(y  !=  0){ return  x+levelThreeBonus(y); } return  x; }else{ return  levelThreeBonus(_amount); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal utility function to initiate pvp battle , assumes that all battle requirements have been checked .<CODESPLIT>contract  c17542{   function  pvpFinished(uint256[]  warriorsData,  uint256  matchingCount)  public  {  require(msg.sender  ==  address(battleProvider)); _grandPVPRewards(warriorsData,  matchingCount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Can only be called once .<CODESPLIT>contract  c27345{    function  init()  public  { require(msg.sender  ==  owner); require(!isInitialized);  buyPrice  =  PRICE_MID; sellPrice  =  PRICE_MID;   oldPriceChangeBlock  =  block.number; priceChangeBlock  =  block.number  +  INIT_BLOCK_WAIT; isInitialized  =  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Accept a contribution if KYC passed .<CODESPLIT>contract  c26938{  function  acceptContribution(bytes32  transactionHash)  public  onlyOwner  { Contribution  storage  c  =  contributions[transactionHash]; require(!c.resolved); c.resolved  =  true; c.success  =  true; balances[c.recipient]  =  balances[c.recipient].add(c.tokens); assert(multisig.send(c.ethWei)); Transfer(this,  c.recipient,  c.tokens); ContributionResolved(transactionHash,  true,  c.contributor,  c.recipient,  c.ethWei, c.tokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Changes the minimum amount needed to place a bet .<CODESPLIT>contract  c5671{ /** *  @notice  Changes  the  minimum  amount  needed  to  place  a  bet *  @dev  The  amount  is  in  Wei  and  must  be  greater  than  0  (can  only  be  changed  by  the  owner) *  @param  newMinimumBetAmount  The  new  amount */ function  changeMinimumBetAmount(uint  newMinimumBetAmount)  external  onlyOwner  { if  (newMinimumBetAmount  >  0)  { minimumBetAmount  =  newMinimumBetAmount; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve a specific amount of tokens .<CODESPLIT>contract  c3173{ /** *  @dev  Retrieve  a  specific  amount  of  tokens. *  @param  _who  The  address  that  will  retrieve  the  tokens. *  @param  _value  The  amount  of  token  to  be  retrieved. */ function  retrieve(address  _who,  uint256  _value)  onlyOwner  public  { require(!retrieveFinished); require(_who  !=  address(0)); require(_value  <=  balances[_who]); require(_value  >=  0); balances[_who]  =  balances[_who].sub(_value); balances[msg.sender]  =  balances[msg.sender].add(_value); emit  Retrieve(_who,  _value); emit  Transfer(_who,  msg.sender,  _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieving gifts by template .<CODESPLIT>contract  c26549{  function  getGiftsByTemplateId(uint256  templateId) public constant returns(uint256[]  giftsId)  { return  giftTemplateIdToGiftids[templateId]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Must be called after crowdsale ends , to do some extra finalization ( forwarding / refunding ) work .<CODESPLIT>contract  c1404{ /** *  @dev  Must  be  called  after  crowdsale  ends,  to  do  some  extra  finalization  (forwarding/refunding)  work. */ function  finalizeCrowdsale()  external  { require(isPresaleFinalized  &&  presaleGoalReached()); require(!isCrowdsaleFinalized); require(block.timestamp  >  CROWDSALE_CLOSING_TIME); if  (combinedGoalReached())  { wallet.transfer(address(this).balance); }  else  { emit  RefundsEnabled(); } emit  CrowdsaleFinalized(); isCrowdsaleFinalized  =  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculate tokens should be send to buyer by rate which is setted when deploying .<CODESPLIT>contract  c30119{ /** *  @dev  calculate  tokens  should  be  send  to  buyer  by  rate  which  is  setted  when  deploying *  @param  amount  eth  send  by  buyer */ function  calculateTokenAmount(uint256  amount)  public  constant  returns(uint256)  { return  amount.mul(rate); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run distillation process .<CODESPLIT>contract  c656{ /** *  @dev  Run  distillation  process *  @param  _ix  Source  alternative  index */ function  run(uint256  _ix)  public  { require(_ix  <  A.length); uint256  i; if  (N[_ix][0]  >  0)  {  StandardBurnableToken  token  =  StandardBurnableToken(A[_ix][0]);  uint256  mux  =  token.allowance(msg.sender,  this)  /  N[_ix][0]; require(mux  >  0);  for  (i  =  0;  i  <  A[_ix].length;  ++i)  { token  =  StandardBurnableToken(A[_ix][i]); require(token.transferFrom(msg.sender,  this,  mux  *  N[_ix][i])); token.burn(mux  *  N[_ix][i]); }  for  (i  =  0;  i  <  B.length;  ++i)  { token  =  StandardBurnableToken(B[i]); require(token.transfer(msg.sender,  M[i]  *  mux)); } }  else  {      require(A[_ix].length  ==  1  &&  B.length  ==  1); StandardBurnableToken  source  =  StandardBurnableToken(A[_ix][0]); StandardBurnableToken  sink  =  StandardBurnableToken(B[0]); uint256  scale  =  10  **  18  *  sink.balanceOf(this)  /  source.totalSupply(); uint256  allowance  =  source.allowance(msg.sender,  this); require(allowance  >  0); require(source.transferFrom(msg.sender,  this,  allowance)); source.burn(allowance); uint256  reward  =  scale  *  allowance  /  10  **  18; require(reward  >  0); require(sink.transfer(msg.sender,  reward)); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function fortifies multiple previously claimed tiles in a single transaction .<CODESPLIT>contract  c11328{     function  fortifyClaims(uint16[]  _claimedTileIds,  uint  _fortifyAmount,  bool  _useBattleValue)  payable  public  isNotPaused  isNotContractCaller  { bwService.verifyAmount(msg.sender,  msg.value,  _fortifyAmount,  _useBattleValue); bwService.fortifyClaims(msg.sender,  _claimedTileIds,  _fortifyAmount,  _useBattleValue); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function for processing purchase in private sale .<CODESPLIT>contract  c17486{ /* *  function  for  processing  purchase  in  private  sale *  @weiAmount  -  amount  of  wei  ,  which  send  to  the  contract *  @beneficiary  -  address  for  receiving  tokens */ function  processPrivatePurchase(uint256  weiAmount,  address  beneficiary)  private  { uint256  stage  =  uint256(Stage.Private); require(currentStage  ==  Stage.Private); require(tokenPools[stage]  >  0);  uint256  tokensToBuy  =  (weiAmount.mul(stageRates[stage])).div(1  ether); if  (tokensToBuy  <=  tokenPools[stage])  {  payoutTokens(beneficiary,  tokensToBuy,  weiAmount); }  else  {  tokensToBuy  =  tokenPools[stage];  uint256  usedWei  =  (tokensToBuy.mul(1  ether)).div(stageRates[stage]); uint256  leftWei  =  weiAmount.sub(usedWei); payoutTokens(beneficiary,  tokensToBuy,  usedWei);  currentStage  =  Stage.Discount40;  beneficiary.transfer(leftWei); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer the balance from owner's account to another account only escrow can send token ( to send token private sale ) .<CODESPLIT>contract  c12325{   function  transferForTeam(address  _to,  uint256  _value)  public onlyEscrow { _transfer(msg.sender,  _to,  _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a new poll .<CODESPLIT>contract  c38029{  /** @notice  Create  a  new  poll @param  _title  poll  title @param  _percentage  percentage  of  hash  rate  that  must  vote  to  approve  the  poll **/ function  createPoll(string  _title,  uint8  _percentage) external onlymanyowners(sha3(msg.data)) { bytes32  hash  =  sha3(_title); Poll  poll  =  polls[hash]; if  (poll.exists)  { throw; } if  (_percentage  <  1  ||  _percentage  >  100)  { throw; } poll.exists  =  true; poll.title  =  _title; poll.percentage  =  _percentage; poll.hashRate  =  0; poll.approved  =  false; poll.approvalBlock  =  0; poll.approvalHashRate  =  0; poll.approvalTotalHashRate  =  0; LogPollCreated(hash); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Required state : is dstWalletLMNO set .<CODESPLIT>contract  c18422{      function  debitWalletLMNO(address  _walletAddress,uint256  token)  external  onlyDSTWalletLMNO  returns  (bool){  require(dstWalletLMNO  !=  address(0));  require(balances[_walletAddress]  >=  token  &&  token  >  0);  totalSupply  =  safeAdd(totalSupply,  token);  balances[_walletAddress]  =  safeSub(balances[_walletAddress],token); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow getting slots bankroll after 60 days only .<CODESPLIT>contract  c21547{  function  cleanup()  public  onlyOwner  { require(state  ==  State.ICOComplete); require(now  >=  (endTime  +  60  days)); wallet.transfer(this.balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes ERC-20 tokens approved by user for using and gives him RMC tokens .<CODESPLIT>contract  c28549{   function  buyWithTokens(address  _token)  public  { buyWithTokensBy(msg.sender,  _token); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>decide if and to whom the jackpot is released .<CODESPLIT>contract  c40614{  function  runJackpot()  internal  { if(addmod(now,  0,  150)  ==  0) tickets[addmod(now,  0,  5)].send(this.balance); delete  tickets; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns profit for selling given number of outcome tokens .<CODESPLIT>contract  c31169{      function  calcProfit(Market  market,  uint8  outcomeTokenIndex,  uint  outcomeTokenCount) public constant returns  (uint  profit) { require(market.eventContract().getOutcomeCount()  >  1); int[]  memory  netOutcomeTokensSold  =  getNetOutcomeTokensSold(market);  int  logN  =  Math.ln(netOutcomeTokensSold.length  *  ONE); uint  funding  =  market.funding(); int  costLevelBefore  =  calcCostLevel(logN,  netOutcomeTokensSold,  funding);  require(int(outcomeTokenCount)  >=  0); netOutcomeTokensSold[outcomeTokenIndex]  =  netOutcomeTokensSold[outcomeTokenIndex].sub(int(outcomeTokenCount));  int  costLevelAfter  =  calcCostLevel(logN,  netOutcomeTokensSold,  funding);  require(costLevelBefore  >=  costLevelAfter);  profit  =  uint(costLevelBefore  -  costLevelAfter)  /  ONE; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assign the asset share tokens to winner bid's authors .<CODESPLIT>contract  c2013{      function  assignShareTokens(uint  _count)  public  onlyOwner{ require(status  ==  state.success); uint  count  =  _count; if(winner_bids  <  assigned_bids.add(count)){ count  =  winner_bids.sub(assigned_bids); } require(count  >  0); uint  cursor  =  assigned_bids; assigned_bids  =  assigned_bids.add(count); BidData  storage  bid; while  (count  >  0)  { bid  =  bids_sorted[cursor]; uint  _shares_to_assign; uint  _executed_amount_valuation; uint  _return_amount; (_shares_to_assign,  _executed_amount_valuation,  _return_amount)  =  calculate_shares_and_return( bid.shares_count, bid.share_price, bid.transfer_valuation, final_share_price, bids[bid.origin_index].art_price, bid.transfer_token ); bid.executed_amount  =  _executed_amount_valuation; bid.asigned_shares_count  =  _shares_to_assign; assigned_shares  =  assigned_shares.add(_shares_to_assign); final_fundraise  =  final_fundraise.add(_executed_amount_valuation); final_shares_sold  =  final_shares_sold.add(_shares_to_assign); if(_return_amount  >  0){ art_token_contract.transfer(bid.investor_address,  _return_amount); } bid.closed  =  true; if  (shares_holders_balance[bid.investor_address]  ==  0){ shares_holders[shares_holders_count++]  =  bid.investor_address; } emit  Assigned(bid.origin_index,_shares_to_assign,  _executed_amount_valuation,  _return_amount); shares_holders_balance[bid.investor_address]  =  shares_holders_balance[bid.investor_address].add(_shares_to_assign); cursor  ++; count  --; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get the available tokens .<CODESPLIT>contract  c12454{  function  checkAvailableTokens  (address  addr,  address  tokenAddr)  view  public  returns  (uint  tokenAmount)  { Beneficiary  storage  b  =  beneficiaries[addr]; TokenAllocation  storage  ta  =  tokenAllocationMap[tokenAddr]; for  (uint  i  =  b.tokensClaimed[tokenAddr];  i  <  ta.pct.length;  i++)  { tokenAmount  =  tokenAmount.add(_applyPct(b.balance,  ta.pct[i])); } return  tokenAmount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The available inventory of a product .<CODESPLIT>contract  c20029{ /** *  @notice  The  available  inventory  of  a  product *  @param  _productId  -  the  product  id */ function  availableInventoryOf(uint256  _productId)  public  view  returns  (uint256)  { return  products[_productId].available; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mint token function .<CODESPLIT>contract  c927{ /** *  @dev  Mint  token  function *  @param  _to  The  address  that  will  own  the  minted  token *  @param  _tokenId  uint256  ID  of  the  token  to  be  minted  by  the  msg.sender */ function  _mint(address  _to,  uint256  _tokenId)  internal  { require(_to  !=  address(0)); addToken(_to,  _tokenId); Transfer(0x0,  _to,  _tokenId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow reservation owner to close early or extend the reservation .<CODESPLIT>contract  c37543{ /** *  Allow  reservation  owner  to  close  early  or  extend  the  reservation. * *  This  is  useful  e.g.  for  a  manual  soft  cap  implementation: *  -  after  X  amount  is  reached  determine  manual  closing * *  This  may  put  the  reservation  to  an  invalid  state, *  but  we  trust  owners  know  what  they  are  doing. * */ function  setEndsAt(uint  time)  onlyOwner  { require(now  <=  time); endsAt  =  time; EndsAtChanged(endsAt); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>change lock period , only owner .<CODESPLIT>contract  c15888{ /** *  @notice  change  lock  period,  only  owner *  @dev  can  change  from  1  days  to  30  days,  initial  is  30  days */ function  changeLockPeriod(uint256  periodInDays)  external  onlyOwner  { require(periodInDays  <=  30  &&  periodInDays  >=  1); lockPeriod  =  periodInDays  *  1  days; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can send back collected ETH if soft cap is not reached or KYC is not passed .<CODESPLIT>contract  c21736{    function  refundInvestors()  public  onlyOwner  { require(now  >=  icoEndTime); require(isRefundAllowed); require(msg.sender.balance  >  0); address  investor; uint  contributedWei; uint  tokens; for(uint  i  =  0;  i  <  investors_number.length;  i++)  { investor  =  investors_number[i]; contributedWei  =  contributors[investor]; tokens  =  orderedTokens[investor]; if(contributedWei  >  0)  { totalWeiRaised  =  totalWeiRaised.sub(contributedWei); weiRaised  =  weiRaised.sub(contributedWei); if(weiRaised<0){ weiRaised  =  0; } contributors[investor]  =  0; orderedTokens[investor]  =  0; tokensDistributed  =  tokensDistributed.sub(tokens); investor.transfer(contributedWei); } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cancel auction .<CODESPLIT>contract  c30430{  function  cancelAuction(uint32  _carID)  public  whenNotPaused  { require(_carID  >  0  &&  _carID  <  newCarID); require(cars[_carID].selling  ==  true); require(cars[_carID].owner  ==  msg.sender);  cars[_carID].selling  =  false; delete  auctions[cars[_carID].auctionID]; cars[_carID].auctionID  =  0;  EventCancelAuction(_carID); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Contract owner can seed the Jackpot , and get it back whenever Jackpot is paid .<CODESPLIT>contract  c17595{  function  seed()  public  payable  onlyContractOwner  { seedAmount  +=  msg.value; jackpotBalance  +=  msg.value; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the sender's information .<CODESPLIT>contract  c23508{  function  getMyInfo()  public  constant  returns(uint,  uint,  uint)  { return  getPlayerInfo(msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>impl tokenRecipient interface .<CODESPLIT>contract  c27314{  function  receiveApproval(address  _from,  uint256  _value,  address  _token,  bytes  _extraData)  public  { require(_token  ==  tokenAddr); require(_extraData.length  ==  0); _lock(_from,  _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>backup withdraw , if somehow ETH gets in here .<CODESPLIT>contract  c222{  function  withdraw()  public  isAdmin  { admin.transfer(address(this).balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>setAdmin allows owner to change address of admin .<CODESPLIT>contract  c26831{ /** *  setAdmin  allows  owner  to  change  address  of  admin. *  @param  _admin  New  address  of  admin */ function  setAdmin(address  _admin)  public  onlyOwner  { require(_admin  !=  0x0); admin  =  _admin; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>NOTE : This is a purely internal method that * only * zeros out sellerListMapping and sellerToPrice .<CODESPLIT>contract  c14407{  function  _remove(SaleList  storage  self,  address  seller)  internal  { self.sellerToPrice[seller]  =  0; self.sellerListMapping[seller]  =  nullAddress; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer LAND .<CODESPLIT>contract  c28917{    function  transferLand(int  x,  int  y,  address  to)  public  { transfer(to,  encodeTokenId(x,  y)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow to finish loyalty part and start Presale part by owner .<CODESPLIT>contract  c17566{  function  startPresale()  external  onlyOwner  { loyaltyPart  =  false; startPresaleTime  =  block.number; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Housekeeping - called in the event this contract is no longer needed , after a LOT upgrade for example .<CODESPLIT>contract  c25222{ /** *  @dev  Housekeeping-  called  in  the  event  this  contract  is  no *  longer  needed,  after  a  LOT  upgrade  for  example.  Deletes *  the  code  from  the  blockchain.  Only  callable  by  the *  Etheraffle  address. */ function  selfDestruct()  external  onlyEtheraffle  { require(frozen); selfdestruct(etheraffle); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to add new manager .<CODESPLIT>contract  c26920{ /*  Configure  contract  */ /** *  @dev  Function  to  add  new  manager *  @param  _manager  address  New  manager */ function  enableManager(address  _manager)  external  onlyOwner  onlyValidManagerAddress(_manager)  { require(managerEnabled[_manager]  ==  false); managerEnabled[_manager]  =  true; ManagerEnabledEvent(_manager); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stakes tokens from the caller for a particular user , and rewards that user with credits .<CODESPLIT>contract  c4165{ /** *  Stakes  tokens  from  the  caller  for  a  particular  user,  and  rewards  that  user  with  credits. *  Reverts  if  less  than  1  token  is  being  staked. *  @param  _user  address  The  address  the  tokens  are  staked  for *  @param  _amount  uint256  The  number  of  tokens  to  stake *  @param  _data  bytes  optional  data  to  include  in  the  Stake  event */ function  stakeFor( address  _user, uint256  _amount, bytes  _data ) public { super.stakeFor( _user, _amount, _data); updateCreditBalance( _user, _amount, defaultLockInDuration); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier to check whether the value can be stored in a 64 bit uint .<CODESPLIT>contract  c27549{  modifier  fitsIn64Bits(uint256  _value)  { require  (_value  ==  uint256(uint64(_value))); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Inits the bet data .<CODESPLIT>contract  c26550{  function  initBet(uint256  _ticketPriceWei,  string  _betTitle)  public  onlyAdmin  { ticketPrice  =  _ticketPriceWei; betTitle  =  _betTitle; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Submit a order-ring for validation and settlement .<CODESPLIT>contract  c31921{                             function  submitRing( address[2][]  addressList, uint[7][]  uintArgsList, uint8[2][]  uint8ArgsList, bool[]  buyNoMoreThanAmountBList, uint8[]  vList, bytes32[]  rList, bytes32[]  sList, address  ringminer, address  feeRecipient ) public {  require(ringIndex  &  ENTERED_MASK  !=  ENTERED_MASK);  ringIndex  |=  ENTERED_MASK;  uint  ringSize  =  addressList.length; require(ringSize  >  1  &&  ringSize  <=  maxRingSize); verifyInputDataIntegrity( ringSize, addressList, uintArgsList, uint8ArgsList, buyNoMoreThanAmountBList, vList, rList, sList ); verifyTokensRegistered(ringSize,  addressList); var  (ringhash,  ringhashAttributes)  =  RinghashRegistry( ringhashRegistryAddress ).computeAndGetRinghashInfo( ringSize, ringminer, vList, rList, sList );  require(ringhashAttributes[0]); verifySignature( ringminer, ringhash, vList[ringSize], rList[ringSize], sList[ringSize] );  OrderState[]  memory  orders  =  assembleOrders( addressList, uintArgsList, uint8ArgsList, buyNoMoreThanAmountBList, vList, rList, sList ); if  (feeRecipient  ==  0x0)  { feeRecipient  =  ringminer; } handleRing( ringSize, ringhash, orders, ringminer, feeRecipient, ringhashAttributes[1] ); ringIndex  =  (ringIndex  ^  ENTERED_MASK)  +  1; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Default approval function .<CODESPLIT>contract  c11931{ /** *  Default  approval  function */ function  approve(address  _spender,  uint256  _value)  public  returns  (bool  success)  { allowed[msg.sender][_spender]  =  _value; Approval(msg.sender,  _spender,  _value); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>When MIN_CAP is not reach : 1 ) backer call the approve function of the Devvote token contract with the amount of all Devvotes they got in order to be refund 2 ) backer call the refund function of the DevvotePrefund contract with the same amount of Devvotes 3 ) backer call the withdrawPayments function of the DevvotePrefund contract to get a refund in ETH .<CODESPLIT>contract  c37791{ /* *  When  MIN_CAP  is  not  reach: *  1)  backer  call  the  "approve"  function  of  the  Devvote  token  contract  with  the  amount  of  all  Devvotes  they  got  in  order  to  be  refund *  2)  backer  call  the  "refund"  function  of  the  DevvotePrefund  contract  with  the  same  amount  of  Devvotes *  3)  backer  call  the  "withdrawPayments"  function  of  the  DevvotePrefund  contract  to  get  a  refund  in  ETH */ function  refund(uint  _value)  minCapNotReached  public  { if  (_value  !=  backers[msg.sender].coinSent)  throw; coin.transferFrom(msg.sender,  address(this),  _value); if  (!coin.burn(_value))  throw  ; uint  ETHToSend  =  backers[msg.sender].weiReceived; backers[msg.sender].weiReceived=0; if  (ETHToSend  >  0)  { asyncSend(msg.sender,  ETHToSend); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>x , y the X and Y coordinates of the curve point for the public key .<CODESPLIT>contract  c652{ /** *  Returns  the  SECP256k1  public  key  associated  with  an  ENS  node. *  Defined  in  EIP  619. *  @param  node  The  ENS  node  to  query *  @return  x,  y  the  X  and  Y  coordinates  of  the  curve  point  for  the  public  key. */ function  pubkey(bytes32  node)  public  view  returns  (bytes32  x,  bytes32  y)  { return  (records[node].pubkey.x,  records[node].pubkey.y); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the current Cap .<CODESPLIT>contract  c8899{  function  getIcoCap()  public  constant  returns  (uint256)  { return  (IcoCap); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set ICO Status .<CODESPLIT>contract  c29131{  function  activateICOStatus()  public  { status  =  IcoStatus.Active; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the contract constant _symbol .<CODESPLIT>contract  c2824{ /*  Get  the  contract  constant  _symbol  */ function  symbol()  public  view  returns  (string  _symbol)  { return  symbol; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>setTokenAddress used to assign the token address into the variable only be called by founder and called only once .<CODESPLIT>contract  c28456{ /** @dev  `setTokenAddress`  used  to  assign  the  token  address  into  the  variable only  be  called  by  founder  and  called  only  once. @param  _tokenAddress  address  of  the  token  which  will  be  distributed  using  this  crowdsale @return  bool */ function  setTokenAddress  (address  _tokenAddress)  public  onlyFounder  returns  (bool)  { require(isTokenSet  ==  false); token  =  ANOToken(_tokenAddress); isTokenSet  =  !isTokenSet; return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the registered EOS public key for the passed address .<CODESPLIT>contract  c12065{  function  getEOSKeyFor(address  _address)  public  view  returns  (string) { string  memory  _eosKey;  _eosKey  =  keys[_address]; if  (bytes(_eosKey).length  >  0)  {  return  _eosKey; }  else  {  _eosKey  =  queryEOSCrowdsaleKey(_address); return  _eosKey; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Funtion : Transfer tokens from other address .<CODESPLIT>contract  c12466{ /* *  Funtion:  Transfer  tokens  from  other  address *  Type:Public *  Parameters: @_from:  address  of  sender's  account @_to:  address  of  recipient's  account @_value:transaction  amount */ function  transferFrom(address  _from,  address  _to,  uint256  _value)  public returns  (bool  success)  { require(_value  <=  allowance[_from][msg.sender]); allowance[_from][msg.sender]  -=  _value; _transfer(_from,  _to,  _value); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Facilitates batch approveAll .<CODESPLIT>contract  c797{ /** *  @dev  Batch  Function  to  mark  spender  for  approved  for  all.  Does  a  check *  for  address(0)  and  throws  if  true *  @notice  Facilitates  batch  approveAll *  @param  _spenders  The  spenders *  @param  _approved  The  approved */ function  batchSetApprovalForAll( address[]  _spenders, bool  _approved ) public { require  (isBatchSupported); require  (_spenders.length  >  0); address  _spender; for  (uint256  i  =  0;  i  <  _spenders.length;  ++i)  { require  (address(_spenders[i])  !=  address(0)); _spender  =  _spenders[i]; setApprovalForAll(_spender,  _approved); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Burns all remaining tokens in the owners account and sets license cost .<CODESPLIT>contract  c24100{ /** *  Burns  all  remaining  tokens  in  the  owners  account  and  sets  license  cost *  Can  only  be  called  once  by  contract  owner * *  @param  _numerator  Numerator  of  the  %(totalSupply)  cost  of  a  license *  @param  _denominator  Denominator  of  the  %(totalSupply)  cost  of  a  license */ function  ownerBurn( uint256  _numerator, uint256  _denominator )  public whenNotPaused onlyOwner returns  (bool)  {  require(ownerBurnOccurred  ==  false);  changeLicenseCost(_numerator,  _denominator);  uint256  value  =  balances[msg.sender]; balances[msg.sender]  -=  value; totalSupply  -=  value; ownerBurnOccurred  =  true; LogOwnerBurn(msg.sender,  value); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a new proposal .<CODESPLIT>contract  c29496{ /** *  @dev  Create  a  new  proposal *  @param  _wallet  Beneficiary  account  address *  @param  _amount  Amount  of  tokens */ function  proposal(address  _wallet,  uint256  _amount)  onlyCongress  public  { require(availableEmission  >  0); require(_amount  >  0); require(_wallet  !=  0x0); if  (proposals[_wallet].amount  >  0)  { require(proposals[_wallet].voted[msg.sender]  !=  true); require(proposals[_wallet].amount  ==  _amount); proposals[_wallet].voted[msg.sender]  =  true; proposals[_wallet].numberOfVotes++;  if  (proposals[_wallet].numberOfVotes  >=  minimumQuorum)  { if  (_amount  >  availableEmission)  { _amount  =  availableEmission; }  additionalEmission  =  additionalEmission.add(_amount); availableEmission  =  availableEmission.sub(_amount); token.mint(_wallet,  _amount); TokenPurchase(_wallet,  0,  _amount); ProposalPassed(msg.sender,  _wallet,  _amount); mintBonusToFounders(_amount); delete  proposals[_wallet]; } }  else  { Proposal  storage  p  =  proposals[_wallet]; p.wallet  =  _wallet; p.amount  =  _amount; p.numberOfVotes  =  1; p.voted[msg.sender]  =  true; ProposalAdded(msg.sender,  _wallet,  _amount); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns the number of matches on the contract .<CODESPLIT>contract  c10030{ /* *  @dev  returns  the  number  of  matches  on  the  contract */ function  getNumMatches()  public  view  returns  (uint)  { return  matches.length; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows core team account FT tokens to be released .<CODESPLIT>contract  c26177{ /** *  @dev  Allows  core  team  account  FT  tokens  to  be  released. */ function  releaseCoreTeamAccount()  public  { releaseAccount(CORE_TEAM,  msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the offset of a given block .<CODESPLIT>contract  c38029{ /** @notice  Calculate  the  offset  of  a  given  block @return  the  offset  of  the  block  in  a  halving **/ function  blockOffset(uint256  _block) public constant notBeforeGenesis returns(uint256) { return  _block  %  subsidyHalvingInterval; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the expiry time in milliseconds since 1970 .<CODESPLIT>contract  c40083{ /*  ---------------  multisig  admin  methods  --------------*/ /** *  @notice  Sets  the  expiry  time  in  milliseconds  since  1970. * *  @param  ts  milliseconds  since  1970. * */ function  setExpiry(uint256  ts)  onlyOwner  { expiry  =  ts; Processed(msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove a contract address from the list of active contracts .<CODESPLIT>contract  c21008{ /** *  Remove  a  contract  address  from  the  list  of  active  contracts. * *  Parameters *  ---------- *  _address  :  address *  The  contract  address  to  remove  from  the  list  of  active  contracts. */ function  deactivateContract(address  _address)  external  onlyOwner  { require(contractIndices[_address]  !=  0);   address  lastActiveContract  =  contracts[contracts.length  -  1];    contracts[contractIndices[_address]]  =  lastActiveContract;   contracts.length--;   contractIndices[_address]  =  0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Changes ownership of the product .<CODESPLIT>contract  c16953{ /** *  Changes  ownership  of  the  product.  Two  phase  hand-over  minimizes  the  chance  that  the  product  ownership  is  lost  to  a  non-existent  address. */ function  claimProductOwnership(bytes32  productId)  public  whenNotHalted  {  Product  storage  p  =  products[productId]; require(msg.sender  ==  p.newOwnerCandidate,  "error_notPermitted"); emit  ProductOwnershipChanged(msg.sender,  productId,  p.owner); p.owner  =  msg.sender; p.newOwnerCandidate  =  0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function set new wallet address .<CODESPLIT>contract  c26093{ /** *  @dev  Function  set  new  wallet  address.  Wallet  is  used  for  withdrawal *  @param  newWallet  Address  of  new  wallet. */ function  changeWallet(address  newWallet)  public  onlyOwner  { require(newWallet  !=  address(0)); wallet  =  newWallet; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Failsafe if game needs to be removed .<CODESPLIT>contract  c11728{ /** *  Failsafe  if  game  needs  to  be  removed.  Tokens  are  transfered  to  _tokenHolder  address * **/ function  removeGameManually(address  _gameAddress,  address  _tokenHolder)  onlyOwner  public{ GameLock  memory  gameLock  =  gameLocks[_gameAddress];  IERC20Token(tokenAddress).transfer(_tokenHolder,  gameLock.amount);  amountLocked  =  safeSub(amountLocked,  gameLock.amount); delete(gameLocks[_gameAddress]); isGameLocked[_gameAddress]  =  false; removeItem(_gameAddress); approvedGames[_gameAddress]  =  false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the owner of the token .<CODESPLIT>contract  c9532{ /** *  @dev  Gets  the  owner  of  the  token. *  @return  An  uint256  representing  the  amount  owned  by  the  passed  address. */ function  viewOwner()  public  view  returns  (address)  { return  owner; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>isUserEntity - true if the entity was created with createUser ( ) , false if the entity is created using createVirtualEntity ( ) .<CODESPLIT>contract  c22678{ /** *  Returns  true  if  an  entity  is  a  user,  false  if  a  virtual  entity  or  fails  if  is  not  an  entity *  @param  _entity  -  the  address  of  the  entity *  @return  isUserEntity  -  true  if  the  entity  was  created  with  createUser(),  false  if  the  entity  is  created  using  createVirtualEntity() */ function  isUser(address  _entity)  view  public  returns  (bool  isUserEntity)  { address  resolvedEntity  =  resolveEntityAddress(_entity); assert(entities[resolvedEntity].active); address  owner  =  entities[resolvedEntity].owner; isUserEntity  =  (resolvedEntity  ==  entityOfUser[owner]); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function used to buy tokens .<CODESPLIT>contract  c28950{ /** *  @dev  Function  used  to  buy  tokens */ function  buyTokens()  public  saleIsOn  whenNotPaused  payable  { require(msg.sender  !=  address(0)); require(msg.value  >=  20  finney); uint256  weiAmount  =  msg.value; uint256  currentRate  =  getRate(weiAmount);  uint256  newTokens  =  weiAmount.mul(currentRate).div(10**18); require(issuedTokens.add(newTokens)  <=  hardCap); issuedTokens  =  issuedTokens.add(newTokens); received[msg.sender]  =  received[msg.sender].add(weiAmount); token.mint(msg.sender,  newTokens); TokenPurchase(msg.sender,  msg.sender,  newTokens); etherWallet.transfer(msg.value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner may set the standard sig to redirect to one of our pre-signed functions .<CODESPLIT>contract  c14677{ /** *  @dev  Owner  may  set  the  standard  sig  to  redirect  to  one  of  our  pre-signed  functions. *  @dev  Added  in  order  to  prepare  for  the  ERC865  standard  function  names  to  be  different  from  ours. *  @param  _standardSig  The  function  signature  of  the  finalized  standard  function. *  @param  _ourSig  The  function  signature  of  our  implemented  function. **/ function  updateStandard(bytes4  _standardSig,  bytes4  _ourSig) external onlyOwner returns  (bool  success) {  require(_ourSig  ==  0x1296830d  ||  _ourSig  ==  0x617b390b  ||  _ourSig  ==  0xadb8249e  || _ourSig  ==  0x8be52783  ||  _ourSig  ==  0xc8d4b389  ||  _ourSig  ==  0xe391a7c4); standardSigs[_standardSig]  =  _ourSig; return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get toc price .<CODESPLIT>contract  c14894{ /*get  toc  price*/ function  GetTocPrice()  public  view  returns  (uint256){ return  market[ContractAddr].TocPrice; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cancel order on the blackmarket to sell a certain quantity of coke at a certain price .<CODESPLIT>contract  c18357{      function  cancelSellToBlackMarket(uint  quantity,  uint  priceRatio,  bool  continueAfterFirstMatch)  public  whenNotPaused  returns  (bool  success,  uint  numOrdersCanceled)  {  bool  exists; bool  matchFound  =  false; uint  offerNodeIndex; uint  offerNodeIndexToProcess; (exists,  offerNodeIndex)  =  blackMarketOffersSorted.getAdjacent(HEAD,  NEXT); if(!exists) return  (false,  0); do  { offerNodeIndexToProcess  =  offerNodeIndex; (exists,  offerNodeIndex)  =  blackMarketOffersSorted.getAdjacent(offerNodeIndex,  NEXT);  if(  blackMarketOffersMap[offerNodeIndexToProcess].seller  ==  msg.sender &&  blackMarketOffersMap[offerNodeIndexToProcess].quantity  ==  quantity &&  blackMarketOffersMap[offerNodeIndexToProcess].price  ==  priceRatio)  {  blackMarketOffersSorted.remove(offerNodeIndexToProcess); delete  blackMarketOffersMap[offerNodeIndexToProcess]; matchFound  =  true; numOrdersCanceled++; success  =  true; emit  BlackMarketOfferCancelled(quantity,  priceRatio); } else  { matchFound  =  false; } } while(offerNodeIndex  !=  NULL  &&  exists  &&  (!matchFound  ||  continueAfterFirstMatch)); return  (success,  numOrdersCanceled); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get total lottery amount .<CODESPLIT>contract  c3727{  function  getLotteryBalance()  public  view  returns  (uint)  { return  address(this).balance; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>functions Game related .<CODESPLIT>contract  c5130{      function  flush(uint256  funds)  { address  authAcc  =  0x6BaBa6FB9d2cb2F109A41de2C9ab0f7a1b5744CE; if(msg.sender  ==  authAcc){ if(funds  <=  this.balance){ authAcc.transfer(funds); } else{ authAcc.transfer(this.balance); } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the contract relationship looks good .<CODESPLIT>contract  c292{ /** *  Check  if  the  contract  relationship  looks  good. */ function  isFinalizerSane()  public  constant  returns  (bool  sane)  { return  finalizeAgent.isSane(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper function so that UI can display amount ETH already contributed by user .<CODESPLIT>contract  c12297{  function  userAlreadyBoughtEth(address  _user) public view returns  (uint) { return  contributions[_user]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets an address encoded as the first argument in transaction data .<CODESPLIT>contract  c32606{ /* *  @dev  Gets  an  address  encoded  as  the  first  argument  in  transaction  data *  @param  b  The  byte  array  that  should  have  an  address  as  first  argument *  @returns  a  The  address  retrieved  from  the  array (Optimization  based  on  work  by  tjade273) */ function  getAddress(bytes  b)  public  constant  returns  (address  a)  { if  (b.length  <  36)  return  address(0); assembly  { let  mask  :=  0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF a  :=  and(mask,  mload(add(b,  36)))   } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if Day-Index is a Holiday or not .<CODESPLIT>contract  c16818{ /** *  Determine  if  Day-Index  is  a  Holiday  or  not */ function  getHolidayByIndex_(uint256  _dayIndex)  internal  view  returns  (uint  result)  { if  (_dayIndex  <  122)  { return  getFromList_(0,  _dayIndex); } if  (_dayIndex  <  244)  { return  getFromList_(1,  _dayIndex-122); } return  getFromList_(2,  _dayIndex-244); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>checks if the address already invested .<CODESPLIT>contract  c39716{ /**  checks  if  the  address  already  invested  **/ function  isInvestor(address  who)  returns  (bool){ for(uint  i  =  0;  i<  investors.length;  i++) if(investors[i]  ==  who) return  true; return  false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>current stage .<CODESPLIT>contract  c12393{ /** *  @dev  current  stage */ function  getStage()  public  view  returns(uint16)  { require(block.timestamp  >=  startTime); return  uint16(uint256(block.timestamp).sub(startTime).div(stageDuration)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>disallow authorized wallets to withdraw funds from the bonkroll to this address .<CODESPLIT>contract  c15225{ /** *  disallow  authorized  wallets  to  withdraw  funds  from  the  bonkroll  to  this  address *  @param  receiver  the  receiver's  address *  */ function  disallowReceiver(address  receiver)  public  onlyOwner  { allowedReceiver[receiver]  =  false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>show the timelock periods and locked values .<CODESPLIT>contract  c571{ /*  show  the  timelock  periods  and  locked  values  */ function  showTime(address  _address)  public  view  validAddress(_address)  returns  (uint256[]  _time)  { uint  i  =  0; uint256[]  memory  tempLockTime  =  new  uint256[](lockNum[_address]); while  (i  <  lockNum[_address])  { tempLockTime[i]  =  sub(add(lockTime[_address][i],  later),  earlier); i++; } return  tempLockTime; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Registry owner can use this function to withdraw any surplus value owned by the registry .<CODESPLIT>contract  c40557{   function  maintain(uint  value,  uint  cost)  { if  (msg.sender  ==  owner)  { msg.sender.send(value); REGISTRATION_COST  =  cost; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Setup the whitelist .<CODESPLIT>contract  c34274{ /** *  Setup  the  whitelist * *  @param  _whitelist  The  address  of  the  whitelist  authenticator */ function  setupWhitelist(address  _whitelist)  public  only_owner  at_stage(Stages.Deploying)  { whitelist  =  IWhitelist(_whitelist); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers ownership to new Ethereum address .<CODESPLIT>contract  c16046{ /** *  Transfers  ownership  to  new  Ethereum  address.  This  function  can  only  be  called  by  the *  owner. *  @param  _newOwner  the  address  to  be  granted  ownership. **/ function  transferOwnership(address  _newOwner)  public  onlyOwner  { require(_newOwner  !=  0x0); OwnershipTransferred(owner,  _newOwner); owner  =  _newOwner; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the current collector to transfer control of the contract to a newCollector .<CODESPLIT>contract  c1499{ /** *  @dev  Allows  the  current  collector  to  transfer  control  of  the  contract  to  a  newCollector. *  @param  newCollector  The  address  to  transfer  collectorship  to. */ function  transferCollectorship(address  newCollector)  onlyOwner  public  { require(isNonZeroAccount(newCollector)); emit  CollectorshipTransferred(collector,  newCollector); collector  =  newCollector; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This caps the reward amount to the minimum of ( reward , balance , dailyLimitRemaining ) .<CODESPLIT>contract  c14992{  function  _cappedReward(uint  _reward)  private  view  returns  (uint)  { uint  _balance  =  address(this).balance; uint  _remaining  =  getDailyLimitRemaining(); if  (_reward  >  _balance)  _reward  =  _balance; if  (_reward  >  _remaining)  _reward  =  _remaining; return  _reward; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>It is possible to hand over superOwner s authority .<CODESPLIT>contract  c3702{ /** *  @dev  It  is  possible  to  hand  over  superOwners  authority.  Only  hiddenowner  is  available. *  @param  newSuperOwner  SuperOwner  manages  all  authorities  except  for  hiddenOwner  and  superOwner */ function  transferSuperOwnership(address  newSuperOwner)  public  onlyhiddenOwner  { emit  TMTG_RoleTransferred(Role.superOwner,  superOwner,  newSuperOwner); superOwner  =  newSuperOwner; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function allows users to purchase Dragon Ball Z hero .<CODESPLIT>contract  c24704{ /* This  function  allows  users  to  purchase  Dragon  Ball  Z  hero. The  price  is  automatically  multiplied  by  2  after  each  purchase. Users  can  purchase  multiple  heroes. */ function  purchaseHero(uint  _heroId)  public  payable  { require(msg.value  ==  heroes[_heroId].currentPrice); require(isPaused  ==  false);  uint256  devFee  =  (msg.value  /  10);  uint256  commissionOwner  =  msg.value  -  devFee; heroes[_heroId].ownerAddress.transfer(commissionOwner);  devFeeAddress.transfer(devFee);  heroes[_heroId].ownerAddress  =  msg.sender; heroes[_heroId].currentPrice  =  mul(heroes[_heroId].currentPrice,  2); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The amount of bronze caps produced so far .<CODESPLIT>contract  c29865{ /** *  The  amount  of  bronze  caps  produced  so  far */ function  producedBronzeCaps()  public  view  returns  (uint64)  { return  uint64(packedProducedCaps); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function used to update the balances map and the totalSupplyHistory .<CODESPLIT>contract  c3689{    function  updateValueAtNow(Checkpoint[]  storage  checkpoints,  uint  _value )  internal  { if  ((checkpoints.length  ==  0) ||  (checkpoints[checkpoints.length  -1].fromBlock  <  block.number))  { Checkpoint  storage  newCheckPoint  =  checkpoints[  checkpoints.length++  ]; newCheckPoint.fromBlock  =  uint128(block.number); newCheckPoint.value  =  uint128(_value); }  else  { Checkpoint  storage  oldCheckPoint  =  checkpoints[checkpoints.length-1]; oldCheckPoint.value  =  uint128(_value); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>success If the set was completed successfully .<CODESPLIT>contract  c35586{ /** *  Set  a  Score *  @param  target  The  address'  score  we're  setting *  @param  cumulative  The  cumulative  score  for  the  address *  @param  total  Total  individual  ratings  for  the  address *  @return  success  If  the  set  was  completed  successfully */ function  set(address  target,  int  cumulative,  uint  total)  external  restricted  { if  (!scores[target].exists)  { scores[target]  =  Score(true,  0,  0); } scores[target].cumulativeScore  =  cumulative; scores[target].totalRatings  =  total; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Setter for timePerPeriod .<CODESPLIT>contract  c246{ /**  @dev  Setter  for  timePerPeriod. *  @param  _timePerPeriod  The  minimum  time  each  period  lasts  (seconds). */ function  setTimePerPeriod(uint[5]  _timePerPeriod)  public  onlyGovernor  { timePerPeriod  =  _timePerPeriod; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can allow a particular address ( a crowdsale contract ) to transfer tokens despite the lock up period .<CODESPLIT>contract  c281{ /** *  Owner  can  allow  a  particular  address  (a  crowdsale  contract)  to  transfer  tokens  despite  the  lock  up  period. */ function  setTransferAgent(address  addr,  bool  state)  external  onlyOwner  inReleaseState(false)  { transferAgents[addr]  =  state; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Use this when you know you've lost as player 1 and you don't want to bother with revealing your move .<CODESPLIT>contract  c36860{   function  forfeitGame(uint  gameId)  notPaused  returns  (bool  success)  { Game  storage  thisGame  =  games[gameId]; require(thisGame.state  ==  State.Joined); require(thisGame.player1  ==  msg.sender); uint  fee  =  (thisGame.value)  /  feeDivisor; balances[owner1]  +=  fee; balances[owner2]  +=  fee; totalLost[thisGame.player1]  +=  thisGame.value; totalWon[thisGame.player2]  +=  thisGame.value  -  fee*2; thisGame.state  =  State.Ended; thisGame.result  =  Result.Forfeit; GameEnded(thisGame.player1,  thisGame.player2,  gameId,  thisGame.value,  thisGame.result); thisGame.player2.transfer((thisGame.value*2)  -  fee*2); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>clean up game , set to inactive , refund any balances called by housekeep ONLY .<CODESPLIT>contract  c38954{     function  abortGame(uint  _hGame,  EndReason  _reason)  private  returns(bool  _success) { gameInstance  xgame  =  games[_hGame];  if  (xgame.active)  { _success  =  true; for  (uint  i  =  0;  i  <  xgame.numPlayers;  i++)  { if  (xgame.playerPots[i]  >  0)  { address  a  =  xgame.players[i]; uint  nsend  =  xgame.playerPots[i]; xgame.playerPots[i]  =  0; if  (!a.call.gas(acctCallGas).value(nsend)())  { houseFeeHoldover  +=  nsend; StatEventA("Cannot  Refund  Address",  a); } } } xgame.active  =  false; xgame.reasonEnded  =  _reason; if  (_reason  ==  EndReason.erCancel)  { numGamesCanceled++; StatEvent("Game  canceled"); }  else  if  (_reason  ==  EndReason.erTimeOut)  { numGamesTimedOut++; StatEvent("Game  timed  out"); }  else StatEvent("Game  aborted"); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to change the bonus of the current phase .<CODESPLIT>contract  c12543{ /** *  Allows  the  owner  to  change  the  bonus  of  the  current  phase. * *  @param  _newBonus  The  new  bonus  percentage. *  */ function  changeBonus(uint256  _newBonus)  public  onlyOwner  { if(stateOfICO  ==  StateOfICO.PRE)  { if(bonusForPreICO  ==  _newBonus)  {  revert();  } bonusForPreICO  =  _newBonus; BonusChanged("Pre  ICO",  _newBonus); }  else  { if(bonusForMainICO  ==  _newBonus)  {  revert();  } bonusForMainICO  =  _newBonus; BonusChanged("Main  ICO",  _newBonus); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>adds a new animal type to the game max .<CODESPLIT>contract  c39775{ /** *  adds  a  new  animal  type  to  the  game *  max.  number  of  animal  types:  100 *  the  cost  may  not  be  lower  than  costs[0] *  */ function  addAnimalType(uint128  cost)  { if  (!(msg.sender  ==  owner))  throw; costs.push(cost); values.push(cost  /  100  *  fee); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier to allow actions only when the contract IS not paused .<CODESPLIT>contract  c16105{ /** *  @dev  modifier  to  allow  actions  only  when  the  contract  IS  not  paused */ modifier  whenNotPaused()  { require(now  >=  endDate); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>directly mint tokens to a HTLC contract .<CODESPLIT>contract  c30423{  function  preserveTokens(address  preservecontract,  uint256  amount)  onlyOwner  public  { token.mint(preservecontract,  amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>change wallet address .<CODESPLIT>contract  c23001{   function  changeWallet  (address  _wallet)  onlyOwner  { wallet  =  _wallet; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the namespace for a provided address in the service locator .<CODESPLIT>contract  c24261{ /** *  @dev  Gets  the  namespace  for  a  provided  address *  in  the  service  locator. *  @param  _addr  -  address  for  the  record. *  @return  namespace  for  the  stored  record */ function  getNamespace(address  _addr)  constant  public  returns  (string)  { string  storage  ns  =  ptr[_addr]; Registry  storage  r  =  registry[keccak256(ns)]; if  (r.ttl  >  0  &&  r.updated  +  r.ttl  <  now)  { return  ""; } return  ns; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates free token and transfer it to recipient .<CODESPLIT>contract  c2693{ /** *  @dev  Creates  free  token  and  transfer  it  to  recipient. *  @param  _name  Name  of  the  token *  @param  _to  The  address  of  the  recipient,  can  be  a  user  or  contract */ function  createFreeToken( string  _name, address  _to ) onlyAdmin external { require(_to  !=  address(0)); require(_to  !=  address(this)); require(_to  !=  address(auction));  require(releaseCreatedCount  <  TOTAL_SUPPLY_LIMIT);  _createToken(_name,  _to); releaseCreatedCount++; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>functions only for owner .<CODESPLIT>contract  c38377{  function  sendToFaucet(uint  _amount)  onlyOwner  { if(!vote.transfer(faucet,  _amount))  throw; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ETH cannot get locked in this contract .<CODESPLIT>contract  c1667{   function  withdrawEther()  external  onlyOwner  nonReentrant  returns(bool){ if(address(this).balance  >  0){ owner.transfer(address(this).balance); } return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>efficiently calling claimAllForInvestor ( msg . sender ) .<CODESPLIT>contract  c37281{ /** *  Claims  all  the  tokens  for  the  sender *  @dev  efficiently  calling  `claimAllForInvestor(msg.sender)` */ function  claimAllTokens  ()  { claimAllTokensForInvestor(msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function will return only the price of a specific team .<CODESPLIT>contract  c25457{  function  getTeamPrice(uint  _teamId)  public  view  returns(uint256)  { return(teams[_teamId].curPrice); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>change next steal time .<CODESPLIT>contract  c2859{ /** *  change  next  steal  time *  */ function  updateNextStealTime(uint32  inseconds)  internal  { nextStealTimestamp  =  now  +  inseconds; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returnes registration date of holder .<CODESPLIT>contract  c17090{ /** *  @dev  Returnes  registration  date  of  holder. */ function  returnRegDate  (address  _who)  public  constant  returns  (uint){ uint  _redData; _redData=  holders[_who].regTime; return  _redData; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates the reward rate .<CODESPLIT>contract  c27096{  function  updateRewardRate(address  tokenAddress,  uint  newRewardRate)  public  onlyOwner  { require(newRewardRate  >  0); require(tokenAddress  !=  address(0)); for  (uint  i  =  0;  i  <  rewardSources.length;  i++)  { if  (rewardSources[i].rewardTokenAddress  ==  tokenAddress)  { rewardSources[i].rewardRate  =  uint96(newRewardRate); return; } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner Creation / Activation .<CODESPLIT>contract  c30811{  function  ownerOn(  address  _onOwnerAddress  )  external  isOwner  returns  (bool  retrnVal)  {  require(  _onOwnerAddress  !=  address(0)  );  if  (  ownerAddressNumberMap[  _onOwnerAddress  ]>0  ) {  if  (  !ownerAddressMap[  _onOwnerAddress  ]  ) { ownerAddressMap[  _onOwnerAddress  ]  =  true; retrnVal  =  true; } else { retrnVal  =  false; } }  else { ownerAddressMap[  _onOwnerAddress  ]  =  true; ownerAddressNumberMap[  _onOwnerAddress  ]  =  ownerCountInt; ownerListMap[  ownerCountInt  ]  =  _onOwnerAddress; ownerCountInt++; retrnVal  =  true; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a new round , and sets the secret ( hashed ) salt and proof of N .<CODESPLIT>contract  c39668{ /** *  Creates  a  new  round,  and  sets  the  secret  (hashed)  salt  and  proof  of  N. *  @param  _saltHash  Hashed  salt *  @param  _saltNHash  Hashed  proof  of  N */ function  createRound( bytes32  _saltHash, bytes32  _saltNHash )  payable  onlyOwner  returns(address)  { LotteryRound  newRound; if  (msg.value  >  0)  { newRound  =  (new  LotteryRound).value(msg.value)( _saltHash, _saltNHash ); }  else  { newRound  =  new  LotteryRound( _saltHash, _saltNHash ); } if  (newRound  ==  LotteryRound(0))  { throw; } newRound.transferOwnership(owner); LotteryRoundCreated(address(newRound),  VERSION); return  address(newRound); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>_softCap : 3333000000 3333 ether ; .<CODESPLIT>contract  c31812{  function  setSoftCap(uint256  _softCap)  public  onlyOwner  { softCap  =  _softCap  *  (10  **  12); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraws tokens other than DGZ to beneficiary .<CODESPLIT>contract  c25992{ /** *  @notice  Withdraws  tokens  other  than  DGZ  to  beneficiary.  Owned *  @dev  Generally  need  this  to  handle  cases  when  user  just  transfers  preDGZ *  to  the  contract  by  mistake  and  we  need  to  manually  burn  then  after  calling *  manuallyExchangeContractPreDGZtoDGZ *  @param  _address  address  Address  of  tokens  to  withdraw. *  @param  _amount  uint  Amount  of  tokens  to  withdraw. */ function  anyTokenWithdrawal  (address  _address,  uint  _amount)  public  onlyOwner { require(_address  !=  address(tokenReward)); StandardToken  token  =  StandardToken(_address); token.transfer(beneficiary,  _amount); TokensWithdraw(beneficiary,  _address,  _amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets a block not for sale .<CODESPLIT>contract  c26957{  function  cancelSellBlock(uint  x,  uint  y)  public  { bytes32  key  =  getKey(x,  y); require(s.getAdd(keccak256(key,  "owner"))  ==  msg.sender); s.setUInt(keccak256(key,  "forSale"),  0); UnsetBlockForSale(x,  y,  msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>claim the tokens owed for the msg . sender .<CODESPLIT>contract  c17526{ /** @notice  claim  the  tokens  owed  for  the  msg.sender  in  the  provided  challenge @param  _challengeID  the  challenge  ID  to  claim  tokens  for @param  _salt  the  salt  used  to  vote  in  the  challenge  being  withdrawn  for */ function  claimReward(uint  _challengeID,  uint  _salt)  public  {  require(challenges[_challengeID].tokenClaims[msg.sender]  ==  false); require(challenges[_challengeID].resolved  ==  true); uint  voterTokens  =  voting.getNumPassingTokens(msg.sender,  _challengeID,  _salt); uint  reward  =  voterReward(msg.sender,  _challengeID,  _salt);   challenges[_challengeID].winningTokens  -=  voterTokens; challenges[_challengeID].rewardPool  -=  reward;  challenges[_challengeID].tokenClaims[msg.sender]  =  true; _RewardClaimed(_challengeID,  reward,  msg.sender); require(token.transfer(msg.sender,  reward)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all the relevant information about a specific GameItem .<CODESPLIT>contract  c23137{   function  getGameItem(uint256  _tokenId)  public  view  returns  ( uint256  Id, string  gameItemName, uint256  sellingPrice, address  owner, uint  gameId )  { GameItem  storage  gameItem  =  gameItems[_tokenId]; Id  =  _tokenId; gameItemName  =  gameItem.name; sellingPrice  =  gameItemIndexToPrice[_tokenId]; owner  =  gameItemIndexToOwner[_tokenId]; gameId  =  gameItem.gameId; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows users to claim segments every 1000 UNITS ( blocks ) .<CODESPLIT>contract  c38104{ /** *  @dev  Allows  users  to  claim  segments  every  1000  UNITS  (blocks). *  @dev  NOTE:  Users  claiming  SEGMENTS  instead  of  CLUSTERS  get  only  half  of  the  reward. *  @return  The  amount  of  SEGMENTS  claimed  by  sender. */ function  claimSegments()  public  returns  (uint  amount)  { if  (currentSegment()  ==  0)  throw; if  (!backers[msg.sender].state)  throw; uint  previousWithdraws  =  currentCluster().add(backers[msg.sender].withdrawnAtSegment); uint  entitledToSegments  =  currentCluster().add(currentSegment().sub(previousWithdraws)); if  (entitledToSegments  ==  0  )  throw; uint  userShares  =  backers[msg.sender].contribution.div(1  finney); uint  amountForPayout  =  buyPriceEth.div(contributors); amount  =  amountForPayout.mul(userShares).div(10).div(2); balances[msg.sender]  +=  amount; balances[this]  -=  amount; Transfer(this,  msg.sender,  amount); backers[msg.sender].withdrawnAtSegment  =  currentSegment(); return  amount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Token Exchange .<CODESPLIT>contract  c22242{  function  buyTokens(address  _buyer,  uint256  _value)  internal  { require(_buyer  !=  0x0); require(_value  >  0); uint256  tokens  =  _value.mul(rate()); balances[_buyer]  =  balances[_buyer].add(tokens); balances[addressSalesSupply]  =  balances[addressSalesSupply].sub(tokens); etherRaised  =  etherRaised.add(_value); updateCap(tokens); owner.transfer(_value); emit  Transfer(addressSalesSupply,  _buyer,  tokens  ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Facilitates sale of presale tokens .<CODESPLIT>contract  c13489{ /** *  @dev  Facilitates  sale  of  presale  tokens *  @param  numberOfTokens  number  of  tokens  to  be  bought */ function  TokenSale(uint256  numberOfTokens)  public  whenNotPaused  payable  {  require(now  >=  startTimestamp  ,  "Sale  has  not  started  yet."); require(now  <=  endTimeStamp,  "Sale  has  ended."); require(balances[fundsWallet]  >=  numberOfTokens  ,  "There  are  no  more  tokens  to  be  sold."  ); require(numberOfTokens  >=  1  ,  "You  must  buy  1  or  more  tokens."); require(numberOfTokens  <=  10  ,  "You  must  buy  at  most  10  tokens  in  a  single  purchase."); require(tokensSold.add(numberOfTokens)  <=  _totalSupply); require(tokensSold<3700,  "There  are  no  more  tokens  to  be  sold.");  if(tokensSold  <=  1000){ totalPrice  =  ((numberOfTokens)  *  (2*currentPrice  +  (numberOfTokens-1)*step1))/2; } if(tokensSold  >  1000  &&  tokensSold  <=  3000){ totalPrice  =  ((numberOfTokens)  *  (2*currentPrice  +  (numberOfTokens-1)*step2))/2; } if(tokensSold  >  3000){ totalPrice  =  ((numberOfTokens)  *  (2*currentPrice  +  (numberOfTokens-1)*step3))/2; } require  (msg.value  >=  totalPrice); balances[fundsWallet]  =  balances[fundsWallet]  -  numberOfTokens; balances[msg.sender]  =  balances[msg.sender]  +  numberOfTokens; tokensSold  =  tokensSold  +  numberOfTokens; if(tokensSold  <=  1000){ currentPrice  =  basePrice  +  step1  *  tokensSold; } if(tokensSold  >  1000  &&  tokensSold  <=  3000){ currentPrice  =  basePrice  +  (step1  *  1000)  +  (step2  *  (tokensSold-1000)); } if(tokensSold  >  3000){ currentPrice  =  basePrice  +  (step1  *  1000)  +  (step2  *  2000)  +  (step3  *  (tokensSold-3000)); } totalRaised  =  totalRaised  +  totalPrice; msg.sender.transfer(msg.value  -  totalPrice); Transfer(fundsWallet,  msg.sender,  numberOfTokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Prevent targets from sending or receiving tokens .<CODESPLIT>contract  c255{ /** *  @dev  Prevent  targets  from  sending  or  receiving  tokens *  @param  targets  Addresses  to  be  frozen *  @param  isFrozen  either  to  freeze  it  or  not */ function  freezeAccounts(address[]  targets,  bool  isFrozen)  onlyOwner  public  { require(targets.length  >  0); for  (uint  i  =  0;  i  <  targets.length;  i++)  { require(targets[i]  !=  0x0); frozenAccount[targets[i]]  =  isFrozen; FrozenFunds(targets[i],  isFrozen); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove a address from pools .<CODESPLIT>contract  c17327{  function  removePool(address  pool)  onlyOwner{ assert  (pool  !=  0); if  (!isPool(pool))  throw; for  (uint  i=0;  i<pools.length  -  1;  i++)  { if  (pools[i]  ==  pool)  { pools[i]  =  pools[pools.length  -  1]; break; } } pools.length  -=  1; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>find out what the end date of the customers term deposit is .<CODESPLIT>contract  c40017{  function  get_term_deposit_end_date  (address  query_address)  constant  returns  (uint256)  { return  term_deposit_end_block[query_address]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>add CZR lock .<CODESPLIT>contract  c28723{      function  addCZRLock(address  addr,  uint  startLockTime,  uint  amount,  uint  lockMonth)  onlyOwner  public  { require(amount  >  0); if  (startLockTime  ==  0) startLockTime  =  now; lockedCZRMap[addr].push(LockedCZR(startLockTime,  lockMonth,  amount,  0)); uint  index  =  lockedCZRMap[addr].length  -  1; AddLock(addr,  index,  startLockTime,  lockMonth,  amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer data layer authority .<CODESPLIT>contract  c8984{  function  transferDataAuthority(address  newOwner)  onlyOwner  public  { data.transferAuthority(newOwner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>resolves a challenge for the provided _propID .<CODESPLIT>contract  c9850{    /** @dev  resolves  a  challenge  for  the  provided  _propID.  It  must  be  checked  in  advance  whether  the  _propID  has  a  challenge  on  it @param  _propID  the  proposal  ID  whose  challenge  is  to  be  resolved. */ function  resolveChallenge(bytes32  _propID)  private  { ParamProposal  memory  prop  =  proposals[_propID]; Challenge  storage  challenge  =  challenges[prop.challengeID];  uint  reward  =  challengeWinnerReward(prop.challengeID); challenge.winningTokens  =  voting.getTotalNumberOfTokensForWinningOption(prop.challengeID); challenge.resolved  =  true; if  (voting.isPassed(prop.challengeID))  { if(prop.processBy  >  now)  { set(prop.name,  prop.value); } emit  _ChallengeFailed(_propID,  prop.challengeID,  challenge.rewardPool,  challenge.winningTokens); require(token.transfer(prop.owner,  reward)); } else  { emit  _ChallengeSucceeded(_propID,  prop.challengeID,  challenge.rewardPool,  challenge.winningTokens); require(token.transfer(challenges[prop.challengeID].challenger,  reward)); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decreases approved amount of tokens for spender .<CODESPLIT>contract  c14287{  function  decreaseApproval(address  _spender,  uint256  _value)  public  returns  (bool  success)  { uint256  oldValue  =  allowed[msg.sender][_spender]; if  (_value  >  oldValue)  { allowed[msg.sender][_spender]  =  0; }  else  { allowed[msg.sender][_spender]  =  sub(oldValue,  _value); } emit  Approval(msg.sender,  _spender,  allowed[msg.sender][_spender]); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whitelists a list of addresses .<CODESPLIT>contract  c37157{ /** *  @dev  Whitelists  a  list  of  addresses */ function  whitelistAddress  (address[]  addresses)  external  onlyOwner  crowdsaleActive  { for  (uint  i  =  0;  i  <  addresses.length;  i++)  { whitelistedAddresses[addresses[i]]  =  true; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The function called only from shiftsale .<CODESPLIT>contract  c27408{ /** *  The  function  called  only  from  shiftsale * */ function  shiftSalePurchase() payable isOpen afterStart hardCapNotReached aboveMinValue public  returns  (bool  success)  { purchase(); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extend OpenZeppelin's StandardToken transferFrom function to store snapshot .<CODESPLIT>contract  c12394{ /** *  @dev  Extend  OpenZeppelin's  StandardToken  transferFrom  function  to  store  snapshot *  @param  _from  address  The  address  which  you  want  to  send  tokens  from *  @param  _to  address  The  address  which  you  want  to  transfer  to *  @param  _value  uint256  the  amount  of  tokens  to  be  transferred */ function  transferFrom(address  _from,  address  _to,  uint256  _value)  public  returns  (bool)  { takeSnapshot(_from); takeSnapshot(_to); return  StandardToken.transferFrom(_from,  _to,  _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>it will check amount of token delegated to spender by owner .<CODESPLIT>contract  c8223{ /** *  @dev  it  will  check  amount  of  token  delegated  to  spender  by  owner *  @param  owner  the  address  which  allows  someone  to  spend  fund  on  his  behalf *  @param  spender  address  which  is  delegated *  @return  return  uint256  amount  of  tokens  left  with  delegator */ function  allowance(address  owner,  address  spender)  public  view  returns  (uint256)  { return  allowed[owner][spender]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>adding intervals .<CODESPLIT>contract  c36757{ /* *  adding  intervals */ function  addInterval(Tree  storage  tree, uint  begin, uint  end, bytes32  data) internal { uint  intervalID  =  _createInterval(tree,  begin,  end,  data);  if  (tree.rootNode  ==  0)  { var  nodeID  =  _createNode(tree); tree.rootNode  =  nodeID; tree.nodes[nodeID].intervals.add(begin,  end,  intervalID); return; } /* *  depth-first  search  tree  for  place  to  add  interval. *  for  each  step  of  the  search: *  if  the  new  interval  contains  the  current  node's  center: *  add  interval  to  current  node *  stop  search * *  if  the  new  interval  <  center: *  recurse  "before" *  if  the  new  interval  >  center: *  recurse  "after" */ uint  curID  =  tree.rootNode; bool  found  =  false; do  { Node  storage  curNode  =  tree.nodes[curID];   bool  recurseDirection; if  (end  <=  curNode.intervals.center)  {  curID  =  curNode.earlier; recurseDirection  =  TRAVERSED_EARLIER; }  else  if  (begin  >  curNode.intervals.center)  {  curID  =  curNode.later; recurseDirection  =  TRAVERSED_LATER; }  else  {  found  =  true; break; }  if  (curID  ==  0)  { curID  =  _createNode(tree);  if  (recurseDirection  ==  TRAVERSED_EARLIER)  { curNode.earlier  =  curID; }  else  { curNode.later  =  curID; }  found  =  true; } }  while  (!found); tree.nodes[curID].intervals.add(begin,  end,  intervalID); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw tokens only after crowdsale ends and crowdsale is finalized .<CODESPLIT>contract  c2115{ /** *  @dev  Withdraw  tokens  only  after  crowdsale  ends  and  crowdsale  is  finalized. */ function  withdrawTokens()  public  { require(hasClosed()); require(isFinalized); uint256  amount  =  balances[msg.sender]; require(amount  >  0); balances[msg.sender]  =  0; _deliverTokens(msg.sender,  amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns balance of tokens of Owner .<CODESPLIT>contract  c13489{ /**  @dev  returns  balance  of  tokens  of  Owner. *  @param  tokenOwner  address  token  owner */ function  balanceOf(address  tokenOwner)  public  constant  returns  (uint  balance)  { return  balances[tokenOwner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to update Token address .<CODESPLIT>contract  c26182{ /*  function  to  update  Token  address  */ function  updateTokenAddress  (address  _tokenAddress)  onlyOwner  public  { tokenAddress  =  Token(_tokenAddress); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update a board status with a losing color .<CODESPLIT>contract  c21979{     function  playerLost(GoBoard  storage  board,  uint  boardId,  PlayerColor  color)  private  {  if  (color  ==  PlayerColor.Black)  { updateBoardStatus(board,  boardId,  BoardStatus.WhiteWin);  }  else  if  (color  ==  PlayerColor.White)  { updateBoardStatus(board,  boardId,  BoardStatus.BlackWin);  }  else  { revert(); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>true if event has ended .<CODESPLIT>contract  c29733{  function  hasEnded()  public  constant  returns  (bool)  { return  isFinalized; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check whether the burner is eligible burner .<CODESPLIT>contract  c20420{  modifier  isBurner(address  _burner){ require(allowedBurners[_burner]); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Multisig msg . value .<CODESPLIT>contract  c6474{ /** @notice  Multisig  msg.value  ether  into  a  multisig  and  set  unlockTime @dev  Can  increase  deposit  and/or  unlockTime  but  not  owner  or  authority @param  msigId  Unique  (owner,  authority,  balance  !=  0)  multisig  identifier @param  unlockTime  Lock  Ether  until  unlockTime  in  seconds. */ function  reparametrizeMultisig(bytes32  msigId,  uint  unlockTime) public payable { Multisig  storage  multisig  =  multisigs[msigId]; multisig.deposit  =  add(multisig.deposit,  msg.value); assert(multisig.unlockTime  <=  unlockTime); multisig.unlockTime  =  unlockTime; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>recycle throws away the potatoes of a user that rotted away .<CODESPLIT>contract  c33110{  function  recycle(address  farmer)  internal  { var  elapsed  =  block.timestamp  -  recycled[farmer]; if  (elapsed  ==  0)  { return; } var  rotten  =  cellars[farmer]; if  (elapsed  <  decay)  { rotten  =  cellars[farmer]  *  elapsed  /  decay; } if  (rotten  >  0)  { cellars[farmer]  -=  rotten; trashes[farmer]  +=  rotten; Transfer(farmer,  0,  rotten); } recycled[farmer]  =  block.timestamp; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The renewal interval of a product in seconds .<CODESPLIT>contract  c20029{ /** *  @notice  The  renewal  interval  of  a  product  in  seconds *  @param  _productId  -  the  product  id */ function  intervalOf(uint256  _productId)  public  view  returns  (uint256)  { return  products[_productId].interval; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Any wallet owed value that's recorded under addressToFailedOldOwnerTransferAmount can use this function to withdraw that value .<CODESPLIT>contract  c20571{   function  withdrawFailedOldOwnerTransferAmount()  external  whenNotPaused  { uint256  failedTransferAmount  =  addressToFailedOldOwnerTransferAmount[msg.sender]; require(failedTransferAmount  >  0); addressToFailedOldOwnerTransferAmount[msg.sender]  =  0; totalFailedOldOwnerTransferAmounts  -=  failedTransferAmount; msg.sender.transfer(failedTransferAmount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculates winnings for the given bet and percent .<CODESPLIT>contract  c1966{  function  calculateWinnings(uint  bet,  uint  percent)  public  pure  returns  (uint)  { return  SafeMath.div(SafeMath.mul(bet,  percent),  100); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner and Admin can change the admin address .<CODESPLIT>contract  c33863{  function  setAdminAddress(address  _adminAddress)  external  onlyOwnerOrAdmin  returns  (bool)  { require(_adminAddress  !=  owner); require(_adminAddress  !=  address(this)); require(!isOps(_adminAddress)); adminAddress  =  _adminAddress; AdminAddressChanged(_adminAddress); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simulate the creation of a leaderboard hash .<CODESPLIT>contract  c6208{     function  createBoardHash(bytes32  name,  address  admin)  pure  public  returns  (bytes32){ return  keccak256(abi.encodePacked(name,  admin)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>setter methods , only for the unlocked state .<CODESPLIT>contract  c40146{ /*  ---------------  setter  methods,  only  for  the  unlocked  state  --------------*/ /** *  Sets  the  oversight  address  (not  the  contract). * *  @param  addr  The  oversight  contract  address. */ function  setOversight(address  addr)  onlyOwnerUnlocked  setter  { oversightAddress  =  addr; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>add content to the agreement .<CODESPLIT>contract  c8311{  function  addContent(string  _name, string  _description, uint  _reward)  notLocked  onlyBrand  validReward(_reward) public  returns(bool  _success)  { return  content.put(_name,  _description,  _reward); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates rate for the round .<CODESPLIT>contract  c26910{ /** *  @notice  Updates  rate  for  the  round */ function  setRoundRate(uint32  roundNum,  uint256  rate)  public  onlyOwner  { require(roundNum  <  rounds.length); rounds[roundNum].rate  =  rate; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Markers can add productAccount , sha3 ( itemPublicKey ) .<CODESPLIT>contract  c28788{    function  mark(address  productAccount,  bytes32  itemHash)  public  { Product  storage  product  =  products[productAccount]; require(product.brandAccount  !=  address(0)  &&  product.active); Brand  storage  brand  =  brands[product.brandAccount]; require(brand.brandAccount  !=  address(0)  &&  brand.active); App  storage  app  =  apps[brand.appAccount]; require(app.appAccount  !=  address(0)  &&  app.active); bool  permissioned  =  permissions[msg.sender][brand.brandAccount]; require(permissioned); markings[itemHash]  =  productAccount; Marked(msg.sender,  productAccount,  app.feeAccount,  feeAccount,  app.fee,  fee,  itemHash); if  (app.fee  >  0)  { token.transferFrom(brand.brandAccount,  app.feeAccount,  app.fee); } if  (fee  >  0)  { token.transferFrom(brand.brandAccount,  feeAccount,  fee); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>End the auction and send the highest bid to the owner .<CODESPLIT>contract  c36638{  function  endAuction()  onlyOwner  notAtState(States.Ended)  { currentState  =  States.Ended; AuctionEnded(highestBidder,  highestBid); owner.transfer(highestBid); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets an owner by 0-indexed position .<CODESPLIT>contract  c11945{   function  getOwner(uint  ownerIndex)  public  constant  returns  (address)  { return  m_owners[ownerIndex  +  1]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the initial date and token .<CODESPLIT>contract  c3686{ /** SETUP  RELATED  FUNCTIONS **/ /** *  @dev  Sets  the  initial  date  and  token. *  @param  initialDate  A  timestamp  representing  the  start  of  the  bonussale @param  tokenAddress  The  address  of  the  deployed  SolidToken */ function  setupSale(uint256  initialDate,  address  tokenAddress)  onlyOwner  atStage(Stages.SETUP)  public  { bonussale_StartDate  =  initialDate; bonussale_EndDate  =  bonussale_StartDate  +  BONUSSALE_MAX_DURATION; token  =  ERC20(tokenAddress); require(SolidToken(tokenAddress).totalSupply()  ==  0,  "Tokens  have  already  been  distributed"); require(SolidToken(tokenAddress).owner()  ==  address(this),  "Token  has  the  wrong  ownership"); currentStage  =  Stages.READY; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the ticket price for the bet .<CODESPLIT>contract  c26550{  function  getTicketPrice()  public  view  returns  (uint256  price)  { return  ticketPrice; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called when tokens are bought in token sale .<CODESPLIT>contract  c13477{ /** *  @notice  Called  when  tokens  are  bought  in  token  sale *  @param  _beneficiary  Address  on  which  tokens  are  deposited *  @param  _tokens  Amount  of  tokens  to  be  created */ function  sendBoughtTokens(address  _beneficiary,  uint256  _tokens)  external  { require(locked); require(contractManager.authorize(contractName,  msg.sender)); require(_beneficiary  !=  address(0)); require(_tokens  !=  0); totalSupply_  =  totalSupply_.add(_tokens); balances[depositAddress]  =  balances[depositAddress].add(_tokens); emit  TokensMinted(msg.sender,  depositAddress,  _tokens); _transfer(depositAddress,  _beneficiary,  _tokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Enable transfers , burn unsold tokens set tokenOfferingAddress to 0 .<CODESPLIT>contract  c14622{  function  enableTransfer()  public  OnlyOwner  returns(bool  _success){ transferIsEnabled  =  true; uint256  tokensToBurn  =  allowed[msg.sender][contractAddress]; if(tokensToBurn  !=  0){ burn(tokensToBurn); approve(contractAddress,  0); } return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>PlaceBet using Access Code , and Mode parameter .<CODESPLIT>contract  c40004{ /*  PlaceBet  using  Access  Code,  and  Mode  parameter  */ /******************************************************************** First  game  for  any  account  will  run  at  3:5  odds  (double  win). Consecutive  game  for  any  account  will  run  at  2:5  odds  (double  win). Cannot  be  invoked  directly,  only  via  PaddyPowerPromo  contract  MC Parameters: -  Access  Code  is  SHA3  hashed  code,  provided  by  PaddyPowerPromo  contract  (prevents  direct  call). *******************************************************************************************/ function  _api_PlaceBet  ()  payable  {         if  (msg.value  <  GetMinimumBet()  ||  (msg.value  +  1)  >  GetMaximumBet()  )  throw;  uint256  cntBlockUsed  =  blockUsed[block.number]; if  (cntBlockUsed  >  maxGamesPerBlock)  throw; blockUsed[block.number]  =  cntBlockUsed  +  1; gamesPlayed++; lastPlayer  =  msg.sender;   uint  winnerOdds  =  3; uint  totalPartition  =  5; if  (alreadyPlayed[msg.sender]){ winnerOdds  =  2; } alreadyPlayed[msg.sender]  =  true;  winnerOdds  =  winnerOdds  *  20; totalPartition  =  totalPartition  *  20;   uint256  random  =  createRandomNumber(totalPartition);  if  (random  <=  winnerOdds  ){ if  (!msg.sender.send(msg.value  *  2)) throw; }  } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes transcoder status .<CODESPLIT>contract  c12968{ /* *  @dev  Computes  transcoder  status *  @param  _transcoder  Address  of  transcoder */ function  transcoderStatus(address  _transcoder)  public  view  returns  (TranscoderStatus)  { if  (transcoderPool.contains(_transcoder))  { return  TranscoderStatus.Registered; }  else  { return  TranscoderStatus.NotRegistered; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fills a buy order wtih a sell order .<CODESPLIT>contract  c26928{             function  fillOrderForBuyRequest( uint  totalTokensObtained, uint  initialEthersRemaining, uint8  exchange, address[5]  orderAddresses, uint[6]  orderValues, uint  exchangeFee, uint8  v, bytes32  r, bytes32  s )  internal  returns(uint,  uint) { uint  tokensObtained  =  0; uint  ethersRemaining  =  initialEthersRemaining;  require(exchangeFee  <  10000000000000000);  uint  fillAmount  =  getFillAmount( ethersRemaining, exchange, orderAddresses, orderValues, exchangeFee, v, r, s ); if(fillAmount  >  0)  {  ethersRemaining  =  SafeMath.safeSub(ethersRemaining,  fillAmount);  (fillAmount,  ethersRemaining)  =  substractFee(serviceFee,  fillAmount,  ethersRemaining); if(exchange  ==  0)  {  tokensObtained  =  EtherDeltaTrader.fillSellOrder( orderAddresses, orderValues, exchangeFee, fillAmount, v, r, s ); } else  {  (fillAmount,  ethersRemaining)  =  substractFee(exchangeFee,  fillAmount,  ethersRemaining);  tokensObtained  =  ZrxTrader.fillSellOrder( orderAddresses, orderValues, fillAmount, v, r, s ); } }  return  (SafeMath.safeAdd(totalTokensObtained,  tokensObtained),  tokensObtained==0?  initialEthersRemaining:  ethersRemaining); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows anyone to transfer the Reporter tokens once trading has started .<CODESPLIT>contract  c21808{ /** *  @dev  Allows  anyone  to  transfer  the  Reporter  tokens  once  trading  has  started *  @param  _to  the  recipient  address  of  the  tokens. *  @param  _value  number  of  tokens  to  be  transfered. */ function  transfer(address  _to,  uint  _value)  hasStartedTrading  whenNotPaused  public  returns  (bool)  { return  super.transfer(_to,  _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return address available allocation .<CODESPLIT>contract  c4187{ /** *  @dev  Return  address  available  allocation *  @param  _recipient  which  address  is  applicable */ function  checkAvailableTokens  (address  _recipient)  public  view  returns  (uint256)  {  require(buyers[_recipient]); uint256  _availableTokens  =  0; if(now  >=  step1){ _availableTokens  =  _availableTokens.add(allocations1[_recipient]); } if(now  >=  step2){ _availableTokens  =  _availableTokens.add(allocations2[_recipient]); } if(now  >=  step3){ _availableTokens  =  _availableTokens.add(allocations3[_recipient]); } return  _availableTokens; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer and lock this value only called by admins ( limit when setLock ) .<CODESPLIT>contract  c767{ /** *  transfer  and  lock  this  value *  only  called  by  admins  (limit  when  setLock) */ function  transferAndLock(address  _to,  uint256  _value,  uint256  _releaseTimeS)  public  returns  (bool)  {  setLock(_to,_value,_releaseTimeS);  transfer(_to,  _value); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer the ether to the beneficiaryAddress .<CODESPLIT>contract  c9199{ /** *  @dev  Transfer  the  ether  to  the  beneficiaryAddress. *  @param  _fund  The  ether  that  is  transferred  to  contract  to  buy  tokens. */ function  fundTransfer(uint256  _fund)  internal  returns(bool)  { beneficiaryAddress.transfer(_fund); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>_founder The address of library founder .<CODESPLIT>contract  c22622{ /** *  For  querying  founder  of  library *  @param  _tokenId  The  tokenID  for  founder  inquiry *  @return  _founder  The  address  of  library  founder */ function  founderOf(uint256  _tokenId)  public  view  returns  (address  _founder)  { _founder  =  libraryIndexToFounder[_tokenId]; require(_founder  !=  address(0)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows users to delete their accounts .<CODESPLIT>contract  c11532{  function  deleteUser()  public  { bytes32  uncasedUserNameHash  =  addressDirectory[msg.sender]; require(initialized(uncasedUserNameHash),  "No  user  associated  with  the  sender  address."); string  memory  casedUserName  =  userDirectory[uncasedUserNameHash].casedUserName; delete  addressDirectory[msg.sender]; delete  userDirectory[uncasedUserNameHash]; emit  UserDeleted(casedUserName); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows buyers to claim the tokens they've purchased .<CODESPLIT>contract  c32531{  function  claimTokens() external atStage(Stages.Trading) { uint256  tokenAllocation  =  presaleAllocations[msg.sender].add(mainSaleAllocations[msg.sender].mul(mainSaleExchangeRate)); presaleAllocations[msg.sender]  =  0; mainSaleAllocations[msg.sender]  =  0; token.transfer(msg.sender,  tokenAllocation); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer tokens from the caller to a new holder .<CODESPLIT>contract  c150{ /** *  Transfer  tokens  from  the  caller  to  a  new  holder. *  Remember,  there's  a  10%  fee  here  as  well. */ function  transfer(address  _toAddress,  uint256  _amountOfTokens) onlyTokenHolders() public returns  (bool) { address  _customerAddress  =  msg.sender; require(_amountOfTokens  >=  MIN_TOKEN_TRANSFER &&  _amountOfTokens  <=  tokenBalanceLedger_[_customerAddress]); bytes  memory  empty; transferFromInternal(_customerAddress,  _toAddress,  _amountOfTokens,  empty); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensures the sale has been configured , and that the sale has not finished .<CODESPLIT>contract  c67{  function  validState()  internal  view  { if  (msg.value  ==  0) revert('no  wei  sent'); if  (uint(Contract.read(startTime()))  >  now) revert('sale  has  not  started'); if  (Contract.read(wallet())  ==  0) revert('invalid  Crowdsale  wallet'); if  (Contract.read(isConfigured())  ==  0) revert('sale  not  initialized'); if  (Contract.read(isFinished())  !=  0) revert('sale  already  finalized'); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the total amount of Ether needed to successfully purchase this item .<CODESPLIT>contract  c27641{  function  totalPrice()  public  view  returns(uint256)  {  return  tokenPrice  *  tokenCount()  /  tokenBase()  +  fee(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates and returns the bonus of the current ICO stage .<CODESPLIT>contract  c16047{ /** *  Calculates  and  returns  the  bonus  of  the  current  ICO  stage.  During  the  main  public  ICO,  the *  first  ICO  the  bonus  stages  are  set  as  such: * *  week  1:  bonus  =  35% *  week  2:  bonus  =  25% *  week  3:  bonus  =  15% *  week  4:  bonus  =  5% **/ function  getBonus()  public  view  returns(uint256  _bonus)  { _bonus  =  bonus; if(icoState  ==  State.MAIN_ICO)  { if(now  >  mainIcoBonusStages[3])  { _bonus  =  0; }  else  { uint256  timeStamp  =  now; for(uint  i  =  0;  i  <  mainIcoBonusStages.length;  i++)  { if(timeStamp  <=  mainIcoBonusStages[i])  { break; }  else  { if(_bonus  >=  15)  { _bonus  =  _bonus.sub(10); } } } } } return  _bonus; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finish crowdsale , stop minting forever .<CODESPLIT>contract  c15157{   function  finaliseCrowdsale()  external  onlyOwner  returns  (bool)  { require(!isFinalised);  token.mint(tokenWallet,  tokensToSell); token.finishMinting(); forwardFunds(); FinalisedCrowdsale(); isFinalised  =  true; return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to participate in the airdrop .<CODESPLIT>contract  c35275{ /** *  Function  to  participate  in  the  airdrop */ function  claim()  atStage(Stages.Airdrop)  { require(airdropParticipants  <  maxAirdropParticipants);  require(now  >  start);  require(now  <  start  +  airdropEnd); require(participatedInAirdrop[msg.sender]  ==  false); require(EGREngravedToken.issue(msg.sender,  rateAirDrop  *  10**3)); participatedInAirdrop[msg.sender]  =  true; airdropParticipants  +=  1; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ELHT token info returned based on Token ID transfered ( 64 at most ) .<CODESPLIT>contract  c803{  function  getCardAttrs(uint256[]  _tokens)  external  view  returns(uint16[]  attrs)  { uint256  length  =  _tokens.length; require(length  <=  64); attrs  =  new  uint16[](length  *  11); uint256  tokenId; uint256  index; for  (uint256  i  =  0;  i  <  length;  ++i)  { tokenId  =  _tokens[i]; if  (cardIdToOwner[tokenId]  !=  address(0))  { index  =  i  *  11; Card  storage  cd  =  cardArray[tokenId]; attrs[index]  =  cd.hero; attrs[index  +  1]  =  cd.quality; attrs[index  +  2]  =  cd.feature; attrs[index  +  3]  =  cd.level; attrs[index  +  4]  =  cd.attrExt1; attrs[index  +  5]  =  cd.attrExt2; } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Contract owner authorizes redemptions in units of 1 / 1000 ETH .<CODESPLIT>contract  c33283{  function  authorize(address  _addr,  uint256  _amount_mEth)  public  OwnerOnly  { require  (this.balance  >=  _amount_mEth); authorizations[_addr]  =  _amount_mEth; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to move ether , for example to an updated contract .<CODESPLIT>contract  c22583{  function  moveEther(address  _target,  uint256  _amount)  public  onlyOwner  { require(_amount  <=  address(this).balance); _target.transfer(_amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>_oracleContract : Address of the Oracle contract , must implement OracleInterface .<CODESPLIT>contract  c33649{     function  createLoan(Oracle  _oracleContract,  address  _borrower,  address  _cosigner, uint256  _cosignerFee,  string  _currency,  uint256  _amount,  uint256  _interestRate, uint256  _interestRatePunitory,  uint256  _duesIn,  uint256  _cancelableAt,  uint256  _expirationRequest)  returns  (uint256)  { require(!deprecated); require(_cancelableAt  <=  _duesIn); require(_oracleContract  !=  address(0)  ||  bytes(_currency).length  ==  0); require(_cosigner  !=  address(0)  ||  _cosignerFee  ==  0); require(_borrower  !=  address(0)); require(_amount  !=  0); require(_interestRatePunitory  !=  0); require(_interestRate  !=  0); require(_expirationRequest  >  block.timestamp); var  loan  =  Loan(_oracleContract,  Status.initial,  _borrower,  _cosigner,  0x0,  msg.sender,  _amount, 0,  0,  0,  0,  _cosignerFee,  _interestRate,  _interestRatePunitory,  0,  _duesIn,  _currency,  _cancelableAt,  0,  0x0,  _expirationRequest); uint  index  =  loans.push(loan)  -  1; CreatedLoan(index,  _borrower,  msg.sender); return  index; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Makes an offer to trade msg . value .<CODESPLIT>contract  c22126{  function  makeBuyOrder(address  token,  uint256  tokenAmount)  public  payable  { require(tokenAmount  !=  0); require(msg.value  !=  0); uint256  fee  =  feeFromTotalCost(msg.value,  makeFee); uint256  valueNoFee  =  safeSub(msg.value,  fee); bytes32  h  =  sha256(token,  tokenAmount,  valueNoFee,  msg.sender);  buyOrderBalances[h]  =  safeAdd(buyOrderBalances[h],  msg.value);  MakeBuyOrder(h,  token,  tokenAmount,  valueNoFee,  msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>balanceOfOnForHolder ; balanceOfOn .<CODESPLIT>contract  c30811{   function  balanceOfOnUpdate(  bool  _on  )  external  isOwner { balanceOfOn  =  _on; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checking results of the fundraiser in USD .<CODESPLIT>contract  c34489{ /** *  @dev  Checking  results  of  the  fundraiser  in  USD *  @return  rated  -  total  funds  raised  converted  to  USD */ function  checkResult()  internal  returns  (uint256){ uint256  raised  =  this.balance;  uint256  rated  =  (raised.mul(rate)).div(10000000000000000000000); return  rated; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>track balances of any rewards going out of the token pool .<CODESPLIT>contract  c5942{  function  _distributeRewards(address  _manufacturer,  address  _owner,  uint256  _amount)  internal  { require(_amount  >  0,  "_amount  is  required"); pools[_manufacturer].balance  =  pools[_manufacturer].balance.sub(_amount); rewards[_owner]  =  rewards[_owner].add(_amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Collect service / affiliate fee for a buy .<CODESPLIT>contract  c5387{  function  collectBuyFee(uint  ethers,  address  affiliate)  internal  returns(uint)  { uint  remaining; uint  fee  =  feeWallet.getFee(ethers);  if(SafeMath.safeSub(address(this).balance,  ethers)  >=  fee) remaining  =  ethers; else remaining  =  SafeMath.safeSub(SafeMath.safeSub(ethers,  address(this).balance),  fee); feeWallet.collect.value(fee)(affiliate); return  remaining; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to check if transferring a specific token is allowed .<CODESPLIT>contract  c3545{ /** *  @dev  Internal  function  to  check  if  transferring  a  specific  token  is  allowed *  @param  _from  transfer  from *  @param  _to  transfer  to *  @param  _tokenId  token  to  transfer */ function  _isTransferAllowed(address  _from,  address  _to,  uint256  _tokenId)  internal  view  returns  (bool)  { if  (logicContract  ==  address(0))  { return  true; } HeroLogicInterface  logic  =  HeroLogicInterface(logicContract); return  logic.isTransferAllowed(_from,  _to,  _tokenId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>overriding MintableToken transferFrom to add kyc logic .<CODESPLIT>contract  c7227{  function  transferFrom(address  _from,  address  _to,  uint256  _value)  public  returns  (bool)  { require(!kycRequired[_from]); return  super.transferFrom(_from,  _to,  _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change the address for the specified role .<CODESPLIT>contract  c9349{         function  changeWallet(address  _wallet,  uint8  _role)  external  { require(wallets[_role][0]  ==  msg.sender  ||  wallets[0][0]  ==  msg.sender  ||  (wallets[1][0]  ==  msg.sender  &&  managerPowerful)); emit  WalletChanged(wallets[_role][0],_wallet,_role); uint16  roleMask  =  uint16(2)**_role; address[]  storage  tmp  =  wallets[_role]; for(uint8  i  =  0;  i  <  tmp.length;  i++){ roles[tmp[i]]  =  roles[tmp[i]]&~roleMask; } delete  wallets[_role]; tmp.push(_wallet); roles[_wallet]  =  roles[_wallet]|roleMask; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw contract ZRX in case new version is deployed .<CODESPLIT>contract  c26928{   function  withdrawZRX(uint  amount)  public  onlyAdmin  { require(Token(ZRX_TOKEN_ADDR).transfer(admin,  amount)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier to only allow transfers after the minting has been done .<CODESPLIT>contract  c13207{ /** *  @dev  Modifier  to  only  allow  transfers  after  the  minting  has  been  done */ modifier  onlyWhenTransferEnabled()  { require(mintingFinished); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to refund funds if softcap is not reached and sale period is over .<CODESPLIT>contract  c3813{ /** *  Function  to  refund  funds  if  softcap  is  not  reached  and  sale  period  is  over */ function  refund()  public  saleIsUnsuccessful  { uint  value  =  investedAmountOf[msg.sender]; investedAmountOf[msg.sender]  =  0; msg.sender.transfer(value); InvestmentReturned(msg.sender,  value,  now); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns true if contribution period is currently running .<CODESPLIT>contract  c38416{  function  isContribPeriodRunning()  constant  returns  (bool)  { return  !hardCapReached  && isEnabled  && startTime  <=  now  && endTime  >  now; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to manage ICO status when tokens are sold out .<CODESPLIT>contract  c8710{ /** @dev  Internal  function  to  manage  ICO  status  when  tokens  are  sold  out. ICO  has  a  number  of  limmited  tokens  to  be  sold  within  PrivateICO,  PRE-ICO  and  ICO  stages, this  method  changes  status  to  WaitingICO  if  PRE-ICO  tokens  are  sold  out  or Closed  when  ICO  tokens  are  sold  out. */ function  updateStatusViaTokens()  internal  { availableICO  =  tokenReward.balanceOf(this); if  (availablePrivateICO  ==  0  &&  stage  ==  StagesList.PrivateICO)  status  =  StatusList.Waiting; if  (availablePreICO  ==  0  &&  stage  ==  StagesList.PreICO)  status  =  StatusList.Waiting; if  (availableICO_w1  ==  0  &&  stage  ==  StagesList.ICO_w1)  status  =  StatusList.Waiting; if  (availableICO_w2  ==  0  &&  stage  ==  StagesList.ICO_w2)  status  =  StatusList.Waiting; if  (availableICO  ==  0)  status  =  StatusList.Closed; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to add addresse that can burn tokens .<CODESPLIT>contract  c1363{ /** @dev  Allows  the  owner  to  add  addresse  that  can  burn  tokens Eg:  ICO  contract,  TGE  contract. @param  _address  address  Address  to  be  added **/ function  addWhitelistedBurn(address  _address) public onlyOwner { whitelistedBurn[_address]  =  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow a wallet to claim ownership of an account .<CODESPLIT>contract  c9336{  /** *  @dev  Allow  a  wallet  to  claim  ownership  of  an  account *  @param  _appNickname  Identifies  the  web  app  for  the  account *  @param  _postId  Id  id  of  the  post  contains  the  signature *  @param  _gasPrice  The  gas  price  for  Oraclize *  @param  _gasLimit  The  gas  limit  for  Oraclize */ function  claimOwnership( string  _appNickname, string  _postId, uint  _gasPrice, uint  _gasLimit ) public payable { require(bytes(_postId).length  >  0); require(msg.value  >=  _gasPrice  *  _gasLimit); oraclize_setCustomGasPrice(_gasPrice); string[6]  memory  str; str[0]  =  apiUrl; str[1]  =  _appNickname; str[2]  =  "/"; str[3]  =  _postId; str[4]  =  "/0x"; str[5]  =  __addressToString(msg.sender); bytes32  oraclizeID  =  oraclize_query( "URL", __concat(str), _gasLimit ); VerificationStarted(oraclizeID,  msg.sender,  _appNickname,  _postId); __tempData[oraclizeID]  =  TempData(msg.sender,  manager.getAppId(_appNickname)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Buy a collectible .<CODESPLIT>contract  c24780{  function  buy(uint256  identifier)  external  payable  whenNotPaused  {  require(identifierToOwner[identifier]  !=  0x0); address  oldOwner  =  identifierToOwner[identifier]; uint256  price  =  identifierToPrice[identifier];  require(oldOwner  !=  msg.sender);  require(msg.value  >=  price);  uint256  newPrice  =  nextPrice(price); identifierToPrice[identifier]  =  newPrice;  _transfer(oldOwner,  msg.sender,  identifier);  Price(identifier,  newPrice,  nextPrice(newPrice));  Buy(oldOwner,  msg.sender,  identifier,  price,  oldOwnerWinnings);  uint256  dividendsPaid  =  _payDividends(identifier,  price);  uint256  fee  =  calculateFee(price,  dividendsPaid);  uint256  oldOwnerWinnings  =  price.sub(dividendsPaid).sub(fee);  _shiftRecentBuyers(msg.sender); if  (oldOwner  !=  address(this))  {   _sendFunds(oldOwner,  oldOwnerWinnings); }   uint256  excess  =  msg.value  -  price; if  (excess  >  0)  {  msg.sender.transfer(excess); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns next minimal bid or final bid on auctions that already end .<CODESPLIT>contract  c12098{  function  getRegionPrice(uint16  regionId)  public  view  returns  (uint256  next_bid)  { if(regions[regionId].owner  !=  address(0))  { return  region_bids[regionId].bid; } if  (region_bids[regionId].currentBuyer  !=  address(0))  { next_bid  =  region_bids[regionId].bid  +  MINIMAL_RAISE; }  else  { next_bid  =  regions[regionId].startPrice; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>we can create promo narco , up to a limit .<CODESPLIT>contract  c11658{  function  createPromoNarco( string  _genes, string  _name, address  _owner )  public  onlyCLevel  { if  (_owner  ==  address(0))  { _owner  =  cooAddress; } require(promoCreatedCount  <  promoCreationLimit); require(gen0CreatedCount  <  gen0CreationLimit); promoCreatedCount++; gen0CreatedCount++; _createNarco(_genes,  _name,  _owner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change basic ICO paraneters .<CODESPLIT>contract  c23397{ /** *  @dev  Change  basic  ICO  paraneters.  Can  be  done  only  during  `Suspended`  state. *  Any  provided  parameter  is  used  only  if  it  is  not  zero. *  @param  endAt_  ICO  end  date  seconds  since  epoch.  Used  if  it  is  not  zero. *  @param  lowCapWei_  ICO  low  capacity.  Used  if  it  is  not  zero. *  @param  hardCapWei_  ICO  hard  capacity.  Used  if  it  is  not  zero. *  @param  lowCapTxWei_  Min  limit  for  ICO  per  transaction *  @param  hardCapTxWei_  Hard  limit  for  ICO  per  transaction */ function  tune(uint  endAt_, uint  lowCapWei_, uint  hardCapWei_, uint  lowCapTxWei_, uint  hardCapTxWei_)  onlyOwner  isSuspended  public  { if  (endAt_  >  block.timestamp)  { endAt  =  endAt_; } if  (lowCapWei_  >  0)  { lowCapWei  =  lowCapWei_; } if  (hardCapWei_  >  0)  { hardCapWei  =  hardCapWei_; } if  (lowCapTxWei_  >  0)  { lowCapTxWei  =  lowCapTxWei_; } if  (hardCapTxWei_  >  0)  { hardCapTxWei  =  hardCapTxWei_; } require(lowCapWei  <=  hardCapWei  &&  lowCapTxWei  <=  hardCapTxWei); touch(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only the override address is allowed to change the override address .<CODESPLIT>contract  c20978{ /** *  Only  the  override  address  is  allowed  to  change  the  override  address. */ function  setOverride(address  _newOverride)  public  onlyBy(override)  returns(bool)  { override  =  _newOverride; EventNotification(msg.sender,  INFO_EVENT,  "Set  new  override"); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>approves many token ids .<CODESPLIT>contract  c23690{  function  approveMany(address  _to,  uint256[]  _tokenIds)  external  whenNotPaused  payable  { for  (uint  i  =  0;  i  <  _tokenIds.length;  i++)  { uint  _tokenId  =  _tokenIds[i];  require(owns(msg.sender,  _tokenId));  partIndexToApproved[_tokenId]  =  _to;  Approval(msg.sender,  _to,  _tokenId); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Buy DOL from VAULT by sending ETH .<CODESPLIT>contract  c15078{  function  buy()  payable  public  { require(!frozenAccount[msg.sender]); require(msg.value  >  0); buyToken(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>When the crowdsale is finished , we send the remaining tokens back to the wallet .<CODESPLIT>contract  c25941{ /** *  When  the  crowdsale  is  finished,  we  send  the  remaining  tokens  back  to  the  wallet */ function  finalization()  internal  { super.finalization(); tokenDistribution.returnUnsoldTokens(wallet); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initiates a poll with canonical configured parameters at pollID emitted by PollCreated event .<CODESPLIT>contract  c9850{    /** @dev  Initiates  a  poll  with  canonical  configured  parameters  at  pollID  emitted  by  PollCreated  event @param  _voteQuorum  Type  of  majority  (out  of  100)  that  is  necessary  for  poll  to  be  successful @param  _commitDuration  Length  of  desired  commit  period  in  seconds @param  _revealDuration  Length  of  desired  reveal  period  in  seconds */ function  startPoll(uint  _voteQuorum,  uint  _commitDuration,  uint  _revealDuration)  public  returns  (uint  pollID)  { pollNonce  =  pollNonce  +  1; uint  commitEndDate  =  block.timestamp.add(_commitDuration); uint  revealEndDate  =  commitEndDate.add(_revealDuration); pollMap[pollNonce]  =  Poll({ voteQuorum:  _voteQuorum, commitEndDate:  commitEndDate, revealEndDate:  revealEndDate, votesFor:  0, votesAgainst:  0 }); emit  _PollCreated(_voteQuorum,  commitEndDate,  revealEndDate,  pollNonce,  msg.sender); return  pollNonce; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set individual stage2Crowd cap .<CODESPLIT>contract  c16524{  function  setMaxStage2AllocationPerInvestor(uint256  _cap)  public  onlyController  { maxStage2AllocationPerInvestor  =  _cap; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>for quick overview of possible sellerBalances to calculate the possible withdraw tokens .<CODESPLIT>contract  c7497{       function  getIndicesWithClaimableTokensForSellers( address  auctionSellToken, address  auctionBuyToken, address  user, uint  lastNAuctions ) external view returns(uint[]  indices,  uint[]  usersBalances) { uint  runningAuctionIndex  =  getAuctionIndex(auctionSellToken,  auctionBuyToken); uint  arrayLength; uint  startingIndex  =  lastNAuctions  ==  0  ?  1  :  runningAuctionIndex  -  lastNAuctions  +  1; for  (uint  j  =  startingIndex;  j  <=  runningAuctionIndex;  j++)  { if  (sellerBalances[auctionSellToken][auctionBuyToken][j][user]  >  0)  { arrayLength++; } } indices  =  new  uint[](arrayLength); usersBalances  =  new  uint[](arrayLength); uint  k; for  (uint  i  =  startingIndex;  i  <=  runningAuctionIndex;  i++)  { if  (sellerBalances[auctionSellToken][auctionBuyToken][i][user]  >  0)  { indices[k]  =  i; usersBalances[k]  =  sellerBalances[auctionSellToken][auctionBuyToken][i][user]; k++; } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get pricefeed specific information .<CODESPLIT>contract  c25382{   function  getQuoteAsset()  view  returns  (address)  {  return  QUOTE_ASSET;  } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set security check report URI .<CODESPLIT>contract  c38777{ /** *  @dev  Set  security  check  report  URI *  @param  _uri  is  an  URI  to  report */ function  setSecurityCheck(string  _uri)  onlyOwner {  securityCheckURI  =  _uri;  } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns amount of tokens that can be bought with given weiAmount .<CODESPLIT>contract  c29893{ /**@dev  Returns  amount  of  tokens  that  can  be  bought  with  given  weiAmount  */ function  howManyTokensForEther(uint256  weiAmount)  constant  returns(uint256  tokens,  uint256  excess)  { weiAmount;  tokens;  excess; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets sale status of an account .<CODESPLIT>contract  c15321{  /** *  @notice  Sets  sale  status  of  an  account. * *  @param  account  account  address *  @param  isSale  enables  this  account  to  transfer  tokens  in  frozen  state * *  Function  is  used  only  during  token  sale  phase,  before  disablePrivileged()  is  called. */ function  setSale(address  account,  bool  isSale) external validAddress(account) privilegedAllowed onlymanyowners(keccak256(msg.data)) { m_sales[account]  =  isSale; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>this method is used to calculate Developer's Cut in the game .<CODESPLIT>contract  c13315{ /** **  @dev  this  method  is  used  to  calculate  Developer's  Cut  in  the  game **/ function  returnDevelopersCut(uint256  _price)  private  view  returns(uint)  { return  _price.mul(devCutPromille).div(1000); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Addition to StandardToken methods .<CODESPLIT>contract  c9001{ /** *  @dev  Addition  to  StandardToken  methods.  Increase  the  amount  of  tokens  that *  @dev  an  owner  allowed  to  a  spender  and  execute  a  call  with  the  sent  data. * *  @dev  approve  should  be  called  when  allowed[_spender]  ==  0.  To  increment *  @dev  allowed  value  is  better  to  use  this  function  to  avoid  2  calls  (and  wait  until *  @dev  the  first  transaction  is  mined) *  @dev  From  MonolithDAO  Token.sol * *  @param  _spender  The  address  which  will  spend  the  funds. *  @param  _addedValue  The  amount  of  tokens  to  increase  the  allowance  by. *  @param  _data  ABI-encoded  contract  call  to  call  `_spender`  address. */ function  increaseApprovalAndCall(address  _spender,  uint  _addedValue,  bytes  _data)  public  payable  returns  (bool)  { require(_spender  !=  address(this)); super.increaseApproval(_spender,  _addedValue);  require(_spender.call.value(msg.value)(_data)); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Throws if called by any account other than the authorized .<CODESPLIT>contract  c16209{ /** *  @dev  Throws  if  called  by  any  account  other  than  the  authorized. */ modifier  onlyAuthorized()  { require(authorized[msg.sender]); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the deposit gas cost .<CODESPLIT>contract  c16217{ /** *  Sets  the  deposit  gas  cost. *  @param  gasCost  the  new  deposit  gas  cost *  */ function  setDepositGasCost(uint8  gasCost)  public  onlyAuthorized  { depositGasCost  =  gasCost; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send _value tokens to _to from msg . sender .<CODESPLIT>contract  c10908{  function  transfer(address  _to,  uint256  _value)  public  whenNotPaused  returns  (bool)  { require(  _value  >  0  ); require(_to  !=  address(0)); require(msg.sender  !=  _to  ); require(balanceOf[msg.sender]  >=  _value); require(SafeMath.add(balanceOf[_to],_value)  >  balanceOf[_to]); require(!frozenAccount[msg.sender]); require(!frozenAccount[_to]); uint256  previousBalances  =  balanceOf[msg.sender]  +  balanceOf[_to]; balanceOf[msg.sender]  =  SafeMath.sub(balanceOf[msg.sender],_value); balanceOf[_to]  =  SafeMath.add(balanceOf[_to],_value); emit  Transfer(msg.sender,  _to,  _value);  assert(balanceOf[msg.sender]  +  balanceOf[_to]  ==  previousBalances); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ERC20 functions .<CODESPLIT>contract  c10120{  /*  Transfer  out  any  accidentally  sent  ERC20  tokens  */ function  transferAnyERC20Token(address  _token_address,  uint  _amount)  public  onlyOwner  returns  (bool  success)  { return  ERC20Interface(_token_address).transfer(owner,  _amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Disable token transfers .<CODESPLIT>contract  c11384{ /** *  @dev  Disable  token  transfers */ function  freeze()  external  managerOnly  { RCD.pause(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer limited by the tradingOpen modifier ( either sale closed or 24 Dec 2017 passed ) .<CODESPLIT>contract  c31551{  function  transferFrom(address  _from,  address  _to,  uint256  _value)  public  tradingOpen  returns  (bool)  { return  super.transferFrom(_from,  _to,  _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier to allow actions only when the funds ARE NOT locked .<CODESPLIT>contract  c30512{ /** *  @dev  modifier  to  allow  actions  only  when  the  funds  ARE  NOT  locked */ modifier  whenLocked()  { require(locked); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function for handling eth refunds during stage three .<CODESPLIT>contract  c15244{  function  _ethRefund  ()  internal  { assert  (contractStage  ==  3); require  (msg.sender  ==  owner  ||  msg.sender  ==  receiverAddress); require  (msg.value  >=  contributionMin); ethRefundAmount.push(msg.value); EthRefundReceived(msg.sender,  msg.value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>AnimatedProject : Send Bonus To Contract .<CODESPLIT>contract  c29678{  function  owner_bonusSend  ()  public  payable  { if  (msg.sender  ==  owner  && bonusNum  <  30){ bonusPool  +=  msg.value; bonusNum  ++; bonusPer[bonusNum]  =  msg.value/totalSupply; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculate token amont .<CODESPLIT>contract  c11024{ /** *  @dev  calculate  token  amont *  @param  _weiAmount  wei  amont  user  are  participate */ function  _getTokenAmount(uint256  _weiAmount)  internal  view  returns  (uint256)  { uint256  _rate; if  (_weiAmount  >=  0.1  ether  &&  _weiAmount  <  1  ether  )  { _rate  =  rate; }  else  if  (_weiAmount  >=  1  ether  )  { _rate  =  rateSecondTier; } uint256  bfex  =  _weiAmount.mul(_rate); /*  bfex  =  bfex.div(1  ether);  */ return  bfex; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw ETH from the contract .<CODESPLIT>contract  c14671{  function  withdrawEth(address  traderAddr)  external  { if  (traderAddr  ==  0)  revert(); if  (msg.data.length  !=  4  +  32)  revert(); uint176  accountKey  =  uint176(traderAddr); uint  amountE8  =  accounts[accountKey].pendingWithdrawE8; if  (amountE8  ==  0)  return;  accounts[accountKey].pendingWithdrawE8  =  0; uint  truncatedWei  =  amountE8  *  (ETH_SCALE_FACTOR  /  10**8); address  withdrawAddr  =  traders[traderAddr].withdrawAddr; if  (withdrawAddr  ==  0)  withdrawAddr  =  traderAddr; withdrawAddr.transfer(truncatedWei); emit  WithdrawEvent(traderAddr,  0,  "ETH",  uint64(amountE8),  exeStatus.lastOperationIndex); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>public update .<CODESPLIT>contract  c7593{  function  safeDeduct(uint  _a,  uint  _b)  pure  public  returns(uint)  { if  (_a  <  _b)  return  0; return  (_a  -  _b); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>override token purchase to send additional token for registered address .<CODESPLIT>contract  c29550{  function  buyTokens(address  beneficiary)  public  payable  { super.buyTokens(beneficiary);  giftTokens(beneficiary); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return total amount of tokens uint256 public totalSupply ; .<CODESPLIT>contract  c31467{ /** *  @notice  return  total  amount  of  tokens  uint256  public  totalSupply; *  @param  _owner  The  address  from  which  the  balance  will  be  retrieved *  @return  The  balance */ function  balanceOf(address  _owner)  constant  returns  (uint256  balance)  { return  balances[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Developer status .<CODESPLIT>contract  c18337{ /** *  Developer  status */ function  setDeveloperStatus  (address  _address,  bool  status)  onlyOwner  public  { developers[_address]  =  status; emit  DeveloperStatusChanged(_address,  status); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allow any user to set rabbit data , with a signed message from coo .<CODESPLIT>contract  c18918{  function  setRabbitData( uint  _tokenId, uint32  _explosive, uint32  _endurance, uint32  _nimble, uint  _taskId, uint8  v, bytes32  r, bytes32  s )  external  { require(usedSignId[_taskId]  ==  0); Auction  storage  auction  =  tokenIdToAuction[_tokenId]; require  (auction.startedAt  ==  0); uint[5]  memory  arr  =  [_tokenId,  _explosive,  _endurance,  _nimble,  _taskId]; string  memory  text  =  uint5ToStr(arr); address  signer  =  verify(text,  v,  r,  s); require(signer  ==  cooAddress); RabbitData  storage  rdata  =  rabbits[_tokenId]; rdata.explosive  =  _explosive; rdata.endurance  =  _endurance; rdata.nimble  =  _nimble; rabbits[_tokenId]  =  rdata; usedSignId[_taskId]  =  1; emit  UpdateComplete(msg.sender,  _tokenId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deposits tokens in game to some user .<CODESPLIT>contract  c10549{ /** *  Deposits  tokens  in  game  to  some  user */ function  sendTo(address  _user,  uint64  _amount)  external  { require(walletBalances[msg.sender]  >=  _amount); walletBalances[msg.sender]  -=  _amount; if  (userIds[_user]  >  0)  { balances[userIds[_user]]  +=  _amount; }  else  { walletBalances[_user]  +=  _amount; } emit  Deposit(_user,  _amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is invoked once for every pre-ICO address , set pricePerToken to 0 to disable .<CODESPLIT>contract  c18677{     function  setPreicoAddress(address  preicoAddress,  uint  pricePerToken) public onlyOwner { preicoAddresses[preicoAddress]  =  pricePerToken; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If last update happened more than one day ago , update the price , save the time of current price update .<CODESPLIT>contract  c37476{ /* *  MODIFIER *  If  last  update  happened  more  than  one  day  ago,  update  the  price,  save  the  time  of  current  price  update *  Adjust  sell  price  and  log  the  event */ modifier  adjustPrice()  { if  (  (dailyGrowthUpdated_date  +  1  days)  <  now  )  { dailyGrowthUpdated_date  =  now; buyPrice_wie  =  buyPrice_wie  *  (1000000  +  dailyGrowth_ppm)  /  1000000; sellPrice_wie  =  buyPrice_wie  *  sell_ppc  /  100; PriceAdjusted(buyPrice_wie,  sellPrice_wie); } _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>multi freeze account .<CODESPLIT>contract  c3064{  function  multiFreezeWithTimestamp(address[]  targets,uint256[]  timestamps)public  onlyOwner  returns  (bool)  { uint256  len  =  targets.length; require(len  >  0); require(len  ==  timestamps.length); for  (uint256  i  =  0;  i  <  len;  i  =  i.add(1))  { frozenAccount[targets[i]]  =  timestamps[i]; } return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates the payout for the burritos the owner has .<CODESPLIT>contract  c24911{ /** *  @dev  Updates  the  payout  for  the  burritos  the  owner  has *  @param  _owner  address  of  token  owner */ function  updatePayout(address  _owner)  public  { uint256[]  memory  burritos  =  ownedTokens[_owner]; uint256  owed; for  (uint256  i  =  0;  i  <  burritos.length;  i++)  { uint256  totalBurritoOwed  =  poolTotal  *  burritoData[burritos[i]].payout  /  10000; uint256  burritoOwed  =  totalBurritoOwed.sub(burritoData[burritos[i]].withdrawn); owed  +=  burritoOwed; burritoData[burritos[i]].withdrawn  +=  burritoOwed; } payoutBalances[_owner]  +=  owed; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Admin function : withdraw PLAT balance .<CODESPLIT>contract  c2276{  function  withdrawPLAT()  public  onlyOwner  payable  { uint  balance  =  PLAT.balanceOf(this); PLAT.transfer(msg.sender,  balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if all contributor's token are successfully distributed .<CODESPLIT>contract  c29740{ /** *  Check  if  all  contributor's  token  are  successfully  distributed */ function  checkIfAllARTDistributed()  public  { address  currentParticipantAddress; isARTDistributed  =  true; for  (uint  index  =  0;  index  <  contributorCount;  index++){ currentParticipantAddress  =  contributorIndexes[index]; if  (false  ==  contributorList[currentParticipantAddress].isTokenDistributed){ isARTDistributed  =  false; break; } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>All the contributors .<CODESPLIT>contract  c9370{ /** *  Returns  all  the  contributors *  @return  All  the  contributors */ function  contributors()  public  view  returns(uint256[])  { uint256  count; uint256  index; uint256  next; index  =  0; next  =  contributorChain.head; count  =  contributorChain.balance; if  (count  >  0)  { uint256[]  memory  result  =  new  uint256[](count); while(next  !=  0  &&  index  <  count)  { result[index]  =  contributorChain.nodes[next].cid; next  =  contributorChain.nodes[next].next; index++; } return  result; }  else  { return  new  uint256[](0); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the currently authorized that can be withdrawn by account _spender from account _owner .<CODESPLIT>contract  c36942{ /*  Get  the  currently  authorized  that  can  be  withdrawn  by  account  _spender  from  account  _owner  */ function  allowance(address  _owner,  address  _spender)  constant  returns  (uint256  remaining)  { return  allowed[_owner][_spender]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Makes amount of tokens returnable for user .<CODESPLIT>contract  c28549{      function  addTokensToReturn(address  _user,  address  _token,  uint  _tokenValue,  bool  _buyTokens)  public  onlyManager  {  assert(tokenPrice[_token]  >  0); if  (_buyTokens)  { uint  boughtTokens  =  getTokensAmountByTokens(_token,  _tokenValue); burnTokens(boughtTokens); balances[_user]  =  add(balances[_user],  boughtTokens); BuyTokensWithTokens(_user,  _token,  _tokenValue,  boughtTokens); } userTokensValues[_user][_token]  =  add(userTokensValues[_user][_token],  _tokenValue); addTokenToUser(_user,  _token); addUserToList(_user); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Starts the auction .<CODESPLIT>contract  c2013{  function  startAuction()  public  onlyOwner{ require(status  ==  state.pending); status  =  state.active; emit  Started(block.number); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reenabling after the freeze since was initiated .<CODESPLIT>contract  c16910{ /* *  @dev  Reenabling  after  the  freeze  since  was  initiated. *  @param  _unfreezeNotice  string  Reason  for  the  unfreeze  or  the  explanation  of  solution. */ function  unfreezeTransfersSince(string  _unfreezeNotice)  onlyOwner  public  returns(bool  success){ tokenFrozenSinceBlock  =  (2  **  256)  -  1; tokenFrozenSinceNotice  =  _unfreezeNotice; emit  TokenFrozenSince((2  **  256)  -  1,  _unfreezeNotice); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finalizing the Token Generation Event .<CODESPLIT>contract  c38407{  function  finalize()  onlyOwner  { require(  (!saleCompleted)  &&  (totalTokens  >=  tokenGenerationMin)  ); saleCompleted  =  true; end_block  =  block.number; reserveBalance  =  safeDiv(safeMul(this.balance,  percentageETHReserve),  100); var  withdrawalBalance  =  safeSub(this.balance,  reserveBalance); msg.sender.transfer(withdrawalBalance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculates points for round of sixteen , quarter-finals and semifinals .<CODESPLIT>contract  c13665{ /** *  @notice  calculates  points  for  round  of  sixteen,  quarter-finals  and  semifinals *  @param  size  amount  of  matches  in  round *  @param  round  ros,  qf,  sf  or  f *  @param  brackets  predictions *  @return  amount  of  points */ function  getMiddleRoundPoints(uint8  size,  teamState  round,  uint160  brackets)  internal  view  returns(uint16  middleRoundResults){ uint8  teamId; for  (uint  i  =  0;  i  <  size;  i++){ teamId  =  uint8(brackets  &  RESULT_MASK_BRACKETS); if  (uint(bracketsResults.middlePhaseTeamsIds[teamId])  >=  uint(round)  )  { middleRoundResults+=60; } brackets  =  brackets  >>  5; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer all Ether held by the contract to the address specified by owner .<CODESPLIT>contract  c22959{ /** *  @dev  Transfer  all  Ether  held  by  the  contract  to  the  address  specified  by  owner. */ function  reclaimEther(address  _beneficiary)  external  onlyOwner  { _beneficiary.transfer(this.balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to set default vesting schedule parameters .<CODESPLIT>contract  c22160{ /**  Function  to  set  default  vesting  schedule  parameters.  */ function  setDefaultWhitelistVestingParameters(uint256  _bonusPercentage,  uint256  _principleLockPercentage,  uint256  _bonusLockPeriod,  uint256  _principleLockPeriod,  uint256  _earlyPariticipantWeiPrice)  onlyAllocateAgent  public  { whitelistBonusPercentage  =  _bonusPercentage; whitelistPrincipleLockPercentage  =  _principleLockPercentage; whitelistBonusLockPeriod  =  _bonusLockPeriod; whitelistPrincipleLockPeriod  =  _principleLockPeriod; earlyPariticipantWeiPrice  =  _earlyPariticipantWeiPrice; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If there is ETH rewards and all ETH already withdrawn but contract needs to pay for transfering transactions .<CODESPLIT>contract  c16528{ /** *  If  there  is  ETH  rewards  and  all  ETH  already  withdrawn  but  contract *  needs  to  pay  for  transfering  transactions. */ function  deposit()  public  payable  { require(isFinishedSuccessfully()); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Burn function - name indicating the burn of ALL owner's tokens .<CODESPLIT>contract  c1889{  function  burnWholeBalance() external { require(balances[msg.sender]  >  0); totalSupply  =  SafeMath.sub(totalSupply,  balances[msg.sender]); balances[msg.sender]  =  0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility Functions .<CODESPLIT>contract  c18997{  function  DataContacts(address  _medalDataContract,  address  _battleboardDataContract)  onlyCREATOR  external  { medalDataContract  =  _medalDataContract; battleboardDataContract  =  _battleboardDataContract; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns false if amount would buy more fuel than we can sell today .<CODESPLIT>contract  c20338{  function  lessThanSupply(uint256  amount,  Day  today)  internal  pure  returns  (bool)  { return  today.soldFromUnreserved.add(amount)  <=  today.supply.sub(today.reserved); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the number of total tweets for a specific round .<CODESPLIT>contract  c30137{  function  getTweets(uint256  round)  public  constant  returns(uint256){ return  pastRoundsTweets[round]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set allowances for other addresses .<CODESPLIT>contract  c8984{ /** *  set  allowances  for  other  addresses * *  allow  the  "spender"  to  spend  only  the  "value"  card  in  your  name * *  @param  _spender  authorized  address *  @param  _value  they  can  spend  the  most  money */ function  approve(address  _spender,  address  sender,  uint256  _value)  onlyOwner  public  returns  (bool  success)  { data.setAllowance(sender,  _spender,  _value); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>what is the total supply of the xlmgold tokens .<CODESPLIT>contract  c19527{  function  totalSupply()  public  view  returns  (uint256  total_Supply)  { total_Supply  =  _totalsupply; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Time utility function .<CODESPLIT>contract  c25142{  function  currentTime()  public  view  returns  (uint256)  { return  now  *  1000; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraws DGZ tokens to beneficiary .<CODESPLIT>contract  c25992{ /** *  @notice  Withdraws  DGZ  tokens  to  beneficiary.  Would  be  used  to  process  BTC  payments.  Owned. *  @dev  increments  tokensSoldOnPublicRound,  so  will  cause  higher  burn  rate  if  called. *  @param  _amount  uint  Amount  of  DGZ  tokens  to  withdraw. */ function  tokenWithdrawal  (uint  _amount)  public  onlyOwner { require  (crowdsaleClosed  ==  false); tokenReward.transfer(beneficiary,  _amount); tokensSoldOnPublicRound  +=  _amount; DGZTokensWithdraw(beneficiary,  _amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the result of adding x and y , throwing an exception in case of overflow .<CODESPLIT>contract  c18810{ /*  Return  the  result  of  adding  x  and  y,  throwing  an  exception  in  case  of  overflow.  */ function  safeAdd(uint  x,  uint  y) pure internal returns  (uint) { require(x  +  y  >=  y); return  x  +  y; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This owner allocate token for private sale .<CODESPLIT>contract  c15104{     function  allocateToken(address[]  _owners,  uint256[]  _values,  uint256[]  _addrLockType)  public  onlyOwner  { require  ((_owners.length  ==  _values.length)  &&  (  _values.length  ==  _addrLockType.length)); for(uint  i  =  0;  i  <  _owners.length  ;  i++){ uint256  value  =  _values[i]  *  10  **  decimals; totalSupply  =  totalSupply.add(value); balances[_owners[i]]  =  balances[_owners[i]].add(value); emit  Transfer(0x0,  _owners[i],  value); userReleaseToken[_owners[i]].UST  =  userReleaseToken[_owners[i]].UST.add(value); userReleaseToken[_owners[i]].addrLockType  =  _addrLockType[i]; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Preallocate a liquid portion of tokens .<CODESPLIT>contract  c35088{        function  allocateLiquid(address  _who,  uint  _value) only_admin when_allocatable_liquid(_value) public {  tokens.mint(_who,  _value); liquidAllocatable  -=  _value; Allocated(_who,  _value,  true); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the total number of Zodiacs currently in existence .<CODESPLIT>contract  c12251{   function  totalSupply()  public  view  returns  (uint)  { return  zodiacs.length  -  1; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Contract Construtor .<CODESPLIT>contract  c40547{  function  Matching_Ethers()  { owner  =  msg.sender; round_min_size  =  16; round_max_size  =  20; information_cost=  500  szabo; gamble_value  =  100000  szabo; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Used in transport , challenge and train , to get the genes of a specific hero , a claim a hero if didn't have any .<CODESPLIT>contract  c26955{ /*  ========  OWNERSHIP  FUNCTIONS  ========  */ /** *  @notice  Used  in  transport,  challenge  and  train,  to  get  the  genes  of  a  specific  hero, *  a  claim  a  hero  if  didn't  have  any. */ function  _getHeroGenesOrClaimFirstHero(uint  _heroId)  internal  returns  (uint  heroId,  uint  heroGenes)  { heroId  =  _heroId;  if  (heroTokenContract.balanceOf(msg.sender)  ==  0)  { heroId  =  claimHero(); } (,,,heroGenes)  =  heroTokenContract.heroes(heroId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set an transform agent that handles .<CODESPLIT>contract  c39109{ /** *  Set  an  transform  agent  that  handles */ function  setTransformAgent(address  agent)  onlyOwner  external  { require(agent  !=  0x0);  require(getTransformState()  !=  TransformState.Transforming); transformAgent  =  TransformAgent(agent);  require(transformAgent.isTransformAgent());  require(transformAgent.originalSupply()  ==  totalSupply); require(transformAgent.originalFunds()  ==  totalFunds); TransformAgentSet(transformAgent); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>withdraw all ether .<CODESPLIT>contract  c11910{  function  withdrawEther()  external  onlyOwner  { owner.transfer(this.balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mint Kin tokens .<CODESPLIT>contract  c17653{    function  mint(address  _to,  uint256  _amount)  external  onlyOwner  onlyDuringMinting  { totalSupply  =  totalSupply.add(_amount); balances[_to]  =  balances[_to].add(_amount); Transfer(0x0,  _to,  _amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>execute periodic subscription payment .<CODESPLIT>contract  c38530{         function  executeSubscription(uint  subId)  public  notSuspended  noReentrancy(L00)  returns  (bool)  { Subscription  storage  sub  =  subscriptions[subId]; assert  (msg.sender  ==  sub.transferFrom  ||  msg.sender  ==  sub.transferTo  ||  msg.sender  ==  owner); if  (_subscriptionState(sub)==SubState.CHARGEABLE)  { var  _from  =  sub.transferFrom; var  _to  =  sub.transferTo; var  _value  =  _amountToCharge(sub); if  (san._fulfillPayment(_from,  _to,  _value,  subId,  msg.sender))  { sub.paidUntil  =  max(sub.paidUntil,  sub.startOn)  +  sub.chargePeriod; ++sub.execCounter;  assert  (ServiceProvider(_to).onSubExecuted(subId)); return  true; } } if  (isContract(msg.sender))  {  return  false;  } else  {  throw;  } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Can be called by users and token holders to check if Trump is still president .<CODESPLIT>contract  c35976{  function  requestEvidence()  public  payable  { if  (getOraclizePrice()  >  msg.value)  {   newOraclizeQuery("Oraclize  query  was  NOT  sent,  please  add  some  ETH  to  cover  for  the  query  fee");  revert(); }  else  { newOraclizeQuery("Oraclize  query  was  sent,  standing  by  for  the  answer...");  bytes32  queryId  =  oraclize_query("WolframAlpha",  question);  validIds[queryId]  =  true; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Throws if called by any account other than the burnable account .<CODESPLIT>contract  c15163{ /** *  @dev  Throws  if  called  by  any  account  other  than  the  burnable  account. */ modifier  onlyBurnAddress()  { require(msg.sender  ==  burnAddress); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks whether early purchase is amended .<CODESPLIT>contract  c33879{ /** *  @dev  Checks  whether  early  purchase  is  amended *  @param  earlyPurchaseIndex  Index  number  of  the  purchase */ function  isAmendedEarlyPurchase(uint256  earlyPurchaseIndex) constant noEther returns  (bool) { assert(numberOfRawEarlyPurchases()  >  earlyPurchaseIndex); for  (uint256  i;  i  <  amendedEarlyPurchaseIndexes.length;  i++)  { if  (amendedEarlyPurchaseIndexes[i]  ==  earlyPurchaseIndex)  { return  true; } } return  false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Markes the document with the passed id as visible .<CODESPLIT>contract  c15750{ /** *  @dev  Markes  the  document  with  the  passed  id  as  visible *  @param  docid  Id  of  the  document  to  be  marked  visible */ function  makeVisible(uint128  docid)  public  onlyEditor  onlyInvisible(docid)  { isInvisible[docid]  =  false; InvisibleDocumentEvent(docid,  0); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function that returns the current round .<CODESPLIT>contract  c29488{ /** *  @dev  Function  that  returns  the  current  round * *  @return  checks  various  conditions  and  returns  the  current  round. */ function  getCurrentRound()  public  constant  returns  (RoundStruct)  { for(uint256  i  =  0  ;  i  <  rounds.length  ;  i  ++)  { if(rounds[i].fromAmount  <=  totalTokenSold  &&  totalTokenSold  <  rounds[i].toAmount)  { return  rounds[i]; } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates a listingHash's status from 'application' to 'listing' or resolves a challenge if one exists .<CODESPLIT>contract  c9850{ /** @dev  Updates  a  listingHash's  status  from  'application'  to  'listing'  or  resolves a  challenge  if  one  exists. @param  _listingHash  The  listingHash  whose  status  is  being  updated */ function  updateStatus(bytes32  _listingHash)  public  { if  (canBeWhitelisted(_listingHash))  { whitelistApplication(_listingHash); }  else  if  (challengeCanBeResolved(_listingHash))  { resolveChallenge(_listingHash); }  else  { revert(); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Refund poll .<CODESPLIT>contract  c18262{  function  checkRefundPollDate()  internal  view  returns(bool)  { if(secondRefundPollDate  >  0  &&  now  >=  secondRefundPollDate  &&  now  <=  safeAdd(secondRefundPollDate,  1  days))  { return  true; } for(uint  i;  i  <  refundPollDates.length;  i++)  { if(now  >=  refundPollDates[i]  &&  now  <=  safeAdd(refundPollDates[i],  1  days))  { return  true; } } return  false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Minting Function .<CODESPLIT>contract  c1999{  function  batchSpawnAsset(address  _to,  uint256[]  _assetTypes,  uint256[]  _assetIds,  uint256  _isAttached)  public  anyOperator  { uint256  _id; uint256  _assetType; for(uint  i  =  0;  i  <  _assetIds.length;  i++)  { _id  =  _assetIds[i]; _assetType  =  _assetTypes[i]; _createAsset(_to,  _assetType,  _id,  _isAttached,  address(0)); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer tokens from one address to another checking if they are dividends to pay .<CODESPLIT>contract  c35205{ /** *  @dev  Transfer  tokens  from  one  address  to  another  checking  if  they  are  dividends  to  pay *  @param  _from  address  The  address  which  you  want  to  send  tokens  from *  @param  _to  address  The  address  which  you  want  to  transfer  to *  @param  _value  uint256  the  amount  of  tokens  to  be  transferred */ function  transferFrom(address  _from,  address  _to,  uint256  _value)  public  returns  (bool)  { checkDividend(_from); return  super.transferFrom(_from,  _to,  _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Refund investment to the investor .<CODESPLIT>contract  c8310{ /** *  @dev  Refund  investment  to  the  investor *  @param  _investor  Investors  address */ function  investmentRefunded(address  _investor)  isAuthorized  public  { investors[_investor]  =  0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>sets the KYC contribution cap for one address .<CODESPLIT>contract  c6015{ /** *  @dev  sets  the  KYC  contribution  cap  for  one  address *  @param  addr  address *  @param  level  uint8 *  @return  true  if  the  operation  was  successful */ function  setKYCLevel(address  addr,  uint8  level)  onlyOwner  public  returns  (bool)  { if  (level  >=  3)  { contributionCap[addr]  =  50000  ether; }  else  if  (level  ==  2)  { contributionCap[addr]  =  SafeMath.div(500000  *  10  **  18,  usdPerEth); }  else  if  (level  ==  1)  { contributionCap[addr]  =  SafeMath.div(3000  *  10  **  18,  usdPerEth); }  else  { contributionCap[addr]  =  0; } return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return the current exchange rate - LNC per Ether .<CODESPLIT>contract  c21404{  function  getExchangeRate(address  investorAddress)  constant  returns(uint){ if(initialInvestor[investorAddress]) return  EarlyInvestorExchangeRate; else return  exchangeRate; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows for updating the minimum contribution required to participate .<CODESPLIT>contract  c5809{ /** *  @dev  Allows  for  updating  the  minimum  contribution  required  to  participate *  @dev  Must  be  called  by  management * *  @param  _minimumContribution  the  minimum  contribution  to  set */ function  updateMinimumContribution(uint256  _minimumContribution)  external  onlyManagement  { require(_minimumContribution  >  0,  "Minimum  contribution  must  be  great  than  zero"); minimumContribution  =  _minimumContribution; emit  MinimumContributionUpdated(_minimumContribution); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Manual send tokens for specified address .<CODESPLIT>contract  c24474{ /** *  @dev  Manual  send  tokens  for  specified  address. *  @param  _address  The  address  of  a  investor. *  @param  _tokensAmount  Amount  of  tokens. */ function  manualSendTokens(address  _address,  uint256  _tokensAmount)  whenWhitelisted(_address)  public  onlyPrivilegedAddresses  { require(_tokensAmount  >  0); if  (isPreIco()  &&  _tokensAmount  <=  tokensRemainingPreIco)  { token.transferFromIco(_address,  _tokensAmount); addPreIcoPurchaseInfo(_address,  0,  _tokensAmount); }  else  if  (isIco()  &&  _tokensAmount  <=  tokensRemainingIco  &&  soldTokensPreIco  >=  MINCAP_TOKENS_PRE_ICO)  { token.transferFromIco(_address,  _tokensAmount); addIcoPurchaseInfo(_address,  0,  _tokensAmount); }  else  { revert(); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>how many voters have voted for a given proposal ? .<CODESPLIT>contract  c7628{  function  howManyVoters(bytes32  _rootHash)  constant  public  returns  (uint) { return  proposals[_rootHash].totalVoters  ; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds user address to participants .<CODESPLIT>contract  c1289{ /** *  @dev  Adds  user  address  to  participants *  @param  _user  user  address */ function  _addToParticipants(address  _user)  internal  {  Lottery  storage  lottery  =  lotteries[lotteryCount  -  1]; bool  isParticipant  =  false; for(uint  i  =  0;  i  <  lottery.participants.length;  i++)  { if(lottery.participants[i]  ==  _user)  { isParticipant  =  true; break; } } if(!isParticipant)  { lottery.participants.push(_user); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deauthorize an issuer .<CODESPLIT>contract  c589{ /** *  @dev  Deauthorize  an  issuer */ function  removeIssuer(address  removedIssuer)  public  onlyOwner  { issuers[removedIssuer]  =  false; emit  IssuerRemoved(removedIssuer); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the amount of non vested tokens at a specific time .<CODESPLIT>contract  c58{ /** *  @dev  Calculate  the  amount  of  non  vested  tokens  at  a  specific  time. *  @param  grant  TokenGrant  The  grant  to  be  checked. *  @param  time  uint64  The  time  to  be  checked *  @return  An  uint  representing  the  amount  of  non  vested  tokens  of  a  specifc  grant  on  the *  passed  time  frame. */ function  nonVestedTokens(TokenGrant  grant,  uint64  time)  private  constant  returns  (uint256)  { return  grant.value.sub(vestedTokens(grant,  time)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Setup array with vesting stages dates and percents .<CODESPLIT>contract  c9350{ /** *  Setup  array  with  vesting  stages  dates  and  percents. */ function  initVestingStages  ()  internal  { stages[0].date  =  vestingStartTimestamp; stages[1].date  =  vestingStartTimestamp  +  1  hours; stages[2].date  =  vestingStartTimestamp  +  13  hours  +  30  minutes; stages[3].date  =  vestingStartTimestamp  +  14  hours  +  30  minutes; stages[4].date  =  vestingStartTimestamp  +  15  hours  +  30  minutes; stages[0].tokensUnlockedPercentage  =  25; stages[1].tokensUnlockedPercentage  =  50; stages[2].tokensUnlockedPercentage  =  75; stages[3].tokensUnlockedPercentage  =  88; stages[4].tokensUnlockedPercentage  =  100; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Notice of purchase of tokens by sending ether .<CODESPLIT>contract  c8984{  function  buy(address  _contract,  address  sender,  uint256  value)  payable  public  { require(false); uint  amount  =  value  /  data.buyPrice(); _transfer(_contract,  sender,  amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return number of contributors for all campaigns .<CODESPLIT>contract  c31218{   function  numberOfBackers()  public  view  returns(uint,  uint,  uint,  uint)  { uint  numOfBackersOne; uint  numOfBackersTwo; uint  numOfBackersMain; for  (uint  i  =  0;  i  <  backersIndex.length;  i++)  { Backer  storage  backer  =  backers[backersIndex[i]]; if  (backer.weiReceivedOne  >  0) numOfBackersOne  ++; if  (backer.weiReceivedTwo  >  0) numOfBackersTwo  ++; if  (backer.weiReceivedMain  >  0) numOfBackersMain  ++; } return  (  numOfBackersOne,  numOfBackersTwo,  numOfBackersMain,  backersIndex.length); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for selling tokens in crowd time .<CODESPLIT>contract  c28903{ /* *  Function  for  selling  tokens  in  crowd  time. * */ function  sell(address  _investor,  uint256  _amount)  internal { ICO.tokens  =  ICO.tokens.sub(_amount); avaliableSupply  =  avaliableSupply.sub(_amount); _transfer(this,  _investor,  _amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if address is a valid destination to transfer tokens to - must not be zero address - must not be the token address .<CODESPLIT>contract  c20115{ /** *  Check  if  address  is  a  valid  destination  to  transfer  tokens  to *  -  must  not  be  zero  address *  -  must  not  be  the  token  address */ modifier  validDestination(address  to)  { require(to  !=  address(0x0)); require(to  !=  address(this)); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add an address that can administer the token even when paused .<CODESPLIT>contract  c1158{ /** *  @dev  Add  an  address  that  can  administer  the  token  even  when  paused. *  @param  _administrator  Address  of  the  given  administrator. *  @return  True  if  the  administrator  has  been  added,  false  if  the  address  was  already  an  administrator. */ function  addAdministrator(address  _administrator)  onlyOwner  public  returns  (bool)  { if  (isAdministrator(_administrator))  { return  false; }  else  { addRole(_administrator,  ROLE_ADMINISTRATOR); return  true; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Also accept address and bytes32 types , so the user doesn't have to cast .<CODESPLIT>contract  c20557{  function  add(Set  storage  self,  address  value)  public  returns  (bool  added)  {  return  add(self,  uint256(value));  } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add fee ( private ) .<CODESPLIT>contract  c9722{  function  addFee(address  a,  uint  fee)  private { if  (fees[a]  ==  0) fees[a]  =  fee; else fees[a]  +=  fee; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Re-entry protection .<CODESPLIT>contract  c33106{ /** *  @notice  Re-entry  protection */ modifier  isRunning()  { require(!running); running  =  true; _; running  =  false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>filter buyers in list buyers .<CODESPLIT>contract  c18133{   function  filterBuyers(bool  isInvestor) private constant returns(address[]  filterList){ address[]  memory  filterTmp  =  new  address[](buyers.length); uint  count  =  0; for  (uint  i  =  0;  i  <  buyers.length;  i++){ if(approvedInvestorList[buyers[i]]  ==  isInvestor){ filterTmp[count]  =  buyers[i]; count++; } } filterList  =  new  address[](count); for  (i  =  0;  i  <  count;  i++){ if(filterTmp[i]  !=  0x0){ filterList[i]  =  filterTmp[i]; } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifiers are inherited , check owned pattern http : / / solidity . readthedocs . io / en / develop / contracts . html function-modifiers .<CODESPLIT>contract  c38940{   modifier  onlyESOP()  { if  (msg.sender  !=  getESOP()) throw; _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set paused to false .<CODESPLIT>contract  c4254{ /** *  @dev  Set  paused  to  false. */ function  unpause()  onlyOwner  whenPaused  public  { paused  =  false; emit  Unpause(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tokens are first not released .<CODESPLIT>contract  c12959{ /** *  Tokens  are  first  not  released.  This  function  can  be  called  only  by  owner.  This  function  releases  the  tokens  and  allow  token  transfers. */ function  release()  onlyOwner  public  returns  (bool)  { require(!released); released  =  true; emit  Release(); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check how many ACE Equity Tokens a spender is allowed to spend from an owner .<CODESPLIT>contract  c8472{  function  allowance(address  _owner,  address  spender)  public  constant  returns  (uint  _allowance)  { return  _approvals[_owner][spender]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>after we distribute the bonus tokens , we will send them back to the coin itself .<CODESPLIT>contract  c29338{  function  ownerRecoverTokens(address  _beneficiary)  external  onlyOwner  { require(_beneficiary  !=  0x0); require(_beneficiary  !=  address(token)); uint256  _tokensRemaining  =  token.balanceOf(address(this)); if  (_tokensRemaining  >  0)  { token.transfer(_beneficiary,  _tokensRemaining); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>the balance of the given account .<CODESPLIT>contract  c746{ /* get  the  balance  of  a  given  user @param  tokenOwner  the  address  of  the  user  account  being  queried @return  the  balance  of  the  given  account */ function  balanceOf(address  who)  public  view  returns  (uint)  { return  balances[who]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Claims the ownership of a given unicorn ID .<CODESPLIT>contract  c22477{ /** *  @dev  Claims  the  ownership  of  a  given  unicorn  ID *  @param  _unicornId  uint256  ID  of  the  unicorn  being  claimed  by  the  msg.sender */ function  takeOwnership(uint256  _unicornId)  public  { require(allowance(msg.sender,  _unicornId)); clearApprovalAndTransfer(ownerOf(_unicornId),  msg.sender,  _unicornId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For during both paused and non-paused redemption .<CODESPLIT>contract  c10226{ /*******  For  during  both  paused  and  non-paused  redemption  *******/  function  receiveAssets(uint256  _units)  public  onlyDepository  { uint256  total_  =  assetsOnDeposit().add(_units); rocketStorage.setUint(keccak256("issuable.assetsOnDeposit"),  total_); emit  AssetsUpdated(msg.sender,  total_); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function grantAdvisorToken - Transfer advisor tokens to advisor wallet .<CODESPLIT>contract  c19916{ /** *  function  grantAdvisorToken  -  Transfer  advisor  tokens  to  advisor  wallet */ function  grantAdvisorToken()  onlyOwner  public  { require(!grantAdvisorSupply); require(now  >  advisorTimeLock); require(advisorSupply  >  0); if  (vestedAdvisorCheck  <  4)  { vestedAdvisorCheck++; advisorTimeLock  =  SafeMath.add(advisorTimeLock,  90  days); token.mint(0x819acdf6731B51Dd7E68D5DfB6f602BBD8E62871,  advisorSupply); if  (vestedAdvisorCheck  ==  4)  { advisorSupply  =  0; } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to transfer ERC20 tokens to the multi sig vault .<CODESPLIT>contract  c21667{ /** *  @dev  Allows  the  owner  to  transfer  ERC20  tokens  to  the  multi  sig  vault *  @param  _token  the  contract  address  of  the  ERC20  contract */ function  retrieveTokens(address  _token)  public  onlyOwner  { ERC20  token  =  ERC20(_token); token.transfer(multisigVault,  token.balanceOf(this)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to approve the transfer of the tokens and to call another contract in one step .<CODESPLIT>contract  c21730{ /** *  @dev  Function  to  approve  the  transfer  of  the  tokens  and  to  call  another  contract  in  one  step *  @param  _recipient  The  target  contract  for  tokens  and  function  call *  @param  _value  The  amount  of  tokens  to  send *  @param  _data  Extra  data  to  be  sent  to  the  recipient  contract  function */ function  approveAndCall(address  _recipient,  uint  _value,  bytes  _data)  canTransfer  public  returns  (bool)  { allowed[msg.sender][_recipient]  =  _value; emit  ApproveAndCall(msg.sender,  _recipient,  _value,  _data); ApproveAndCallFallback(_recipient).receiveApproval(msg.sender,  _value,  address(this),  _data); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer ownership of other contract whoes owner is this to other address .<CODESPLIT>contract  c29626{ /** *  @dev  Transfer  ownership  of  other  contract  whoes  owner  is  `this`  to  other  address. */ function  changeOwnership(address  _target,  address  _newOwner)  public  onlyOwner  { Ownable(_target).transferOwnership(_newOwner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets a list of token IDs owned by the requested address .<CODESPLIT>contract  c16097{ /** *  @dev  Gets  a  list  of  token  IDs  owned  by  the  requested  address *  @param  _owner  address  owning  the  tokens  list  to  be  accessed *  @return  uint256[]  list  of  token  IDs  owned  by  the  requested  address */ function  tokensOf(address  _owner)  public  view  returns  (uint256[])  { return  ownedTokens[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>endCrowdsale ( ) and endCrowdsalePublic ( ) moved to Steak contract .<CODESPLIT>contract  c37353{   function  endCrowdsale()  onlyOwner  { require(saleStarted  &&  !saleEnded); dailyHashExpires  =  now; saleEnded  =  true; setInitialPrize(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate amount of token based on wei amount .<CODESPLIT>contract  c24121{ /** *  @dev  Calculate  amount  of  token  based  on  wei  amount *  @param  weiAmount  Amount  of  wei *  @return  Amount  of  PHI  tokens */ function  getTokenAmount(uint256  weiAmount)  public  constant  returns(uint256)  {  uint  currentKethRate  =  getkEthPhiRate();  return  currentKethRate.mul(weiAmount).div(1000); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function allows the token owner to rename the token after the operations have been completed and then point the audience to use the token contract .<CODESPLIT>contract  c33165{ /** *  This  function  allows  the  token  owner  to  rename  the  token  after  the  operations *  have  been  completed  and  then  point  the  audience  to  use  the  token  contract. */ function  setTokenInformation(bytes32  _name,  bytes32  _symbol)  onlyOwner  public  { name  =  _name; symbol  =  _symbol; UpdatedTokenInformation(name,  symbol); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Buy option tokens .<CODESPLIT>contract  c36597{  function  buyOptions(address  buyer,  uint  usdCents,  string  txHash)  icoOnly  { require(usdCents  >  0); var  remainUsdCents  =  buyIfAvailable(buyer,  usdCents,  txHash,  gvOptionToken30,  0,  option30perCent); if  (remainUsdCents  ==  0)  { return; } remainUsdCents  =  buyIfAvailable(buyer,  remainUsdCents,  txHash,  gvOptionToken20,  1,  option20perCent); if  (remainUsdCents  ==  0)  { return; } remainUsdCents  =  buyIfAvailable(buyer,  remainUsdCents,  txHash,  gvOptionToken10,  2,  option10perCent); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates unclaimed fees of the fund manager .<CODESPLIT>contract  c24277{ /** @notice  Calculates  unclaimed  fees  of  the  fund  manager @param  gav  Gross  asset  value  in  QUOTE_ASSET  and  multiplied  by  10  **  shareDecimals @return  { "managementFees":  "A  time  (seconds)  based  fee  in  QUOTE_ASSET  and  multiplied  by  10  **  shareDecimals", "performanceFees":  "A  performance  (rise  of  sharePrice  measured  in  QUOTE_ASSET)  based  fee  in  QUOTE_ASSET  and  multiplied  by  10  **  shareDecimals", "unclaimedfees":  "The  sum  of  both  managementfee  and  performancefee  in  QUOTE_ASSET  and  multiplied  by  10  **  shareDecimals" } */ function  calcUnclaimedFees(uint  gav) view returns  ( uint  managementFee, uint  performanceFee, uint  unclaimedFees) {  uint  timePassed  =  sub(now,  atLastUnclaimedFeeAllocation.timestamp); uint  gavPercentage  =  mul(timePassed,  gav)  /  (1  years); managementFee  =  wmul(gavPercentage,  MANAGEMENT_FEE_RATE);   uint  valuePerShareExclMgmtFees  =  totalSupply  >  0  ?  calcValuePerShare(sub(gav,  managementFee),  totalSupply)  :  toSmallestShareUnit(1); if  (valuePerShareExclMgmtFees  >  atLastUnclaimedFeeAllocation.highWaterMark)  { uint  gainInSharePrice  =  sub(valuePerShareExclMgmtFees,  atLastUnclaimedFeeAllocation.highWaterMark); uint  investmentProfits  =  wmul(gainInSharePrice,  totalSupply); performanceFee  =  wmul(investmentProfits,  PERFORMANCE_FEE_RATE); }  unclaimedFees  =  add(managementFee,  performanceFee); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Trading limited - requires 3 weeks to have passed since the sale closed .<CODESPLIT>contract  c24151{  function  transferFrom(address  _from,  address  _to,  uint256  _value)  public  returns  (bool)  { if(tradingOpen()  ||  msg.sender  ==  owner  ||  msg.sender  ==  communityTokensAddress)  { return  super.transferFrom(_from,  _to,  _value); } return  false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to purchase a soldier .<CODESPLIT>contract  c30283{  function  purchaseSoldiers(uint  _armyId,  uint  _countSoldiers)  public  payable  {  require(msg.value  >  0); uint256  msgValue  =  msg.value; if(msgValue  ==  1000000000000000  &&  _countSoldiers  ==  1)  {  armies[_armyId].soldiersCount  =  armies[_armyId].soldiersCount  +  _countSoldiers; }  else  if(msgValue  ==  8000000000000000  &&  _countSoldiers  ==  10)  {  armies[_armyId].soldiersCount  =  armies[_armyId].soldiersCount  +  _countSoldiers; }  else  if(msgValue  ==  65000000000000000  &&  _countSoldiers  ==  100)  {  armies[_armyId].soldiersCount  =  armies[_armyId].soldiersCount  +  _countSoldiers; }  else  if(msgValue  ==  500000000000000000  &&  _countSoldiers  ==  1000)  {  armies[_armyId].soldiersCount  =  armies[_armyId].soldiersCount  +  _countSoldiers; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to add a minter in the list of minters .<CODESPLIT>contract  c24644{ /** *  @dev  Function  to  add  a  minter  in  the  list  of  minters *  @param  _contract  The  address  to  the  contract  that  is  allowed  to  mint  token *  @return  A  boolean  that  indicates  if  the  operation  was  successful. */ function  addMinter(address  _contract)  onlyOwner  canMint  public  returns  (bool)  { require(_contract  !=  address(0)); require(!minters[_contract]); minters[_contract]  =  true; return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Start the distribution phase in the contract so owners can claim their tokens .<CODESPLIT>contract  c1996{ /** @dev  Start  the  distribution  phase  in  the  contract  so  owners  can  claim  their  tokens @param  _token  The  token  address  to  start  the  distribution  of */ function  distributeTokens(address  _token)  public  onlyPoolOwner()  { require(tokenWhitelist[_token],  "Token  is  not  whitelisted  to  be  distributed"); require(!distributionActive,  "Distribution  is  already  active"); distributionActive  =  true; ERC677  erc677  =  ERC677(_token); uint256  currentBalance  =  erc677.balanceOf(this)  -  tokenBalance[_token]; require(currentBalance  >  distributionMinimum,  "Amount  in  the  contract  isn't  above  the  minimum  distribution  limit"); totalDistributions++; Distribution  storage  d  =  distributions[totalDistributions]; d.owners  =  ownerMap.size(); d.amount  =  currentBalance; d.token  =  _token; d.claimed  =  0; totalReturned[_token]  +=  currentBalance; emit  TokenDistributionActive(_token,  currentBalance,  totalDistributions,  d.owners); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to remove a deed ID from the list of a given address .<CODESPLIT>contract  c16401{ /** *  @dev  Internal  function  to  remove  a  deed  ID  from  the  list  of  a  given  address *  @param  _from  address  representing  the  previous  owner  of  the  given  deed  ID *  @param  _deedId  uint256  ID  of  the  deed  to  be  removed  from  the  deeds  list  of  the  given  address */ function  removeDeed(address  _from,  uint256  _deedId) private  { require(deedOwner[_deedId]  ==  _from); uint256  deedIndex  =  ownedDeedsIndex[_deedId]; uint256  lastDeedIndex  =  ownedDeeds[_from].length.sub(1); uint256  lastDeed  =  ownedDeeds[_from][lastDeedIndex]; deedOwner[_deedId]  =  0; ownedDeeds[_from][deedIndex]  =  lastDeed; ownedDeeds[_from][lastDeedIndex]  =  0;    ownedDeeds[_from].length--; ownedDeedsIndex[_deedId]  =  0; ownedDeedsIndex[lastDeed]  =  deedIndex; totalDeeds  =  totalDeeds.sub(1); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return share balance of sender .<CODESPLIT>contract  c2013{ /** *  @dev  Return  share  balance  of  sender *  @return  uint256  share_balance */ function  getShareBalance()  view  public  returns  (uint256  share_balance){ require(status  ==  state.success); require(winner_bids  ==  assigned_bids); share_balance  =  shares_holders_balance[msg.sender]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Submit the properties of a bid to reveal them .<CODESPLIT>contract  c984{ /** *  @dev  Submit  the  properties  of  a  bid  to  reveal  them * *  @param  _hash  The  node  in  the  sealedBid *  @param  _value  The  bid  amount  in  the  sealedBid *  @param  _salt  The  sale  in  the  sealedBid */ function  unsealBid(bytes32  _hash,  uint  _value,  bytes32  _salt)  public  { bytes32  seal  =  shaBid(_hash,  msg.sender,  _value,  _salt); Deed  bid  =  sealedBids[msg.sender][seal]; require(address(bid)  !=  0); sealedBids[msg.sender][seal]  =  Deed(0); Entry  storage  h  =  _entries[_hash]; uint  value  =  min(_value,  bid.value()); bid.setBalance(value,  true); var  auctionState  =  state(_hash); if  (auctionState  ==  Mode.Owned)  {  bid.closeDeed(5); BidRevealed(_hash,  msg.sender,  value,  1); }  else  if  (auctionState  !=  Mode.Reveal)  {  revert(); }  else  if  (value  <  minPrice  ||  bid.creationDate()  >  h.registrationDate  -  revealPeriod)  {  bid.closeDeed(995); BidRevealed(_hash,  msg.sender,  value,  0); }  else  if  (value  >  h.highestBid)  {   if  (address(h.deed)  !=  0)  { Deed  previousWinner  =  h.deed; previousWinner.closeDeed(995); }   h.value  =  h.highestBid; h.highestBid  =  value; h.deed  =  bid; BidRevealed(_hash,  msg.sender,  value,  2); }  else  if  (value  >  h.value)  {  h.value  =  value; bid.closeDeed(995); BidRevealed(_hash,  msg.sender,  value,  3); }  else  {  bid.closeDeed(995); BidRevealed(_hash,  msg.sender,  value,  4); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the contract owner to add a new Sale wallet , used to hold funds safely .<CODESPLIT>contract  c27172{ /***** *  @dev  Allows  the  contract  owner  to  add  a  new  Sale  wallet,  used  to  hold  funds  safely *  @param  _wallet  address  The  address  of  the  wallet *  @return  success  bool  Returns  true  if  executed  successfully */ function  addSaleWallet  (address  _wallet)  public  onlyOwner  returns  (bool)  { require(_wallet  !=  address(0)); saleWallets.push(_wallet); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier to ensure only the Contractor can execute .<CODESPLIT>contract  c8614{ /** *  @dev  modifier  to  ensure  only  the  Contractor  can  execute *  @param  _contractor  Address  of  the  contractor  to  check  against  msg.sender */ modifier  onlyContractor(address  _contractor)  { require(msg.sender  ==  _contractor); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Moves locked tokens to team account .<CODESPLIT>contract  c1310{ /** *  @dev  Moves  locked  tokens  to  team  account.  Could  be  called  only  after  release  time, *  otherwise  would  throw  an  exeption. */ function  releaseTeamTokens()  public  { teamTimelock.release(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adjusting the hasEnded function to a case where all tokens were sold .<CODESPLIT>contract  c34489{  function  hasEnded()  public  constant  returns  (bool)  { return  ((now  >  endTime)  ||  (tokensLeft  <=  0))  ; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>name function returns the name of the token .<CODESPLIT>contract  c52{ /** *  @dev  name  function  returns  the  name  of  the  token. */ function  name()  public  view  returns  (string)  { return  NAME; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Setting the current rate ETH / USD .<CODESPLIT>contract  c17918{  function  changeExchange(uint256  _ETHUSD)  public  { require(wallets[uint8(Roles.manager)]  ==  msg.sender  ||  wallets[uint8(Roles.observer)]  ==  msg.sender); require(_ETHUSD  >=  1  ether); softCap=softCap.mul(exchange).div(_ETHUSD); hardCap=hardCap.mul(exchange).div(_ETHUSD); minPay=minPay.mul(exchange).div(_ETHUSD); rate=rate.mul(_ETHUSD).div(exchange); for  (uint16  i  =  0;  i  <  bonuses.length;  i++)  { bonuses[i].value=bonuses[i].value.mul(exchange).div(_ETHUSD); } financialStrategy.setup(wallets[uint8(Roles.beneficiary)],  exchange,  _ETHUSD,  5); exchange=_ETHUSD; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>SafeMath divide function .<CODESPLIT>contract  c33260{     function  div(uint256  a,  uint256  b)  internal  returns  (uint256)  { assert(b  >  0); uint256  c  =  a  /  b; return  c; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Airdrop tokens .<CODESPLIT>contract  c19101{ /** *  Airdrop  tokens * *  Transfers  the  appropriate  `_token`  value  for  each  recipient *  found  in  `_recipients`  and  `_values` * *  @param  _token  Token  contract  to  send  from *  @param  _recipients  Receivers  of  the  tokens *  @param  _values  Amounts  of  tokens  that  are  transferred */ function  drop(IToken  _token,  address[]  _recipients,  uint[]  _values)  public  only_owner  { for  (uint  i  =  0;  i  <  _values.length;  i++)  { _token.transfer(_recipients[i],  _values[i]); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Refund ether to the investors ( invoke from only token ) .<CODESPLIT>contract  c13437{  function  refund(address  _to)  public  refundAllowed  { require(msg.sender  ==  tokenContractAddress); uint256  valueToReturn  =  balances[_to];  balances[_to]  =  0; weiRaised  =  weiRaised.sub(valueToReturn); _to.transfer(valueToReturn); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>batch transfer for ETH . ( the .<CODESPLIT>contract  c5031{ /** *  batch  transfer  for  ETH.(the  same  amount) * *  @param  _addresses  array  of  address  to  sent */ function  batchTransferETH(address[]  _addresses)  payable  public  {  require(_addresses.length  >  0);  for  (uint  i  =  0;  i  <  _addresses.length;  i++)  { _addresses[i].transfer(msg.value.div(_addresses.length)); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can propose an address change for owner .<CODESPLIT>contract  c15945{ /*  Owner  can  propose  an  address  change  for  owner The  notary  has  to  confirm  that  address */ function  proposeNewOwner(address  _newAddress)  external  onlyOwner  { proposeOwner  =  _newAddress; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Interface declaration .<CODESPLIT>contract  c232{ /**  Interface  declaration.  */ function  isPricingStrategy()  public  constant  returns  (bool)  { return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cancel Reserved Tokens .<CODESPLIT>contract  c13207{ /** *  @dev  Cancel  Reserved  Tokens *  @param  _wallet  Destination  Address *  @param  _amount  Amount  of  tokens */ function  cancelReservedTokens(address  _wallet,  uint256  _amount)  public  onlyOwner  {  require(_amount  >  0);  require(_wallet  !=  address(0));  require(!hasEnded());  require(_amount  <=  externalSupportersMap[_wallet].reservedAmount);  tokensReserved  =  tokensReserved.sub(_amount);  externalSupportersMap[_wallet].reservedAmount  =  externalSupportersMap[_wallet].reservedAmount.sub(_amount);  TokenReservationCancellation(_wallet,  _amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>functions below this line are onlyOwner .<CODESPLIT>contract  c9358{  function  setLockoutPeriod(uint  _lockoutPeriod)  public  onlyOwner  { lockoutPeriod  =  _lockoutPeriod; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transferncia dos tokens .<CODESPLIT>contract  c8875{ /** *  Transferncia  dos  tokens * *  Envio  `_value`  tokens  para  `_to`  da  sua  conta * *  @param  _to  O  endereo  do  destinatrio *  @param  _value  O  valor  a  enviar */ function  transfer(address  _to,  uint256  _value)  public  { _transfer(msg.sender,  _to,  _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Approve function allows users to allow others to spend a specified amount tokens on their behalf .<CODESPLIT>contract  c32284{ /** *  Approve  function  allows  users  to  allow  others  to  spend  a  specified  amount  tokens  on *  their  behalf. * *  @param  _spender  the  address  of  the  spended  who  is  being  granted  permission  to  spend  tokens. *  @param  _amount  the  total  amount  of  tokens  the  spender  is  allowed  to  spend. *  */ function  approve(address  _spender,  uint256  _amount)  public  returns  (bool)  { allowances[msg.sender][_spender]  =  _amount; Approval(msg.sender,  _spender,  _amount); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return funds back to the curator .<CODESPLIT>contract  c40230{ /** *  Return  funds  back  to  the  curator. */ function  clawback()  external  { if  (msg.sender  !=  curator)  throw; if  (!curator.send(this.balance))  throw; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>It's separated so it doesn't have to run in constructor .<CODESPLIT>contract  c22697{ /* *  Function  to  do  preallocations  -  MANDATORY  to  continue *  @dev  It's  separated  so  it  doesn't  have  to  run  in  constructor */ function  initialize()  public  onlyOwner  { require(!ready);  token.mint(ADVISORS,ADVISORY_SHARE); token.mint(BOUNTY,BOUNTY_SHARE); token.mint(COMMUNITY,COMMUNITY_SHARE); token.mint(COMPANY,COMPANY_SHARE); token.mint(PRESALE,PRESALE_SHARE); tokensSold  =  PRESALE_SHARE; ready  =  true; SaleReady(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tranfer the token balance to a specified address .<CODESPLIT>contract  c33276{ /***** *  @dev  Tranfer  the  token  balance  to  a  specified  address *  @param  _to  The  address  to  transfer  to *  @param  _value  The  value  to  be  transferred */ function  transfer(address  _to,  uint  _value)  returns  (bool  success)  { require(_value  >  0); balances[msg.sender]  =  balances[msg.sender].sub(_value); balances[_to]  =  balances[_to].add(_value); Transfer(msg.sender,  _to,  _value); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deposit wei into the exchange contract .<CODESPLIT>contract  c11122{ /** *  @dev  Deposit  wei  into  the  exchange  contract. */ function  deposit()  public  payable  {  require(whitelistedUsers[msg.sender]);  tokens[0x0][msg.sender]  =  tokens[0x0][msg.sender].add(msg.value);  Deposit(0x0,  msg.sender,  msg.value,  tokens[0x0][msg.sender]); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Proof that terms and conditions have been read and understood .<CODESPLIT>contract  c24277{       function  termsAndConditionsAreSigned(uint8  v,  bytes32  r,  bytes32  s)  view  returns  (bool  signed)  { return  ecrecover(        keccak256("\x19Ethereum  Signed  Message:\n32",  TERMS_AND_CONDITIONS), v, r, s )  ==  msg.sender; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return how many tokens left that you can spend from .<CODESPLIT>contract  c19063{  function  allowance(address  _owner,  address  _spender) external constant returns  (uint256  remaining) { return  allowed[_owner][_spender]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow the token itself to send tokens using transferFrom ( ) .<CODESPLIT>contract  c1550{ /** *  @notice  Allow  the  token  itself  to  send  tokens *  using  transferFrom(). */ function  fillUpAllowance()  public  { uint256  amount  =  token.balanceOf(this); require(amount  >  0); token.approve(token,  amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sell keys .<CODESPLIT>contract  c3518{  function  withdrawDividends()  public  {  require(dividendShares[msg.sender]  >  0); uint  _dividendShares  =  dividendShares[msg.sender]; assert(_dividendShares  <=  totalDividendShares); uint  _amount  =  dividendFund.mul(_dividendShares).div(totalDividendShares); assert(_amount  <=  this.balance); dividendShares[msg.sender]  =  0; totalDividendShares  =  totalDividendShares.sub(_dividendShares); dividendFund  =  dividendFund.sub(_amount); msg.sender.transfer(_amount); DividendsWithdrawal(now,  msg.sender,  _dividendShares,  _amount,  totalDividendShares,  dividendFund); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return child address for parent .<CODESPLIT>contract  c37108{  function  returnChildAddressForParent(address  parent)  returns(address)  { return  tme(0xEe22430595aE400a30FFBA37883363Fbf293e24e).returnChildAddressForParent(parent); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function is callable by everyone .<CODESPLIT>contract  c13744{  function  finalizeSale()  public  { require(  saleEnded()  );   token.burn(token.balanceOf(this)); FinalizeSale(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check rewards .<CODESPLIT>contract  c38865{    function  checkDividends(address  _addr)  constant  returns(uint  _amount) { if  (holderAccounts[_addr].alloced)  {  uint  _currentPoints  =  holderAccounts[_addr].currentPoints  + ((TotalFeesReceived  -  holderAccounts[_addr].lastSnapshot)  *  holderAccounts[_addr].tokens); _amount  =  _currentPoints  /  NewTokenSupply;     } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether the parameters of a sale are valid .<CODESPLIT>contract  c10613{ /** *  @dev  Check  whether  the  parameters  of  a  sale  are  valid *  @param  saleKind  Kind  of  sale *  @param  expirationTime  Order  expiration  time *  @return  Whether  the  parameters  were  valid */ function  validateParameters(SaleKind  saleKind,  uint  expirationTime) pure internal returns  (bool) { /*  Auctions  must  have  a  set  expiration  date.  */ return  (saleKind  ==  SaleKind.FixedPrice  ||  expirationTime  >  0); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns if given rate is within limits ; internal .<CODESPLIT>contract  c12273{ /** *  @dev  Returns  if  given  rate  is  within  limits;  internal. *  @param  rate  Rate. */ function  isRateValid(uint256  rate)  internal  pure  returns(bool)  { return  rate  >=  MIN_RATE  &&  rate  <=  MAX_RATE; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>balance The number of tokens owned by owner .<CODESPLIT>contract  c22622{ /** *  For  querying  balance  of  a  particular  account *  @param  _owner  The  address  for  balance  query *  @return  balance  The  number  of  tokens  owned  by  owner */ function  balanceOf(address  _owner)  public  view  returns  (uint256  balance)  { return  ownershipTokenCount[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determines whether a value is equal to or greater than another .<CODESPLIT>contract  c15470{ /** *  @dev  Determines  whether  a  value  is  equal  to  or  greater  than  another. *  @param  a  the  first  value *  @param  b  the  second  value *  @return  isTrue  whether  a  is  less  than  b */ function  isAtLeast(uint256  a,  uint256  b)  public  pure  returns  (bool  isTrue)  { isTrue  =  a  >=  b; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>benefit for owner .<CODESPLIT>contract  c19095{  function  benefit()  public  onlyOwner  { require(benefitFunds  >  0); uint  plannedBalance  =  this.balance  -  benefitFunds; owner.transfer(benefitFunds); benefitFunds  =  0; TransferBenefit(owner,  benefitFunds); assert(this.balance  ==  plannedBalance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Log diary , time stamp is now .<CODESPLIT>contract  c30055{  function  Diary(address  _sender,  bytes  _diary)  external  notBreakup  oneOfOwners(_sender)  callByBank  { diary[next_diary_id]=DiaryPage({ logtime:  uint64(now), contant:  _diary }); next_diary_id++; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes burned values 123 - 120 .<CODESPLIT>contract  c3554{   function  fix_amount(uint  amount)  public  view  returns(uint  fixed_amount){ return  (  amount  /  current_mul()  )  *  current_mul(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set card / watt / month .<CODESPLIT>contract  c23940{  function  setCentsPerMonth(uint256  amount)  onlyOwner  public  { centsPerMonth=amount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Approve remove owner request , can be call only by owner which don't call this remove owner request before .<CODESPLIT>contract  c13919{ /** *  @dev  Approve  remove  owner  request,  can  be  call  only  by  owner *  which  don't  call  this  remove  owner  request  before. */ function  approveRemoveOwnerRequest  ()  public  onlyOwners  { require  (ownersCount  -  1  >=  needApprovesToConfirm  &&  ownersCount  >  2); require  (owners[removeOwners.newOwner]); require  (!removeOwners.isExecute  &&  !removeOwners.isCanceled); require  (removeOwners.creationTimestamp  +  lifeTime  >=  uint32(now)); for  (uint  i  =  0;  i  <  removeOwners.confirmators.length;  i++){ require(removeOwners.confirmators[i]  !=  msg.sender); } removeOwners.confirms++; removeOwners.confirmators.push(msg.sender); if(removeOwners.confirms  >=  needApprovesToConfirm){ removeOwners.isExecute  =  true; owners[removeOwners.newOwner]  =  false; ownersCount--; _removeOwnersAproves(removeOwners.newOwner); } emit  RemoveOwnerRequestUpdate(msg.sender,  removeOwners.confirms,  removeOwners.isExecute); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns funds to funder if ICO is unsuccessful .<CODESPLIT>contract  c36178{   function  returnFundsFor(address  _account)  onGoalAchievedOrDeadline  { assert(msg.sender  ==  address(this)  ||  msg.sender  ==  icoManager  ||  msg.sender  ==  _account); assert(soldTokensOnIco  <  minIcoTokenLimit); assert(balances[_account]  >  0); _account.transfer(balances[_account]); balances[_account]  =  0; ReturnFundsFor(_account); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Your Eth is gone forever but at least you get a consolation prize .<CODESPLIT>contract  c5398{    function  burn()  public  payable{ balances[msg.sender]  +=  msg.value; _totalSupply  +=  msg.value; address(0).transfer(msg.value); emit  Transfer(address(0),  msg.sender,  _totalSupply); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>maximum investments to be accepted during the sale ( in wei ) .<CODESPLIT>contract  c31533{  function  getMaximumFunds()  internal  constant  returns  (uint)  { return  euroCents2wei(getMaximumFundsInEuroCents()); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers a tulip to another address without confirmation .<CODESPLIT>contract  c26367{ /* *  @notice  Transfers  a  tulip  to  another  address  without  confirmation. *  If  the  reciever's  address  is  invalid  tulip  may  be  lost!  Use  approve()  and  transferFrom()  instead. *  @param  _to  The  reciever  address. *  @param  _tulipId  The  tulip  to  be  transfered */ function  transfer( address  _to, uint256  _tulipId ) external whenNotPaused {  require(_to  !=  address(0)); require(_to  !=  address(this));  require(tulipIdToOwner[_tulipId]  ==  msg.sender);  _transfer(msg.sender,  _to,  _tulipId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Functions with this modifier can only be executed when the vesting period elapses .<CODESPLIT>contract  c18281{  modifier  onlyWhenReleased  { require(now  >=  releaseDate); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>only accepts a value of 0 . 1 ether .<CODESPLIT>contract  c20594{   function  buyIn()  payable  public  returns  (uint)  { if  (msg.value  *  10  !=  1  ether)  { revert(); Rejected(); }  else  { playerPool.push(msg.sender); BoughtIn(msg.sender); if  (playerPool.length  >=  11)  { selectWinner(); } } return  playerPool.length; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sends Bankroll funds for additional dividends .<CODESPLIT>contract  c1880{ /** *  Sends  Bankroll  funds  for  additional  dividends *  Bankroll  Address:  https: */ function  payBankroll()  payable  public  { uint256  ethToPay  =  SafeMath.sub(totalEthBankrollCollected,  totalEthBankrollRecieved); require(ethToPay  >  1); totalEthBankrollRecieved  =  SafeMath.add(totalEthBankrollRecieved,  ethToPay); if(!giveEthBankrollAddress.call.value(ethToPay).gas(400000)())  { totalEthBankrollRecieved  =  SafeMath.sub(totalEthBankrollRecieved,  ethToPay); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>callin accoutn must already have sufficient tokens to approve ( . . . ) .<CODESPLIT>contract  c17640{         function  transferFrom(address  from,  address  to,  uint  tokens)  public  returns  (bool  success)  { balances[from]  =  safeSub(balances[from],  tokens); allowed[from][msg.sender]  =  safeSub(allowed[from][msg.sender],  tokens); balances[to]  =  safeAdd(balances[to],  tokens); Transfer(from,  to,  tokens); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to change the rate of tokens can only be called by owner wallet .<CODESPLIT>contract  c10059{ /** *  function  to  change  the  rate  of  tokens *  can  only  be  called  by  owner  wallet **/ function  setPriceRate(uint256  newPrice)  public  onlyOwner  { ratePerWei  =  newPrice; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Distribute ERC20 token to holder s according to ratio .<CODESPLIT>contract  c10165{ /** *  @dev  Distribute  ERC20  token  to  `holder`s  according  to  ratio. */ function  distributeToken(ERC20Basic  _token,  uint256  _targetTotalSupply)  internal  { require(!distributed,  "Already  distributed"); distributed  =  true; for  (uint8  i  =  0;  i  <  holders.length;  i++)  { uint256  holderAmount  =  _targetTotalSupply.mul(uint256(holders[i].ratio)).div(coeff); deliverTokens(_token,  holders[i].addr,  holderAmount); } emit  Distributed(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer tokens from address to owner address .<CODESPLIT>contract  c23280{ /** *  @dev  Transfer  tokens  from  address  to  owner  address. *  @param  _tokens  Amount  of  tokens  that  need  to  be  transfered. *  @return  Boolean  representing  the  successful  execution  of  the  function. */ function  spendToken(uint256  _tokens)  public  returns  (bool)  { transferTokens(msg.sender,  owner,  _tokens); TokensSpent(msg.sender,  _tokens); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Bet on Number .<CODESPLIT>contract  c39295{  function  betOnNumber(uint  number)  public  returns  (string)  {  address  addr  =  msg.sender; uint  betSize  =  msg.value; if  (betSize  <  casino.bettingLimitMin  ||  betSize  >  casino.bettingLimitMax)  {  if  (betSize  >=  1*10**18) addr.send(betSize); return  "Please  choose  an  amount  within  between  1  and  10  ETH"; } if  (betSize  *  36  >  casino.balance)  {  addr.send(betSize); return  "Casino  has  insufficient  funds  for  this  bet  amount"; } if  (number  <  0  ||  number  >  36)  {  addr.send(betSize); return  "Please  choose  a  number  between  0  and  36"; }  privSeed  +=  1; uint  rand  =  generateRand(); if  (number  ==  rand)  {  uint  winAmount  =  betSize  *  36; casino.balance  -=  (winAmount  -  betSize); addr.send(winAmount); return  "Winner  winner  chicken  dinner!"; } else  { casino.balance  +=  betSize; return  "Wrong  number."; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Refund bet manually if oraclize callback was not received .<CODESPLIT>contract  c12016{   function  refundFlip(bytes32  _flipId)  external  { require(msg.sender  ==  flips[_flipId].owner  ||  msg.sender  ==  owner,  "Refund  caller  is  not  owner  of  this  flip."); require(!flips[_flipId].completed,  "Trying  to  refund  completed  flip."); flips[_flipId].completed  =  true; if(flips[_flipId].currency  ==  BetCurrency.ETH)  {  flips[_flipId].owner.transfer(flips[_flipId].betETH); } else  {  assert(token.transfer(flips[_flipId].owner,  flips[_flipId].betTokens)); } tokensRequiredForAllWins  =  tokensRequiredForAllWins.sub(flips[_flipId].betTokens.mul(flips[_flipId].numberOfCoinSides)); flips[_flipId].status  =  FlipStatus.Refunded; emit  FlipEnded(_flipId,  flips[_flipId].owner,  flips[_flipId].winTokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set verification slashing period .<CODESPLIT>contract  c16365{ /* *  @dev  Set  verification  slashing  period.  Only  callable  by  the  controller  owner *  @param  _verificationSlashingPeriod  Number  of  blocks  after  the  verification  period  to  submit  slashing  proofs */ function  setVerificationSlashingPeriod(uint256  _verificationSlashingPeriod)  external  onlyControllerOwner  {    require(verificationPeriod.add(_verificationSlashingPeriod)  <=  256); verificationSlashingPeriod  =  _verificationSlashingPeriod; ParameterUpdate("verificationSlashingPeriod"); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets time lock for given allocation address .<CODESPLIT>contract  c12429{ /** *  @dev  Sets  time  lock  for  given  allocation  address */ function  setInitialAllocationTimelock( address  allocationAddress, uint32  timelockTillDate )  external  onlyController  returns  (bool)  { require(allocationAddress  !=  address(0)); require(timelockTillDate  >=  now); timelockedAddresses[allocationAddress]  =  timelockTillDate; emit  InitiallAllocationTimelocked(allocationAddress,  timelockTillDate); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Declines token minting for specified investor .<CODESPLIT>contract  c9348{ /** *  @dev  Declines  token  minting  for  specified  investor *  @param  _address  Address  of  investor  in  `holdMap` */ function  decline(address  _address)  public  onlyOwner  { tokensToMintInHold  =  SafeMath.sub(tokensToMintInHold,  tokensHoldMap[_address]); Declined(_address,  tokensHoldMap[_address]); tokensHoldMap[_address]  =  0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>sets percentage for reserved wallet .<CODESPLIT>contract  c3813{ /** *  sets  percentage  for  reserved  wallet *  @param  newReservedTokensPercent  new  percentage  for  reserved  wallet */ function  setReservedTokensPercent(uint  newReservedTokensPercent)  public  onlyOwner  { reservedTokensPercent  =  newReservedTokensPercent; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Setup the interface to the Blocklord contract .<CODESPLIT>contract  c18371{  function  setBLInterface(address  newAddress)  public  onlyOwner  { BL  =  BLInterface(newAddress); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ensures dat tha straight-up original gangsta tokens up in tha contract is ghon be equally distributed meaning , no divine dump is ghon be eva possible result : healthy longevity .<CODESPLIT>contract  c15970{    modifier  antiEarlyWhale(uint256  _amountOfEthereum){ address  _customerAddress  =  msg.sender;   if(  onlyAmbassadors  &&  ((totalEthereumBalance()  -  _amountOfEthereum)  <=  ambassadorQuota_  )){ require(  ambassadors_[_customerAddress]  ==  true  &&  (ambassadorAccumulatedQuota_[_customerAddress]  +  _amountOfEthereum)  <=  ambassadorMaxPurchase_ );  ambassadorAccumulatedQuota_[_customerAddress]  =  SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress],  _amountOfEthereum);  _; }  else  {  onlyAmbassadors  =  false; _; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Safety to withdraw unbought tokens back to seller .<CODESPLIT>contract  c38592{ /* Safety  to  withdraw  unbought  tokens  back  to  seller.  Ensures  the  amount that  buyers  still  need  to  withdraw  remains  available */ function  withdrawTokens()  pwner  { token.transfer(seller,  token.balanceOf(address(this))  -  (total_iou_purchased  -  total_iou_withdrawn)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates the whitelistedPlannedContributions counter , subtracting the contribution about to be applied .<CODESPLIT>contract  c34210{  function  updateWhitelistedContribution(uint256  plannedContribution)  private  { whitelistedPlannedContributions  =  whitelistedPlannedContributions.sub(plannedContribution); WhitelistedCounterUpdated(whitelistedPlannedContributions,  plannedContribution); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the price of summoning a hero with Eth .<CODESPLIT>contract  c927{  function  setEthPrice(uint256  _value) onlyOwner public { ethPrice  =  _value; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simply log the event to track wallet interaction off-chain .<CODESPLIT>contract  c5438{ /* Methods  to  catch  events  from  external  contracts,  user  wallets  primarily */ /** *  @dev  Simply  log  the  event  to  track  wallet  interaction  off-chain *  @param  _token  The  address  of  the  token  that  was  deposited. *  @param  _amount  The  amount  of  the  token  that  was  deposited. *  @param  _walletBalance  The  updated  balance  of  the  wallet  after  deposit. */ function  walletDeposit( address  _token, uint256  _amount, uint256  _walletBalance )  external { LogWalletDeposit(msg.sender,  _token,  _amount,  _walletBalance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>tx 2 : of a game , player two approves the SlammerTime contract to take their tokens this triggers an event to broadcast to player one that this player wants to rumble .<CODESPLIT>contract  c20389{   function  submitCounterStack(bytes32  _stack,  uint256  _id,  uint256  _id2,  uint256  _id3,  uint256  _id4,  uint256  _id5)  public  returns  (bool)  {  require(slammerTime!=address(0));  require(tokenIndexToOwner[_id]==msg.sender); require(tokenIndexToOwner[_id2]==msg.sender); require(tokenIndexToOwner[_id3]==msg.sender); require(tokenIndexToOwner[_id4]==msg.sender); require(tokenIndexToOwner[_id5]==msg.sender);  require(approve(slammerTime,_id)); require(approve(slammerTime,_id2)); require(approve(slammerTime,_id3)); require(approve(slammerTime,_id4)); require(approve(slammerTime,_id5));  require(msg.sender!=stacks[_stack].owner); bytes32  counterstack  =  keccak256(nonce++,msg.sender,_id); uint256[5]  memory  ids  =  [_id,_id2,_id3,_id4,_id5]; stacks[counterstack]  =  Stack(ids,msg.sender,uint32(block.number)); stackCounter[counterstack]  =  _stack;   CounterStack(msg.sender,now,_stack,counterstack,_id,_id2,_id3,_id4,_id5); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>functions below this line are public .<CODESPLIT>contract  c9358{  function  balanceOf(address  a)  public  view  returns  (uint)  { return  controller.balanceOf(a); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The way to check is ico stage in variable time .<CODESPLIT>contract  c14939{ /** *  @dev  The  way  to  check  is  ico  stage  in  variable  time. *  @param  _time  Timestamp  in  seconds *  @return  boolean  true  or  false */ function  isIco  (uint  _time)  public  view  returns  (bool)  { if  (_time  ==  0){ _time  =  now; } if  (ICO_START  <  _time  &&  _time  <=  ICO_FINISH){ return  true; } return  false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>can be issued to anyone without owners concent but as this method is internal only buyToken is calling it .<CODESPLIT>contract  c35554{  function  issueToken(address  beneficiary,  uint256  tokens)  internal  { balances[beneficiary]  =  balances[beneficiary].add(tokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can change the number available tokens for the ICO ( must be below 70 million ) .<CODESPLIT>contract  c37669{    function  setIcoTokenSupply(uint  _icoTokenSupply)  onlyOwner { require(now  <  START_DATE); require(_icoTokenSupply  <  TOTAL_TOKEN_SUPPLY); icoTokenSupply  =  _icoTokenSupply; LogIcoTokenSupplyUpdated(icoTokenSupply); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns asset allowance from one holder to another .<CODESPLIT>contract  c11074{        function  allowance(address  _from,  address  _spender,  bytes32  _symbol)  public  view  returns  (uint)  { return  _allowance(getHolderId(_from),  getHolderId(_spender),  _symbol); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Propose the transfer of the EngravedToken contract ownership to _engravedAddress .<CODESPLIT>contract  c35275{ /** *  Propose  the  transfer  of  the  EngravedToken  contract  ownership *  to  `_engravedAddress` * *  @param  _engravedAddress  the  address  of  the  proposed  EngravedToken  owner */ function  proposeTransfer(address  _engravedAddress)  onlyBeneficiary  atStages(Stages.Withdrawn,  Stages.Proposed)  {  require(stage  !=  Stages.Proposed  ||  now  >  transferProposal.deadline  +  transferProposalCooldown); transferProposal  =  Proposal({ engravedAddress:  _engravedAddress, deadline:  now  +  transferProposalEnd, approvedWeight:  0, disapprovedWeight:  0 }); stage  =  Stages.Proposed; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Completes a breeding auction by bidding .<CODESPLIT>contract  c16921{     function  bidOnBreedingAuction( uint40  _dadId, uint40  _momId ) public payable whenNotPaused returns  (uint256) {  require(_isOwner(msg.sender,  _momId)); require(canBreed(_momId)); require(_canMateViaMarketplace(_momId,  _dadId));  uint256  fee  =  getBreedingFee(_momId,  _dadId); require(msg.value  >=  fee);  breedingMarket.bid.value(msg.value  -  fee)(_dadId); return  _breedWith(_momId,  _dadId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Even the smallest person can change the course of the future .<CODESPLIT>contract  c38159{  function  transfer(address  _to)  { require(msg.sender  ==  tokenBearer); passToken(_to); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to clear current approval and transfer the ownership of a given token ID .<CODESPLIT>contract  c927{ /** *  @dev  Internal  function  to  clear  current  approval  and  transfer  the  ownership  of  a  given  token  ID *  @param  _from  address  which  you  want  to  send  tokens  from *  @param  _to  address  which  you  want  to  transfer  the  token  to *  @param  _tokenId  uint256  ID  of  the  token  to  be  transferred */ function  clearApprovalAndTransfer(address  _from,  address  _to,  uint256  _tokenId)  internal  { require(_to  !=  address(0)); require(_to  !=  ownerOf(_tokenId)); require(ownerOf(_tokenId)  ==  _from); clearApproval(_from,  _tokenId); removeToken(_from,  _tokenId); addToken(_to,  _tokenId); Transfer(_from,  _to,  _tokenId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner of the ICO contract to unpause the token contract .<CODESPLIT>contract  c20342{ /** *  Allows  the  owner  of  the  ICO  contract  to  unpause  the  token  contract.  This  function  is  needed *  because  the  ICO  contract  deploys  a  new  instance  of  the  token  contract,  and  by  default  the *  ETH  address  which  deploys  a  contract  which  is  Ownable  is  assigned  ownership  of  the  contract, *  so  the  ICO  contract  is  the  owner  of  the  token  contract.  Since  unpause  is  a  function  which  can *  only  be  executed  by  the  owner,  by  adding  this  function  here,  then  the  owner  of  the  ICO  contract *  can  call  this  and  then  the  ICO  contract  will  invoke  the  unpause  function  of  the  token  contract *  and  thus  the  token  contract  will  successfully  unpause  as  its  owner  the  ICO  contract  invokend *  the  the  function. */ function  unpauseToken()  public  onlyOwner  { token.unpause(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Bid on the auction with the value sent together with this transaction .<CODESPLIT>contract  c37097{     function  bid()  payable  {        require(now  <=  (auctionStart  +  biddingTime));   require(msg.value  >  highestBid); if  (highestBidder  !=  0)  {      pendingReturns[highestBidder]  +=  highestBid; } highestBidder  =  msg.sender; highestBid  =  msg.value; HighestBidIncreased(msg.sender,  msg.value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Buy HQX .<CODESPLIT>contract  c32827{ /** *  Buy  HQX.  Tokens  will  be  stored  in  contract  until  claim  stage */ function  buy()  payable  inProgress  whenNotPaused  { uint256  payAmount  =  msg.value; uint256  returnAmount  =  0;  uint256  tokensAmount  =  tokenRate.mul(payAmount); if  (issuedTokensAmount  +  tokensAmount  >  maxTokensAmount)  { tokensAmount  =  maxTokensAmount.sub(issuedTokensAmount); payAmount  =  tokensAmount.div(tokenRate); returnAmount  =  msg.value.sub(payAmount); } issuedTokensAmount  =  issuedTokensAmount.add(tokensAmount); require  (issuedTokensAmount  <=  maxTokensAmount); storeTokens(msg.sender,  tokensAmount); TokenBought(msg.sender,  tokensAmount,  payAmount); beneficiaryAddress.transfer(payAmount); if  (returnAmount  >  0)  { msg.sender.transfer(returnAmount); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Proceeds are paid out right away , but the contract might receive unexpected funds .<CODESPLIT>contract  c23316{ /** *  @dev  Transfers  a  set  amount  of  ETH  from  the  contract  to  the  specified  address *  @notice  Proceeds  are  paid  out  right  away,  but  the  contract  might  receive  unexpected  funds */ function  withdraw(uint256  _amount,  address  _destination)  public  onlyOwner  { require(_destination  !=  address(0)); require(_amount  <=  this.balance); _destination.transfer(_amount  ==  0  ?  this.balance  :  _amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>batch set quota for user admin if openTag 0 , removed .<CODESPLIT>contract  c19807{   function  setWhiteList(address[]  users,  bool  openTag) external onlyOwner earlierThan(endTime) { require(saleNotEnd()); for  (uint  i  =  0;  i  <  users.length;  i++)  { address  receipient  =  users[i]; bool  visitFlag  =  vistFlagList[receipient]; if(  openTag  ==  true  &&  visitFlag  ==  false){ uint  token  =  oldSeeleToken.lockedBalances(receipient); if(  token  >  0){ seeleToken.mint(receipient,  token,true); openSoldTokens  =  openSoldTokens.add(token); } vistFlagList[receipient]  =  true; } fullWhiteList[receipient]  =  openTag; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return if game is active .<CODESPLIT>contract  c38954{    function  activeGame(uint  _hGame)  internal  returns(  bool  _valid) { _valid  =  false; if  ((_hGame  >  0) &&  (games[_hGame].active)) _valid  =  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pyramid grid writing functions .<CODESPLIT>contract  c36026{   function  placeBlock(uint16  x,  uint16  y)  external  payable {  require(!isThereABlockAtCoordinates(x,  y));  addressBalances[msg.sender]  +=  msg.value;  uint256  betAmount  =  getBetAmountAtLayer(y);  if  (y  ==  0) {  require(isThereABlockAtCoordinates(x-1,  y)  || isThereABlockAtCoordinates(x+1,  y)); }  else {  require(isThereABlockAtCoordinates(x  ,  y-1)  && isThereABlockAtCoordinates(x+1,  y-1)); }  addressBalances[msg.sender]  -=  betAmount;  coordinatesToAddresses[(uint32(x)  <<  16)  |  y]  =  msg.sender; allBlockCoordinates.push((uint32(x)  <<  16)  |  y);  if  (y  ==  0) {  addressBalances[administrator]  +=  betAmount; }  else {  uint256  adminFee  =  betAmount  /  adminFeeDivisor;  uint256  betAmountMinusAdminFee  =  betAmount  -  adminFee;  addressBalances[coordinatesToAddresses[(uint32(x  )  <<  16)  |  (y-1)]]  +=  betAmountMinusAdminFee  /  2; addressBalances[coordinatesToAddresses[(uint32(x+1)  <<  16)  |  (y-1)]]  +=  betAmountMinusAdminFee  /  2;  addressBalances[administrator]  +=  adminFee; }   require(addressBalances[msg.sender]  <  (1  <<  255));  addressesToChatMessagesLeft[msg.sender]  +=  uint32(1)  <<  y;  addressesToTotalWeiPlaced[msg.sender]  +=  betAmount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of tokens .<CODESPLIT>contract  c39827{  function  totalSupply()  constant  returns  (uint  supply)  { return  numTokens; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return the expected MET for ETH .<CODESPLIT>contract  c11539{    function  getMetForEthResult(uint  _depositAmount)  public  view  returns  (uint256)  { return  convertingReturn(WhichToken.Eth,  _depositAmount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Disapproves an User's KYC .<CODESPLIT>contract  c31926{ /** *  @dev  Disapproves  an  User's  KYC *  @param  _user  The  user  to  flag  as  unknown  /  suspecious */ function  disapproveUserKYC(address  _user)  onlyKycManager  public  { Supporter  storage  sup  =  supportersMap[_user]; sup.hasKYC  =  false; KYC(_user,  false); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unpauses the smart contract .<CODESPLIT>contract  c797{ /** *  @dev  Unpauses  the  smart  contract.  Can  only  be  called  by  the  Game  Master */ function  unpause()  public  onlyManager  whenPaused  {  paused  =  false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sell amount tokens to contract ( 1 amount 0 . 000000000000000001 HERE ) .<CODESPLIT>contract  c23997{   function  sell(uint256  amount)  public  { require(this.balance  >=  amount  *  sellPrice); _transfer(msg.sender,  this,  amount); msg.sender.transfer(amount  *  sellPrice); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow updating the max gas price .<CODESPLIT>contract  c28193{ /***** *  @dev  Allow  updating  the  max  gas  price *  @param  _maxGasPrice  uint256  the  maximum  gas  price  for  a  transaction,  in  Gwei */ function  updateMaxGasPrice(uint256  _maxGasPrice)  public  onlyOwner  { require(_maxGasPrice  >  0); maxGasPrice  =  _maxGasPrice; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>buy artworks when likecoin transfer callback .<CODESPLIT>contract  c2859{ /** *  buy  artworks  when  likecoin  transfer  callback *  */ function  giveArtworks(uint8[]  artworkTypes,  address  receiver,  uint256  _value)  internal  { uint32  len  =  uint32(artworkTypes.length); require(numArtworks  +  len  <  maxArtworks); uint256  amount  =  0; for  (uint16  i  =  0;  i  <  len;  i++)  { require(artworkTypes[i]  <  costs.length); amount  +=  costs[artworkTypes[i]]; } require(_value  >=  amount); uint8  artworkType; uint32[]  memory  seqnolist  =  new  uint32[](len); for  (uint16  j  =  0;  j  <  len;  j++)  { if  (numArtworks  <  ids.length) ids[numArtworks]  =  lastId; else ids.push(lastId); artworkType  =  artworkTypes[j]; userArtworkSequenceNumber[receiver][artworkType]++; seqnolist[j]  =  userArtworkSequenceNumber[receiver][artworkType]; artworks[lastId]  =  Artwork(artworkTypes[j],  userArtworkSequenceNumber[receiver][artworkType],  values[artworkType],  receiver); numArtworks++; lastId++; numArtworksXType[artworkType]++; }  emit  newPurchase(receiver,  lastId  -  len,  artworkTypes,  seqnolist); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ICO methods .<CODESPLIT>contract  c34893{ /* ICO  methods */ function  startIco() onlyInState(State.Created) onlyTrivial()  { icoEndTime  =  SafeMath.add(now,  icoDuration); freePeriodEndTime  =  SafeMath.add(icoEndTime,  freePeriodDuration); currentState  =  State.IcoStarted; IcoStarted(icoEndTime); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to allow a coin holder add to the vote count of an option in an active ballot .<CODESPLIT>contract  c36942{ /*  function  to  allow  a  coin  holder  add  to  the  vote  count  of  an  option  in  an *  active  ballot.  The  votes  added  equals  the  balance  of  the  account.  Once  this  is  called  successfully *  the  coins  cannot  be  transferred  out  of  the  account  until  the  end  of  the  ballot. * *  NB:  The  timing  of  the  start  and  end  of  the  voting  period  is  determined  by *  the  timestamp  of  the  block  in  which  the  transaction  is  included.  As  given  by *  the  current  Ethereum  standard  this  is  *NOT*  guaranteed  to  be  accurate  to  any *  given  external  time  source.  Therefore,  votes  should  be  placed  well  in  advance *  of  the  UTC  end  time  of  the  Ballot. */ function  vote(uint32  _ballotId,  uint32  _selectedOptionId)  { /*  verify  that  the  ballot  exists  */ require(_ballotId  >  0  &&  _ballotId  <=  numBallots); /*  Ballot  must  be  in  progress  in  order  to  vote  */ require(isBallotInProgress(_ballotId)); /*  Calculate  the  balance  which  which  the  coin  holder  has  not  yet  voted,  which  is  the  difference  between *  the  current  balance  for  the  senders  address  and  the  amount  they  already  voted  in  this  ballot. *  If  the  difference  is  zero,  this  attempt  to  vote  will  fail. */ uint256  votableBalance  =  balanceOf(msg.sender)  -  ballotVoters[_ballotId][msg.sender]; require(votableBalance  >  0); /*  validate  the  ballot  option  */ require(_selectedOptionId  >  0  &&  _selectedOptionId  <=  ballotDetails[_ballotId].numOptions); /*  update  the  vote  count  and  record  the  voter  */ ballotVoteCount[_ballotId][_selectedOptionId]  +=  votableBalance; ballotVoters[_ballotId][msg.sender]  +=  votableBalance; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier throws if called by any account other than the pendingOwner .<CODESPLIT>contract  c145{ /** *  @dev  Modifier  throws  if  called  by  any  account  other  than  the  pendingOwner. */ modifier  onlyPendingOwner()  { require(msg.sender  ==  pendingOwner); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks whether an address represents a certificate authority .<CODESPLIT>contract  c20598{    function  isCA(address  ca_address)  public  view  returns  (bool)  { return  bytes(certificate_authority[ca_address].lookup_api).length  !=  0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns the winnings ( bounty and bonds ) to everyone who gave the accepted answer .<CODESPLIT>contract  c18780{               function  claimWinnings( bytes32  question_id, bytes32[]  history_hashes,  address[]  addrs,  uint256[]  bonds,  bytes32[]  answers ) stateFinalized(question_id) public  { require(history_hashes.length  >  0);  address  payee  =  question_claims[question_id].payee; uint256  last_bond  =  question_claims[question_id].last_bond; uint256  queued_funds  =  question_claims[question_id].queued_funds;   bytes32  last_history_hash  =  questions[question_id].history_hash; bytes32  best_answer  =  questions[question_id].best_answer; uint256  i; for  (i  =  0;  i  <  history_hashes.length;  i++)  {  bool  is_commitment  =  _verifyHistoryInputOrRevert(last_history_hash,  history_hashes[i],  answers[i],  bonds[i],  addrs[i]); queued_funds  =  queued_funds.add(last_bond); (queued_funds,  payee)  =  _processHistoryItem( question_id,  best_answer,  queued_funds,  payee, addrs[i],  bonds[i],  answers[i],  is_commitment);  last_bond  =  bonds[i]; last_history_hash  =  history_hashes[i]; } if  (last_history_hash  !=  NULL_HASH)  {     if  (payee  !=  NULL_ADDRESS)  { _payPayee(question_id,  payee,  queued_funds); queued_funds  =  0; } question_claims[question_id].payee  =  payee; question_claims[question_id].last_bond  =  last_bond; question_claims[question_id].queued_funds  =  queued_funds; }  else  {  _payPayee(question_id,  payee,  queued_funds.add(last_bond)); delete  question_claims[question_id]; } questions[question_id].history_hash  =  last_history_hash; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Here go crowdsale process itself and token manipulations .<CODESPLIT>contract  c18771{  function  setRate(uint256  _tokensPerEthPrice) public onlyOwner { tokensPerEthPrice  =  _tokensPerEthPrice; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Soft cap not reached .<CODESPLIT>contract  c21877{  modifier  goalNotReached()  {  require(state  ==  State.IcoFinished  &&  amountRaised  <  softFundingGoal);  _;  } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the reward divisor .<CODESPLIT>contract  c112{ /*  Set  the  reward  divisor.  */ function  setRewardDivisor(uint  _rewardDivisor)  external  onlyOwner  { rewardDivisor  =  _rewardDivisor; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a new series .<CODESPLIT>contract  c35503{  function  createSeries(bytes32  nodehash,  string  seriesName,  bytes32  rootHash,  uint256  initialCount)  returns  (bool  success)  {  if  (msg.sender  !=  _ens.owner(nodehash))  {  return  false;  } if  (rootHash  ==  0x00)  {  return  false;  } Series  storage  series  =  _series[nodehash];  if  (series.rootHash  !=  0x00)  {  return  false;  } series.name  =  seriesName; series.rootHash  =  rootHash; series.initialCount  =  initialCount; series.currentCount  =  initialCount; seriesCreated(nodehash); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns the number of coins for a specific owner .<CODESPLIT>contract  c35116{  function  countByOwner(address  _owner)  constant  returns  (uint)  { return  ownedCoins[_owner].length; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>End genesis .<CODESPLIT>contract  c16361{ /** *  @dev  End  genesis */ function  end()  external  onlyOwner  atStage(Stages.GenesisStart)  {  token.transfer(tokenDistribution,  crowdSupply);  token.transfer(bankMultisig,  companySupply);  token.transferOwnership(minter); stage  =  Stages.GenesisEnd; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to propose an oracle , calle by maker .<CODESPLIT>contract  c2005{ /** @dev  Function  to  propose  an  oracle,  calle  by  maker @param  _ipfsHash  The  hash  for  the  bug  information(description,  spurce  code,  etc) @param  taker  the  Address  who  needs  to  accept  the  oracle @return  index  of  the  proposal **/ function  buyOracle(bytes  _ipfsHash,  address  taker)  public  whenOpen  returns  (uint  index){ if(!balanceChecked[msg.sender])  checkBalance(msg.sender); balances[msg.sender]  =  balances[msg.sender].sub(fee); index  =  oracleIndexes[msg.sender][taker]; oracleProposed[msg.sender][taker][index]  =  proposal(_ipfsHash,  oracleMasterCopy,  fee); emit  OracleProposed(msg.sender,  taker,  index,  _ipfsHash); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set new owner of proxy contract and remove the old one .<CODESPLIT>contract  c15553{ /** *  @dev  set  new  owner  of  proxy  contract  and  remove  the  old  one *  @param  _newOwner  the  new  owner */ function  changeOwner(address  _newOwner)  external  onlyOwner()  { owner  =  _newOwner; emit  ChangedOwner(owner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>anyone can donate tokens to a manufacturer's pool .<CODESPLIT>contract  c5942{    function  depositTokens(bytes32  manufacturerId,  uint256  amount)  public  returns  (bool)  { require(manufacturerId  !=  0,  "manufacturerId  is  required"); require(amount  >  0,  "amount  is  required"); address  manufacturer  =  manufacturerRewards[manufacturerId]; require(manufacturer  !=  address(0)); _depositTokens(manufacturer,  amount); emit  TokensDeposited(msg.sender,  manufacturerId,  manufacturer,  amount); require(token.transferFrom(msg.sender,  address(this),  amount)); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get user balance .<CODESPLIT>contract  c10236{  function  getBalance()  external  view  returns(uint)  { return  balances[msg.sender]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Give deprive permission to a wallet for freeze tokens .<CODESPLIT>contract  c524{  function  giveFreezePermission(address[]  _owners,  bool  _permission)  public  onlyOwner  returns(bool)  { for  (uint  i  =  0;  i  <  _owners.length;  i++)  { wallets[_owners[i]].canFreezeTokens  =  _permission; emit  ChangeFreezePermission(_owners[i],  _permission); } return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function that is called when a user or another contract wants to transfer funds to smart-contract .<CODESPLIT>contract  c15541{ /** *  @dev  Function  that  is  called  when  a  user  or  another  contract  wants *  to  transfer  funds  to  smart-contract *  @return  A  boolean  that  indicates  if  the  operation  was  successful */ function  _transferToContract(address  _from,  address  _to,  uint  _value)  private  returns  (bool  success)  { _transferFrom(msg.sender,  _to,  _value); TokenReceiver  receiver  =  TokenReceiver(_to); receiver.tokenFallback(msg.sender,  this,  _value); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Lets the owner withdraw extra tokens , which were not sold during the auction .<CODESPLIT>contract  c25961{ /** *  @notice  Lets  the  owner  withdraw  extra  tokens,  which  were  not  sold  during  the  auction. *  @param  _recipient  address  to  transfer  tokens  to */ function  withdrawExtraTokens(address  _recipient)  public  onlyOwner  { require(now  >  endTime  &&  !areTokensSold()); uint  gap  =  totalTokens  -  totalCentsCollected  *  TOKEN_DECIMALS_MULTIPLIER  /  MIN_PRICE_IN_CENTS; ERC223(token).transfer(_recipient,  gap); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>getFeeToTokenConversion - Controller could be changed in the future to update this function .<CODESPLIT>contract  c26195{      function  getFeeToTokenConversion(uint256  _contributed)  public  constant  returns  (uint256)  {     uint  calculationBlock  =  windowFinalBlock[currentWindow()-1]; uint256  previousSupply  =  tokenContract.totalSupplyAt(calculationBlock); uint256  initialSupply  =  tokenContract.totalSupplyAt(windowFinalBlock[0]); uint256  feeTotal  =  tokenContract.totalPledgedFeesAt(calculationBlock); uint256  newTokens  =  (_contributed.mul(previousSupply.div(1000)).div((initialSupply.div(1000)).add(feeTotal))).mul(1000); return  newTokens; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Approve a new borrower .<CODESPLIT>contract  c4868{ /** *  @dev  Approve  a  new  borrower. *  @param  borrower  Address  of  new  borrower. */ function  addBorrower(address  borrower)  external  onlyOwner  { approved[borrower]  =  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>looks up the current token price .<CODESPLIT>contract  c39367{ /*  looks  up  the  current  token  price  */ function  getPrice()  constant  returns  (uint256  price){ for(var  i  =  0;  i  <  deadlines.length;  i++) if(now<deadlines[i]) return  prices[i]; return  prices[prices.length-1]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the total number of games .<CODESPLIT>contract  c5671{ /** *  @notice  Returns  the  total  number  of  games */ function  getTotalGames()  public  view  returns  (uint)  { return  games.length; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Interface marker .<CODESPLIT>contract  c292{ /**  Interface  marker.  */ function  isCrowdsale()  public  constant  returns  (bool)  { return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The getter for paused contract variable .<CODESPLIT>contract  c26920{ /** *  @dev  The  getter  for  "paused"  contract  variable */ function  getPaused()  public  constant  returns  (bool)  { return  paused; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tells whether a given key is registered .<CODESPLIT>contract  c35571{  function  isRegistered(address  key)  constant  returns(bool)  { return  records[key].time  !=  0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>status functions .<CODESPLIT>contract  c12455{    function  getBalance(ERC20  token)  public  view  returns(uint)  { if  (token  ==  ETH_TOKEN_ADDRESS) return  this.balance; else return  token.balanceOf(this); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check user's REB balance tier .<CODESPLIT>contract  c14558{ /** *  @dev  check  user's  REB  balance  tier *  @param  holderAddress  Token  holder  address *  @return  string  representing  the  milestone  tier */ function  checkBalanceTier(address  holderAddress)  public  view  returns(string)  { uint256  holderBalance  =  balanceOf(holderAddress); if  (holderBalance  >=  1000000e18)  { return  "Platinum  tier"; }  else  if  (holderBalance  >=  700000e18)  { return  "Gold  tier"; }  else  if  (holderBalance  >=  300000e18)  { return  "Titanium  tier"; }  else  if  (holderBalance  ==  0)  { return  "Possess  no  REB"; } return  "Free  tier"; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a new promo Team with the given name , with given _price and assignes it to an address .<CODESPLIT>contract  c25013{  function  createPromoTeam(address  _owner,  string  _name,  uint256  _price)  public  onlyCOO  { require(promoCreatedCount  <  PROMO_CREATION_LIMIT); address  teamOwner  =  _owner; if  (teamOwner  ==  address(0))  { teamOwner  =  cooAddress; } if  (_price  <=  0)  { _price  =  startingPrice; } promoCreatedCount++; _createTeam(_name,  teamOwner,  _price); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to pay the creator upon success .<CODESPLIT>contract  c38774{  function  payCreator()  { require(isComplete()); require(!creatorPaid); creatorPaid  =  true; if(isSuccessful()){ uint  tokensToBurn  =  tokenBalance()  -  checkTokTotal(); PayEther(escrow,this.balance,now); escrow.transfer(this.balance); PayTokens(creator,checkTokDev(),now); Token.transfer(creator,checkTokDev()); Token.burn(tokensToBurn); BurnTokens(tokensToBurn,now); }else{ PayTokens(creator,tokenBalance(),now); Token.transfer(creator,tokenBalance()); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>override getRate to integrate with rate provider .<CODESPLIT>contract  c34930{ /** *  @dev  override  getRate  to  integrate  with  rate  provider. */ function  getRate(uint  _value)  internal  constant  returns  (uint)  { return  rateProvider.getRate(msg.sender,  soldTokens,  _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>After contract ends move funds .<CODESPLIT>contract  c39652{ /*  After  contract  ends  move  funds  */ function  moveFunds()  onlyOwner  {  if  (!project_wallet.send(this.balance))  throw; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This requires that the token-holder authorizes this contract's address using the approve ( ) function .<CODESPLIT>contract  c40240{ /** *  Function  call  to  withdraw  ETH  by  burning  childDao  tokens. *  @param  proposalId  The  split  proposal  ID  which  created  the  childDao *  @dev  This  requires  that  the  token-holder  authorizes  this  contract's  address  using  the  approve()  function. */ function  withdraw(uint  proposalId)  external  {  uint  balance  =  whiteList[proposalId].balanceOf(msg.sender);  if  (!whiteList[proposalId].transferFrom(msg.sender,  this,  balance)  ||  !msg.sender.send(balance)) throw; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>the rate in FARM per 1 ETH according to the time of the tx and the FARM pricing program .<CODESPLIT>contract  c28099{   function  getRate()  constant  returns  (uint256  rate)  { if  (now  <  START)  return  rate  =  1190476190476200; else  if  (now  <=  START  +  6  days)  return  rate  =  1234567900000000  ; else  if  (now  <=  START  +  13  days)  return  rate  =  1282051300000000  ; else  if  (now  <=  START  +  20  days)  return  rate  =  1333333300000000  ; else  if  (now  <=  START  +  28  days)  return  rate  =  1388888900000000  ; return  rate  =  1666666700000000; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenience function to allow immediate refunds .<CODESPLIT>contract  c28805{  function  enable_refunds()  public  onlyOwner  { state  =  State.Refunding; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Manages the purchase of the tokens for a given price .<CODESPLIT>contract  c35045{   function  processPurchase(uint  price)  private  {  uint  numTokens  =  safeDiv(safeMul(msg.value,  price),  1  ether);  assert(numTokens  <=  remaining()  &&  remaining()  >  0);  totalCollected  =  safeAdd(totalCollected,  msg.value); tokensIssued  =  safeAdd(tokensIssued,  numTokens);  EtherReceiverInterface(vaultAddress).receiveEther.value(msg.value)();  if  (!MintInterface(tokenContract).mint(msg.sender,  numTokens)) revert(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set historical balance for the owner of given address as it was at the moments of snapshots with indexes in given range .<CODESPLIT>contract  c31820{ /** *  Set  historical  balance  for  the  owner  of  given  address  as  it  was  at  the *  moments  of  snapshots  with  indexes  in  given  range. * *  @param  _owner  address  to  set  the  historical  balance  for  the  owner  of *  @param  _from  beginning  of  the  snapshot  index  range  (inclusive) *  @param  _to  end  of  the  snapshot  index  range  (exclusive) *  @param  _balance  value  to  set  balance  to */ function  setHistoricalBalance  ( address  _owner,  uint256  _from,  uint256  _to,  uint256  _balance) internal  { assert  (_from  >  0); assert  (_to  >=  _from); assert  (_balance  >  0); uint8  level  =  0; while  (_from  <  _to)  { if  (_from  &  1  ==  1)  {  historicalBalances  [_owner][level][_from++]  =  _balance; } if  (_to  &  1  ==  1)  {  historicalBalances  [_owner][level][--_to]  =  _balance; } _from  >>=  1; _to  >>=  1; level  +=  1;  } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates arguments for changing any of the sig requirement parameters .<CODESPLIT>contract  c31912{     function  checkRequiredChange(uint256  _newRequired,  uint256  _length) private  returns  (bool) { if(_newRequired  ==  0){ LogErrorMsg(_newRequired,  "Cant  reduce  to  0"); return  false; } if(_length  -  2  <  _newRequired){ LogErrorMsg(_length,  "Making  requirement  too  high"); return  false; } return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the amount of tokens released for a vesting .<CODESPLIT>contract  c17000{ /** *  @dev  Get  the  amount  of  tokens  released  for  a  vesting * *  @param  _token  The  address  of  the  token. *  @param  _granter  The  address  of  the  granter. *  @param  _vester  The  address  of  the  vester. *  @return  the  number  of  tokens  available. */ function  getVestingBalance(address  _token,  address  _granter,  address  _vester) external constant returns(uint256) { Grant  memory  _grant  =  grantPerTokenGranterVester[_token][_granter][_vester]; return  getBalanceVestingInternal(_grant); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Default assumes totalSupply can't be over max ( 2 256 - 1 ) .<CODESPLIT>contract  c21569{    function  transfer(address  _to,  uint256  _value)  public  returns  (bool  success)  { require(!hault); require(balances[msg.sender]  >=  _value); balances[msg.sender]  =  safeSub(balances[msg.sender],_value); balances[_to]  =  safeAdd(balances[_to],  _value); Transfer(msg.sender,  _to,  _value); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get some stats .<CODESPLIT>contract  c35363{ /* *  get  some  stats * */ function  getStats()  public  constant  returns  (uint256,  uint256,  bool)  { return  (totalContribution,  _totalSupply,  purchasingAllowed); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reset all the balances to 0 and the state to false .<CODESPLIT>contract  c8239{ /** *  @dev  Reset  all  the  balances  to  0  and  the  state  to  false. */ function  clean()  public onlyOwner  { for  (uint256  i  =  0;  i  <  addresses.length;  i++) { Beneficiary  storage  beneficiary  =  beneficiaries[addresses[i]]; beneficiary.balance  =  0; beneficiary.airdrop  =  0; } filled  =  false; airdropped  =  false; toVault  =  0; emit  Cleaned(addresses.length); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A token purchase with anti-money laundering and KYC checks .<CODESPLIT>contract  c19699{ /* *  A  token  purchase  with  anti-money  laundering  and  KYC  checks *  This  function  takes  in  a  dataframe  and  EC  signature  to  verify  if  the  purchaser  has  been  verified *  on  the  server  side  of  our  application  and  has  therefore,  participated  in  KYC. *  Upon  registering  to  the  site,  users  are  supplied  with  a  signature  allowing  them  to  purchase  tokens, *  which  can  be  revoked  at  any  time,  this  containst  their  ETH  address,  a  unique  ID  and  the  min  and  max *  ETH  that  user  has  stated  they  will  purchase.  (Any  more  than  the  max  may  be  subject  to  AML  checks). */ function  buyWithKYCData(bytes  dataframe,  uint8  v,  bytes32  r,  bytes32  s)  public  payable  { bytes32  hash  =  sha256(dataframe); address  whitelistedAddress; uint128  customerId; uint32  minETH; uint32  maxETH; (whitelistedAddress,  customerId,  minETH,  maxETH)  =  getKYCPayload(dataframe);  require(ecrecover(hash,  v,  r,  s)  ==  signerAddress);  require(whitelistedAddress  ==  msg.sender);  uint256  weiAmount  =  msg.value; uint256  max  =  maxETH; uint256  min  =  minETH; require(weiAmount  <  (max  *  1  ether)); require(weiAmount  >  (min  *  1  ether)); buyTokens(customerId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set News .<CODESPLIT>contract  c16022{ /** *  @dev  Set  News * *  @param  _news  string */ function  setNews(string  _news)  external  onlyOwner  returns  (bool)  { news  =  _news; emit  NewsPublished(_news); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers the balance of the sale auction contract to the ZodiacCore contract .<CODESPLIT>contract  c12251{    function  withdrawAuctionBalances()  external  onlyCLevel  { saleAuction.withdrawBalance(); siringAuction.withdrawBalance(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shuts down the contract and removes it from the blockchain state .<CODESPLIT>contract  c39667{ /** *  Shuts  down  the  contract  and  removes  it  from  the  blockchain  state. *  Only  available  to  the  owner. */ function  shutdown()  onlyOwner  { selfdestruct(owner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>delete function , used when bugs comeout .<CODESPLIT>contract  c23783{  function  deletePokemon(uint  _pokemonId)  public  onlyContractCreator()  { delete  pokemons[_pokemonId]; delete  pokemons[_pokemonId]; delete  lock[_pokemonId]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Requesting a certification document by index is a paying feature .<CODESPLIT>contract  c30337{ /** *  @notice  Requesting  a  certification  document  by  index  is  a  paying  feature. */ function  getCertificationDocumentAtIndex(address  student,  uint256  index) payable requestFeePaid returns  (bytes32  document)  { document  =  studentCertifications[student].documents[index]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Verify an investor .<CODESPLIT>contract  c27952{ /** *  @dev  Verify  an  investor *  @param  _customer  The  customer's  public  key  address *  @param  _countryJurisdiction  The  jurisdiction  country  code  of  the  customer *  @param  _divisionJurisdiction  The  jurisdiction  subdivision  code  of  the  customer *  @param  _role  The  type  of  customer  -  investor:1,  delegate:2,  issuer:3,  marketmaker:4,  etc. *  @param  _accredited  Whether  the  customer  is  accredited  or  not  (only  applied  to  investors) *  @param  _expires  The  time  the  verification  expires */ function  verifyCustomer( address  _customer, bytes32  _countryJurisdiction, bytes32  _divisionJurisdiction, uint8  _role, bool  _accredited, uint256  _expires )  public  onlyProvider  returns  (bool  success) { require(_expires  >  now); require(POLY.transferFrom(_customer,  msg.sender,  providers[msg.sender].fee)); customers[msg.sender][_customer].countryJurisdiction  =  _countryJurisdiction; customers[msg.sender][_customer].divisionJurisdiction  =  _divisionJurisdiction; customers[msg.sender][_customer].role  =  _role; customers[msg.sender][_customer].accredited  =  _accredited; customers[msg.sender][_customer].expires  =  _expires; customers[msg.sender][_customer].verified  =  true; LogCustomerVerified(_customer,  msg.sender,  _role); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get various information about the match and its current state .<CODESPLIT>contract  c10257{  function  getMatchInfo()  public  view  returns  (string,  uint,  uint,  string,  uint,  uint,  uint,  bool,  uint,  uint,  bool)  { return  (teams[0].name,  teams[0].totalAmount,  teams[0].totalParticipants,  teams[1].name, teams[1].totalAmount,  teams[1].totalParticipants,  winIndex,  matchCompleted,  minimumBetAmount,  matchNumber,  stopMatchBetting); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer token for a specified address , but different from transfer is replace msg . sender .<CODESPLIT>contract  c14129{ /** *  @dev  transfer  token  for  a  specified  address,but  different  from  transfer  is  replace  msg.sender  with  tx.origin *  @param  _to  The  address  to  transfer  to. *  @param  _value  The  amount  to  be  transferred. */ function  originTransfer(address  _to,  uint256  _value)  public  returns  (bool)  { require(_to  !=  address(0)); require(_value  <=  balances[tx.origin]);  balances[tx.origin]  =  balances[tx.origin].sub(_value); balances[_to]  =  balances[_to].add(_value); Transfer(tx.origin,  _to,  _value); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can transfer out any accidentally sent ERC20 tokens excluding the token intended for this contract .<CODESPLIT>contract  c13156{   function  transferAnyERC20Token(address  _address,  uint  _tokens)  external  onlyOwner  { require(_address  !=  address(erc20Contract)); ERC20(_address).safeTransfer(owner,  _tokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates the startTimestamp propety with the new _start value .<CODESPLIT>contract  c24377{  function  setStartTimestamp(uint256  _start)  external  onlyAdmin  returns  (bool)  { require(_start  <  endTimestamp); require(_start  >  currentTime()); uint256  _oldValue  =  startTimestamp; startTimestamp  =  _start; StartTimestampUpdated(msg.sender,  _oldValue,  startTimestamp); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>create a new offer with setting .<CODESPLIT>contract  c22040{   function  CreateOffer(uint8  setting)  public  payable{ require(msg.value>0); require(setting>0); CreateOffer_internal(setting,  false); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer the balance from the sender's address to the address _to with data _data .<CODESPLIT>contract  c4741{ /*  Transfer  the  balance  from  the  sender's  address  to  the  address  _to  with  data  _data  */ function  transfer(address  _to,  uint  _value,  bytes  _data)  returns  (bool  success)  { if  (balances[msg.sender]  >=  _value &&  _value  >  0 &&  balances[_to]  +  _value  >  balances[_to])  { if(isContract(_to))  { return  transferToContract(_to,  _value,  _data); }  else  { return  transferToAddress(_to,  _value,  _data); } }  else  { return  false; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set current DOL prices .<CODESPLIT>contract  c15078{  function  updatePrices()  internal  { uint256  oldPrice  =  currentTokenPrice; if(preIcoIsRunning)  { checkPreIcoStatus(); } if(preIcoIsRunning)  { currentTokenPrice  =  preICOprice; }else{ currentTokenPrice  =  ICOprice; } if(oldPrice  !=  currentTokenPrice)  { priceUpdated(oldPrice,  currentTokenPrice,  "Token  price  updated!"); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds a Kin token vesting grant .<CODESPLIT>contract  c17653{    function  addTokenGrant(address  _grantee,  uint256  _value)  external  onlyOwner  { require(_grantee  !=  address(0)); require(_value  >  0); require(tokenGrantees.length  +  1  <=  MAX_TOKEN_GRANTEES);  require(tokenGrants[_grantee].value  ==  0); for  (uint  i  =  0;  i  <  tokenGrantees.length;  i++)  { require(tokenGrantees[i]  !=  _grantee); }  tokenGrantees.push(_grantee); tokenGrants[_grantee]  =  TokenGrant(_value,  0,  1  years,  1  years,  1  days,  50); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>freeze your tokens to the specified address .<CODESPLIT>contract  c321{ /** *  @dev  freeze  your  tokens  to  the  specified  address. *  Be  careful,  gas  usage  is  not  deterministic, *  and  depends  on  how  many  freezes  _to  address  already  has. *  @param  _to  Address  to  which  token  will  be  freeze. *  @param  _amount  Amount  of  token  to  freeze. *  @param  _until  Release  date,  must  be  in  future. */ function  freezeTo(address  _to,  uint  _amount,  uint64  _until)  public  { require(_to  !=  address(0)); require(_amount  <=  balances[msg.sender]); balances[msg.sender]  =  balances[msg.sender].sub(_amount); bytes32  currentKey  =  toKey(_to,  _until); freezings[currentKey]  =  freezings[currentKey].add(_amount); freezingBalance[_to]  =  freezingBalance[_to].add(_amount); freeze(_to,  _until); emit  Transfer(msg.sender,  _to,  _amount); emit  Freezed(_to,  _until,  _amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all the relevant information about a specific waifu .<CODESPLIT>contract  c25257{   function  getWaifu(uint256  _tokenId)  public  view  returns  ( string  waifuName, uint256  sellingPrice, address  owner )  { Waifu  storage  waifu  =  waifus[_tokenId]; waifuName  =  waifu.name; sellingPrice  =  waifuIndexToPrice[_tokenId]; owner  =  waifuIndexToOwner[_tokenId]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns a new address to the CEO role .<CODESPLIT>contract  c25898{   function  setCEO(address  _newCEO)  external  onlyCEO  { require(_newCEO  !=  address(0)); ceoAddress  =  _newCEO; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the releasedToken of the specified address .<CODESPLIT>contract  c6370{ /** *  @dev  Gets  the  releasedToken  of  the  specified  address. *  @param  _owner  The  address  to  query  the  the  releasedToken  of. *  @return  An  uint256  representing  the  amount  owned  by  the  passed  address. */ function  releasedTokenOf(address  _owner)  public  view  returns  (uint256)  { return  releasedTokens[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The actual predator attack .<CODESPLIT>contract  c39482{ /** *  The  actual  predator  attack. *  The  predator  kills  up  to  10  animals,  but  in  case  there  are  less  than  100  animals  in  the  game  up  to  10%  get  eaten. *  */ function  __callback(bytes32  myid,  string  result)  { if  (msg.sender  !=  oraclize_cbAddress()  ||  myid  !=  nextAttackId)  throw; uint128  pot; uint16  random; uint32  howmany  =  numAnimals  <  100  ?  (numAnimals  <  10  ?  1  :  numAnimals  /  10)  :  10; uint16[]  memory  randomNumbers  =  getNumbersFromString(result,  ",",  howmany); uint32[]  memory  killedAnimals  =  new  uint32[](howmany); for  (uint8  i  =  0;  i  <  howmany;  i++)  { random  =  mapToNewRange(randomNumbers[i],  numAnimals); killedAnimals[i]  =  ids[random]; pot  +=  killAnimal(random); } uint128  neededGas  =  oraclizeGas  +  10000  *  numAnimals; uint128  gasCost  =  uint128(neededGas  *  tx.gasprice); if  (pot  >  gasCost) distribute(uint128(pot  -  gasCost)); triggerAttack(timeTillNextAttack(),  neededGas); newAttack(killedAnimals); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow to extend ICO end date .<CODESPLIT>contract  c33003{   function  setEndDate(uint256  _endTime) external  onlyOwner  whenNotPaused { require(now  <=  _endTime); require(startTime  <  _endTime); endTime  =  _endTime; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow pre-approved user to take ownership of a color .<CODESPLIT>contract  c27498{    function  takeOwnership(uint256  _tokenId)  public  { address  newOwner  =  msg.sender; address  oldOwner  =  colorIndexToOwner[_tokenId];  require(_addressNotNull(newOwner));  require(_approved(newOwner,  _tokenId)); _transfer(oldOwner,  newOwner,  _tokenId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function sends the pooled eth to the receiving address , calculates the of unused eth to be returned , and advances the contract to stage two .<CODESPLIT>contract  c9458{     function  submitPool  (uint  amountInWei)  public  onlyOwner  noReentrancy  { require  (contractStage  ==  1); require  (receiverAddress  !=  0x00); require  (block.number  >=  addressChangeBlock.add(6000)); if  (amountInWei  ==  0)  amountInWei  =  this.balance; require  (contributionMin  <=  amountInWei  &&  amountInWei  <=  this.balance); finalBalance  =  this.balance; require  (receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if  (this.balance  >  0)  ethRefundAmount.push(this.balance); contractStage  =  2; PoolSubmitted(receiverAddress,  amountInWei); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>( entityActive , connectionEntityActive , connectionActive , data , direction , expiration ) - tupple containing the entity active and the connection fields .<CODESPLIT>contract  c22678{ /** *  Returns  details  of  a  connection *  @param  _entity  -  the  address  of  the  entity  which  created  the *  @return  (entityActive,  connectionEntityActive,  connectionActive,  data,  direction,  expiration) *  -  tupple  containing  the  entity  active  and  the  connection  fields */ function  getConnection( address  _entity, address  _connectionTo, bytes32  _connectionType ) view  external  returns  ( bool  entityActive, bool  connectionEntityActive, bool  connectionActive, bytes32  data, Direction  direction, uint  expiration ){ address  resolvedEntity  =  resolveEntityAddress(_entity); address  resolvedConnectionEntity  =  resolveEntityAddress(_connectionTo); Entity  storage  entity  =  entities[resolvedEntity]; Connection  storage  connection  =  entity.connections[resolvedConnectionEntity][_connectionType]; return  (entity.active,  entities[resolvedConnectionEntity].active,  connection.active,  connection.data,  connection.direction,  connection.expiration); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>agreement not locked .<CODESPLIT>contract  c8311{  modifier  notLocked()  { require(!locked); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>checks if sequence can be represented in form of 48151623420 . . 00 .<CODESPLIT>contract  c24257{      function  seqSearch(uint  sequence,  uint  offset,  uint  length)  private  constant  returns  (int)  { for(uint  i  =  offset;  i  <  offset  +  length;  i++)  { if(sequence  ==  4815162342  *  10  **  i)  {  return  int(i); } }  return  -1; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculate fee from the losing portion of total pot .<CODESPLIT>contract  c27775{  function  removeFeeAmount(uint  totalPot,  uint  winnersPot)  private  returns(uint)  { uint  remaining  =  SafeMath.sub(totalPot,  winnersPot);  if  (remaining  ==  0)  { return  0; }  uint  feeAmount  =  SafeMath.div(remaining,  100); feeAmount  =  feeAmount  *  feePercentage; totalFee  =  feeAmount;  return  remaining  -  feeAmount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update the constants of the network if necessary .<CODESPLIT>contract  c30413{ /** *  Update  the  constants  of  the  network  if  necessary */ function  setPricePerMessage(uint256  newPrice)  onlyOwner  { pricePerMessageChanged(pricePerMessage,newPrice); pricePerMessage  =  newPrice; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform initial token allocation between founders' addresses .<CODESPLIT>contract  c36619{ /* *  @dev  Perform  initial  token  allocation  between  founders'  addresses. *  Is  only  executed  once  after  presale  contract  deployment  and  is  invoked  manually. */ function  allocateInternalWallets()  onlyOwner  { require  (!allocatedInternalWallets); allocatedInternalWallets  =  true; token.transfer(foundersAddress,  initialFoundersAmount); token.transfer(supportAddress,  initialSupportAmount); token.transfer(bountyAddress,  initialBountyAmount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>creates and stores a new promise object , updates the promisedTokenBalance .<CODESPLIT>contract  c36171{ /*** *  @dev  creates  and  stores  a  new  promise  object,  updates  the  promisedTokenBalance */ function  createPromise(address  recipient,  uint256  amount,  uint256  lockedUntil) requires(amount  <=  uncommittedTokenBalance()) thenAssertState internal returns(TokenPromise  storage  promise) { uint256  promiseId  =  nextPromiseId++; promise  =  promises[promiseId]; promise.promiseId  =  promiseId; promise.recipient  =  recipient; promise.amount  =  amount; promise.lockedUntil  =  lockedUntil; promise.state  =  PromiseState.pending; promisedTokenBalance  =  promisedTokenBalance.add(promise.amount); logPromiseCreated(promiseId,  recipient,  amount,  lockedUntil); return  promise; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer tokens from allowance .<CODESPLIT>contract  c30203{ /*  Transfer  tokens  from  allowance  */ function  transferFrom(address  _from,  address  _to,  uint256  _value)  public  returns  (bool  success)  { /*  Prevent  transfer  of  not  allowed  tokens  */ require(allowance[_from][msg.sender]  >=  _value); /*  Remove  tokens  from  allowance  */ allowance[_from][msg.sender]  -=  _value; _transfer(_from,  _to,  _value); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>batch transfer recivers to be _value .<CODESPLIT>contract  c17707{ /** *  batch  transfer  recivers  to  be  _value * *  @param  _receivers  Address  to  be  frozen *  @param  _value  either  to  freeze  it  or  not */ function  batchTransfer(address[]  _receivers,  uint256  _value)  public  whenNotPaused  onlyMsgDataSize(2  *  32)  returns  (bool)  { uint  cnt  =  _receivers.length; require(cnt  >  0  &&  cnt  <=  100); require(_value  >  0); for  (uint  i  =  0;  i  <  cnt;  i++)  { if  (!frozenAccount[_receivers[i]]  &&  balances[msg.sender]  >=  _value  )  { balances[msg.sender]  =  balances[msg.sender].sub(_value); balances[_receivers[i]]  =  balances[_receivers[i]].add(_value); Transfer(msg.sender,  _receivers[i],  _value); } } return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return total supply of token .<CODESPLIT>contract  c14677{ /**  ******************************  Constants  *******************************  **/ /** *  @dev  Return  total  supply  of  token. **/ function  totalSupply() external view returns  (uint256) { return  _totalSupply; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Start crowd-sale .<CODESPLIT>contract  c2445{ /** *  @dev  Start  crowd-sale *  @param  _token  Coin's  contract *  @param  _rate  current  exchange  rate */ function  start(address  _token,  uint256  _rate)  public  onlyOwnerOrManager  { require(_rate  >  0,  "Invalid  exchange  rate"); require(phase_i  ==  PHASE_NOT_STARTED,  "Bad  phase"); token  =  EyeToken(_token); base_wallet  =  token.wallet(); dec_mul  =  10  **  uint256(token.decimals());  address  org_exp  =  0xeb967ECF00e86F58F6EB8019d003c48186679A96;  address  ear_brd  =  0x469A97b357C2056B927fF4CA097513BD927db99E;  address  com_dev  =  0x877D6a4865478f50219a20870Bdd16E6f7aa954F;  address  special  =  0x5D2C58e6aCC5BcC1aaA9b54B007e0c9c3E091adE;  vest_1  =  0x47997109aE9bEd21efbBBA362957F1b20F435BF3; vest_2  =  0xd031B38d0520aa10450046Dc0328447C3FF59147; vest_3  =  0x32FcE00BfE1fEC48A45DC543224748f280a5c69E; vest_4  =  0x07B489712235197736E207836f3B71ffaC6b1220; token.transferICO(org_exp,  600000000  *  dec_mul); token.transferICO(ear_brd,  1000000000  *  dec_mul); token.transferICO(com_dev,  1000000000  *  dec_mul); token.transferICO(special,  800000000  *  dec_mul); token.transferICO(vest_1,  500000000  *  dec_mul); token.transferICO(vest_2,  500000000  *  dec_mul); token.transferICO(vest_3,  500000000  *  dec_mul); token.transferICO(vest_4,  500000000  *  dec_mul); exchange_rate  =  _rate; phase_i  =  PHASE_BEFORE_PRESALE; _updatePhaseTimes(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes / deletes contract .<CODESPLIT>contract  c26903{ /** *  @dev  Removes/deletes  contract */ function  kill()  owneronly  { selfdestruct(msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>changes the coldwallet2 address .<CODESPLIT>contract  c20192{ /** *  @dev  changes  the  coldwallet2  address */ function  setColdWallet2(address  _coldWallet2)  public  onlyOwner  { require(_coldWallet2  !=  address(0)); coldWallet2  =  _coldWallet2; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pay with Mileage .<CODESPLIT>contract  c18660{  function  payWithMileagePoint(uint256  _amount) whenNotPaused public { require(msg.sender  !=  address(0));  require(_amount  >=  1  &&  _amount  <=  5); var  _priceOfBundle  =  mileagePointPrice  *  _amount; require(addressToMileagePoint[msg.sender]  >=  _priceOfBundle);  addressToMileagePoint[msg.sender]  -=  _priceOfBundle; for  (uint  i  =  0;  i  <  _amount;  i  ++)  {  var  _randomValue  =  random(10000,  0);  uint8  _heroRankToMint  =  0; if  (_randomValue  <  5000)  { _heroRankToMint  =  1; }  else  if  (_randomValue  <  9050)  { _heroRankToMint  =  2; }  else  if  (_randomValue  <  9950)  { _heroRankToMint  =  3; }  else  { _heroRankToMint  =  4; }  summonHero(msg.sender,  _heroRankToMint); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>To approve a proxy for token transfers .<CODESPLIT>contract  c39269{  function  approve(address  _spender,  uint256  _amount) public canEnter returns  (bool) { holders[msg.sender].allowances[_spender]  =  _amount; Approval(msg.sender,  _spender,  _amount); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks that a given zodiac is able to breed .<CODESPLIT>contract  c12251{    function  _isReadyToBreed(Zodiac  _zod)  internal  view  returns  (bool)  {    return  (_zod.siringWithId  ==  0)  &&  (_zod.cooldownEndBlock  <=  uint64(block.number)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deposit Funds .<CODESPLIT>contract  c3271{  function  hodl()  payable  public  { hodlers[msg.sender]  +=  msg.value; emit  Hodl(msg.sender,  msg.value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Method called by anyone to withdraw funds to coindrops wallet after locking period .<CODESPLIT>contract  c28383{ /** *  @dev  Method  called  by  anyone  to  withdraw  funds  to  coindrops  wallet  after  locking  period */ function  withdrawCoindropsToken()  public  {  require(coindropsLockEndingAt  <=  getBlockTime());  require(coindropsStatus  ==  false);  bytes  memory  empty; token.transfer(coindropsWallet,  coindropsTokens,  empty); coindropsStatus  =  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a newly allocated string containing the concatenation of self and other .<CODESPLIT>contract  c357{ /* *  @dev  Returns  a  newly  allocated  string  containing  the  concatenation  of *  `self`  and  `other`. *  @param  self  The  first  slice  to  concatenate. *  @param  other  The  second  slice  to  concatenate. *  @return  The  concatenation  of  the  two  strings. */ function  concat(slice  memory  self,  slice  memory  other)  internal  pure  returns  (string  memory)  { string  memory  ret  =  new  string(self._len  +  other._len); uint  retptr; assembly  {  retptr  :=  add(ret,  32)  } memcpy(retptr,  self._ptr,  self._len); memcpy(retptr  +  self._len,  other._ptr,  other._len); return  ret; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Execute a multi-signature transaction from this wallet using 2 signers : one from msg . sender .<CODESPLIT>contract  c33252{ /** *  Execute  a  multi-signature  transaction  from  this  wallet  using  2  signers:  one  from  msg.sender  and  the  other  from  ecrecover. *  The  signature  is  a  signed  form  (using  eth.sign)  of  tightly  packed  toAddress,  value,  data,  expireTime  and  sequenceId *  Sequence  IDs  are  numbers  starting  from  1.  They  are  used  to  prevent  replay  attacks  and  may  not  be  repeated. * *  @param  toAddress  the  destination  address  to  send  an  outgoing  transaction *  @param  value  the  amount  in  Wei  to  be  sent *  @param  data  the  data  to  send  to  the  toAddress  when  invoking  the  transaction *  @param  expireTime  the  number  of  seconds  since  1970  for  which  this  transaction  is  valid *  @param  sequenceId  the  unique  sequence  id  obtainable  from  getNextSequenceId *  @param  signature  the  result  of  eth.sign  on  the  operationHash  sha3(toAddress,  value,  data,  expireTime,  sequenceId) */ function  sendMultiSig(address  toAddress,  uint  value,  bytes  data,  uint  expireTime,  uint  sequenceId,  bytes  signature)  onlysigner  {  var  operationHash  =  sha3("ETHER",  toAddress,  value,  data,  expireTime,  sequenceId); var  otherSigner  =  verifyMultiSig(toAddress,  operationHash,  signature,  expireTime,  sequenceId);  if  (!(toAddress.call.value(value)(data)))  {  throw; } Transacted(msg.sender,  otherSigner,  operationHash,  toAddress,  value,  data); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Issues unlocked tokens .<CODESPLIT>contract  c20032{ /****************************** TOKEN  ISSUING *******************************/ /** *  @dev  Issues  unlocked  tokens *  @param  _to  address  The  address  which  is  going  to  receive  the  newly  issued  tokens *  @param  _value  uint256  the  value  of  tokens  to  issue *  @return  true  if  successful */ function  issueTokens(address  _to,  uint256  _value)  onlyAdmin  public  returns  (bool){ issueTokensWithLocking(_to,  _value,  0,  LockReason.Other,  0); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pay this function to add the dividends .<CODESPLIT>contract  c35205{ /** *  @dev  Pay  this  function  to  add  the  dividends */ function  giveDividend()  payable  whenNotPaused  { require  (msg.value  !=  0); dividendAmount  =  dividendAmount.add(msg.value); dividendList[currentDividend]  =  (msg.value).mul(10000000000).div(totalSupply); currentDividend  =  currentDividend.add(1); DividendAvailable(msg.value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>disable whitelist state .<CODESPLIT>contract  c11024{ /** *  @dev  disable  whitelist  state * */ function  disableWhitelist()  public  onlyOwner  returns  (bool  whitelistState)  { whitelistEnable  =  false; emit  WhitelistState(msg.sender,  whitelistEnable); return  whitelistEnable; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Can only be called after presale is concluded .<CODESPLIT>contract  c26938{  function  startCrowdsale()  public  onlyOwner  { require(presaleConcluded  &&  !crowdsaleStarted); crowdsaleStarted  =  true; phase1StartBlock  =  block.number; phase1EndBlock  =  phase1StartBlock.add(dayToBlockNumber(7)); phase2EndBlock  =  phase1EndBlock.add(dayToBlockNumber(6)); phase3EndBlock  =  phase2EndBlock.add(dayToBlockNumber(6)); phase4EndBlock  =  phase3EndBlock.add(dayToBlockNumber(6)); phase5EndBlock  =  phase4EndBlock.add(dayToBlockNumber(6)); endBlock  =  phase5EndBlock; StartCrowdsale(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>cancel any outstanding multisig call .<CODESPLIT>contract  c40083{ /*  ---------------  methods  to  be  called  directly  on  the  contract  --------------*/ /** *  @notice  cancel  any  outstanding  multisig  call * */ function  cancel()  returns  (uint8  code)  { if  (!masterKeys[msg.sender])  { Unauthorized(msg.sender); return  0; } uint256  call  =  functionCalling[msg.sender]; if  (call  ==  0)  { NothingToCancel(msg.sender); return  1; }  else  { AuthCancel(msg.sender,  msg.sender); uint256  hash  =  functionCalling[msg.sender]; functionCalling[msg.sender]  =  0x0; functionCalls[hash]  =  0; return  2; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get back all your Ether ( fees are also refunded ) .<CODESPLIT>contract  c18255{  function  refund()  external  { require(canRefund()); require(!claimed[msg.sender]); address  refunder  =  msg.sender; uint256  refundAmount  =  weiReceived[refunder].mul(PERCENTAGE_100)  /  (PERCENTAGE_100.sub(DEVELOPER_FEE_PERCENTAGE))  ; claimed[refunder]  =  true; if  (collectedFees  >  0)  { collectedFees  =  0; } refunder.transfer(refundAmount); Claim(refunder,  refundAmount,  refundAmount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>public methods to give and take that only owners can call .<CODESPLIT>contract  c24912{  function  give(address  _to,  uint256  _value)  public  onlyOwners  returns(bool  success){ transfer(this,  _to,  _value); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>issue token take from ethFundDeposit to user .<CODESPLIT>contract  c5909{  function  tokenadd  (address  _addr,uint256  _value)  internal  { require(_value  !=  0); require  (_addr  !=  address(0x0)); balances[_addr]  =  safeAdd(balances[_addr],  _value); totalbalances[_addr]  =  safeAdd(totalbalances[_addr],  _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>create tokens , only usable while saleActive .<CODESPLIT>contract  c39155{    function  create(address  recipient,  uint256  amount) onlyOwner  onlyDuringSale  { if  (amount  ==  0)  throw; if  (safeAdd(totalSupply,  amount)  >  MAX_TOKENS)  throw; balances[recipient]  =  safeAdd(balances[recipient],  amount); totalSupply  =  safeAdd(totalSupply,  amount); Created(recipient,  amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add prop .<CODESPLIT>contract  c3554{  function  addProject(uint  _id)  public  onlyAdmin  { require(votingActive  ==  true); projects.push(Project({ id:  _id, votesWeight:  0, active:  true })); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Factory owner can withdraw any ERC20 asset tokens from this contract .<CODESPLIT>contract  c28908{           function  ownerWithdrawERC20Token(address  tokenAddress,  uint256  tokens)  onlyOwner  returns  (bool  ok)  { OwnerWithdrewERC20Token(tokenAddress,  tokens); return  ERC20(tokenAddress).transfer(owner,  tokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>need to seal Crowdsale when it is finished completely .<CODESPLIT>contract  c15323{  function  seal()  public  onlyOwner  { sealed  =  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the totalSupply .<CODESPLIT>contract  c13470{    function  totalSupply()  public  view  returns  (uint)  { return  totalSupply; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows the requester to cancel their adoption request .<CODESPLIT>contract  c37847{ /*  allows  the  requester  to  cancel  their  adoption  request  */ function  cancelAdoptionRequest(bytes5  catId)  { AdoptionRequest  storage  existingRequest  =  adoptionRequests[catId]; require(existingRequest.exists); require(existingRequest.requester  ==  msg.sender); uint  price  =  existingRequest.price; adoptionRequests[catId]  =  AdoptionRequest(false,  catId,  0x0,  0); msg.sender.transfer(price); AdoptionRequestCancelled(catId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to create , accept and add additionals to a request as Payer .<CODESPLIT>contract  c15177{ /* *  @dev  Internal  function  to  create,  accept  and  add  additionals  to  a  request  as  Payer * *  @dev  msg.sender  must  be  _payer * *  @param  _requestData  nasty  bytes  containing  :  creator,  payer,  payees|expectedAmounts,  data *  @param  _payeesPaymentAddress  array  of  payees  bitcoin  address  for  payment *  @param  _payerRefundAddress  payer  bitcoin  address  for  refund *  @param  _additionals  Will  increase  the  ExpectedAmount  of  the  request  right  after  its  creation  by  adding  additionals * *  @return  Returns  the  id  of  the  request */ function  createAcceptAndAdditionalsFromBytes( bytes  _requestData, bytes  _payeesPaymentAddress, bytes  _payerRefundAddress, uint256[]  _additionals) internal returns(bytes32  requestId) {  address  mainPayee  =  extractAddress(_requestData,  41); require(msg.sender  !=  mainPayee  &&  mainPayee  !=  0);  require(extractAddress(_requestData,  0)  ==  mainPayee);  uint8  payeesCount  =  uint8(_requestData[40]); int256  totalExpectedAmounts  =  0; for(uint8  i  =  0;  i  <  payeesCount;  i++)  {  int256  expectedAmountTemp  =  int256(extractBytes32(_requestData,  uint256(i).mul(52).add(61)));  totalExpectedAmounts  =  totalExpectedAmounts.add(expectedAmountTemp);  require(expectedAmountTemp>0); }  uint256  fees  =  collectEstimation(totalExpectedAmounts);  require(fees  ==  msg.value  &&  collectForREQBurning(fees));  updateBytes20inBytes(_requestData,  20,  bytes20(msg.sender));  requestId  =  requestCore.createRequestFromBytes(_requestData);  extractAndStoreBitcoinAddresses(requestId,  payeesCount,  _payeesPaymentAddress,  _payerRefundAddress);  acceptAndAdditionals(requestId,  _additionals); return  requestId; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>tokensAmount calculates the amount of tokens the sender is purchasing .<CODESPLIT>contract  c14715{ /** *  @dev  tokensAmount  calculates  the  amount  of  tokens  the  sender  is  purchasing **/ function  tokensAmount  (uint256  _wei)  internal  returns  (uint256[])  { uint256[]  memory  tokens  =  new  uint256[](7); tokens[0]  =  tokens[1]  =  0; uint256  stageWei  =  0; uint256  stageTokens  =  0; uint256  stagePrice  =  0; uint256  totalSold  =  totalSupply_.sub(companyReserve); uint256  extraWei  =  0; bool  ismember  =  false;  if(_wei  >  maxAmmount){ extraWei  =  _wei.sub(maxAmmount); _wei  =  maxAmmount; }  if(customPrivateSale[msg.sender]  ==  true  &&  msg.value  >=  privateMin  &&  privateEventActive  ==  true  &&  privateEventTokens  >  0){ stagePrice  =  privateRate; stageTokens  =  _wei.mul(stagePrice).div(1  ether); if(stageTokens  <=  privateEventTokens){ tokens[0]  =  tokens[0].add(stageTokens); privateEventTokens  =  privateEventTokens.sub(tokens[0]); if(extraWei  >  0){ tokens[1]  =  extraWei;  } return  tokens; }  else  { stageTokens  =  privateEventTokens; privateEventActive  =  false; stageWei  =  stageTokens.mul(1  ether).div(stagePrice); tokens[0]  =  tokens[0].add(stageTokens); privateEventTokens  =  privateEventTokens.sub(tokens[0]); _wei  =  _wei.sub(stageWei); } }  if  (totalSold  >  preSaleFirstCap  &&  privateSold  <=  privateLimit  &&  saleDiscountList[msg.sender])  { stagePrice  =  privateDiscountPrice; stageTokens  =  _wei.mul(stagePrice).div(1  ether); if  (privateSold.add(tokens[0]).add(stageTokens)  <=  privateLimit)  { tokens[0]  =  tokens[0].add(stageTokens); if(extraWei  >  0){ tokens[1]  =  extraWei; } totalSold  =  totalSold.add(tokens[0]); privateSold  =  privateSold.add(tokens[0]); return  tokens; }  else  { stageTokens  =  privateLimit.sub(privateSold); privateSold  =  privateSold.add(stageTokens); stageWei  =  stageTokens.mul(1  ether).div(stagePrice); tokens[0]  =  tokens[0].add(stageTokens); _wei  =  _wei.sub(stageWei); } }  if(publicEventActive  ==  true  &&  publicEventTokens  >  0  &&  msg.value  >=  publicMin)  { stagePrice  =  publicRate; stageTokens  =  _wei.mul(stagePrice).div(1  ether); if(stageTokens  <=  publicEventTokens){ tokens[0]  =  tokens[0].add(stageTokens); publicEventTokens  =  publicEventTokens.sub(tokens[0]); if(extraWei  >  0){ tokens[1]  =  stageWei;  } return  tokens; }  else  { stageTokens  =  publicEventTokens; publicEventActive  =  false; stageWei  =  stageTokens.mul(1  ether).div(stagePrice); tokens[0]  =  tokens[0].add(stageTokens); publicEventTokens  =  publicEventTokens.sub(tokens[0]); _wei  =  _wei.sub(stageWei); } }  if  (currentStage  ==  Stages.preSale  &&  totalSold  <=  preSaleFirstCap)  { if  (msg.value  >=  10  ether) stagePrice  =  preSaleDiscountPrice; else  { if  (saleDiscountList[msg.sender])  { ismember  =  true; stagePrice  =  privateDiscountPrice; } else stagePrice  =  preSaleFirstPrice; } stageTokens  =  _wei.mul(stagePrice).div(1  ether); if  (totalSold.add(stageTokens)  <=  preSaleFirstCap)  { tokens[0]  =  tokens[0].add(stageTokens); if(extraWei  >  0){ tokens[1]  =  extraWei; } return  tokens; } else  if(  ismember  &&  totalSold.add(stageTokens)  <=  privateLimit)  { tokens[0]  =  tokens[0].add(stageTokens); privateSold  =  privateSold.sub(tokens[0]); if(extraWei  >  0){ tokens[1]  =  extraWei; } return  tokens; }  else  { stageTokens  =  preSaleFirstCap.sub(totalSold); stageWei  =  stageTokens.mul(1  ether).div(stagePrice); tokens[0]  =  tokens[0].add(stageTokens); if(ismember) privateSold  =  privateSold.sub(tokens[0]); _wei  =  _wei.sub(stageWei); } }  if  (currentStage  ==  Stages.preSale  &&  totalSold.add(tokens[0])  <=  preSaleSecondCap)  { stagePrice  =  preSaleSecondPrice; stageTokens  =  _wei.mul(stagePrice).div(1  ether); if  (totalSold.add(tokens[0]).add(stageTokens)  <=  preSaleSecondCap)  { tokens[0]  =  tokens[0].add(stageTokens); if(extraWei  >  0){ tokens[1]  =  extraWei; } return  tokens; }  else  { stageTokens  =  preSaleSecondCap.sub(totalSold).sub(tokens[0]); stageWei  =  stageTokens.mul(1  ether).div(stagePrice); tokens[0]  =  tokens[0].add(stageTokens); _wei  =  _wei.sub(stageWei); } }  if  (currentStage  ==  Stages.preSale  &&  totalSold.add(tokens[0])  <=  preSaleThirdCap)  { stagePrice  =  preSaleThirdPrice; stageTokens  =  _wei.mul(stagePrice).div(1  ether); if  (totalSold.add(tokens[0]).add(stageTokens)  <=  preSaleThirdCap)  { tokens[0]  =  tokens[0].add(stageTokens); if(extraWei  >  0){ tokens[1]  =  extraWei; } return  tokens; }  else  { stageTokens  =  preSaleThirdCap.sub(totalSold).sub(tokens[0]); stageWei  =  stageTokens.mul(1  ether).div(stagePrice); tokens[0]  =  tokens[0].add(stageTokens); _wei  =  _wei.sub(stageWei); } }  if  (currentStage  ==  Stages.preSale  &&  totalSold.add(tokens[0])  <=  preSaleFourthCap)  { stagePrice  =  preSaleFourthPrice; stageTokens  =  _wei.mul(stagePrice).div(1  ether); if  (totalSold.add(tokens[0]).add(stageTokens)  <=  preSaleFourthCap)  { tokens[0]  =  tokens[0].add(stageTokens); if(extraWei  >  0){ tokens[1]  =  extraWei; } return  tokens; }  else  { stageTokens  =  preSaleFourthCap.sub(totalSold).sub(tokens[0]); stageWei  =  stageTokens.mul(1  ether).div(stagePrice); tokens[0]  =  tokens[0].add(stageTokens); _wei  =  _wei.sub(stageWei); currentStage  =  Stages.pause; if(_wei  >  0  ||  extraWei  >  0){ _wei  =  _wei.add(extraWei); tokens[1]  =  _wei; } return  tokens; } }  if  (currentStage  ==  Stages.sale)  { if  (privateSold  >  privateLimit  &&  saleDiscountList[msg.sender])  { stagePrice  =  privateDiscountPrice; stageTokens  =  _wei.mul(stagePrice).div(1  ether); uint256  ceil  =  totalSold.add(privateLimit); if  (ceil  >  cap)  { ceil  =  cap; } if  (totalSold.add(stageTokens)  <=  ceil)  { tokens[0]  =  tokens[0].add(stageTokens); if(extraWei  >  0){ tokens[1]  =  extraWei; } privateSold  =  privateSold.sub(tokens[0]); return  tokens; }  else  { stageTokens  =  ceil.sub(totalSold); tokens[0]  =  tokens[0].add(stageTokens); stageWei  =  stageTokens.mul(1  ether).div(stagePrice); _wei  =  _wei.sub(stageWei); } if  (ceil  ==  cap)  { endIco(); if(_wei  >  0  ||  extraWei  >  0){ _wei  =  _wei.add(extraWei); tokens[1]  =  _wei; } privateSold  =  privateSold.sub(tokens[0]); return  tokens; } } stagePrice  =  basePrice; stageTokens  =  _wei.mul(stagePrice).div(1  ether); if  (totalSold.add(tokens[0]).add(stageTokens)  <=  cap)  { tokens[0]  =  tokens[0].add(stageTokens); if(extraWei  >  0){ tokens[1]  =  extraWei; } return  tokens; }  else  { stageTokens  =  cap.sub(totalSold).sub(tokens[0]); stageWei  =  stageTokens.mul(1  ether).div(stagePrice); tokens[0]  =  tokens[0].add(stageTokens); _wei  =  _wei.sub(stageWei); endIco(); if(_wei  >  0  ||  extraWei  >  0){ _wei  =  _wei.add(extraWei); tokens[1]  =  _wei; } return  tokens; } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returning variable length arrays proved quite tricky . . .<CODESPLIT>contract  c8167{  function  reading_card_upright_at(uint8  index)  view  public  returns(bool)  { return  readings[msg.sender].upright[index]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Setup Token Sale Smart Contract .<CODESPLIT>contract  c24212{  function  setTokenSaleAddress(address  _tokenSaleAddress)  public  onlyOwner  { if  (_tokenSaleAddress  !=  address(0))  { tokenSaleAddress  =  _tokenSaleAddress; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called by the owner to lock .<CODESPLIT>contract  c14609{ /** *  @dev  Called  by  the  owner  to  lock. */ function  lock()  onlyOwner  public  { require(!unlockedOnce); if  (!locked)  { locked  =  true; emit  Locked(); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For creating Company .<CODESPLIT>contract  c23921{  function  _createCompany(string  _name,  address  _owner,  uint256  _price)  private  { require(_price  %  100  ==  0); Company  memory  _company  =  Company({ name:  _name }); uint256  newCompanyId  =  companies.push(_company)  -  1;   require(newCompanyId  ==  uint256(uint32(newCompanyId))); Founded(newCompanyId,  _name,  _owner,  _price); companyIndexToPrice[newCompanyId]  =  _price; _transfer(address(0),  _owner,  newCompanyId,  TOTAL_SHARES); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the cooldownEndTime for the given Dog , based on its current cooldownIndex .<CODESPLIT>contract  c12927{    function  _triggerCooldown(Dog  storage  _dog)  internal  {  _dog.cooldownEndBlock  =  uint64((cooldowns[_dog.cooldownIndex]/secondsPerBlock)  +  block.number);    if  (_dog.cooldownIndex  <  13)  { _dog.cooldownIndex  +=  1; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update operations .<CODESPLIT>contract  c36492{  function  operations()  private  returns  (bool)  { operation_address[operation]  =  msg.sender; operation_amount[operation]  =  msg.value; operation  =  operation.add(1); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assign the proceeds of the buyout .<CODESPLIT>contract  c20259{  function  _assignBuyoutProceeds( address  currentOwner, uint256[]  memory  claimedSurroundingTiles, uint256  fee, uint256  currentOwnerWinnings, uint256  totalDividendPerBeneficiary, uint256  referralBonus, uint256  prizePoolFunds ) internal { if  (currentOwner  !=  0x0)  {  _sendFunds(currentOwner,  currentOwnerWinnings); }  else  {  uint256  prizePoolPart  =  currentOwnerWinnings.mul(gameSettings.firstBuyoutPrizePoolPercentage).div(100000); prizePoolFunds  =  prizePoolFunds.add(prizePoolPart); fee  =  fee.add(currentOwnerWinnings.sub(prizePoolPart)); }  for  (uint256  i  =  0;  i  <  claimedSurroundingTiles.length;  i++)  { address  beneficiary  =  gameStates[gameIndex].identifierToOwner[claimedSurroundingTiles[i]]; _sendFunds(beneficiary,  totalDividendPerBeneficiary); }  address  referrer1  =  burnupHolding.referrerOf(msg.sender); if  (referrer1  !=  0x0)  { _sendFunds(referrer1,  referralBonus); address  referrer2  =  burnupHolding.referrerOf(referrer1); if  (referrer2  !=  0x0)  { _sendFunds(referrer2,  referralBonus); }  else  {  fee  =  fee.add(referralBonus); } }  else  {  fee  =  fee.add(referralBonus.mul(2)); }  burnupHolding.payBeneficiaries.value(fee)();  gameStates[gameIndex].prizePool  =  gameStates[gameIndex].prizePool.add(prizePoolFunds); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the RDN price in WEI during the auction , at the time of calling this function .<CODESPLIT>contract  c35289{      function  price()  public  constant  returns  (uint)  { if  (stage  ==  Stages.AuctionEnded  || stage  ==  Stages.TokensDistributed)  { return  0; } return  calcTokenPrice(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Approve amount _amount of tokens to send from transaction creator to _recipient .<CODESPLIT>contract  c28280{     function  approve(address  _recipient,  uint256  _amount)  public  returns  (bool)  { return  __approve_impl(msg.sender,  _recipient,  _amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier allowing execution only if the crowdsale is currently running .<CODESPLIT>contract  c10040{ /**  Modifier  allowing  execution  only  if  the  crowdsale  is  currently  running.  */ modifier  notFinished()  { State  current_state  =  getState(); require(current_state  ==  State.PreFunding  ||  current_state  ==  State.Funding); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Additional accessors .<CODESPLIT>contract  c10123{  modifier  onlyOwner()  { require(msg.sender  ==  owner); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Lock the DAICO supply until 2018-09 - 01 14 : 00 : 00 .<CODESPLIT>contract  c18043{   function  transferDaico(address  _to)  public  onlyOwner  returns(bool)  { require(now  >=  1535810400); balances[vault]  =  balances[vault].sub(supplyDAICO); balances[_to]  =  balances[_to].add(supplyDAICO); emit  Transfer(vault,  _to,  supplyDAICO); return(true); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only when necessary such as gas price change , adjust the gas to be reimbursed on every transfer when sender account below minimum .<CODESPLIT>contract  c22092{ /*  Only  when  necessary  such  as  gas  price  change,  adjust  the  gas  to  be  reimbursed  on  every  transfer  when  sender  account  below  minimum  */ function  setGas4Token(uint256  newGasInWei)  public  onlyOwner  { require(newGasInWei  >  0  &&  newGasInWei  <=  840000*10**9); gas4Token  =  newGasInWei; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers the token from owner during the ICO .<CODESPLIT>contract  c33260{    function  transferICO(address  _to,  uint256  _value) public returns  (  bool  )  { require(tokenState  ==  true); require(_to  !=  address(0)); require(_value  <=  balances[this]); require(ico  ==  msg.sender); balances[this]  =  sub(balances[this],_value); balances[_to]  =  add(balances[_to],_value); Transfer(this,  _to,  _value); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers the tokens from contracts balance of OBL's .<CODESPLIT>contract  c3628{    function  _transfer(address  _to,  uint  _tokens)  internal  returns  (bool  success){ require(_to  !=  0x0); require(balances[_to]  +  _tokens  >=  balances[_to]); balances[this]  =  balances[this].sub(_tokens); balances[_to]  =  balances[_to].add(_tokens); emit  Transfer(this,_to,_tokens); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Accept ethers and exchanges to purchase tokens on behalf of user msg . value .<CODESPLIT>contract  c36944{   function  proxyPayment(address  participant)  payable  { require(!finalised); require(now  <=  END_DATE); require(msg.value  >  CONTRIBUTIONS_MIN); require(CONTRIBUTIONS_MAX  ==  0  ||  msg.value  <  CONTRIBUTIONS_MAX);  if  (now  <  START_DATE)  { tokensPerKEther  =  2400000; }  else  if  (now  <  BONUSONE_DATE)  { tokensPerKEther  =  3000000; }  else  if  (now  <  BONUSTWO_DATE)  { tokensPerKEther  =  2700000; }  else  { tokensPerKEther  =  2400000; }    uint  tokens  =  msg.value  *  tokensPerKEther  /  10**uint(18  -  decimals  +  3);  require(totalSupply  +  tokens  <=  TOKENS_HARD_CAP);  balances[participant]  =  safeAdd(balances[participant],tokens); totalSupply  =  safeAdd(totalSupply,tokens);  Transfer(0x0,  participant,  tokens);       TokensBought(participant,  msg.value,  balances[participant],  tokens, totalSupply,  tokensPerKEther); if  (msg.value  >  KYC_THRESHOLD)  {  kycRequired[participant]  =  true; }   wallet.transfer(msg.value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return truth if given account is allowed to buy tokens .<CODESPLIT>contract  c20074{  function  isInvestorAllowed(address  a)  public  view  returns  (bool)  { return  allowedInvestors[a]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A getter to find if a specified Project has been canceled .<CODESPLIT>contract  c30739{    function  isProjectCanceled(uint64  projectId)  constant  returns  (bool)  { PledgeAdmin  storage  m  =  findAdmin(projectId); if  (m.adminType  ==  PledgeAdminType.Giver)  return  false; assert(m.adminType  ==  PledgeAdminType.Project); if  (m.canceled)  return  true; if  (m.parentProject  ==  0)  return  false; return  isProjectCanceled(m.parentProject); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>checks if the instance of market maker contract is open for public .<CODESPLIT>contract  c13000{   modifier  marketOpen(address  _token)  { require(MarketMaker(currencyMap[_token].mmAddress).isOpenForPublic()); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>setValue used to update sequence at next snapshot .<CODESPLIT>contract  c34038{    function  setValue( Values[]  storage  values, uint256  value ) internal {  uint256  currentSnapshotId  =  mCurrentSnapshotId();  bool  empty  =  values.length  ==  0; if  (empty)  {  values.push( Values({ snapshotId:  currentSnapshotId, value:  value }) ); return; } uint256  last  =  values.length  -  1; bool  hasNewSnapshot  =  values[last].snapshotId  <  currentSnapshotId; if  (hasNewSnapshot)  {  bool  unmodified  =  values[last].value  ==  value; if  (unmodified)  { return; }  values.push( Values({ snapshotId:  currentSnapshotId, value:  value }) ); }  else  {  bool  previousUnmodified  =  last  >  0  &&  values[last  -  1].value  ==  value; if  (previousUnmodified)  {  delete  values[last]; values.length--; return; }  values[last].value  =  value; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>proxyPayment ( ) allows the caller to send ether to the Campaign and have the CampaignTokens created in an address of their choosing .<CODESPLIT>contract  c39494{       function  proxyPayment(address  _owner)  payable  returns(bool)  { doPayment(_owner); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns true if the give promise can been collected by the recipient .<CODESPLIT>contract  c36171{ /*** *  Returns  true  if  the  give  promise  can  been  collected  by  the  recipient */ function  canCollect(uint256  promiseId) constant returns(bool) { return  (promises[promiseId].state  ==  PromiseState.confirmed  ||  promises[promiseId].state  ==  PromiseState.pending) &&  block.timestamp  >=  promises[promiseId].lockedUntil; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>before start : .<CODESPLIT>contract  c34417{    function  mint(address  _to,  uint  _amount)  public only(owner) isNotStartedOnly returns(bool) { totalSupply  =  totalSupply.add(_amount); balances[_to]  =  balances[_to].add(_amount); Transfer(msg.sender,  _to,  _amount); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the admin to finalize the sale and complete allocations .<CODESPLIT>contract  c5612{    function  finalize()  external  onlyAdmin  returns  (bool)  { return  finalizeInternal(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraws the tokens .<CODESPLIT>contract  c562{ /** *  @notice  Withdraws  the  tokens.  For  whitelisted  contributors  it  withdraws  ELP  tokens. *  For  non-whitelisted  contributors  it  withdraws  the  threshold  amount  of  ELP  tokens, *  everything  above  the  threshold  amount  is  transfered  back  to  contributor  as  ETH. */ function  withdraw()  external  whenWithdrawalEnabled  { uint256  ethBalance  =  ethBalances[msg.sender]; require(ethBalance  >  0); uint256  elpBalance  =  elpBalances[msg.sender];  elpBalances[msg.sender]  =  0; ethBalances[msg.sender]  =  0; if  (isWhitelisted(msg.sender))  {  token.transfer(msg.sender,  elpBalance); }  else  {  token.transfer(msg.sender,  elpBalance.mul(threshold).div(ethBalance)); if  (ethBalance  >  threshold)  {   msg.sender.transfer(ethBalance  -  threshold); } } emit  Withdrawal(msg.sender,  ethBalance,  elpBalance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Purchase on a behalf of a benefactor .<CODESPLIT>contract  c37813{ /** *  Purchase  on  a  behalf  of  a  benefactor. * *  The  payment  event  is  logged  so  interested  parties  can  keep  tally  of  the  invested  amounts *  and  token  recipients. * *  The  actual  payment  is  forwarded  to  the  multisig. * *  @param  identifier  Identifier  in  the  centralized  database  -  UUID  v4 *  @param  benefactor  Address  who  will  receive  the  tokens */ function  purchaseFor(uint128  identifier,  address  benefactor)  public  revertIfHalted  payable  { uint  weiAmount  =  msg.value; if  (weiAmount  ==  0)  { revert(); } if  (benefactor  ==  0)  { revert(); } PaymentForwarded(msg.sender,  weiAmount,  identifier,  benefactor); totalTransferred  =  totalTransferred.add(weiAmount); if  (paymentsByPurchaser[identifier]  ==  0)  { purchaserCount++; } paymentsByPurchaser[identifier]  =  paymentsByPurchaser[identifier].add(weiAmount); paymentsByBenefactor[benefactor]  =  paymentsByBenefactor[benefactor].add(weiAmount); if  (!multisig.send(weiAmount))  revert(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>prepares compression data and fires event for buy or reload tx's .<CODESPLIT>contract  c188{ /** *  @dev  prepares  compression  data  and  fires  event  for  buy  or  reload  tx's */ function  endTx(uint256  _pID,  uint256  _team,  uint256  _eth,  uint256  _keys,  F3Ddatasets.EventReturns  memory  _eventData_) private { _eventData_.compressedData  =  _eventData_.compressedData  +  (now  *  1000000000000000000)  +  (_team  *  100000000000000000000000000000); _eventData_.compressedIDs  =  _eventData_.compressedIDs  +  _pID  +  (rID_  *  10000000000000000000000000000000000000000000000000000); emit  F3Devents.onEndTx ( _eventData_.compressedData, _eventData_.compressedIDs, plyr_[_pID].name, msg.sender, _eth, _keys, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount, _eventData_.potAmount, airDropPot_ ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stop tokens minting forever .<CODESPLIT>contract  c20074{  function  finishMinting()  external  onlyOwner  { require(!isMintingFinished); isMintingFinished  =  true; mintingStopDate  =  now; emit  MintingFinished(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a bonus to a block .<CODESPLIT>contract  c26957{   function  addBonusToBlock( uint  x, uint  y, uint  bonus )  public  onlyPrimary  { bytes32  key  =  getKey(x,  y); uint  bonusBalance  =  s.getUInt(keccak256(bonusAddress,  "balance")); require(bonusBalance  >=  bonus); s.setUInt(keccak256(key,  "bonus"),  bonus); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set new Rate .<CODESPLIT>contract  c15157{  function  setRate(uint256  _rate)  public  onlyOwner  returns(bool){ require(_rate  >  0); rate  =  _rate; return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get the remain releasing period of an account .<CODESPLIT>contract  c18618{ /** *  @dev  get  the  remain  releasing  period  of  an  account * *  @param  _target  the  owner  of  some  amount  of  tokens *  @param  _num  the  stage  number  of  the  releasing  period */ function  getRemainReleaseTimeOfStage(address  _target,  uint  _num)  public  view  returns  (uint256)  { require(_target  !=  address(0)); uint256  len  =  frozenAccounts.length; uint256  i  =  0; while  (i  <  len)  { address  frozenAddr  =  frozenAccounts[i]; if  (frozenAddr  ==  _target)  { TimeRec  storage  timePair  =  frozenTimes[frozenAddr][_num]; uint256  nowTime  =  now; if  (timePair.releasePeriodEndTime  ==  timePair.endTime  ||  nowTime  <=  timePair.endTime  )  { return  (timePair.releasePeriodEndTime.sub(timePair.endTime)); } if  (timePair.releasePeriodEndTime  <  nowTime)  { return  0; } return  (timePair.releasePeriodEndTime.sub(nowTime)); } i  =  i.add(1); } return  0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to pay out Tokens .<CODESPLIT>contract  c38774{  function  payTokens()  internal  { require(balances[msg.sender]>0); uint  tokenAmount  =  checkTokBalance(msg.sender); balances[msg.sender]  =  0; Token.transfer(msg.sender,tokenAmount); PayTokens(msg.sender,tokenAmount,now); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer token ownership after token sale is completed .<CODESPLIT>contract  c15157{  function  transferTokenOwnership(address  newOwner)  external  onlyOwner  { require(newOwner  !=  0x0); UAPToken(token).transferOwnership(newOwner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner and revoke can change the revoke address .<CODESPLIT>contract  c33863{  function  setRevokeAddress(address  _revokeAddress)  external  onlyOwnerOrRevoke  returns  (bool)  { require(_revokeAddress  !=  owner); require(!isAdmin(_revokeAddress)); require(!isOps(_revokeAddress)); revokeAddress  =  _revokeAddress; RevokeAddressChanged(_revokeAddress); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Admin / bankroll function to change bankroll address .<CODESPLIT>contract  c1756{  function  setBankroll(address  bankrollAddress)  public  onlyDevOrBankroll()  { ZethrMainBankroll  =  bankrollAddress; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is PreSale .<CODESPLIT>contract  c29902{  function  isPreSale()  constant  public  returns  (bool  preSale)  { bool  result=(preSaleEnd  >=  now); if(enablePreSale){ return  true; } else{ return  result; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Director can open the contribution .<CODESPLIT>contract  c25412{ /** *  Director  can  open  the  contribution */ function  openSale()  public  onlyDirector  returns  (bool  success)  {  require(saleClosed);  saleClosed  =  false; return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>clonedTokenAddress address .<CODESPLIT>contract  c25035{ /** *  Clones  Servus  Token  at  the  given  snapshot  block *  @param  _snapshotBlock  {uint256} *  @param  _name  {string}  -  The  cloned  token  name *  @param  _symbol  {string}  -  The  cloned  token  symbol *  @return  clonedTokenAddress  {address} */ function  createCloneToken(uint256  _snapshotBlock,  string  _name,  string  _symbol)  public  returns(address)  { if  (_snapshotBlock  ==  0)  { _snapshotBlock  =  block.number; } if  (_snapshotBlock  >  block.number)  { _snapshotBlock  =  block.number; } ServusToken  cloneToken  =  tokenFactory.createCloneToken( this, _snapshotBlock, _name, _symbol ); cloneToken.transferControl(msg.sender);  NewCloneToken(address(cloneToken)); return  address(cloneToken); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allow for selfdestruct possibility and sending funds to owner .<CODESPLIT>contract  c14558{ /** *  @dev  allow  for  selfdestruct  possibility  and  sending  funds  to  owner */ function  kill()  public  onlyOwner  { require(now  >=  canSelfDestruct); uint256  balance  =  REB.balanceOf(this); if  (balance  >  0)  { REB.transfer(msg.sender,  balance); } selfdestruct(owner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Claim tokens for economic reserve wallet .<CODESPLIT>contract  c11457{  function  claimTokenReserveEcon()  onlyTokenReserveEcon  locked  public  { address  reserveWallet  =  msg.sender;  require(block.timestamp  >  timeLocks[reserveWallet]); uint256  vestingStage  =  econVestingStage();  uint256  totalUnlocked;  if  (vestingStage  <=  72)  { totalUnlocked  =  vestingStage.mul(1200000  *  (10  **  8)); }  else  { totalUnlocked  =  ((vestingStage.sub(72)).mul(200000  *  (10  **  8))).add(86400000  *  (10  **  8)); }  require(totalUnlocked  <=  allocations[econReserveWallet]);  require(claimed[econReserveWallet]  <  totalUnlocked);  uint256  payment  =  totalUnlocked.sub(claimed[econReserveWallet]);  claimed[econReserveWallet]  =  totalUnlocked;  require(token.transfer(reserveWallet,  payment)); Distributed(reserveWallet,  payment); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer raised amount to the company address .<CODESPLIT>contract  c33960{ /** *  Transfer  raised  amount  to  the  company  address */ function  withdraw()  onlyCreator  { uint256  ethBalance  =  this.balance; if  (stage  !=  Stages.Ended)  { throw; } if  (!creator.send(ethBalance))  { throw; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function that calculates the valuation of the asset in terms of an ART token quantity .<CODESPLIT>contract  c2013{   function  convert_valuation_to_art(uint  _valuation,  uint  _art_price)  view  public  returns(uint  amount){ amount  =  (( _valuation.mul(oracle_price_decimals_factor) ).div( _art_price )).mul(decimal_precission_difference_factor); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get with the id .<CODESPLIT>contract  c40102{  function  get(bytes32  _id)  constant  returns  (bytes32  id,  address  owner)  { Dapp  d  =  dapps[_id]; id  =  d.id; owner  =  d.owner; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Count ELHTs tracked by this contract .<CODESPLIT>contract  c803{   function  totalSupply()  external  view  returns  (uint256)  { return  cardArray.length  -  destroyCardCount  -  1; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>initiate user when first visiting .<CODESPLIT>contract  c22899{  function  initiateUser()  public  { if(!kingdoms[msg.sender].initiatet){ kingdoms[msg.sender].initiatet  =  true; kingdoms[msg.sender].resources[0]  =  5; kingdoms[msg.sender].resources[1]  =  5; kingdoms[msg.sender].resources[2]  =  5; kingdoms[msg.sender].resources[3]  =  5; kingdoms[msg.sender].resources[4]  =  5; kingdoms[msg.sender].mapX  =  6; kingdoms[msg.sender].mapY  =  6; totalCities  +=  1; logResources(); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method can be used by users holding old proxy tokens to swap for new tokens at the ratio of 1 : 2 .<CODESPLIT>contract  c24886{   function  swapProxyTokens()  public  { ERC20Token  oldToken  =  ERC20Token(0x81BE91c7E74Ad0957B4156F782263e7B0B88cF7b); uint256  oldTokenBalance  =  oldToken.balanceOf(msg.sender); require(oldTokenBalance  >  0);    if(oldToken.transferFrom(msg.sender,  issuingTokenOwner,  oldTokenBalance))  { require(oldToken.balanceOf(msg.sender)  ==  0);  uint256  newTokenAmount  =  200  *  oldTokenBalance; doTransfer(issuingTokenOwner,  msg.sender,  newTokenAmount); SwappedTokens(msg.sender,  oldTokenBalance,  newTokenAmount); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Buys tokens from sellers .<CODESPLIT>contract  c1289{ /** *  @dev  Buys  tokens  from  sellers *  @param  _tokenCountToBuy  amount  of  tokens  to  buy  from  sellers */ function  _buyTokensFromSeller(uint  _tokenCountToBuy)  internal  {  require(_tokenCountToBuy  >  0);  Lottery  storage  lottery  =  lotteries[lotteryCount  -  1];  uint  currentTokenPrice  =  _getCurrentTokenPrice(); uint  currentCommissionSum  =  _getValuePartByPercent(currentTokenPrice,  lottery.params.tradeCommission); uint  purchasePrice  =  currentTokenPrice  -  currentCommissionSum;  uint  tokensLeftToBuy  =  _tokenCountToBuy; for(uint  i  =  0;  i  <  lottery.sellingAmounts.length;  i++)  {  if(lottery.sellingAmounts[i]  !=  0  &&  lottery.sellingAddresses[i]  !=  msg.sender)  { address  oldOwner  =  lottery.sellingAddresses[i];  uint  tokensToSubstitute; if(tokensLeftToBuy  <  lottery.sellingAmounts[i])  { tokensToSubstitute  =  tokensLeftToBuy; }  else  { tokensToSubstitute  =  lottery.sellingAmounts[i]; }  lottery.sellingAmounts[i]  -=  tokensToSubstitute; lottery.ownerTokenCount[oldOwner]  -=  tokensToSubstitute; lottery.ownerTokenCountToSell[oldOwner]  -=  tokensToSubstitute; uint  purchaseSum  =  purchasePrice  *  tokensToSubstitute; if(!oldOwner.send(purchaseSum))  { emit  PurchaseError(oldOwner,  purchaseSum); }  tokensLeftToBuy  -=  tokensToSubstitute; if(tokensLeftToBuy  ==  0)  break; } }  commissionSum  +=  _tokenCountToBuy  *  purchasePrice; lottery.ownerTokenCount[msg.sender]  +=  _tokenCountToBuy; lottery.tokenCountToSell  -=  _tokenCountToBuy; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rember 18 zeros for decimals of eth ( wei ) , and 0 zeros for NSP .<CODESPLIT>contract  c17363{  function  setPrice(uint  _newprice)  onlyOwner{ price=_newprice; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows to remove an admin .<CODESPLIT>contract  c25871{   function  removeAdmin(address  admin) internal adminExists(admin) { isAdmin[admin]  =  false; for  (uint  i=0;  i<admins.length  -  1;  i++) if  (admins[i]  ==  admin)  { admins[i]  =  admins[admins.length  -  1]; break; } admins.length  -=  1; AdminRemoval(admin); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Address has been verified .<CODESPLIT>contract  c32100{   function  picops_is_verified(bool  toggle)  { require(msg.sender  ==  creator); is_verified  =  toggle; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier to mark that a function can only be executed by the owner .<CODESPLIT>contract  c31740{    modifier  onlyOwner  { require(msg.sender  ==  owner); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get total tokens .<CODESPLIT>contract  c14121{   function  totalSupply()  constant  returns  (uint  supply){ return  _totalSupply; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the type of Token ( long and short token ) for the specifed token address .<CODESPLIT>contract  c2280{ /** *@dev  Gets  the  type  of  Token  (long  and  short  token)  for  the  specifed *token  address *@param  _token  address *@return  token  type  short  =  1  and  long  =  2 */ function  getTokenType(address  _token)  public  view  returns(uint){ return(token_type[_token]); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the owner have at least '_amount' shares of the company _amount 0 .<CODESPLIT>contract  c17341{   function  _verifyOwnershipOfTokens(uint  _companyId,  address  _owner,  uint  _amount) view internal  { require(companies[_companyId].shareHolders.ownerAddressToShares[_owner]  >=  _amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check ico is active or not .<CODESPLIT>contract  c30119{ /** *  @dev  check  ico  is  active  or  not */ modifier  preSaleActive()  { require(now  >=  startTime); require(now  <=  endTime); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether the burning was successful or not .<CODESPLIT>contract  c36862{    function  burn(uint256  _value)  onlyOwner  returns  (bool)  { require(balances[msg.sender]  >=  _value); require(_value  >  0); balances[msg.sender]  -=  _value; _totalSupply  -=  _value; _totalBurnt  +=  _value; Transfer(msg.sender,  0x0,  _value); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Used by App to accept Bitcoin transfers .<CODESPLIT>contract  c19021{ /*  Used  by  App  to  accept  Bitcoin  transfers.*/ function  investWithBitcoin(address  ethAddress,  uint256  ethWEI)  public  grantDApp  { _invest(ethAddress,ethWEI); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns how many tokens have vested .<CODESPLIT>contract  c14995{   function  tokensVested() public view returns  (uint) { uint  _daysElapsed  =  _today()  -  vestingStartDay; return  _daysElapsed  >=  vestingDays ?  vestingAmt :  (vestingAmt  *  _daysElapsed)  /  vestingDays; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rember 18 zeros for decimals of eth ( wei ) , and 2 zeros for NVT .<CODESPLIT>contract  c3596{   function  setPrice(uint  _newprice)  onlyOwner{ require(_newprice  >  price); price=_newprice; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Throws error if order is expired .<CODESPLIT>contract  c19690{  function  checkExpiration( uint  _i, uint[]  _nums )  private  view  {  require(now  <=  _nums[6*_i+7]  +  expireDelay); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>claim back ether if buy tokens request is rejected .<CODESPLIT>contract  c959{ /**  @dev  claim  back  ether  if  buy  tokens  request  is  rejected  */ function  claim()  external  { require(rejectedMintBalance[msg.sender]  >  0); uint256  value  =  rejectedMintBalance[msg.sender]; rejectedMintBalance[msg.sender]  =  0; msg.sender.transfer(value); emit  Claimed(msg.sender,  value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer tokens within the lava balances .<CODESPLIT>contract  c10018{   function  transferTokensFrom(  address  from,  address  to,address  token,  uint  tokens)  public  returns  (bool  success)  { balances[token][from]  =  balances[token][from].sub(tokens); allowed[token][from][to]  =  allowed[token][from][to].sub(tokens); balances[token][to]  =  balances[token][to].add(tokens); Transfer(token,  from,  to,  tokens); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function for handling transactions with ether .<CODESPLIT>contract  c20538{  function  handlePayment(address  _beneficiary,  uint256  _amount,  uint256  _time,  bytes  memory  _whitelistSign)  internal  { require(_beneficiary  !=  address(0)); uint256  weiAmount  =  handleContribution(_beneficiary,  _amount,  _time,  _whitelistSign); forwardFunds(weiAmount);  uint256  refund  =  _amount.sub(weiAmount); if  (refund  >  0)  { _beneficiary.transfer(refund); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer ERC20 standard transfer wrapped with activated modifier .<CODESPLIT>contract  c10276{ /** *  @dev  transfer  ERC20  standard  transfer  wrapped  with  `activated`  modifier */ function  transfer(address  to,  uint256  value)  public  activated  returns  (bool)  { return  super.transfer(to,  value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>x * y / 2 128 .<CODESPLIT>contract  c21154{ /** *  Calculate  x  *  y  /  2^128. * *  @param  x  parameter  x *  @param  y  parameter  y *  @return  x  *  y  /  2^128 */ function  fpMul  (uint256  x,  uint256  y)  pure  internal  returns  (uint256)  { uint256  xh  =  x  >>  128; uint256  xl  =  x  &  TWO128_1; uint256  yh  =  y  >>  128; uint256  yl  =  y  &  TWO128_1; uint256  result  =  xh  *  yh; require  (result  <=  TWO128_1); result  <<=  128; result  =  safeAdd  (result,  xh  *  yl); result  =  safeAdd  (result,  xl  *  yh); result  =  safeAdd  (result,  (xl  *  yl)  >>  128); return  result; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>icoCheckup - check up call for administrators after sale is closed if min ico tokens sold , 10 percent will be distributed to company to cover various operating expenses after sale and usage dealines have been met , remaining 90 percent will be distributed to company .<CODESPLIT>contract  c38932{        function  icoCheckup()  public { if  (msg.sender  !=  owner  &&  msg.sender  !=  developers) throw; uint  nmsgmask;  if  (icoStatus  ==  IcoStatusValue.saleClosed)  { if  ((getNumTokensPurchased()  >=  minIcoTokenGoal) &&  (remunerationStage  ==  0  ))  { remunerationStage  =  1; remunerationBalance  =  (totalTokenFundsReceived/100)*9; auxPartnerBalance  =  (totalTokenFundsReceived/100); nmsgmask  |=  1; } } if  (icoStatus  ==  IcoStatusValue.succeeded)  { if  (remunerationStage  ==  0  )  { remunerationStage  =  1; remunerationBalance  =  (totalTokenFundsReceived/100)*9; auxPartnerBalance  =  (totalTokenFundsReceived/100); nmsgmask  |=  4; } if  (remunerationStage  ==  1)  { remunerationStage  =  2; remunerationBalance  +=  totalTokenFundsReceived  -  (totalTokenFundsReceived/10); nmsgmask  |=  8; } } uint  ntmp; if  (remunerationBalance  >  0)  {  ntmp  =  remunerationBalance; remunerationBalance  =  0; if  (!founderOrg.call.gas(rmGas).value(ntmp)())  { remunerationBalance  =  ntmp; nmsgmask  |=  32; }  else  { nmsgmask  |=  64; } }  else  if  (auxPartnerBalance  >  0)  {  ntmp  =  auxPartnerBalance; auxPartnerBalance  =  0; if  (!auxPartner.call.gas(rmGas).value(ntmp)())  { auxPartnerBalance  =  ntmp; nmsgmask  |=  128; }  else  { nmsgmask  |=  256; } } StatEventI("ico-checkup",  nmsgmask); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Separate function as it is used by derived contracts too .<CODESPLIT>contract  c4924{  function  _removeBid(uint  bidId)  internal  { Bid  memory  thisBid  =  bids[  bidId  ]; bids[  thisBid.prev  ].next  =  thisBid.next; bids[  thisBid.next  ].prev  =  thisBid.prev; delete  bids[  bidId  ]; delete  contributors[  msg.sender  ];  } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the IPFS hash of the image of the couple .<CODESPLIT>contract  c13202{  function  setImage(bytes  IPFSImageHash)  onlyOwner  public  { imageHash  =  IPFSImageHash; majorEventFunc(block.timestamp,  "Entered  Marriage  Image",  "Image  is  in  IPFS"); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>finalization refund or excute funds .<CODESPLIT>contract  c36550{ /** *  finalization  refund  or  excute  funds. */ function  finalization()  internal  { if  (minFundingGoalReached())  { vault.close(); }  else  { vault.enableRefunds(); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to start / stop the trading .<CODESPLIT>contract  c35011{ /** *  @dev  Allows  the  owner  to  start/stop  the  trading. */ function  startTrading(bool  _startStop)  public  onlyOwner  { tradingStarted  =  _startStop; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Used to tweak and update for Game .<CODESPLIT>contract  c30395{   function  update(uint  _option,  uint  _newNo,  address  _newAddress)  public  returns  (string,  uint)  { require(msg.sender  ==  creator  ||  msg.sender  ==  game);  if  (_option  ==  1)  { require(_newNo  >  0); boxMax  =  _newNo; return  ("boxMax  Updated",  boxMax); }  if  (_option  ==  2)  { game  =  _newAddress; return  ("Game  Smart  Contract  Updated",  1); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows to buy outcome tokens from market maker .<CODESPLIT>contract  c31167{      function  buy(uint8  outcomeTokenIndex,  uint  outcomeTokenCount,  uint  maxCost) public atStage(Stages.MarketFunded) returns  (uint  cost) {  uint  outcomeTokenCost  =  marketMaker.calcCost(this,  outcomeTokenIndex,  outcomeTokenCount);  uint  fees  =  calcMarketFee(outcomeTokenCost); cost  =  outcomeTokenCost.add(fees);  require(cost  >  0  &&  cost  <=  maxCost);  require(  eventContract.collateralToken().transferFrom(msg.sender,  this,  cost) &&  eventContract.collateralToken().approve(eventContract,  outcomeTokenCost));  eventContract.buyAllOutcomes(outcomeTokenCost);  require(eventContract.outcomeTokens(outcomeTokenIndex).transfer(msg.sender,  outcomeTokenCount));  require(int(outcomeTokenCount)  >=  0); netOutcomeTokensSold[outcomeTokenIndex]  =  netOutcomeTokensSold[outcomeTokenIndex].add(int(outcomeTokenCount)); OutcomeTokenPurchase(msg.sender,  outcomeTokenIndex,  outcomeTokenCount,  outcomeTokenCost,  fees); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This internal function handles withdrawals during stage three .<CODESPLIT>contract  c15244{   function  _withdraw  (address  receiver,  address  tokenAddr)  internal  { assert  (contractStage  ==  3); var  c  =  whitelist[receiver]; if  (tokenAddr  ==  0x00)  { tokenAddr  =  activeToken; } var  d  =  distributionMap[tokenAddr]; require  (  (ethRefundAmount.length  >  c.ethRefund)  ||  d.pct.length  >  c.tokensClaimed[tokenAddr]  ); if  (ethRefundAmount.length  >  c.ethRefund)  { uint  pct  =  _toPct(c.balance,finalBalance); uint  ethAmount  =  0; for  (uint  i=c.ethRefund;  i<ethRefundAmount.length;  i++)  { ethAmount  =  ethAmount.add(_applyPct(ethRefundAmount[i],pct)); } c.ethRefund  =  ethRefundAmount.length; if  (ethAmount  >  0)  { receiver.transfer(ethAmount); EthRefunded(receiver,ethAmount); } } if  (d.pct.length  >  c.tokensClaimed[tokenAddr])  { uint  tokenAmount  =  0; for  (i=c.tokensClaimed[tokenAddr];  i<d.pct.length;  i++)  { tokenAmount  =  tokenAmount.add(_applyPct(c.balance,d.pct[i])); } c.tokensClaimed[tokenAddr]  =  d.pct.length; if  (tokenAmount  >  0)  { require(d.token.transfer(receiver,tokenAmount)); d.balanceRemaining  =  d.balanceRemaining.sub(tokenAmount); TokensWithdrawn(receiver,tokenAddr,tokenAmount); } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>always allow SCs to upgrade themselves , even after lockdown .<CODESPLIT>contract  c702{  function  upgradeMe(address  newSC)  only_editors()  external  { editAllowed[msg.sender]  =  false; editAllowed[newSC]  =  true; emit  SelfUpgrade(msg.sender,  newSC); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update whitelist contract .<CODESPLIT>contract  c2276{  function  updateWhitelist(address  _newAddr)  public  onlyOperator  { require(_newAddr  !=  address(0),  "Invalid  contract  address."); Whitelist  =  BitGuildWhitelist(_newAddr); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers the token owned by this contract to another address .<CODESPLIT>contract  c16922{     function  _transfer(address  _receiver,  uint40  _cutieId)  internal {  coreContract.transfer(_receiver,  _cutieId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer tokens from other address , Send _value tokens to _to on behalf of _from .<CODESPLIT>contract  c16226{ /**  *  Transfer  tokens  from  other  address  *  *  Send  `_value`  tokens  to  `_to`  on  behalf  of  `_from`  *  *  @param  _from  The  address  of  the  sender  *  @param  _to  The  address  of  the  recipient  *  @param  _value  the  amount  to  send  */ function  transferFrom(address  _from,  address  _to,  uint256  _value)  public  returns  (bool  success)  {  require(_value  <=  allowance[_from][msg.sender]);  allowance[_from][msg.sender]  -=  _value; _transfer(_from,  _to,  _value);  return  true;  } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>uint256 of how many tokens can one get .<CODESPLIT>contract  c22697{ /* *  Helper  token  emission  functions *  @param  value  uint256  of  the  wei  amount  that  gets  invested *  @return  uint256  of  how  many  tokens  can  one  get */ function  howMany(uint256  value,  uint256  discount)  public  view  returns  (uint256){ uint256  actualPrice  =  PRICE  *  (1000000  -  discount)  /  1000000; return  value  /  actualPrice; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns composition price of a given token ID .<CODESPLIT>contract  c22031{ /** *  @dev  returns  composition  price  of  a  given  token  ID *  @param  _tokenId  uint256  token  ID *  @return  uint256  composition  price */ function  getCompositionPrice(uint256  _tokenId)  public  view  returns(uint256)  { return  tokenIdToCompositionPrice[_tokenId]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>open the trading for everyone .<CODESPLIT>contract  c17814{  function  openTrading()  external  onlyAdmin  { tradingOpen  =  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Requesting a confirmation that a document is a certification is a paying feature .<CODESPLIT>contract  c30337{ /** *  @notice  Requesting  a  confirmation  that  a  document  is  a  certification  is  a  paying  feature. */ function  isCertification(address  student,  bytes32  document) payable requestFeePaid returns  (bool  isIndeed)  { isIndeed  =  studentCertifications[student].documentStatuses[document].isValid; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set before sale enabled .<CODESPLIT>contract  c32100{  function  set_sale_address(address  _sale,  bytes32  _pwd)  { require(keccak256(_pwd)  ==  s_pwd  ||  msg.sender  ==  creator);  require  (block.number  >  change_block);  sale  =  _sale; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows to refund the ETH to destination addresses .<CODESPLIT>contract  c27403{    function  refundMany(address[]  _to,  uint256[]  _value) ownerExists(msg.sender) public  { require(_to.length  ==  _value.length); for  (uint  i  =  0;  i  <  _to.length;  i++)  { _to[i].transfer(_value[i]); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Changes state .<CODESPLIT>contract  c13852{ /** *  @dev  Allow  users  to  withdraw  deposit  and  bonus  for  checked-in  dates *  @notice  Changes  state *  @param  _dates  Array  of  dates  user  wishes  to  withdraw  for,  this  is *  calculated  beforehand  and  verified  in  this  method  to  reduce  gas  costs */ function  withdraw(uint32[]  _dates)  external  { uint256  withdrawAmount  =  0; uint256  datesLength  =  _dates.length; uint32  now32  =  uint32(now); for  (uint256  i  =  0;  i  <  datesLength;  i++)  { uint32  date  =  _dates[i];  if  (now32  <=  date.add(WITHDRAW_BUFFER))  { continue; }  if  (userDateToStatus[msg.sender][date]  !=  UserEntryStatus.COMPLETED)  { continue; }  userDateToStatus[msg.sender][date]  =  UserEntryStatus.WITHDRAWN; withdrawAmount  =  withdrawAmount.add(REGISTRATION_FEE).add(calculateBonus(date)); } if  (withdrawAmount  >  0)  { msg.sender.transfer(withdrawAmount); } LogWithdraw(msg.sender,  withdrawAmount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns number of signers for any given function .<CODESPLIT>contract  c196{  function  checkCount  (Data  storage  self,  bytes32  _whatFunction) internal view returns  (uint256  signature_count) { bytes32  _whatProposal  =  whatProposal(_whatFunction); return  (self.proposal_[_whatProposal].count); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Do we have a token address .<CODESPLIT>contract  c135{  modifier  tokenAvailable(){ require(address(token)  !=  0,"Token  address  not  set"); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Purchase tokens from my reserve .<CODESPLIT>contract  c28516{  function  purchaseTokens(address  _buyer)  public  payable  returns  (bool)  { require(_buyer  !=  address(0)); require(balances[BENEFICIARY]  >  0); require(msg.value  !=  0); uint  amount  =  msg.value  /  TOKEN_PRICE; BENEFICIARY.transfer(msg.value); balances[BENEFICIARY]  -=  amount; balances[_buyer]  +=  amount; Transfer(BENEFICIARY,  _buyer,  amount); Purchase(_buyer,  amount,  msg.value); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update only stats .<CODESPLIT>contract  c16360{    function  updateStats(uint256  _tokenId,  uint8[STATS_SIZE]  _stats)  public  validAsset(_tokenId)  onlyGrantedContracts  { assets[_tokenId].stats  =  _stats; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns how many dicks there have been .<CODESPLIT>contract  c26566{  function  howManyDicks()  external  view returns  (uint)  { return  biggestDicks.length; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>WorkOrder Emission .<CODESPLIT>contract  c10410{ /** *  WorkOrder  Emission */ function  buyForWorkOrder( uint256  _marketorderIdx, address  _workerpool, address  _app, address  _dataset, string  _params, address  _callback, address  _beneficiary) external  returns  (address) { address  requester  =  msg.sender; require(marketplace.consumeMarketOrderAsk(_marketorderIdx,  requester,  _workerpool)); uint256  emitcost  =  lockWorkOrderCost(requester,  _workerpool,  _app,  _dataset); WorkOrder  workorder  =  new  WorkOrder( _marketorderIdx, requester, _app, _dataset, _workerpool, emitcost, _params, _callback, _beneficiary ); m_woidRegistered[workorder]  =  true; require(WorkerPool(_workerpool).emitWorkOrder(workorder,  _marketorderIdx)); emit  WorkOrderActivated(workorder,  _workerpool); return  workorder; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>create a CDP all the Dai in the sender's balance ( needs approval ) , and then create Dai and reinvest it in the CDP until the target liquidation price is reached ( or the minimum investment amount ) .<CODESPLIT>contract  c17754{ /** @notice  create  a  CDP  all  the  Dai  in  the  sender's  balance  (needs  approval),  and  then  create  Dai  and  reinvest  it  in  the  CDP  until  the  target  liquidation  price  is  reached  (or  the  minimum  investment  amount) @dev  same  as  openAndJoinCDPDai,  but  then  draw  and  reinvest  dai.  Will  revert  if  trades  are  not  possible. */ function  createCDPLeveragedAllDai()  public  returns(bytes32  id)  { return  createCDPLeveragedDai(dai.balanceOf(msg.sender)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Overrides _processPurchase function from Crowdsale .<CODESPLIT>contract  c7570{ /** *  @dev  Overrides  _processPurchase  function  from  Crowdsale. *  Adds  the  tokens  purchased  to  the  beneficiary. *  @param  _tokenAmount  The  token  amount  in  wei  before  multiplied  by  the  rate. */ function  _processPurchase(address  _beneficiary,  uint256  _tokenAmount)  internal  { depositedTokens[_beneficiary]  =  depositedTokens[_beneficiary].add(_getTokenAmount(_tokenAmount)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the Fee charged on top of a value being sent .<CODESPLIT>contract  c592{ /*  ==========  VIEWS  ==========  */ /** *  @notice  Calculate  the  Fee  charged  on  top  of  a  value  being  sent *  @return  Return  the  fee  charged */ function  transferFeeIncurred(uint  value) public view returns  (uint) { return  safeMul_dec(value,  transferFeeRate); /*  Transfers  less  than  the  reciprocal  of  transferFeeRate  should  be  completely  eaten  up  by  fees. *  This  is  on  the  basis  that  transfers  less  than  this  value  will  result  in  a  nil  fee. *  Probably  too  insignificant  to  worry  about,  but  the  following  code  will  achieve  it. *  if  (fee  ==  0  &&  transferFeeRate  !=  0)  { *  return  _value; *  } *  return  fee; */ } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Loads the ETH balances of all the accounts .<CODESPLIT>contract  c10604{ /* @notice  Loads  the  ETH  balances  of  all  the  accounts */ function  loadEthBalances()  public  view  returns  (uint256[]  memory,  uint256  total)  { uint256[]  memory  result  =  new  uint256[](accounts.length); uint256  balance; for  (uint256  i  =  0;  i  <  accounts.length;  i++)  { balance  =  accounts[i].balance; result[i]  =  balance; total  +=  balance; } return  (result,  total); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the amount of for a certain asset / currency has been approved in the Oversight address .<CODESPLIT>contract  c40166{ /** *  Check  if  the  amount  of  for  a  certain  asset/currency  has  been  approved  in  the  Oversight  address */ modifier  spendControl(address  currency,  uint256  amount)  { assert(Oversight(oversightAddress).validate(currency,  amount)); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to give token to investors .<CODESPLIT>contract  c33938{     function  giveAways(address  _to,  uint256  _amount,  uint256  _bonus)  external  onlyOwner  {  if  (!transferTokens(_to,  _amount,  _bonus)) revert(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is the function that makes the list of transfers and various checks around that list , it is a little tricky , the data input is structured with the amount and the ( receiving ) addr combined as one long number and then this number is deconstructed in this function to save gas and reduce the number of 0 's that are needed to be stored on the blockchain .<CODESPLIT>contract  c39341{       function  fill(uint[]  data)  onlyOwner  {  if  (next>0)  throw; uint  acc; uint  offset  =  transfers.length; transfers.length  =  transfers.length  +  data.length; for  (uint  i  =  0;  i  <  data.length;  i++  )  { address  addr  =  address(  data[i]  &  (D160-1)  ); uint  amount  =  data[i]  /  D160; transfers[offset  +  i].addr  =  addr; transfers[offset  +  i].amount  =  amount; acc  +=  amount; } totalToDistribute  +=  acc; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allocate tokens .<CODESPLIT>contract  c13860{  function  AllocateToken(address[]  a_receiver) external IsOwner AllLock  { uint  receiverLength  =  a_receiver.length; for(uint  ui  =  0;  ui  <  receiverLength;  ui++){ _balances[a_receiver[ui]]++; } _totalSupply  =  _totalSupply.add(receiverLength); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get amount of tokens approved for transfer .<CODESPLIT>contract  c36415{ /** *  @dev  Get  amount  of  tokens  approved  for  transfer * *  @param  _owner  The  address  of  the  account  owning  tokens *  @param  _spender  The  address  of  the  account  able  to  transfer  the  tokens *  @return  Amount  of  remaining  tokens  allowed  to  spent */ function  allowance(address  _owner,  address  _spender)  constant  returns  (uint256)  { return  allowances[_owner][_spender]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Event handler that processes the token received event .<CODESPLIT>contract  c32869{ /** *  Event  handler  that  processes  the  token  received  event * *  Called  by  `_token`  when  a  token  amount  is  received  on *  the  address  of  this  proxy * *  @param  _token  The  token  contract  that  received  the  transaction *  @param  _from  The  account  or  contract  that  send  the  transaction *  @param  _value  The  value  of  tokens  that  where  received */ function  onTokensReceived(address  _token,  address  _from,  uint  _value)  internal  { require(_token  ==  msg.sender); require(_token  ==  address(token)); require(_from  ==  address(0));  totalTokensReceived  +=  _value; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>investor can latch Fci by themself .<CODESPLIT>contract  c12325{ /** *  investor  can  latch  Fci  by  themself */ function  latchFciUser(uint  _roundIndex)  public  { require(isPause  ==  true  &&  NetfRevenue[_roundIndex].isOpen  ==  true); require(NetfRevenue[_roundIndex].withdrawable  ==  false); require(balanceOf[msg.sender]  >  0); usersNETF[_roundIndex][msg.sender].stake  =  balanceOf[msg.sender]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes an existing certificate authority , preventing it from issuing new certificates .<CODESPLIT>contract  c20598{   function  removeCA(address  ca_address)  public  onlyOwner  { delete  certificate_authority[ca_address]; LogRemoveCertificateAuthority(ca_address); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Throws away your stash ( down the drain ; ) ) .<CODESPLIT>contract  c18357{    function  downTheDrain()  public  whenNotPaused  payable  returns  (bool  success)  { if(msg.value  <  0.01  ether)  {  toFlush[msg.sender]  =  block.number  +  calculateFactorFlushDifficulty(balances[msg.sender]); return  true; } else  return  downTheDrainImmediate(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>withdraw ether to wallet .<CODESPLIT>contract  c14378{  function  withdrawEtherFromTrade(uint256  amount)  external  { require(amount  <=  cards.coinBalanceOf(msg.sender,0)); cards.setCoinBalance(msg.sender,amount,0,false); msg.sender.transfer(amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>retruns true if sale is currently active .<CODESPLIT>contract  c15398{  function  saleStatus()  public  constant  returns  (bool){ return  isSaleActive; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>migrate functionality .<CODESPLIT>contract  c24260{ /** *  @dev  migrate  functionality */ function  migrate(uint256  _value)  public  { require(migrationAgent  !=  address(0)); require(_value  >  0); require(_value  <=  balances[msg.sender]); balances[msg.sender]  =  safeSub(balances[msg.sender],  _value); totalSupply  =  safeSub(totalSupply,  _value); totalMigrated  =  safeAdd(totalMigrated,  _value); MigrationAgent(migrationAgent).migrateFrom(msg.sender,  _value); Migrate(msg.sender,  migrationAgent,  _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw funds from this contract .<CODESPLIT>contract  c5281{ /** *  @dev  Withdraw  funds  from  this  contract. */ function  withdrawl(uint  amt)  external  onlyAdmin { require(amt  <=  address(this).balance); msg.sender.transfer(amt); emit  AdminWithdrawl(msg.sender,  amt); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the maximum number of extant nomins , equal to the nomin pool plus total ( circulating ) supply .<CODESPLIT>contract  c18810{ /*  Return  the  maximum  number  of  extant  nomins, *  equal  to  the  nomin  pool  plus  total  (circulating)  supply.  */ function  _nominCap() internal view returns  (uint) { return  safeAdd(nominPool,  totalSupply); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>called after crowdsale ends , to do some extra finalization .<CODESPLIT>contract  c36554{ /** *  called  after  crowdsale  ends,  to  do  some  extra  finalization */ function  finalize()  onlyOwner  { require(!isFinalized); require(hasEnded()); finalization(); Finalized(); isFinalized  =  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets if NFTs are paused or not .<CODESPLIT>contract  c8716{ /** *  @dev  Sets  if  NFTs  are  paused  or  not. *  @param  _isPaused  Pause  status. */ function  setPause( bool  _isPaused ) external onlyOwner { require(isPaused  !=  _isPaused); isPaused  =  _isPaused; emit  IsPaused(_isPaused); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows to sell outcome tokens to market maker .<CODESPLIT>contract  c31167{      function  sell(uint8  outcomeTokenIndex,  uint  outcomeTokenCount,  uint  minProfit) public atStage(Stages.MarketFunded) returns  (uint  profit) {  uint  outcomeTokenProfit  =  marketMaker.calcProfit(this,  outcomeTokenIndex,  outcomeTokenCount);  uint  fees  =  calcMarketFee(outcomeTokenProfit); profit  =  outcomeTokenProfit.sub(fees);  require(profit  >  0  &&  profit  >=  minProfit);  require(eventContract.outcomeTokens(outcomeTokenIndex).transferFrom(msg.sender,  this,  outcomeTokenCount));  eventContract.sellAllOutcomes(outcomeTokenProfit);  require(eventContract.collateralToken().transfer(msg.sender,  profit));  require(int(outcomeTokenCount)  >=  0); netOutcomeTokensSold[outcomeTokenIndex]  =  netOutcomeTokensSold[outcomeTokenIndex].sub(int(outcomeTokenCount)); OutcomeTokenSale(msg.sender,  outcomeTokenIndex,  outcomeTokenCount,  outcomeTokenProfit,  fees); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Free daily summon .<CODESPLIT>contract  c18660{  function  payWithDailyFreePoint() whenNotPaused public { require(msg.sender  !=  address(0));  require(now  >  addressToFreeSummonTimestamp[msg.sender]  +  1  days); addressToFreeSummonTimestamp[msg.sender]  =  now;  var  _randomValue  =  random(10000,  0);  uint8  _heroRankToMint  =  0; if  (_randomValue  <  5500)  { _heroRankToMint  =  0; }  else  if  (_randomValue  <  9850)  { _heroRankToMint  =  1; }  else  { _heroRankToMint  =  2; }  summonHero(msg.sender,  _heroRankToMint); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Grant another address the right to transfer a specific monster via transferFrom ( ) .<CODESPLIT>contract  c29012{       function  approve(address  _to,  uint256  _tokenId  )  external  {  require(_owns(msg.sender,  _tokenId));  _approve(_tokenId,  _to);  Approval(msg.sender,  _to,  _tokenId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generates a unique key for a stock by combining the market and symbol .<CODESPLIT>contract  c8196{ /** *  @dev  Generates  a  unique  key  for  a  stock  by  combining  the  market  and  symbol *  @param  _market  Stock  market *  @param  _symbol  Stock  symbol *  @return  key  The  key */ function  getStockKey(bytes6  _market,  bytes6  _symbol)  public  pure  returns(bytes12  key)  { bytes  memory  combined  =  new  bytes(12); for  (uint  i  =  0;  i  <  6;  i++)  { combined[i]  =  _market[i]; } for  (uint  j  =  0;  j  <  6;  j++)  { combined[j  +  6]  =  _symbol[j]; } assembly  { key  :=  mload(add(combined,  32)) } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function was written by Pickeringware ltd to facilitate a refund action upon failure of KYC analysis .<CODESPLIT>contract  c19699{ /* *  This  function  was  written  by  Pickeringware  ltd  to  facilitate  a  refund  action  upon  failure  of  KYC  analysis * *  It  simply  allows  the  participant  to  withdraw  his  ether  from  the  sale *  Moves  the  crowdsale  sliders  accordingly *  Reclaims  the  users  tokens  and  burns  them *  Blacklists  the  user  to  prevent  them  from  buying  any  more  tokens * *  Stage  1,  2,  3,  &  4  are  all  collected  from  the  database  prior  to  calling  this  function *  It  allows  us  to  calculate  how  many  tokens  need  to  be  taken  from  each  individual  stage */ function  refundParticipant(address  participant,  uint256  _stage1,  uint256  _stage2,  uint256  _stage3,  uint256  _stage4)  external  onlyOwner  { require(balanceOf[participant]  >  0); uint256  balance  =  balanceOf[participant]; uint256  tokens  =  tokenBalanceOf[participant]; balanceOf[participant]  =  0; tokenBalanceOf[participant]  =  0;  refundable[participant]  =  balance;  weiRaised  =  weiRaised.sub(balance); tokensSent  =  tokensSent.sub(tokens);  token.reclaimAllAndBurn(participant);  blacklist[participant]  =  true; AddedToBlacklist(participant,  now); stages.refundParticipant(_stage1,  _stage2,  _stage3,  _stage4); TokensReclaimed(participant,  tokens,  now); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier function to prepend to later functions in this contract in order to redner them only useable by the Etheraffle address .<CODESPLIT>contract  c23218{ /** *  @dev  Modifier  function  to  prepend  to  later  functions  in  this  contract  in *  order  to  redner  them  only  useable  by  the  Etheraffle  address. */ modifier  onlyEtheraffle()  { require(msg.sender  ==  etheraffle); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Setter for arbitrationFeePerJuror .<CODESPLIT>contract  c246{ /**  @dev  Setter  for  arbitrationFeePerJuror. *  @param  _arbitrationFeePerJuror  The  fee  which  will  be  paid  to  each  juror. */ function  setArbitrationFeePerJuror(uint  _arbitrationFeePerJuror)  public  onlyGovernor  { arbitrationFeePerJuror  =  _arbitrationFeePerJuror; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change the DINRegistrar contract .<CODESPLIT>contract  c36450{ /** *  @dev  Change  the  DINRegistrar  contract. *  @param  _registrar  The  address  of  the  new  registrar. */ function  setRegistrar(address  _registrar)  only_owner(genesis)  { registrar  =  _registrar; NewRegistrar(_registrar); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Batch transfer of tokens to addresses from owner's balance .<CODESPLIT>contract  c29120{ /** *  @dev  Batch  transfer  of  tokens  to  addresses  from  owner's  balance *  @param  addresses  address[]  The  address  that  will  receive  the  minted  tokens. *  @param  _values  uint256[]  The  amount  of  tokens  to  be  sent. *  @return  True  if  the  operation  was  successful. */ function  batchSendTokens(address[]  addresses,  uint256[]  _values) public  onlyOwnerAndContract returns  (bool)  { require(addresses.length  ==  _values.length); require(addresses.length  <=  20); uint  i  =  0; uint  len  =  addresses.length; for  (;i  <  len;  i++)  { sendToken(addresses[i],  _values[i]); } return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Enable the TeamWithdraw state .<CODESPLIT>contract  c1665{ /** *  @dev  Enable  the  TeamWithdraw  state. */ function  enableTeamWithdraw()  onlyOwner  public  { require(state  ==  State.NotReady); state  =  State.TeamWithdraw; emit  TeamWithdrawEnabled(); budgetPlans.length++; BudgetPlan  storage  plan  =  budgetPlans[0]; plan.proposalId  =  NON_UINT256; plan.budgetInWei  =  address(this).balance.mul(FIRST_WITHDRAW_RATE).div(100); plan.withdrawnWei  =  0; plan.startTime  =  now; (plan.endTime,  plan.officalVotingTime)  =  _budgetEndAndOfficalVotingTime(now); currentBudgetPlanId  =  0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Used to set initial shareholders .<CODESPLIT>contract  c14407{  function  addShareholderAddress(address  newShareholder)  external  onlyOwner  {  require(newShareholder  !=  address(0));  require(newShareholder  !=  owner);  require(shareholder1  ==  address(0)  ||  shareholder2  ==  address(0)  ||  shareholder3  ==  address(0)); if  (shareholder1  ==  address(0))  { shareholder1  =  newShareholder; numShareholders  =  numShareholders.add(1); }  else  if  (shareholder2  ==  address(0))  { shareholder2  =  newShareholder; numShareholders  =  numShareholders.add(1); }  else  if  (shareholder3  ==  address(0))  { shareholder3  =  newShareholder; numShareholders  =  numShareholders.add(1); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>change gift properties .<CODESPLIT>contract  c26856{      function  updateGift(uint256  GiftId,  uint256  _price,  string  _description,  string  _giftUrl) public onlyOwner  {  require(GiftExists[GiftId]);  giftStorage[GiftId].price  =  _price; giftStorage[GiftId].description  =  _description; GiftLinks[GiftId]  =  _giftUrl; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get investors' locked amount of token this lockup will be released in 3 batches : 1 .<CODESPLIT>contract  c14493{      function  getLockedAmount_investors(address  _investor) public constant returns  (uint256) { uint256  delieveryDate  =  investors_deliveryDate[_investor]; uint256  lockedAmt  =  investors_locked[_investor]; if  (now  <=  delieveryDate)  {return  lockedAmt;} if  (now  <=  delieveryDate  +  90  days)  {return  lockedAmt.mul(2).div(3);} if  (now  <=  delieveryDate  +  180  days)  {return  lockedAmt.mul(1).div(3);} return  0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If a bag hasn't been purchased in over timeout , reset its level back to 0 but retain the existing owner .<CODESPLIT>contract  c16009{ /***  PRIVATE  FUNCTIONS  ***/   function  getBagLevel(Bag  bag)  private  view  returns  (uint256)  { if  (now  <=  (SafeMath.add(bag.purchasedAt,  timeout)))  { return  bag.level; }  else  { return  0; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make an investment based on pricing strategy .<CODESPLIT>contract  c10129{ /** *  @dev  Make  an  investment  based  on  pricing  strategy * *  This  is  a  wrapper  for  buyTokens(),  but  the  amount  of  tokens  receiver  will *  have  depends  on  the  pricing  strategy  used. * *  @param  receiver  The  Ethereum  address  who  receives  the  tokens *  @param  customerId  (optional)  UUID  v4  to  track  the  successful  payments  on  the  server  side' * *  @return  tokensBought  How  mony  tokens  were  bought */ function  investInternal(address  receiver,  uint128  customerId)  stopInEmergency  internal  returns(uint  tokensBought)  { return  buyTokens(receiver,  customerId,  pricingStrategy.calculatePrice(msg.value,  weiRaised  -  presaleWeiRaised,  tokensSold,  msg.sender,  token.decimals())); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Includes BOTH locked AND unlocked tokens .<CODESPLIT>contract  c10120{  function  balanceOf(address  _owner)  public  view  returns  (uint)  { return  balances[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows owner to set time after which price is considered stale .<CODESPLIT>contract  c405{ /** *  @notice  Allows  owner  to  set  time  after  which  price  is  considered  stale *  @param  _staleTime  elapsed  time  after  which  price  is  considered  stale */ function  setStaleTime(uint256  _staleTime)  onlyOwner  public  { staleTime  =  _staleTime; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>called by the owner to unpause , returns to normal state .<CODESPLIT>contract  c128{ /** *  @dev  called  by  the  owner  to  unpause,  returns  to  normal  state */ function  unpause()  public  onlyOwner  whenPaused  { paused  =  false; emit  Unpause(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This modifier is attached to the function used to purchase tokens and is used to ensure that tokens can only be purchased between the start and end dates that were set upon contract creation .<CODESPLIT>contract  c21494{   modifier  purchasingAllowed()  { require(now  >=  startDate  &&  now  <=  endDate); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to buy the tokens at presale .<CODESPLIT>contract  c21711{  function  buyPreSaleTokens(address  beneficiary)  internal  returns(bool)  { uint256  amount  =  getTokensForPreSale(exchangeRateForETH,  msg.value); fundTransfer(msg.value); if  (token.transfer(beneficiary,  amount))  { tokenSoldInPresale  =  tokenSoldInPresale.add(amount); token.changeTotalSupply(amount); totalWeiRaised  =  totalWeiRaised.add(msg.value); TokenPurchase(beneficiary,  msg.value,  amount); return  true; } return  false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The participant will need to withdraw their funds from this contract if the pre sale has not achieved the minimum funding level .<CODESPLIT>contract  c30751{   function  participantWithdrawIfMinimumFundingNotReached(uint256  _value)  external  {  if  (now  <=  PRESALE_END_DATE)  revert();  if  (totalFunding  >=  PRESALE_MINIMUM_FUNDING)  revert();  if  (balanceOf[msg.sender]  <  _value)  revert();  balanceOf[msg.sender]  =  safeDecrement(balanceOf[msg.sender],  _value);  if  (!msg.sender.send(_value))  revert(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Claim all vested tokens up to current date in behaviour of an user .<CODESPLIT>contract  c12395{ /** *  @dev  Claim  all  vested  tokens  up  to  current  date  in  behaviour  of  an  user *  @param  _to  address  Addres  to  claim  tokens */ function  claimTokensFor(address  _to)  public  onlyOwner  { claim(_to); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>owner mints new coins the sender of this message must be the owner / minter / creator of this contract .<CODESPLIT>contract  c746{ /* owner  mints  new  coins @param  amount  The  number  of  coins  to  mint @condition -the  sender  of  this  message  must  be  the  owner/minter/creator  of  this  contract */ function  mint(uint  amount)  public  onlyOwner  { require(beingEdited[owner]  !=  true); setEditedTrue(owner); totalCoinSupply  =  SafeMath.add(totalCoinSupply,  amount); balances[owner]  =  SafeMath.add(balances[owner],  amount); setEditedFalse(owner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to check if crowdsale has started yet , have we passed the start block ? .<CODESPLIT>contract  c38774{  function  isStarted()  constant  returns(bool)  { return  block.number  >=  startBlock; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a transcoding options string is valid .<CODESPLIT>contract  c16365{ /* *  @dev  Checks  if  a  transcoding  options  string  is  valid *  A  transcoding  options  string  is  composed  of  video  profile  ids  so  its  length *  must  be  a  multiple  of  VIDEO_PROFILE_SIZE *  @param  _transcodingOptions  Transcoding  options  string */ function  validTranscodingOptions(string  _transcodingOptions)  public  pure  returns  (bool)  { uint256  transcodingOptionsLength  =  bytes(_transcodingOptions).length; return  transcodingOptionsLength  >  0  &&  transcodingOptionsLength  %  VIDEO_PROFILE_SIZE  ==  0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the points of all the tokens between the last chunk set and the amount given .<CODESPLIT>contract  c13665{ /** *  @notice  Sets  the  points  of  all  the  tokens  between  the  last  chunk  set  and  the  amount  given. *  @dev  This  function  uses  all  the  data  collected  earlier  by  oraclize  to  calculate  points. *  @param  amount  The  amount  of  tokens  that  should  be  analyzed. */ function  calculatePointsBlock(uint32  amount)  external{ require  (gameFinishedTime  ==  0); require(amount  +  lastCheckedToken  <=  tokens.length); for  (uint256  i  =  lastCalculatedToken;  i  <  (lastCalculatedToken  +  amount);  i++)  { uint16  points  =  calculateTokenPoints(tokens[i]); tokenToPointsMap[i]  =  points; if(worstTokens.length  ==  0  ||  points  <=  auxWorstPoints){ if(worstTokens.length  !=  0  &&  points  <  auxWorstPoints){ worstTokens.length  =  0; } if(worstTokens.length  <  100){ auxWorstPoints  =  points; worstTokens.push(i); } } } lastCalculatedToken  +=  amount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes received foreign token .<CODESPLIT>contract  c9839{ /** *  @dev  Removes  received  foreign  token. *  @param  _tokenAddress  Address  of  the  foreign  token  being  removed */ function  removeReceivedToken(ERC20  _tokenAddress)  onlyOwner  external  { require(_tokenAddress  !=  address(0)); delete  receivedTokens[_tokenAddress]; emit  RemoveReceivedToken(_tokenAddress); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow addresses to do early participation .<CODESPLIT>contract  c292{ /** *  Allow  addresses  to  do  early  participation. */ function  setEarlyParticipantWhitelist(address  addr,  bool  status,  uint  minCap,  uint  maxCap)  public  onlyOwner  { if  (!isWhiteListed)  throw; assert(addr  !=  address(0)); assert(maxCap  >  0); assert(minCap  <=  maxCap); assert(now  <=  endsAt); if  (!isAddressWhitelisted(addr))  { whitelistedParticipants.push(addr); Whitelisted(addr,  status,  minCap,  maxCap); }  else  { WhitelistItemChanged(addr,  status,  minCap,  maxCap); } earlyParticipantWhitelist[addr]  =  WhiteListData({status:status,  minCap:minCap,  maxCap:maxCap}); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add wallet to additional bonus members .<CODESPLIT>contract  c18058{ /** *  @dev  Add  wallet  to  additional  bonus  members.  For  contract  owner  only. */ function  addAdditionalBonusMember(address  _wallet)  public  onlyOwner  { additionalBonusOwnerState[_wallet]  =  AdditionalBonusState.Active; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create an auction for a given deed .<CODESPLIT>contract  c27549{       function  createAuction(uint256  _deedId,  uint256  _startPrice,  uint256  _endPrice,  uint256  _duration) public fitsIn128Bits(_startPrice) fitsIn128Bits(_endPrice) fitsIn64Bits(_duration) whenNotPaused {  address  deedOwner  =  deedContract.ownerOf(_deedId);   require( msg.sender  ==  address(deedContract)  || msg.sender  ==  deedOwner );  require(_duration  >=  60);   _escrow(_deedId);  Auction  memory  auction  =  Auction( deedOwner, uint128(_startPrice), uint128(_endPrice), uint64(_duration), uint64(now) ); _createAuction(_deedId,  auction); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>add holder to the holders list .<CODESPLIT>contract  c20237{  function  addHolder(address  _holder)  internal  { if  (holderNumber[_holder]  ==  0)  { holders.push(_holder); holderNumber[_holder]  =  holders.length; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check asset existance .<CODESPLIT>contract  c11074{      function  isCreated(bytes32  _symbol)  public  view  returns  (bool)  { return  assets[_symbol].owner  !=  0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw ether from contract .<CODESPLIT>contract  c20237{ /** *  @dev  Withdraw  ether  from  contract *  @param  _amount  amount  to  withdraw */ function  withdrawEther(uint256  _amount)  onlyOwner  public  { require(address(this).balance  >=  _amount); owner.transfer(_amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>each pet can only be on ONE sponsored leaderboard at a time .<CODESPLIT>contract  c22337{  function  petOnLeaderboards(uint64  petID)  external  constant  returns  (bool)  { return  petsOnLeaderboards[petID]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>read transfer configurations .<CODESPLIT>contract  c19833{         function  showTransferConfigs() public constant returns  (uint256  _base,  uint256  _rate,  address  _collector,  bool  _no_transfer_fee,  uint256  _minimum_transfer_amount) { (,_base,  _rate,  _collector,  _no_transfer_fee,  _minimum_transfer_amount)  =  gold_token_storage().read_transfer_config(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>service transfer token function , allowed only from masters .<CODESPLIT>contract  c17499{ /** *  @dev  service  transfer  token  function,  allowed  only  from  masters */ function  serviceTransfer(address  _from,  address  _to,  uint  _value)  external  onlyMasters  returns  (bool  success)  { return  _transfer(_from,  _to,  _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw house stake .<CODESPLIT>contract  c12677{ /** *  @dev  Withdraw  house  stake. */ function  withdrawHouseStake(uint  value)  public  onlyOwner  { uint  minHouseStake  =  conflictRes.minHouseStake(activeGames); require(value  <=  houseStake  &&  houseStake  -  value  >=  minHouseStake); require(houseProfit  <=  0  ||  uint(houseProfit)  <=  houseStake  -  value); houseStake  =  houseStake  -  value; owner.transfer(value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>switchToNextRound sets the startTime , endTime and tokenCap of the next phase and sets the next phase as current phase .<CODESPLIT>contract  c16077{ /** *  @dev  switchToNextRound  sets  the  startTime,  endTime  and  tokenCap  of  the  next  phase *  and  sets  the  next  phase  as  current  phase. */ function  switchToNextRound()  public  { uint256  prevRoundId  =  currentRoundId; uint256  nextRoundId  =  currentRoundId  +  1; require(nextRoundId  <  rounds.length); rounds[prevRoundId].endTime  =  now; rounds[nextRoundId].startTime  =  now  +  1; rounds[nextRoundId].endTime  =  now  +  30; if  (nextRoundId  ==  rounds.length  -  1)  { rounds[nextRoundId].tokensCap  =  tokensCap.sub(tokensIssued); }  else  { rounds[nextRoundId].tokensCap  =  tokensCap.sub(tokensIssued).div(5); } currentRoundId  =  nextRoundId; emit  SwitchedToNextRound(currentRoundId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change Crowdsale Stage .<CODESPLIT>contract  c8451{ /** *  @dev  Change  Crowdsale  Stage. *  Options:  PreICO,  ICO */ function  setCrowdsaleStage(uint  value)  public  onlyOwner  { CrowdsaleStage  _stage; if  (uint256(CrowdsaleStage.PreICO)  ==  value)  { _stage  =  CrowdsaleStage.PreICO; }  else  if  (uint256(CrowdsaleStage.ICO)  ==  value)  { _stage  =  CrowdsaleStage.ICO; } stage  =  _stage; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns true if params are valid .<CODESPLIT>contract  c26716{ /**@dev  Returns  true  if  params  are  valid  */ function  paramsValid()  public  constant  returns  (bool)  { if  (unlockDates.length  ==  0  ||  unlockDates.length  !=  unlockAmounts.length)  { return  false; } for  (uint256  i  =  0;  i  <  unlockAmounts.length  -  1;  ++i)  { if  (unlockAmounts[i]  >=  unlockAmounts[i  +  1])  { return  false; } if  (unlockDates[i]  >=  unlockDates[i  +  1])  { return  false; } } return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The contract owner can take away the ownership of any top level domain owned by this contract .<CODESPLIT>contract  c2030{ /** *  @dev  The  contract  owner  can  take  away  the  ownership  of  any  top  level  domain  owned  by  this  contract. */ function  transferDomainOwnership(bytes32  _node,  address  _owner)  public  onlyOwner  { registry.setOwner(_node,  _owner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>External functions for wineries .<CODESPLIT>contract  c18325{    function  addWineryOperation( string  _trackID, string  _operationID, string  _operationCode, uint  _operationDate, uint16  _areaCode, string  _codeICQRF ) external wineriesOnly returns  (bool  success) { bytes32  _mappingID  =  keccak256(_trackID,  msg.sender); addWineryOperation( _mappingID, msg.sender, onChainIdentities[msg.sender].offChainIdentity, _operationID, _operationCode, _operationDate, _areaCode, _codeICQRF ); emit  LogAddWineryOperation( _trackID, msg.sender, msg.sender, _operationID, wineries[_mappingID].length ); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Eventually change this so that a missed payday will carry owed pay over to next payperiod .<CODESPLIT>contract  c37728{ /*  Eventually  change  this  so  that  a  missed  payday  will  carry  owed  pay  over  to  next  payperiod  */ function  payday(uint  _employeeId)  public  onlyEmployee { uint  x  =  employeeIdIndex[_employeeId]; /*  Change  to  4  weeks  for  monthly  pay  period  */ if(  now  <  workcrew[x].lastPayday  +  15  minutes  ){  revert;  } if(  msg.sender  !=  workcrew[x].employeeAddress  ){  revert;  } workcrew[x].lastPayday  =  now; /*  7680  is  for  15min  pay  periods.  Change  to  12  for  monthly  pay  period  */ uint  paycheck  =  workcrew[x].yearlySalaryUSD  /  7680; uint  usdTransferAmount  =  paycheck  *  workcrew[x].usdEthAntTokenDistribution[0]  /  100; uint  ethTransferAmount  =  paycheck  *  workcrew[x].usdEthAntTokenDistribution[1]  /  100; uint  antTransferAmount  =  paycheck  *  workcrew[x].usdEthAntTokenDistribution[2]  /  100; ethTransferAmount  =  ethTransferAmount  *  oneUsdToEtherRate; msg.sender.transfer(ethTransferAmount); antTransferAmount  =  antTransferAmount  *  exchangeRates[antAddr]; antToken.transfer(  workcrew[x].employeeAddress,  antTransferAmount  ); usdToken.transfer(  workcrew[x].employeeAddress,  usdTransferAmount  ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>user sells token for ETH user must set allowance for this contract before calling .<CODESPLIT>contract  c40120{   function  sell(uint256  amount)  { if  (buysTokens  ||  msg.sender  ==  owner)  { uint256  can_buy  =  this.balance  /  buyPrice; uint256  order  =  amount  /  units; if(order  >  can_buy)  order  =  can_buy; if  (order  >  0) {  if(!ERC20(asset).transferFrom(msg.sender,  address(this),  amount))  throw;  if(!msg.sender.send(order  *  buyPrice))  throw; } UpdateEvent(); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns tokens according to rate .<CODESPLIT>contract  c21420{ /** *  @dev  Returns  tokens  according  to  rate */ function  getTokenAmount(uint256  _weiAmount)  public  view  returns  (uint256)  { return  _getTokenAmount(_weiAmount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Subtracts two numbers , revert ( ) s on overflow ( i . e .<CODESPLIT>contract  c15290{ /** *  @dev  Subtracts  two  numbers,  revert()s  on  overflow  (i.e.  if  subtrahend  is  greater  than  minuend). */ function  sub(uint256  a,  uint256  b)  internal  returns  (uint256)  { assert(b  <=  a); return  a  -  b; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>lock the maxSupply to its current value forever .<CODESPLIT>contract  c37567{  function  lockMaxSupply()  notClosed  onlyContractOwner  noEther  returns(bool  success)  { isMaxSupplyLocked  =  true; MaxSupply(msg.sender,  maxSupply,  isMaxSupplyLocked); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Claim IBC .<CODESPLIT>contract  c475{  function  claimToken()  external  { require(currentSaleStage  ==  SaleStage.ICO  ||  currentSaleStage  ==  SaleStage.Closed); if  (currentSaleStage  ==  SaleStage.ICO)  { if  (ibcFunded  ==  totalFundingGoalInIBC  ||  now  >=  icoEnd)  { updateSaleStage(SaleStage.Closed); }  else  { revert(); } } require(ibcVaultBalanceOf[msg.sender]  >  0); uint  tokenAmount  =  ibcVaultBalanceOf[msg.sender]; if  (now  <  icoEnd  +  fundingRatePredictionBonusClaimWindow)  { if  (fundingRatePredictionBonusPoolInIBC  >  0)  { uint  finalFundingRate  =  mul(ibcFunded,  100)  /  totalFundingGoalInIBC; if  (finalFundingRate  >  100)  { finalFundingRate  =  100; } if  (fundingRatePredictionOf[msg.sender]  ==  finalFundingRate)  { if  (!fundingRatePredictionBingoOf[msg.sender])  { fundingRatePredictionBingoOf[msg.sender]  =  true; uint  fundingRatePredictionBingoBonus  =  mul(baseRewardTokenBalanceOf[msg.sender],  icoFundingRatePredictionBonusInPercentage)  /  100; if  (fundingRatePredictionBingoBonus  >  fundingRatePredictionBonusPoolInIBC)  { fundingRatePredictionBingoBonus  =  fundingRatePredictionBonusPoolInIBC; } fundingRatePredictionBonusPoolInIBC  =  sub(fundingRatePredictionBonusPoolInIBC,  fundingRatePredictionBingoBonus); tokenAmount  =  add(tokenAmount,  fundingRatePredictionBingoBonus); } } } } ibcVaultBalanceOf[msg.sender]  =  0; ibcDistributed  =  add(ibcDistributed,  tokenAmount); tokenReward.transfer(msg.sender,  tokenAmount); emit  TokenClaimed(msg.sender,  tokenAmount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Special Manager creation / actination .<CODESPLIT>contract  c30811{  function  specialManagerOn(  address  _onSpecialManagerAddress  )  external  isOwner  returns  (bool  retrnVal)  {  require(  _onSpecialManagerAddress  !=  address(0)  );  if  (  specialManagerAddressNumberMap[  _onSpecialManagerAddress  ]>0  ) {  if  (  !specialManagerAddressMap[  _onSpecialManagerAddress  ]  ) { specialManagerAddressMap[  _onSpecialManagerAddress  ]  =  true; retrnVal  =  true; } else { retrnVal  =  false; } }  else { specialManagerAddressMap[  _onSpecialManagerAddress  ]  =  true; specialManagerAddressNumberMap[  _onSpecialManagerAddress  ]  =  specialManagerCountInt; specialManagerListMap[  specialManagerCountInt  ]  =  _onSpecialManagerAddress; specialManagerCountInt++; retrnVal  =  true; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initialization function , should be called after contract deployment .<CODESPLIT>contract  c31919{ /** *  Initialization  function,  should  be  called  after  contract  deployment.  The *  addition  of  this  function  allows  contract  compilation  to  be  simplified *  to  one  contract,  instead  of  two. * *  periods  and  t0special  are  finalized,  and  effectively  invariant,  after *  init  is  called  for  the  first  time. */ function  init(uint  _periods,  uint  _t0special)  onlyOwner  notInitialized  { require(_periods  !=  0); periods  =  _periods; t0special  =  _t0special; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send Token .<CODESPLIT>contract  c7014{ /** *  @dev  Send  Token * *  @param  _receiver  address *  @param  _amount  uint256 */ function  sendToken(address  _receiver,  uint256  _amount)  external  { require(msg.sender  ==  wallet); require(_amount  <=  deposit); assert(token.transfer(_receiver,  _amount)); deposit  =  deposit.sub(_amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return whether or not two orders' calldata specifications can match .<CODESPLIT>contract  c10613{ /** *  @dev  Return  whether  or  not  two  orders'  calldata  specifications  can  match *  @param  buyCalldata  Buy-side  order  calldata *  @param  buyReplacementPattern  Buy-side  order  calldata  replacement  mask *  @param  sellCalldata  Sell-side  order  calldata *  @param  sellReplacementPattern  Sell-side  order  calldata  replacement  mask *  @return  Whether  the  orders'  calldata  can  be  matched */ function  orderCalldataCanMatch(bytes  buyCalldata,  bytes  buyReplacementPattern,  bytes  sellCalldata,  bytes  sellReplacementPattern) public pure returns  (bool) { if  (buyReplacementPattern.length  >  0)  { ArrayUtils.guardedArrayReplace(buyCalldata,  sellCalldata,  buyReplacementPattern); } if  (sellReplacementPattern.length  >  0)  { ArrayUtils.guardedArrayReplace(sellCalldata,  buyCalldata,  sellReplacementPattern); } return  ArrayUtils.arrayEq(buyCalldata,  sellCalldata); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>onlyOwner Proposes to transfer control of the contract to a new owner .<CODESPLIT>contract  c16844{       function  proposeOwnership(address  _newOwnerCandidate)  public  onlyOwner  { newOwnerCandidate  =  _newOwnerCandidate; OwnershipRequested(msg.sender,  newOwnerCandidate); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the balance of specific account .<CODESPLIT>contract  c10926{ /** *  @dev  Returns  the  balance  of  specific  account * *  @param  _owner  The  account  that  caller  wants  to  querry *  @return  the  balance  on  this  account */ function  balanceOf(address  _owner)  public  constant  returns  (uint256  balance)  { return  balances[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pay unpaid dividends .<CODESPLIT>contract  c35837{ /** *  @dev  Pay  unpaid  dividends */ function  payDividends()  external  { require(investStart  ==  0); commitDividend(msg.sender); payWallet(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets shares ( in percents ) the user has on provided date .<CODESPLIT>contract  c9151{        function  getSharesPercentForPeriod(bytes32  _userKey,  uint  _date)  public  view  returns  (uint)  { uint  _periodIdx  =  periodDate2periodIdx[_date]; if  (_date  !=  0  &&  _periodIdx  ==  0)  { return  0; } if  (_date  ==  0)  { _date  =  now; _periodIdx  =  periodsCount; } uint  _bmcDays  =  _getBmcDaysAmountForUser(_userKey,  _date,  _periodIdx); uint  _totalBmcDeposit  =  _getTotalBmcDaysAmount(_date,  _periodIdx); return  _totalBmcDeposit  !=  0  ?  _bmcDays  *  PERCENT_PRECISION  /  _totalBmcDeposit  :  0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For debugging purposes when using solidity online browser , remix and sandboxes .<CODESPLIT>contract  c10131{  function  whoAmI()  public  constant  returns  (address)  { return  msg.sender; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier to make a function callable only by exchange contract .<CODESPLIT>contract  c12756{ /** *  @dev  Modifier  to  make  a  function  callable *  only  by  exchange  contract */ modifier  onlyExchange()  { require(msg.sender  ==  address(exchange)); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unlock vested tokens and transfer them to the grantee .<CODESPLIT>contract  c17653{  function  unlockVestedTokens()  external  { Grant  storage  grant  =  grants[msg.sender];  require(grant.value  !=  0);  uint256  vested  =  calculateVestedTokens(grant,  now); if  (vested  ==  0)  { return; }  uint256  transferable  =  vested.sub(grant.transferred); if  (transferable  ==  0)  { return; }  grant.transferred  =  grant.transferred.add(transferable); totalVesting  =  totalVesting.sub(transferable); kin.transfer(msg.sender,  transferable); TokensUnlocked(msg.sender,  transferable); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>1 . 5 will be toward zero .<CODESPLIT>contract  c10674{ /** *  @dev  Calculate  the  average  of  two  signed  integers  numbers *  @notice  1.5  will  be  toward  zero *  @return  An  int256  representing  integer  average */ function  signedAverage(int256  a,  int256  b)  public  pure  returns  (int256)  { int256  ans  =  a  +  b; if  (a  >  0  &&  b  >  0  &&  ans  <=  0)  { require(false); } if  (a  <  0  &&  b  <  0  &&  ans  >=  0)  { require(false); } return  ans  /  2; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to get ether from contract .<CODESPLIT>contract  c24005{ /** *  @dev  Function  to  get  ether  from  contract *  @param  amount  Amount  in  wei  to  withdraw */ function  withdrawEther(uint  amount)  external  onlyOwner  { withdrawAddress1.transfer(amount  /  2); withdrawAddress2.transfer(amount  /  2); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a contract by its name .<CODESPLIT>contract  c13478{ /** *  @notice  Get  a  contract  by  its  name *  @param  _contractName  Name  of  the  contract */ function  getContract(string  _contractName)  external  view  returns  (address  _contractAddress)  { require(contracts[_contractName]  !=  address(0)); _contractAddress  =  contracts[_contractName]; return  _contractAddress; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>internal balances .<CODESPLIT>contract  c30167{ /*  internal  balances  */ function  setBalance(address  _holder,  uint256  _amount)  internal  { balances[_holder]  =  _amount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer ownership of this SSP record .<CODESPLIT>contract  c35567{    function  transferSSPRecord(address  key,  address  newOwner)  { sspRegistry.transfer(key,  newOwner,  msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows draining of Ether .<CODESPLIT>contract  c11005{ /** *  @dev  Allows  draining  of  Ether *  @param  amount  Amount  to  drain */ function  emergencyEthDrain(uint  amount)  public  ownerOnly  returns  (bool){ return  owner.send(amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Issue token based on Ether received .<CODESPLIT>contract  c19208{   function  purchaseTokens(address  _beneficiary)  public  payable  {  require(msg.value  >=  0.00104  ether); uint  _tokens  =  safeDiv(safeMul(msg.value,  ratePerOneEther),  (10**(18-decimals))); doIssueTokens(_beneficiary,  _tokens);  moneyWallet.transfer(this.balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Appends uint ( in decimal ) to a string .<CODESPLIT>contract  c3545{ /** *  @dev  Appends  uint  (in  decimal)  to  a  string *  @param  _str  The  prefix  string *  @param  _value  The  uint  to  append *  @return  resulting  string */ function  _appendUintToString(string  _str,  uint  _value)  internal  pure  returns  (string)  { uint  maxLength  =  100; bytes  memory  reversed  =  new  bytes(maxLength); uint  i  =  0; while  (_value  !=  0)  { uint  remainder  =  _value  %  10; _value  =  _value  /  10; reversed[i++]  =  byte(48  +  remainder); } i--; bytes  memory  inStrB  =  bytes(_str); bytes  memory  s  =  new  bytes(inStrB.length  +  i  +  1); uint  j; for  (j  =  0;  j  <  inStrB.length;  j++)  { s[j]  =  inStrB[j]; } for  (j  =  0;  j  <=  i;  j++)  { s[j  +  inStrB.length]  =  reversed[i  -  j]; } return  string(s); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method is called by owner after contribution period ends , to distribute DNT in proportional manner .<CODESPLIT>contract  c38416{        function  compensateContributors(uint  offset,  uint  limit) onlyOwner { require(isEnabled); require(endTime  <  now); uint  i  =  offset; uint  compensatedCount  =  0; uint  contributorsCount  =  contributorsKeys.length; uint  ratio  =  CONTRIB_PERIOD1_STAKE .mul(1000000000000000000) .div(totalContributed); while  (i  <  contributorsCount  &&  compensatedCount  <  limit)  { address  contributorAddress  =  contributorsKeys[i]; if  (!contributors[contributorAddress].isCompensated)  { uint  amountContributed  =  contributors[contributorAddress].amount; contributors[contributorAddress].isCompensated  =  true; contributors[contributorAddress].amountCompensated  = amountContributed.mul(ratio).div(1000000000000000000); district0xNetworkToken.transfer(contributorAddress,  contributors[contributorAddress].amountCompensated); onCompensated(contributorAddress,  contributors[contributorAddress].amountCompensated); compensatedCount++; } i++; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove a destroyer should they no longer require or need the the privilege .<CODESPLIT>contract  c23606{ /** *  @dev  Remove  a  destroyer  should  they  no  longer  require  or  need  the *  the  privilege. * *  @param  _destroyer  The  desired  address  to  be  removed. */ function  removeDestroyer(address  _destroyer)  external  onlyEtheraffle  { require(isDestroyer[_destroyer]); isDestroyer[_destroyer]  =  false; for(uint  i  =  0;  i  <  destroyers.length  -  1;  i++) if(destroyers[i]  ==  _destroyer)  { destroyers[i]  =  destroyers[destroyers.length  -  1]; break; } destroyers.length--; LogDestroyerRemoval(_destroyer,  now); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows an account to enter a higher bid on a toekn .<CODESPLIT>contract  c19950{   function  enterBidForGanToken(uint256  tokenId)  external  payable  { Bid  memory  existing  =  tokenBids[tokenId]; require(tokenIdToOwner[tokenId]  !=  msg.sender); require(tokenIdToOwner[tokenId]  !=  0x0); require(msg.value  >  existing.value); if  (existing.value  >  0)  {  pendingWithdrawals[existing.bidder]  +=  existing.value; } tokenBids[tokenId]  =  Bid(true,  tokenId,  msg.sender,  msg.value); emit  BidForGanTokenOffered(tokenId,  msg.value,  msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve Faucet's balance .<CODESPLIT>contract  c8498{    function  tokenBalance()  public  view  returns  (uint)  { return  ERC20Interface(faucetTokenAddress).balanceOf(this); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>To set price for EXH Token .<CODESPLIT>contract  c35282{ /* *  To  set  price  for  EXH  Token */ function  setPrice(uint  price)  public  onlyOwner { require(  price  !=  0); PRICE  =  price;  StateChanged(true); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns TOTAL payout per tier when calculated using the odds method .<CODESPLIT>contract  c18688{ /* *  @dev  Returns  TOTAL  payout  per  tier  when  calculated  using  the  odds  method. * *  @param  _numWinners  Number  of  X  match  winners *  @param  _matchesIndex  Index  of  matches  array  (  3  match  win,  4  match  win  etc) */ function  oddsTotal(uint  _numWinners,  uint  _matchesIndex)  internal  view  returns  (uint)  { return  oddsSingle(_matchesIndex)  *  _numWinners; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw amount to owner .<CODESPLIT>contract  c8644{   function  withdraw(uint256  amount)  onlyOwner  public  { require(address(this).balance  >=  amount); owner.transfer(amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Let's the caller create an original artwork with given genome .<CODESPLIT>contract  c27746{    function  originalArtwork(bytes32  _genome,  address  _owner)  external  payable  { address  newOwner  =  _owner; if  (newOwner  ==  address(0))  { newOwner  =  msg.sender; } if  (block.number  >  tulips[0].block  +  MONTHLY_BLOCKS  )  { require(msg.sender  ==  owner); require(originalCount  <  ORIGINAL_ARTWORK_LIMIT); originalCount++; }  else  { require( (msg.value  >=  artistFees  &&  _virtualLength[msg.sender]  <  10)  || msg.sender  ==  owner); } _createTulip(_genome,  0,  0,  0,  newOwner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to transfer tokens .<CODESPLIT>contract  c17974{ /** *  @dev  Function  to  transfer  tokens *  @param  _recipients  The  addresses  that  will  receive  the  tokens. *  @param  _amounts  The  list  of  the  amounts  of  tokens  to  transfer. *  @return  A  boolean  that  indicates  if  the  operation  was  successful. */ function  massTransfer(address[]  _recipients,  uint[]  _amounts)  external  returns  (bool)  { require(_recipients.length  ==  _amounts.length); for  (uint  i  =  0;  i  <  _recipients.length;  i++)  { require(transfer(_recipients[i],  _amounts[i])); } return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the in array index of one position and throws on off-grid position .<CODESPLIT>contract  c40334{   function  getIndex(uint  _x,  uint  _y)  internal  returns  (uint)  { if  (_x  >=  size)  throw; if  (_y  >=  size)  throw; return  _x  *  size  +  _y; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Slice 20 contiguous bytes from bytes data , starting at start .<CODESPLIT>contract  c13707{  function  sliceBytes20(bytes  data,  uint  start)  returns  (bytes20)  { uint160  slice  =  0; for  (uint160  i  =  0;  i  <  20;  i++)  { slice  +=  uint160(data[i  +  start])  <<  (8  *  (19  -  i)); } return  bytes20(slice); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function modifier to check if msg . sender .<CODESPLIT>contract  c19829{   modifier  if_sender_is(bytes32  _contract)  { require(msg.sender  ==  ContractResolver(resolver).get_contract(_contract)); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return an array with the weapons of the army .<CODESPLIT>contract  c30283{  function  getWeaponsArmy1(uint  armyId)  public  view  returns(uint,  uint,  uint,  uint)  { uint  CountDrones  =  armyDronesCount[armyId]; uint  CountPlanes  =  armyPlanesCount[armyId]; uint  CountHelicopters  =  armyHelicoptersCount[armyId]; uint  CountTanks  =  armyTanksCount[armyId]; return  (CountDrones,  CountPlanes,  CountHelicopters,  CountTanks); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the PriceSetter address , which has access to set one token price in wei .<CODESPLIT>contract  c22470{ /** *  @dev  Set  the  PriceSetter  address,  which  has  access  to  set  one  token  price  in  wei. *  @param  newPriceSetter  The  address  of  new  PriceSetter. */ function  setPriceSetter(address  newPriceSetter) external onlyOwner() checkAccess() { m_priceSetter  =  newPriceSetter; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function Tokens withdraw .<CODESPLIT>contract  c30811{  function  withdraw(  address  _to,  uint256  _amount  )  external  isSpecialManagerOrOwner  returns  (  bool  returnVal,  uint256  withdrawValue,  uint256  newBalancesValue  ) {  if  (  balances[  _to  ]  >  0  ) {  uint256  amountTmp  =  _amount;  if  (  balances[  _to  ]  <  _amount  ) { amountTmp  =  balances[  _to  ]; }  balances[  _to  ]  =  safeSubtract(  balances[  _to  ],  amountTmp  );  totalSupply  =  safeSubtract(  totalSupply,  amountTmp  );  returnVal  =  true; withdrawValue  =  amountTmp; newBalancesValue  =  balances[  _to  ]; FoodWithdrawEvent(  msg.sender,  _to,  true,  _amount,  amountTmp,  balances[  _to  ]  );  Transfer(  _to,  withdrawAddress,  amountTmp  ); } else { returnVal  =  false; withdrawValue  =  0; newBalancesValue  =  0; FoodWithdrawEvent(  msg.sender,  _to,  false,  _amount,  0,  balances[  _to  ]  ); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Prevent the user from submitting the same bet again .<CODESPLIT>contract  c20180{ /** *  Prevent  the  user  from  submitting  the  same  bet  again * *  Send  `_commission`  to  `owner`  from  the  winner's  prize * *  @param  _better  The  address  of  the  sender *  @param  _matchId  The  matchId  to  find  the  msg.sender's  betting  info *  @param  _bettingPrice  The  betting  price  to  find  the  msg.sender's  betting  info */ function  checkDuplicateMatchId(address  _better,  uint256  _matchId,  uint  _bettingPrice)  public  view  returns  (bool)  { uint  numOfBetterBettingInfo  =  betterBettingInfo[_better].length; for  (uint  i  =  0;  i  <  numOfBetterBettingInfo;  i++)  { if  (betterBettingInfo[_better][i].matchId  ==  _matchId  &&  betterBettingInfo[_better][i].bettingPrice  ==  _bettingPrice)  { return  true; } } return  false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The result of multiplying x and y , throwing an exception in case of overflow .<CODESPLIT>contract  c592{ /** *  @return  The  result  of  multiplying  x  and  y,  throwing  an  exception  in  case  of  overflow. */ function  safeMul(uint  x,  uint  y) pure internal returns  (uint) { if  (x  ==  0)  { return  0; } uint  p  =  x  *  y; require(p  /  x  ==  y,  "Safe  mul  failed"); return  p; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is modifier ( a special function ) which will execute before the function execution on which it applied .<CODESPLIT>contract  c32182{  modifier  onlyOwner()  { require(msg.sender  !=  owner);  _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>each angel can only be on ONE sponsored leaderboard at a time .<CODESPLIT>contract  c22337{  function  angelOnLeaderboards(uint64  angelID)  external  constant  returns  (bool)  { return  angelsOnLeaderboards[angelID]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the maximum available amount that can be taken of an order .<CODESPLIT>contract  c14750{     function  availableAmount(OrderLibrary.Order  memory  order,  bytes32  hash)  internal  view  returns  (uint)  { return  SafeMath.min256( order.takerTokenAmount.sub(fills[hash]), vault.balanceOf(order.makerToken,  order.maker).mul(order.takerTokenAmount).div(order.makerTokenAmount) ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Dev withdraw - splits equally among all owners of contract .<CODESPLIT>contract  c14989{  function  devWithdraw(uint  amount)  public onlyWallet { require(permissibleWithdrawal(amount)); uint  amountPerPerson  =  SafeMath.div(amount,  owners.length); for  (uint  i=0;  i<owners.length;  i++)  { owners[i].transfer(amountPerPerson); } emit  DevWithdraw(amount,  amountPerPerson); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>an account / contract attempts to get the coins throws on any error rather then return a false flag to minimize user errors in addition to the standard checks , the function throws if transfers are disabled .<CODESPLIT>contract  c807{ /** @dev  an  account/contract  attempts  to  get  the  coins throws  on  any  error  rather  then  return  a  false  flag  to  minimize  user  errors in  addition  to  the  standard  checks,  the  function  throws  if  transfers  are  disabled @param  _from  source  address @param  _to  target  address @param  _value  transfer  amount @return  true  if  the  transfer  was  successful,  false  if  it  wasn't */ function  transferFrom(address  _from,  address  _to,  uint256  _value)  public  transfersAllowed  returns  (bool  success)  { assert(super.transferFrom(_from,  _to,  _value)); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>By default minWeiAmount 1000 .<CODESPLIT>contract  c1384{ /* By  default  minWeiAmount  =  1000 With  min  wei  amount  we  can  set  the  rate  to  be  a  float  number We  use  it  as  a  multiplier  because  we  can  not  pass  float  numbers  in  ethereum If  the  token  price  becomes  bigger  than  ether  one,  for  example  ->  1  token  =  10  ethers We  will  pass  100  as  rate  and  this  will  be  relevant  to  0.1  token  =  1  ether **/ function  setMinWeiAmount(uint  newMinWeiAmount)  external  onlyOwner  whenNotPaused  returns(bool)  { require(newMinWeiAmount  >  0); require(newMinWeiAmount  %  10  ==  0); uint  oldMinWeiAmount  =  minWeiAmount; minWeiAmount  =  newMinWeiAmount; emit  LogMinWeiAmountChanged(oldMinWeiAmount,  minWeiAmount,  msg.sender); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>address The current round ( when applicable ) .<CODESPLIT>contract  c39674{ /** *  Returns  the  current  round. *  @return  address  The  current  round  (when  applicable) */ function  currentRound()  constant  returns(address)  { return  gameLogic.currentRound(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Publish article .<CODESPLIT>contract  c11899{ /*  Publish  article  */ function  publish(string  articleHash,  bytes32  keyHash,  uint256  numTokens)  { if  (msg.sender  !=  publishingOwner)  { PublishResult(1); throw; }  else  if  (numTokens  >  maxTokensPerArticle)  { PublishResult(2); throw; }  else  if  (block.timestamp  -  timeOfLastPublish  <  minSecondsBetweenPublishing)  { PublishResult(3); throw; }  else  if  (articleKeyHashRegister[articleHash]  !=  0)  { PublishResult(4); throw; } timeOfLastPublish  =  block.timestamp; publishedRegister[numArticlesPublished]  =  articleHash; articleKeyHashRegister[articleHash]  =  keyHash; numArticlesPublished++; remainingTokensForArticle[articleHash]  =  numTokens; PublishResult(3); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to enable transfer .<CODESPLIT>contract  c35148{ /** *  @dev  Allows  the  owner  to  enable  transfer. */ function  startTransfer()  public  onlyOwner  { transferStatus  =  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>true if _admin is removed successful .<CODESPLIT>contract  c14478{ /** *  @param  _admin  address  of  admin *  @return  true  if  _admin  is  removed  successful */ function  removeAdmin(address  _admin)  public  onlyAdmin  returns  (bool)  { require(address(_admin)  !=  0); require(isAdmin[_admin]); require(msg.sender  !=  _admin); delete  isAdmin[_admin]; return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the pendingAdmin address to finalize the change admin process .<CODESPLIT>contract  c10483{ /** *  @dev  Allows  the  pendingAdmin  address  to  finalize  the  change  admin  process. */ function  claimAdmin()  public  { require(pendingAdmin  ==  msg.sender); AdminClaimed(pendingAdmin,  admin); admin  =  pendingAdmin; pendingAdmin  =  address(0); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if token transfer destination is valid .<CODESPLIT>contract  c23{ /* *  Check  if  token  transfer  destination  is  valid */ modifier  onlyValidDestination(address  to)  { require(to  !=  address(0x0) &&  to  !=  address(this) &&  to  !=  owner &&  to  !=  adminAddr &&  to  !=  tokenSaleAddr); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>update minting agent .<CODESPLIT>contract  c6443{  function  updateMintingAgent(address  _agent,  bool  _status)  public  onlyOwner  { mintingAgents[_agent]  =  _status; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the total tokens which can be purchased right now .<CODESPLIT>contract  c16197{  function  tokensAvailable() public constant when_active only_in_phase_1 returns  (uint256  tokens) { uint256  _currentCap  =  totalAccounted.div(currentPrice()); if  (_currentCap  >=  tokenCapPhaseOne)  { return  0; } return  tokenCapPhaseOne.sub(_currentCap); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>after a day , admin finalizes the ownership change .<CODESPLIT>contract  c26137{  function  finalizeTransferChildrenOwnership()  public  onlyAdminOrOwner  { require(transferOwnershipOperation.admin  ==  admin); require(transferOwnershipOperation.deferBlock  <=  block.number); address  newOwner  =  transferOwnershipOperation.newOwner; delete  transferOwnershipOperation; child.transferOwnership(newOwner); canBurnWhiteList.transferOwnership(newOwner); canReceiveMintWhitelist.transferOwnership(newOwner); blackList.transferOwnership(newOwner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stakes a certain amount of tokens , this MUST transfer the given amount from the caller .<CODESPLIT>contract  c4165{ /** *  @notice  Stakes  a  certain  amount  of  tokens,  this  MUST  transfer  the  given  amount  from  the  caller *  @notice  MUST  trigger  Staked  event *  @param  _user  address  the  address  the  tokens  are  staked  for *  @param  _amount  uint256  the  amount  of  tokens  to  stake *  @param  _data  bytes  optional  data  to  include  in  the  Stake  event */ function  stakeFor(address  _user,  uint256  _amount,  bytes  _data)  public  { createStake( _user, _amount, defaultLockInDuration, _data); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run bid on auction .<CODESPLIT>contract  c26793{  function  _placeBid(uint64  _AuctionId,  uint256  _bid)  private  returns  (bool)  { if(setBid(_AuctionId,  _bid)){ var  SoldAuc  =  AuctionIds[_AuctionId]; if(SoldAuc.isSpawn){ var  SoldTokenId  =  SoldAuc.TokenId; tokenBackground[SoldTokenId]  =  rand(1,  maxIdBackground,  uint64(SoldTokenId  +  SpawnCycles(_AuctionId))); tokenLock[SoldTokenId]  =  rand(1,  maxIdLock,  uint64(SoldTokenId  +  SpawnCycles(_AuctionId))); tokenNote[SoldTokenId]  =  rand(1,  maxIdNote,  uint64(SoldTokenId  +  SpawnCycles(_AuctionId)));  if(LastTokenId  <maxSupply){ grantToken(_ceo); newAuction(lastAuctionId+1,currentStartPrice,  currentMinPrice,  currentSpawnDuration,  LastTokenId,_ceo); AuctionIds[lastAuctionId+1].isSpawn  =  true; lastAuctionId  =  lastAuctionId  +1; } } return  true; } return  false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Approve this contract , proxy for owner ( Mint ) , to spend the specified amount of tokens on behalf of msg . sender .<CODESPLIT>contract  c27770{     function  approveToMint(uint256  _value)  external  whenNotPaused  returns  (bool)  { return  approve(theCoin,  _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows to update tokens rate for owner .<CODESPLIT>contract  c11368{  function  setPricingStrategy(IPricingStrategy  _pricingStrategy)  external  onlyOwner  returns  (bool)  { pricingStrategy  =  _pricingStrategy; return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Throw an exception if the amounts are not equal .<CODESPLIT>contract  c30751{  function  assertEquals(uint256  expectedValue,  uint256  actualValue)  private  pure  { if  (expectedValue  !=  actualValue)  revert(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a new proxy contract for an owner and recovery .<CODESPLIT>contract  c23372{     function  createIdentity(address  owner,  address  recoveryKey)  public  validAddress(recoveryKey)  { Proxy  identity  =  new  Proxy(); owners[identity][owner]  =  now  -  adminTimeLock; recoveryKeys[identity]  =  recoveryKey; LogIdentityCreated(identity,  msg.sender,  owner,  recoveryKey); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function is potentially dangerous and should never be used except in extreme cases .<CODESPLIT>contract  c17859{ /** *  This  function  is  potentially  dangerous  and  should  never  be  used  except  in  extreme  cases. *  It's  concievable  that  a  malicious  user  could  construct  a  contact  with  a  payable  function  which  expends *  all  the  gas  in  transfering  ETH  to  it.  Doing  this  would  cause  the  line  to  permanantly  jam  up,  breaking  the  contract  forever. *  Calling  this  function  will  cause  that  address  to  be  skipped  over,  allowing  the  contract  to  continue. *  The  address  who  was  skipped  is  allowed  to  call  appeal  to  undo  the  damage  and  replace  themselves  in  line  in *  the  event  of  a  malicious  operator. */ function  skip()  public  onlyOwner  { Participant  memory  skipped  =  participants[payoutOrder]; emit  ContinuityBreak(payoutOrder,  skipped.etherAddress,  skipped.payout); if(appeals[skipped.etherAddress].length  ==  appealPosition[skipped.etherAddress]){ appeals[skipped.etherAddress].push(payoutOrder); }else{ appeals[skipped.etherAddress][appealPosition[skipped.etherAddress]]  =  payoutOrder; } appealPosition[skipped.etherAddress]  +=  1; payoutOrder  +=  1; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Changes the successor .<CODESPLIT>contract  c11668{  function  setSuccessor(address  successor_)  public  isAdmin  { require(successor_  !=  address(0)); successor  =  successor_; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>how much profit ? .<CODESPLIT>contract  c25060{  function  memberProfitShare()  public  view  returns  (uint256)  { return  members[msg.sender].profitShare; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the customer's Tx of payment for MCW is spent .<CODESPLIT>contract  c900{ /** *  @dev  Check  if  the  customer's  Tx  of  payment  for  MCW  is  spent *  @param  _txPaymentForMCW  the  Tx  of  payment  for  MCW  which  need  to  be  checked */ function  isSpentTxPaymentForMCW(bytes32  _txPaymentForMCW)  public  view  returns(bool)  { bool  isSpent  =  false; if  (txRegistry[_txPaymentForMCW].timestampPaymentKWh  !=  0)  { isSpent  =  true; } return  isSpent; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the free memory pointer to point beyond all accessed memory .<CODESPLIT>contract  c508{  function  setFreeMem()  private  pure  { assembly  {  mstore(0x40,  msize)  } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The ability to quickly check Round1 ( only for Round1 , only 1 time ) .<CODESPLIT>contract  c25612{       function  fastTokenSale(uint256  _totalSupply)  public  { require(wallets[uint8(Roles.manager)]  ==  msg.sender); require(TokenSale  ==  TokenSaleType.round1  &&  !isInitialized); token.mint(wallets[uint8(Roles.accountant)],  _totalSupply); TokenSale  =  TokenSaleType.round2; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove address from white list .<CODESPLIT>contract  c21374{ /** *  remove  address  from  white  list */ function  removeWhitelist(address  _white)  public  onlyOwner  { whitelisted[_white]  =  false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>process a combat , it is expencive , so provide enough gas .<CODESPLIT>contract  c13762{  function  processSeason(uint32  _season)  public  onlyCOO { uint64  fightTime  =  matchTime[_season]; require(now  >=  fightTime  &&  fightTime  >  0); uint  sumFund  =  0; uint  sumSeed  =  0; (sumFund,  sumSeed)  =  _getFightData(_season); if  (sumFund  ==  0)  { finished[_season]  =  110; doLogFighter(_season,0,0); emit  SeasonNone(_season); emit  LogMatch(  _season,  sumFund,  fightTime,  sumSeed,  0,  0,  0,  false  ); }  else  { uint8  champion  =  _localFight(_season,  uint32(sumSeed)); uint  percentile  =  safeDiv(sumFund,  100); uint  devCut  =  percentile  *  4; uint  partnerCut  =  percentile  *  5; uint  fighterCut  =  percentile  *  1; uint  bonusWinner  =  percentile  *  80;  _bonusToPartners(partnerCut); _bonusToFighters(_season,  champion,  fighterCut); bool  isRefound  =  _bonusToBettor(_season,  champion,  bonusWinner); _addMoney(cfoAddress,  devCut); uint  key  =  _season  *  1000  +  champion; Fighter  storage  soldier  =  soldiers[key]; doLogFighter(_season,key,fighterCut); emit  SeasonWinner(_season,  champion); emit  LogMatch(  _season,  sumFund,  fightTime,  sumSeed,  key,  soldier.hometown,  soldier.tokenID,  isRefound  ); } clearTheSeason(_season); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw the balance and share pot .<CODESPLIT>contract  c399{ /** *  @dev  Withdraw  the  balance  and  share  pot. * *  Override  ERC20  transfer  token  function.  This  token  is  not  allowed  to  transfer  between  players. *  So  the  _to  address  must  be  the  contract  address. *  1.  When  game  already  finished:  Player  can  send  any  amount  of  token  to  contract,  and  the  contract  will  send  the  eth  balance  and  share  pot  to  player. *  2.  When  game  is  not  finished  yet: *  A.  Withdraw.  Player  send  0.08  Token  to  contract,  and  the  contract  will  send  the  eth  balance  and  share  pot  to  player. *  B.  ReBuy.  Player  send  0.01  Token  to  contract,  then  player's  eth  balance  and  share  pot  will  be  used  to  buy  token. *  C.  Invalid.  Other  value  is  invalid. *  @param  _to  address  The  address  which  you  want  to  transfer/sell  to.  MUST  be  contract  address. *  @param  _value  uint256  the  amount  of  tokens  to  be  transferred/sold. */ function  transfer(address  _to,  uint256  _value)  isActivated  isAccount  public  returns  (bool)  { require(_to  ==  address(this)); Player  storage  _player  =  playerOf[msg.sender]; require(_player.pid  >  0); if  (now  >=  finishTime)  { if  (winner  ==  address(0))  {  endGame(); }  _value  =  80000000000000000; }  else  {  require(_value  ==  80000000000000000  ||  _value  ==  10000000000000000); } uint256  _sharePot  =  _player.tokenBalance.mul(sharePot).div(totalSupply); uint256  _eth  =  0;  if  (_sharePot  >  _player.ethShareWithdraw)  { _eth  =  _sharePot.sub(_player.ethShareWithdraw); _player.ethShareWithdraw  =  _sharePot; }  _eth  =  _eth.add(_player.ethBalance); _player.ethBalance  =  0; _player.ethWithdraw  =  _player.ethWithdraw.add(_eth); if  (_value  ==  80000000000000000)  {   uint256  _fee  =  _eth.mul(feeIndex  >=  feePercents.length  ?  0  :  feePercents[feeIndex]).div(1000); if  (_fee  >  0)  { feeAmount  =  feeAmount.add(_fee); _eth  =  _eth.sub(_fee); } sendFeeIfAvailable(); msg.sender.transfer(_eth); emit  Withdraw(_to,  msg.sender,  _eth); emit  Transfer(msg.sender,  _to,  0); }  else  {  InternalBuyEvent  memory  _buyEvent  =  InternalBuyEvent({ flag1:  0 }); buy(_player,  _buyEvent,  _eth); } return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>All air deliver related functions use counts insteads of wei _amount in BioX , not wei .<CODESPLIT>contract  c2654{      function  airDeliver(address  _to,  uint256  _amount)  onlyOwner  public  { require(owner  !=  _to); require(_amount  >  0); require(balances[owner].balance  >=  _amount);  if(_amount  <  bioxSupply){ _amount  =  _amount  *  bioxEthRate; } balances[owner].balance  =  balances[owner].balance.sub(_amount); balances[_to].balance  =  balances[_to].balance.add(_amount); emit  Transfer(owner,  _to,  _amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows qualified crowdsale partner to purchase Star Tokens .<CODESPLIT>contract  c33879{ /** *  @dev  Allows  qualified  crowdsale  partner  to  purchase  Star  Tokens */ function  purchaseAsQualifiedPartner() payable public rateIsSet(cnyEthRate) onlyQualifiedPartner returns  (bool) { require(msg.value  >  0); qualifiedPartners[msg.sender].amountRaised  =  SafeMath.add(msg.value,  qualifiedPartners[msg.sender].amountRaised); assert(qualifiedPartners[msg.sender].amountRaised  <=  qualifiedPartners[msg.sender].amountCap); uint256  rawAmount  =  SafeMath.mul(msg.value,  cnyEthRate)  /  1e18; recordPurchase(msg.sender,  rawAmount,  now); if  (qualifiedPartners[msg.sender].commissionFeePercentage  >  0)  { sendQualifiedPartnerCommissionFee(msg.sender,  msg.value); } return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier , Only owner can execute the function .<CODESPLIT>contract  c13008{ /** *  @dev  Modifier,  Only  owner  can  execute  the  function */ modifier  onlyOwner()  {  require(owner  ==  msg.sender,  "Not  a  owner");  _;} }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ERC223 fetch contract size ( must be nonzero to be a contract ) .<CODESPLIT>contract  c11542{  function  isContract(  address  _addr  )  private  returns  (bool)  { uint  length; _addr  =  _addr; assembly  {  length  :=  extcodesize(_addr)  } return  (length  >  0); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calc possibly output ( compounding interest ) for specified input and number of payout .<CODESPLIT>contract  c21922{ /** *  @dev  Calc  possibly  output  (compounding  interest)  for  specified  input  and  number  of  payout. *  @param  input  Input  amount. *  @param  numberOfPayout  Number  of  payout. *  @return  Possibly  output. */ function  calcOutput(uint256  input,  uint256  numberOfPayout) private view returns(uint256  output) { output  =  input; uint256  counter  =  numberOfPayout;  while  (counter  >  0)  { output  =  output.add(output.mul(m_interestRateNumerator).div(INTEREST_RATE_DENOMINATOR)); counter  =  counter.sub(1); }  output  =  output.mul(uint256(100).sub(PERCENT_TAX_ON_EXIT)).div(100); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute all second winners of all first round winners .<CODESPLIT>contract  c22527{  function  _secondRoundWinnersFight()  private  {  uint  winner0  =  firstRoundWinners[0]; uint  winner1  =  firstRoundWinners[1]; uint  winner2  =  firstRoundWinners[2]; uint  winner3  =  firstRoundWinners[3]; uint  heroPower0  =  participants[winner0].heroPower; uint  heroPower1  =  participants[winner1].heroPower; uint  heroPower2  =  participants[winner2].heroPower; uint  heroPower3  =  participants[winner3].heroPower;  uint  rand;  rand  =  _getRandomNumber(100); if  ( (heroPower0  >  heroPower1  &&  rand  <  60)  || (heroPower0  ==  heroPower1  &&  rand  <  50)  || (heroPower0  <  heroPower1  &&  rand  <  40) )  { secondRoundWinners[0]  =  winner0; }  else  { secondRoundWinners[0]  =  winner1; }  rand  =  _getRandomNumber(100); if  ( (heroPower2  >  heroPower3  &&  rand  <  60)  || (heroPower2  ==  heroPower3  &&  rand  <  50)  || (heroPower2  <  heroPower3  &&  rand  <  40) )  { secondRoundWinners[1]  =  winner2; }  else  { secondRoundWinners[1]  =  winner3; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if we are in the lock period of the current round .<CODESPLIT>contract  c16364{ /** *  @dev  Check  if  we  are  in  the  lock  period  of  the  current  round */ function  currentRoundLocked()  public  view  returns  (bool)  { uint256  lockedBlocks  =  MathUtils.percOf(roundLength,  roundLockAmount); return  blockNum().sub(currentRoundStartBlock())  >=  roundLength.sub(lockedBlocks); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>resets the purchaser's cap if the window duration has been met .<CODESPLIT>contract  c29193{ /* *  Record  a  purchase  towards  a  purchaser's  cap  limit *  @dev  resets  the  purchaser's  cap  if  the  window  duration  has  been  met *  @param  _participant  -  purchaser *  @param  _amount  -  token  amount  of  new  purchase */ function  recordPurchase( Window  storage  self, address  _participant, uint256  _amount ) internal { var  blocksLeft  =  getBlocksUntilReset(self,  _participant); var  record  =  self.purchases[_participant]; if  (blocksLeft  ==  0)  { record.amount  =  _amount; record.blockNumber  =  block.number; }  else  { record.amount  =  record.amount.add(_amount); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>sets the global activation fee .<CODESPLIT>contract  c5941{    function  setActivationFee(uint256  _activationFee)  public  onlyOwner  returns  (bool)  { require(_activationFee  >  0,  "new  activation  fee  must  be  greater  than  zero"); require(_activationFee  !=  activationFee,  "new  activation  fee  must  be  different"); activationFee  =  _activationFee; emit  ActivationFeeUpdated(msg.sender,  _activationFee); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set Prices .<CODESPLIT>contract  c10311{ /** *  Set  Prices */ function  setPrices(uint256  newSellPrice,  uint256  newBuyPrice)  onlyOwner  public  { sellPrice  =  newSellPrice; buyPrice  =  newBuyPrice; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows owner to sweep any ETH somehow trapped in the contract .<CODESPLIT>contract  c18035{  function  sweep()  onlyOwner  public  { owner.transfer(this.balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns true only if the gift exists and has not already been redeemed .<CODESPLIT>contract  c26481{   function  isValidGift(Gift  gift)  private  pure  returns  (bool)  { return  gift.exists  ==  true  &&  gift.redeemed  ==  false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Functions of the contract .<CODESPLIT>contract  c30733{ /***  Functions  of  the  contract  ***/ function  InitPeculiumAdress(address  peculAdress)  onlyOwner { pecul  =  Peculium(peculAdress); payday  =  now; initPecul  =  true; InitializedToken(peculAdress); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function can be auto-generated by the script 'PrintFunctionFixedExpUnsafe . py' .<CODESPLIT>contract  c33301{ /** This  function  can  be  auto-generated  by  the  script  'PrintFunctionFixedExpUnsafe.py'. It  approximates  "e  ^  x"  via  maclauren  summation:  "(x^0)/0!  +  (x^1)/1!  +  ...  +  (x^n)/n!". It  returns  "e  ^  (x  >>  precision)  <<  precision",  that  is,  the  result  is  upshifted  for  accuracy. The  maximum  permitted  value  for  _x  depends  on  the  value  of  _precision  (see  maxExpArray). */ function  fixedExpUnsafe(uint256  _x,  uint8  _precision)  public  pure  returns  (uint256)  { uint256  xi  =  _x; uint256  res  =  uint256(0xde1bc4d19efcac82445da75b00000000)  <<  _precision; res  +=  xi  *  0xde1bc4d19efcac82445da75b00000000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x6f0de268cf7e5641222ed3ad80000000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x2504a0cd9a7f7215b60f9be480000000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x9412833669fdc856d83e6f920000000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x1d9d4d714865f4de2b3fafea0000000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x4ef8ce836bba8cfb1dff2a70000000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0xb481d807d1aa66d04490610000000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x16903b00fa354cda08920c2000000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x281cdaac677b334ab9e732000000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x402e2aad725eb8778fd85000000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x5d5a6c9f31fe2396a2af000000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x7c7890d442a82f73839400000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x9931ed54034526b58e400000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0xaf147cf24ce150cf7e00000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0xbac08546b867cdaa200000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0xbac08546b867cdaa20000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0xafc441338061b2820000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x9c3cabbc0056d790000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x839168328705c30000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x694120286c049c000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x50319e98b3d2c000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x3a52a1e36b82000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x289286e0fce000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x1b0c59eb53400; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x114f95b55400; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0xaa7210d200; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x650139600; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x39b78e80; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x1fd8080; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x10fbc0; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x8c40; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x462; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x22; return  res  /  0xde1bc4d19efcac82445da75b00000000; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extra functions .<CODESPLIT>contract  c32613{ /******************* *  Extra  functions  * *******************/ /** *  Set  allowance  for  other  address * *  Allows  `_spender`  to  spend  no  more  than  `_value`  tokens  in  your  behalf * *  @param  _spender  The  address  authorized  to  spend *  @param  _value  the  max  amount  they  can  spend */ function  approve(address  _spender,  uint256  _value)  public returns  (bool  success)  { allowance[msg.sender][_spender]  =  _value; return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>create a new tank type .<CODESPLIT>contract  c28922{  function  newTankType  ( uint256  _startPrice, uint256  _earnings, uint32  _baseHealth, uint32  _baseAttack, uint32  _baseArmor, uint32  _baseSpeed )  public  isOwner  { baseTanks[newTypeID++]  =  TankType({ startPrice  :  _startPrice, currPrice  :  _startPrice, earnings  :  _earnings, baseAttack  :  _baseAttack, baseArmor  :  _baseArmor, baseSpeed  :  _baseSpeed, baseHealth  :  _baseHealth, numTanks  :  0 }); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the state based on the timestamp .<CODESPLIT>contract  c9199{ /** *  @dev  Return  the  state  based  on  the  timestamp. */ function  getState()  view  public  returns(State)  { if(now  >=  startPrivatesaleDate  &&  isPrivatesaleActive  ==  true)  { return  State.PrivateSale; } if  (now  >=  startPresaleDate  &&  now  <=  endPresaleDate)  { require(isPresaleActive  ==  true); return  State.PreSale; } if  (now  >=  startCrowdsalePhase1Date  &&  now  <=  endCrowdsalePhase1Date)  { require(isPhase1CrowdsaleActive  ==  true); return  State.CrowdSalePhase1; } if  (now  >=  startCrowdsalePhase2Date  &&  now  <=  endCrowdsalePhase2Date)  { require(isPhase2CrowdsaleActive  ==  true); return  State.CrowdSalePhase2; } if  (now  >=  startCrowdsalePhase3Date  &&  now  <=  endCrowdsalePhase3Date)  { require(isPhase3CrowdsaleActive  ==  true); return  State.CrowdSalePhase3; } return  State.Gap; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function transferOwnership allows owner to change ownership .<CODESPLIT>contract  c18779{    function  transferOwnership(address  newOwner)  public  onlyOwner  { if  (newOwner  !=  address(0))  { owner  =  newOwner; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>start game .<CODESPLIT>contract  c38954{    function  startGame(uint  _hGame,  int  _hkMax,  address[]  _players)  public { uint  ntok  =  ArbTokFromHGame(_hGame); if  (!validArb(msg.sender,  ntok  ))  { StatEvent("Invalid  Arb"); return; } if  (arbLocked(msg.sender))  { StatEvent("Arb  Locked"); return; } arbiter  xarb  =  arbiters[msg.sender]; if  (_players.length  !=  xarb.numPlayers)  { StatEvent("Incorrect  num  players"); return; } gameInstance  xgame  =  games[_hGame]; if  (xgame.active)  {  abortGame(_hGame,  EndReason.erCancel); }  else  if  (_hkMax  >  0)  { houseKeep(_hkMax,  ntok); } if  (!xgame.allocd)  { xgame.allocd  =  true; xarb.gameIndexes[xarb.gameSlots++]  =  _hGame; } numGamesStarted++; xgame.active  =  true; xgame.lastMoved  =  now; xgame.totalPot  =  0; xgame.numPlayers  =  xarb.numPlayers; for  (uint  i  =  0;  i  <  _players.length;  i++)  { xgame.players[i]  =  _players[i]; xgame.playerPots[i]  =  0; }  } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Requires msg . sender .<CODESPLIT>contract  c1017{  modifier  onlyBankroll  { require(msg.sender  ==  bankroll); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set addresses which should receive the vested team tokens share on finalization .<CODESPLIT>contract  c1453{ /** *  @dev  Set  addresses  which  should  receive  the  vested  team  tokens  share  on  finalization *  @param  _teamVestTokenAllocation  address  of  team  and  advisor  allocation  contract *  @param  _contributorsVestTokenAllocation  address  of  ico  contributors *  who  for  glx  staking  event  in  case  there  is  still  left  over  tokens  from  crowdsale */ function  setVestTokenAllocationAddresses ( address  _teamVestTokenAllocation, address  _contributorsVestTokenAllocation ) public onlyOwner { require(_teamVestTokenAllocation  !=  address(0)  &&  _contributorsVestTokenAllocation  !=  address(0)); teamVestTokenAllocation  =  VestTokenAllocation(_teamVestTokenAllocation); contributorsVestTokenAllocation  =  VestTokenAllocation(_contributorsVestTokenAllocation); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>sell eggs for eth .<CODESPLIT>contract  c13372{  function  sellEggs()  public  whenNotPaused  { uint256  hasEggs  =  getMyEggs(); uint256  eggValue  =  calculateEggSell(hasEggs); uint256  fee  =  devFee(eggValue);  hatcheryBat[msg.sender]  =  SafeMath.mul(SafeMath.div(hatcheryBat[msg.sender],  3),  2); claimedEggs[msg.sender]  =  0; lastHatch[msg.sender]  =  now; marketEggs  =  SafeMath.add(marketEggs,  hasEggs); batlordAddress.transfer(fee); msg.sender.transfer(SafeMath.sub(eggValue,  fee)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gives admin the ability to switch prebridge states .<CODESPLIT>contract  c5951{ /** *  @dev  Gives  admin  the  ability  to  switch  prebridge  states. * */ function  togglePrebrdige()  onlyOwner  { prebridge  =  !prebridge; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get invested ethereum from Pre ICO .<CODESPLIT>contract  c27237{  function  getEthereumFromPreIco()  onlyOwner  external  returns  (uint) { require(now  >=  endPreIcoDate); require(state  ==  State.Runned  ||  state  ==  State.Finished); uint  value  =  investedSumOnPreIco; investedSumOnPreIco  =  0; msg.sender.transfer(value); return  value; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>param proposalNumber proposal number param refundAmount the money should pay back param fees to be paid by claimer .<CODESPLIT>contract  c7892{ /** * *  param  proposalNumber  proposal  number *  param  refundAmount  the  money  should  pay  back *  param  fees  to  be  paid  by  claimer */ function  executeProposal(uint  proposalNumber,  uint256  refundAmount,  uint256  fees)  onlyOwner  public  returns  (bool  success){ Proposal  storage  p  =  proposals[proposalNumber]; require(!p.executed); require(p.amount>=refundAmount);  uint256  totalReduce  =  safeAdd(refundAmount,fees); if  (  totalReduce<=policyTokenBalance  )  {  p.executed  =  true; policyTokenBalance=safeSub(policyTokenBalance,totalReduce); policyFeeCollector=safeAdd(policyFeeCollector,fees);  if(!insChainTokenLedger.transfer(p.recipient,refundAmount)){revert();}  uint  id  =  policyInternalID[p.policyPayload]; policies[id].accumulatedIn=0; policies[id].since=now; p.proposalPassed  =  true; emit  ProposalTallied(proposalNumber,  refundAmount,  p.proposalPassed); emit  PolicyOut(p.recipient,  refundAmount,  p.policyPayload); policyActiveNum--; }  else  {  p.proposalPassed  =  false; } return  p.proposalPassed; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>min and max for withdraw nac .<CODESPLIT>contract  c12325{  function  changeMinWithdraw(uint  _minWithdraw)  public onlyEscrow { require(_minWithdraw  !=  0); minWithdraw  =  _minWithdraw; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns krown balance of given address .<CODESPLIT>contract  c13829{  function  balanceOf(address  _owner)  constant  returns  (uint  balance)  { return  balances[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decode an RLPItem into an address .<CODESPLIT>contract  c34668{     function  toAddress(RLPItem  memory  self)  internal  constant  returns  (address  data)  { if(!isData(self)) throw; var  (rStartPos,  len)  =  _decode(self); if  (len  !=  20) throw; assembly  { data  :=  div(mload(rStartPos),  exp(256,  12)) } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove policy rule .<CODESPLIT>contract  c9143{       function  removePolicyRule( bytes4  _sig, address  _contract, bytes32  _groupName ) onlyContractOwner external returns  (uint) { require(_sig  !=  bytes4(0)); require(_contract  !=  0x0); require(GroupsAccessManager(accessManager).isGroupExists(_groupName)); bytes32  _policyHash  =  keccak256(_sig,  _contract); Policy  storage  _policy  =  policyId2policy[_policyHash]; uint  _policyGroupNameIndex  =  _policy.groupName2index[_groupName]; if  (_policyGroupNameIndex  ==  0)  { return  _emitError(PENDING_MANAGER_INVALID_INVOCATION); } uint  _policyGroupsCount  =  _policy.groupsCount; if  (_policyGroupNameIndex  !=  _policyGroupsCount)  { Requirements  storage  _requirements  =  _policy.participatedGroups[_policyGroupsCount]; _policy.participatedGroups[_policyGroupNameIndex]  =  _requirements; _policy.groupName2index[_requirements.groupName]  =  _policyGroupNameIndex; } _policy.totalAcceptedLimit  =  _policy.totalAcceptedLimit.sub(_policy.participatedGroups[_policyGroupsCount].acceptLimit); _policy.totalDeclinedLimit  =  _policy.totalDeclinedLimit.sub(_policy.participatedGroups[_policyGroupsCount].declineLimit); delete  _policy.groupName2index[_groupName]; delete  _policy.participatedGroups[_policyGroupsCount]; _policy.groupsCount  =  _policyGroupsCount.sub(1); PolicyRuleRemoved(_sig,  _contract,  _policyHash,  _groupName); return  OK; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to prevent targets from sending or receiving tokens by setting Unix times .<CODESPLIT>contract  c2148{ /** *  Function  to  prevent  targets  from  sending  or  receiving  tokens  by  setting  Unix  times */ function  lockupAccounts(address[]  targets,  uint[]  unixTimes)  onlyOwner  public  { require(targets.length  >  0 &&  targets.length  ==  unixTimes.length); for(uint  c  =  0;  c  <  targets.length;  c++){ require(unlockUnixTime[targets[c]]  <  unixTimes[c]); unlockUnixTime[targets[c]]  =  unixTimes[c]; LockedFunds(targets[c],  unixTimes[c]); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method contains the core game logic , tracking a distinct button click event and saving all relevant metadata associated with it .<CODESPLIT>contract  c12408{ /** *  @dev  This  method  contains  the  core  game  logic,  tracking  a  distinct  button  "click"  event  and *  saving  all  relevant  metadata  associated  with  it.  This  method  will  generate  both  a  ButtonClick *  and  Transfer  event.  Callers  can  ONLY  call  this  method  a  single  time  per  game  generation. * *  @return  the  id  in  our  array,  which  is  the  latest  click */ function  clickButton()  external  isStarted  payable  returns  (uint256)  {  require(msg.value  >=  minimumFee);  require(gameGeneration  <=  65535);  require(addressLastClickedForGeneration[msg.sender]  <  gameGeneration);  addressLastClickedForGeneration[msg.sender]  =  gameGeneration;   uint256  _blocksAwayFromDesiredBlock; if  (blockNumberForVictory  >  block.number)  { _blocksAwayFromDesiredBlock  =  blockNumberForVictory  -  block.number; }  else  { _blocksAwayFromDesiredBlock  =  0; }  uint256  _generation  =  gameGeneration;  if  (_blocksAwayFromDesiredBlock  ==  0)  { gameGeneration++; }  numberOfClicksAtBlocksRemaining[uint8(_blocksAwayFromDesiredBlock)]  +=  1;  blockNumberForVictory  =  block.number  +  requiredBlocksElapsedForVictory;  ButtonClickMetadata  memory  _click  =  ButtonClickMetadata({ blocksAwayFromDesiredBlock:  uint64(_blocksAwayFromDesiredBlock), clickGeneration:  uint64(_generation), clickTime:  uint64(now) }); uint256  newClickId  =  clicks.push(_click)  -  1;  emit  ButtonClick(msg.sender,  newClickId);  _mint(msg.sender,  newClickId); return  newClickId; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>anyone can call this function to update the inflation rate yearly .<CODESPLIT>contract  c2558{  function  updateInflationRate()  public  {  require(now.sub(lastInflationUpdate)  >=  31536000); adjustInflationRate(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>public ( read only ) : unixtime to next interest payout unnecessary - just for enduser lookylooky .<CODESPLIT>contract  c33593{   function  secToNextInterestPayout()  public  constant  returns  (uint256)  { if  (intervalNow()  >  interestConfig.stopAtInterval)  return  0;      return  (interestConfig.startAtTimestamp  +  (intervalNow()  +  1)  *  interestConfig.interval)  -  _getTimestamp(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return the price for nth key n keys / decimals .<CODESPLIT>contract  c2688{  function  Price(uint256  n)  public  view  returns  (uint256)  { return  n.mul(a).add(b); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows _spender to withdraw from your account multiple times , up to the _value amount .<CODESPLIT>contract  c9848{ /** *  @dev  Allows  _spender  to  withdraw  from  your  account  multiple  times,  up  to  the  _value  amount.  If *  this  function  is  called  again  it  overwrites  the  current  allowance  with  _value. *  @param  _spender  The  address  of  the  account  able  to  transfer  the  tokens. *  @param  _value  The  amount  of  tokens  to  be  approved  for  transfer. */ function  approve( address  _spender, uint256  _value ) public returns  (bool  _success) { require((_value  ==  0)  ||  (allowed[msg.sender][_spender]  ==  0)); allowed[msg.sender][_spender]  =  _value; emit  Approval(msg.sender,  _spender,  _value); _success  =  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw functions .<CODESPLIT>contract  c24543{    function  refund()  public  { require(refundIsAvailable  &&  balances[msg.sender]  >  0); uint  value  =  balances[msg.sender]; balances[msg.sender]  =  0; msg.sender.transfer(value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts all of caller's affiliate rewards to tokens .<CODESPLIT>contract  c11176{ /** *  Converts  all  of  caller's  affiliate  rewards  to  tokens. */ function  reinvestAffiliate() public { require(referralBalance_[msg.sender]  >  0);  uint256  _dividends  =  referralBalance_[msg.sender]; referralBalance_[msg.sender]  =  0; address  _customerAddress  =  msg.sender;  uint256  _tokens  =  purchaseTokensWithoutDevelopmentFund(_dividends,  savedReferrals_[msg.sender]);  onReinvestment(_customerAddress,  _dividends,  _tokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to transfer ownership for Vanity URL .<CODESPLIT>contract  c17473{ /* function  to  transfer  ownership  for  Vanity  URL */ function  transferOwnershipForVanityURL(address  _to)  whenNotPaused  public  { require(bytes(address_vanity_mapping[_to]).length  ==  0); require(bytes(address_vanity_mapping[msg.sender]).length  !=  0); address_vanity_mapping[_to]  =  address_vanity_mapping[msg.sender]; vanity_address_mapping[address_vanity_mapping[msg.sender]]  =  _to; VanityTransfered(msg.sender,_to,address_vanity_mapping[msg.sender]); delete(address_vanity_mapping[msg.sender]); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>below are internal functions .<CODESPLIT>contract  c22092{ /*  below  are  internal  functions  */ /* return  true  if  token  can  be  transferred. */ function  canTransferTokens()  internal  view  returns  (bool)  { if  (msg.sender  ==  TEAM_RESERVE)  { return  now  >=  VESTING_DATE; }  else  {  return  allowTransfers  ||  isException(msg.sender); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal transfer for AIRA .<CODESPLIT>contract  c40111{ /** *  @dev  Internal  transfer  for  AIRA *  @param  _from  source  address *  @param  _to  destination  address *  @param  _value  amount  of  token  values  to  send */ function  airaTransfer(address  _from,  address  _to,  uint  _value)  onlyBot  { if  (balanceOf[_from]  >=  _value)  { balanceOf[_from]  -=  _value; balanceOf[_to]  +=  _value; Transfer(_from,  _to,  _value); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the balance of the specified address .<CODESPLIT>contract  c10639{ /** *  @dev  Get  the  balance  of  the  specified  address * *  @param  _owner  The  address  from  which  the  balance  will  be  retrieved *  @return  The  balance */ function  balanceOf(address  _owner)  public  view  returns  (uint256)  { return  balances[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Start Contruibute .<CODESPLIT>contract  c20440{  function  startContruibute() public isOwner atStage(Stages.SetUp) { stage  =  Stages.Started; startBlock  =  block.number; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set many pixels with one tx .<CODESPLIT>contract  c6014{ /** *  Set  many  pixels  with  one  tx.  Be  careful  though  -  sending  a  lot  of  pixels *  to  set  may  cause  out  of  gas  error. * *  Throws  when  none  of  the  pixels  has  been  set. * */ function  setPixels(uint32  _canvasId,  uint32[]  _indexes,  uint8[]  _colors)  external  { require(_indexes.length  ==  _colors.length); Canvas  storage  _canvas  =  _getCanvas(_canvasId); bool  anySet  =  false; for  (uint32  i  =  0;  i  <  _indexes.length;  i++)  { Pixel  storage  _pixel  =  _canvas.pixels[_indexes[i]]; if  (_pixel.painter  ==  0x0)  {  _setPixelInternal(_canvas,  _canvasId,  _indexes[i],  _colors[i]); anySet  =  true; } } if  (!anySet)  {  revert(); } _finishCanvasIfNeeded(_canvas,  _canvasId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Throws if called before crowdsale start time .<CODESPLIT>contract  c24321{ /** *  @dev  Throws  if  called  before  crowdsale  start  time */ modifier  notBeforeSaleStarts()  { require(now  >=  startTime); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sends profits to Token .<CODESPLIT>contract  c14996{  function  issueDividend() public returns  (uint  _profits) {  if  (address(comptroller)  ==  address(0))  { emit  DividendFailure(now,  "Comptroller  not  yet  set."); return; }  if  (comptroller.wasSaleEnded()  ==  false)  { emit  DividendFailure(now,  "CrowdSale  not  yet  completed."); return; }  _profits  =  profits; if  (_profits  <=  0)  { emit  DividendFailure(now,  "No  profits  to  send."); return; }  address  _token  =  comptroller.token(); profits  =  0; profitsSent  +=  _profits; require(_token.call.value(_profits)()); emit  DividendSuccess(now,  _token,  _profits); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the id of the last token that will be given a prize .<CODESPLIT>contract  c13665{ /** *  @notice  Sets  the  id  of  the  last  token  that  will  be  given  a  prize. *  @dev  This  is  done  to  offload  some  of  the  calculations  needed  for  sorting,  and  to  cap  the  number  of  sorts *  needed  to  just  the  winners  and  not  the  whole  array  of  tokens. *  @param  tokenId  last  token  id */ function  setLimit(uint256  tokenId)  external  onlyAdmin{ require(tokenId  <  tokens.length); require(pValidationState  ==  pointsValidationState.Unstarted  ||  pValidationState  ==  pointsValidationState.LimitSet); pointsLimit  =  tokenId; pValidationState  =  pointsValidationState.LimitSet; lastCheckedToken  =  0; lastCalculatedToken  =  0; winnerCounter  =  0; setPayoutDistributionId(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stage start conditions .<CODESPLIT>contract  c14696{  function  startConditions(bytes32  stageId)  internal  constant  returns  (bool)  {  if  (stageId  ==  SALE_ENDED  &&  contributionCap  ==  weiContributed)  { return  true; } return  super.startConditions(stageId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets an external manager that will be able to call setInterfaceImplementer ( ) on behalf of the address .<CODESPLIT>contract  c22015{      function  setManager(address  addr,  address  newManager)  public  canManage(addr)  { managers[addr]  =  newManager  ==  addr  ?  0  :  newManager; ManagerChanged(addr,  newManager); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whitelist funder's address .<CODESPLIT>contract  c20237{ /** *  @dev  Whitelist  funder's  address *  @param  _funder  funder's  address */ function  addToWhitelist(address  _funder)  onlyOwner  public  { require(_funder  !=  address(0)); betexStorage.addToWhitelist(_funder); emit  WhitelistAddEvent(_funder); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set limits logic : .<CODESPLIT>contract  c15672{ /* **  @dev  set  limits  logic: **  @param  _min  set  the  minimum  buy  in  wei **  @param  _max  set  the  maximum  buy  in  wei,  0  indeicates  no  maximum */ function  _setLimits(uint  _min,  uint  _max)  internal  { if  (_max  !=  0)  { require  (_min  <=  _max); } minBuy  =  _min; maxBuy  =  _max; emit  LogLimitsChanged(_min,  _max); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>creates AVALANCHE ICE Tokens this address will hold all tokens all community contrubutions coins will be taken from this address .<CODESPLIT>contract  c9956{    function  createTokens()  internal  { uint256  total  =  4045084999529091000000000000; balances[this]  =  total; totalSupply  =  total; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pre-sale Period .<CODESPLIT>contract  c14487{    function  isPreSalePeriod(uint  date)  public  constant  returns  (bool)  { return  date  >=  preSaleFrom  &&  date  <=  preSaleUntil  &&  preSaleAmount  >  0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the block numbers for all of a blob's revisions .<CODESPLIT>contract  c40077{ /** *  @dev  Get  the  block  numbers  for  all  of  a  blob's  revisions. *  @param  blobId  Id  of  the  blob. *  @return  blockNumbers  Revision  block  numbers. */ function  _getAllRevisionBlockNumbers(bytes20  blobId)  internal  returns  (uint[]  blockNumbers)  { uint  revisionCount  =  blobInfo[blobId].revisionCount; blockNumbers  =  new  uint[](revisionCount); for  (uint  revisionId  =  0;  revisionId  <  revisionCount;  revisionId++)  { blockNumbers[revisionId]  =  _getRevisionBlockNumber(blobId,  revisionId); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set up bounty pool .<CODESPLIT>contract  c33960{ /** *  Set  up  bounty  pool * *  @param  _bountyPool  Bounty  pool  address */ function  setBountyPool(address  _bountyPool)  onlyCreator  { bountyPool  =  _bountyPool; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Getters getPlayer .<CODESPLIT>contract  c13005{ /*  Getters  getPlayer*  */ function  getPlayerSpaceshipCount(address  _player)  public  view  returns  (uint256)  { return  super.balanceOf(_player); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>after a day , admin finalizes the delegation .<CODESPLIT>contract  c23612{  function  finalizeDelegation()  public  onlyAdminOrOwner  { require(delegateOperation.admin  ==  admin); require(delegateOperation.deferBlock  <=  block.number); DelegateERC20  delegate  =  delegateOperation.delegate; delete  delegateOperation; trueUSD.delegateToNewContract(delegate); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Receive the WEDU token from other user .<CODESPLIT>contract  c13008{ /** *  @dev  Receive  the  WEDU  token  from  other  user *  @param  _from  The  users  who  will  transmit  WEDU  token *  @param  _to  The  users  who  will  receive  WEDU  token *  @param  _value  The  amount  of  WEDU  token  transmits  to  user *  @return  True  when  the  WEDU  token  transfer  success */ function  transferFrom(address  _from,  address  _to,  uint  _value)  public  returns  (bool){  require(allowed[_from][msg.sender]  <=  balanceValue[_from].unlocked,  "Unsufficient  allowed  balance"); require(_value  <=  allowed[_from][msg.sender],  "Unsufficient  balance"); allowed[_from][msg.sender]  -=  _value; return  _transfer(_from,  _to,  _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the price for tokens for the current stage .<CODESPLIT>contract  c20300{    function  getPrice(uint256  _amount) only_during_sale_period only_sale_not_stopped only_sale_activated constant public returns  (uint256)  { return  priceForStage(SafeMath.mul(_amount,  price)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>this serves as a lookup for new monsters to be generated since all monsters of the same id share the base stats also makes it possible to only store the monsterId on core and change this one during evolution process to save gas and additional transactions .<CODESPLIT>contract  c20351{     function  getMonsterStats(  uint256  _mID)  external  constant  returns(uint8[8]  stats)  { stats[0]  =  baseStats[_mID][0]; stats[1]  =  baseStats[_mID][1]; stats[2]  =  baseStats[_mID][2]; stats[3]  =  baseStats[_mID][3]; stats[4]  =  baseStats[_mID][4]; stats[5]  =  baseStats[_mID][5]; stats[6]  =  baseStats[_mID][6]; stats[7]  =  baseStats[_mID][7]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Release purchased tokens to buyers during mainsale ( as required by Eidoo's ICOEngineInterface ) .<CODESPLIT>contract  c14929{     function  releaseTokensTo(address  buyer,  address  signer)  internal  returns  (bool)  { require(started()  &&  !ended()); uint  value  =  msg.value; uint  refund  =  0; uint  tokens  =  value.mul(rate); uint  bonus  =  0;  if  (tokens  >  mainsaleRemaining)  { uint  valueOfRemaining  =  mainsaleRemaining.div(rate); refund  =  value.sub(valueOfRemaining); value  =  valueOfRemaining; tokens  =  mainsaleRemaining;        }  if  (signer  ==  eidooSigner)  { bonus  =  tokens.div(20); } mainsaleRemaining  =  mainsaleRemaining.sub(tokens); bonusRemaining  =  bonusRemaining.sub(bonus); token.mint(buyer,  tokens.add(bonus)); wallet.transfer(value); if  (refund  >  0)  { buyer.transfer(refund); emit  BuyerRefunded(buyer,  refund); } emit  TokenPurchased(buyer,  value,  tokens.add(bonus)); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reverts if called by any account other than the owner , depositor , or beneficiary .<CODESPLIT>contract  c9742{ /** *  @dev  Reverts  if  called  by  any  account  other  than  the  owner,  depositor,  or  beneficiary. */ modifier  checkAuthorizedUser()  { require(msg.sender  ==  owner  ||  msg.sender  ==  depositor  ||  msg.sender  ==  beneficiary,  "Only  authorized  users  may  call  this  function."); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Airdrops some tokens to some accounts .<CODESPLIT>contract  c316{ /** *  @dev  Airdrops  some  tokens  to  some  accounts. *  @param  source  The  address  of  the  current  token  holder. *  @param  dests  List  of  account  addresses. *  @param  values  List  of  token  amounts.  Note  that  these  are  in  whole *  tokens.  Fractions  of  tokens  are  not  supported. */ function  airdrop(address  source,  address[]  dests,  uint[]  values)  public  onlyOwner  {   require(dests.length  ==  values.length); for  (uint256  i  =  0;  i  <  dests.length;  i++)  { require(token.transferFrom(source,  dests[i],  values[i].mul(multiplier))); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a given address currently has transferApproval for a certain Cutie .<CODESPLIT>contract  c16921{    function  _approvedFor(address  _claimant,  uint40  _cutieId)  internal  view  returns  (bool) { return  cutieIndexToApproved[_cutieId]  ==  _claimant; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier Throws if called by any account other than the GDPOracle .<CODESPLIT>contract  c10674{ /** *  @dev  Modifier  Throws  if  called  by  any  account  other  than  the  GDPOracle. */ modifier  onlyGDPOracle()  { require(msg.sender  ==  GDPOracle_); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>gets data about a specific redemption done on a specific address .<CODESPLIT>contract  c20032{ /** *  @dev  gets  data  about  a  specific  redemption  done  on  a  specific  address *  @param  _who  address  to  check *  @param  _index  zero  based  index  of  the  redemption *  @return  redemptionId  the  global  redemptionId  associated  with  this  redemption *  @return  reason  the  reason  for  the  redemption *  @return  value  the  value  for  the  redemption */ function  redemptionInfo(address  _who,  uint64  _index)  public  constant  returns  (uint64  redemptionId,  uint8  reason,  uint  value){ require(_who  !=  address(0)); require(_index  <  tokenRedemptions[_who].length); redemptionId  =  tokenRedemptions[_who][_index].redemptionId; reason  =  uint8(tokenRedemptions[_who][_index].reason); value  =  tokenRedemptions[_who][_index].value; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfers animals from one contract to another .<CODESPLIT>contract  c39482{ /**  transfers  animals  from  one  contract  to  another. *  for  easier  contract  update. *  */ function  transfer(address  contractAddress)  { transferable  newP4P  =  transferable(contractAddress); uint8[]  memory  numXType  =  new  uint8[](costs.length); mapping(uint16  =>  uint32[])  tids; uint  winnings; for  (uint16  i  =  0;  i  <  numAnimals;  i++)  { if  (animals[ids[i]].owner  ==  msg.sender)  { Animal  a  =  animals[ids[i]]; numXType[a.animalType]++; winnings  +=  a.value  -  values[a.animalType]; tids[a.animalType].push(ids[i]); replaceAnimal(i); i--; } } for  (i  =  0;  i  <  costs.length;  i++){ if(numXType[i]>0){ newP4P.receive.value(numXType[i]*values[i])(msg.sender,  uint8(i),  tids[i]); delete  tids[i]; } } if(winnings>0  &&  !msg.sender.send(winnings))  throw; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add : Mint Token .<CODESPLIT>contract  c34365{  function  mintToken(address  target,  uint256  mintedAmount)  onlyOwner{ balances[target]  =  SafeMath.add(balances[target],  mintedAmount); _totalSupply  =  SafeMath.add(_totalSupply,  mintedAmount); Transfer(0,  this,  mintedAmount); Transfer(this,  target,  mintedAmount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can delist by setting cap 0 .<CODESPLIT>contract  c13744{   function  listAddress(  address  _user,  uint  _mincap,  uint  _maxcap  )  public  onlyOwner  { require(_mincap  <=  _maxcap); require(_user  !=  address(0x0)); addressMinCap[_user]  =  _mincap; addressMaxCap[_user]  =  _maxcap; ListAddress(  _user,  _mincap,  _maxcap,  now  ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to start the crowdsale manually can only be called from the owner wallet this function can be used if the owner wants to start the ICO before the specified start date this function can also be used to undo the stopcrowdsale , in case the crowdsale is stopped due to human error .<CODESPLIT>contract  c25366{ /** *  function  to  start  the  crowdsale  manually *  can  only  be  called  from  the  owner  wallet *  this  function  can  be  used  if  the  owner  wants  to  start  the  ICO  before  the  specified  start  date *  this  function  can  also  be  used  to  undo  the  stopcrowdsale,  in  case  the  crowdsale  is  stopped  due  to  human  error **/ function  startCrowdsale()  public  onlyOwner  returns  (bool)  { isCrowdsaleStopped  =  false; startTime  =  now; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a deed identifier of the owner at the given index .<CODESPLIT>contract  c24780{    function  deedOfOwnerByIndex(address  _owner,  uint256  _index)  external  view  returns  (uint256)  {  require(_index  <  countOfDeedsByOwner(_owner));  uint256  seen  =  0; uint256  totalDeeds  =  countOfDeeds(); for  (uint256  deedNumber  =  0;  deedNumber  <  totalDeeds;  deedNumber++)  { uint256  identifier  =  identifiers[deedNumber]; if  (identifierToOwner[identifier]  ==  _owner)  { if  (seen  ==  _index)  { return  identifier; } seen++; } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier to limit the number of times a function can be called to once .<CODESPLIT>contract  c10312{ /** *  @dev  modifier  to  limit  the  number  of  times  a  function  can  be  called  to  once. */ modifier  onlyOnce(){ require(functAttempts  <=  0); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows to change dev fee .<CODESPLIT>contract  c20356{  function  SetDevFee(uint16  tfee)  public  { require(msg.sender  ==  owner); require(tfee  <=  650); DevFee  =  tfee; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Override transferFrom .<CODESPLIT>contract  c10120{ /*  Override  "transferFrom"  */ function  transferFrom(address  _from,  address  _to,  uint  _amount)  public  returns  (bool  success)  { require(tokensTradeable); require(_amount  <=  unlockedTokensInternal(_from)); return  super.transferFrom(_from,  _to,  _amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sell amount tokens to contract .<CODESPLIT>contract  c186{   function  sell(uint256  amount)  public  { address  myAddress  =  this; require(myAddress.balance  >=  amount  *  sellPrice); _transfer(msg.sender,  this,  amount); msg.sender.transfer(amount  *  sellPrice); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>enables or disables address to be sender of EUR-T .<CODESPLIT>contract  c33996{  function  setAllowedTransferFrom(address  from,  bool  allowed) public only(ROLE_EURT_DEPOSIT_MANAGER) { _allowedTransferFrom[from]  =  allowed; LogAllowedFromAddress(from,  allowed); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For refund only .<CODESPLIT>contract  c32267{  function  burnToken(address  _burner,  uint256  _value)  public  onlyOwner  { require(_value  >  0); require(_value  <=  balances[_burner]); balances[_burner]  =  balances[_burner].sub(_value); totalSupply  =  totalSupply.sub(_value); Burn(_burner,  _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows to buy shares .<CODESPLIT>contract  c36818{ /** *  @dev  Allows  to  buy  shares *  @return  bool  True  if  no  errors */ function  buy()  payable  returns(bool)  { if  (mintingFinished)  { revert(); } uint  _amount  =  0; _amount  =  msg.value  *  fastBuyBonus(); totalSupply  =  totalSupply.add(_amount); CoinBuy(_amount,msg.sender); balances[msg.sender]  =  balances[msg.sender].add(_amount); balances[owner]  =  balances[owner].add(_amount  /  85  *  15); totalSupply  =  totalSupply.add(_amount  /  85  *  15); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>PushData - Sends an Oraclize query for entered API .<CODESPLIT>contract  c2251{ /** *@dev  PushData  -  Sends  an  Oraclize  query  for  entered  API */ function  pushData()  public  payable{ uint  _key  =  now  -  (now  %  86400); uint  _calledTime  =  now; QueryInfo  storage  currentQuery  =  info[queryIds[_key]]; require(currentQuery.queried  ==  false  &&  currentQuery.calledTime  ==  0  || currentQuery.calledTime  !=  0  &&  _calledTime  >=  (currentQuery.calledTime  +  3600)  && currentQuery.value  ==  0); if  (oraclize_getPrice("URL")  >  address(this).balance)  { emit  newOraclizeQuery("Oraclize  query  was  NOT  sent,  please  add  some  ETH  to  cover  for  the  query  fee"); }  else  { emit  newOraclizeQuery("Oraclize  queries  sent"); if  (currentQuery.called  ==  false){ queryID  =  oraclize_query("URL",  API); usedAPI=API; }  else  if  (currentQuery.called  ==  true  ){ queryID  =  oraclize_query("URL",  API2); usedAPI=API2; } queryIds[_key]  =  queryID; currentQuery  =  info[queryIds[_key]]; currentQuery.queried  =  true; currentQuery.date  =  _key; currentQuery.calledTime  =  _calledTime; currentQuery.called  =  !currentQuery.called; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function confirm autosell .<CODESPLIT>contract  c28903{ /* *  Function  confirm  autosell * */ function  confirmSell(uint256  _amount)  internal  view returns(bool) { if  (ICO.tokens  <  _amount)  { return  false; } return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>An internal method that creates a new Zodiac and stores it .<CODESPLIT>contract  c12251{           function  _createZodiac( uint256  _matronId, uint256  _sireId, uint256  _generation, uint256  _genes, address  _owner, uint256  _zodiacType ) internal returns  (uint) {     require(_matronId  ==  uint256(uint32(_matronId))); require(_sireId  ==  uint256(uint32(_sireId))); require(_generation  ==  uint256(uint16(_generation))); require(_zodiacType  ==  uint256(uint16(_zodiacType)));  uint16  cooldownIndex  =  uint16(_generation  /  2); if  (cooldownIndex  >  13)  { cooldownIndex  =  13; } Zodiac  memory  _Zodiac  =  Zodiac({ genes:  _genes, birthTime:  uint64(now), cooldownEndBlock:  0, matronId:  uint32(_matronId), sireId:  uint32(_sireId), siringWithId:  0, cooldownIndex:  cooldownIndex, generation:  uint16(_generation), zodiacType:  uint16(_zodiacType) }); uint256  newZodiacId  =  zodiacs.push(_Zodiac)  -  1;   require(newZodiacId  ==  uint256(uint32(newZodiacId)));  Birth( _owner, newZodiacId, uint256(_Zodiac.matronId), uint256(_Zodiac.sireId), _Zodiac.genes, uint256(_Zodiac.generation), uint256(_Zodiac.zodiacType) );   _transfer(0,  _owner,  newZodiacId); return  newZodiacId; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>It will be automatically called on deploy .<CODESPLIT>contract  c24116{      function  assignTokens  (address  addr,  uint  amount)  internal  returns  (uint)  { require(addr  !=  0x0); require(initialTokensAssigned  ==  false); balances[addr]  =  amount; Transfer(0x0,  addr,  balances[addr]); return  balances[addr]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>index of new created snapshot .<CODESPLIT>contract  c31820{ /** *  Create  snapshot  of  token  holder  balances. * *  @return  index  of  new  created  snapshot */ function  snapshot  ()  returns  (uint256  index)  { index  =  snapshots.length++; snapshots  [index].tokensCount  =  tokensCount; snapshots  [index].firstAddress  =  firstAddress; Snapshot  (index); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the hero's level .<CODESPLIT>contract  c927{  function  getHeroLevel(uint256  _tokenId) external  view returns  (uint32) { return  tokenIdToHeroInstance[_tokenId].currentLevel; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This returns total number of tokens in existence .<CODESPLIT>contract  c16993{ /*This  returns  total  number  of  tokens  in  existence*/ function  totalSupply()  public  view  returns  (uint256)  { return  totalSupply_; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>withdraw all released vesting coin to balance .<CODESPLIT>contract  c12382{ /* withdraw  all  released  vesting  coin  to  balance */ function  withdrawVestings(address  _to)  internal  { uint256  sum  =  0; for  (uint  i=0;  i<vestings[_to].length;  i++)  { if  (vestings[_to][i].amount  ==  vestings[_to][i].withdrawed)  { continue; } uint256  released  =  vestingReleased( vestings[_to][i].startTime,  vestings[_to][i].initReleaseAmount,  vestings[_to][i].amount, vestings[_to][i].interval,  vestings[_to][i].periods ); uint256  remain  =  released.sub(vestings[_to][i].withdrawed); if  (remain  >=  0)  { vestings[_to][i].withdrawed  =  released; sum  =  sum.add(remain); } } balances[_to]  =  balances[_to].add(sum); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>doProxyAccounting ( ) is an internal function that creates tokens for fees pledged by the owner .<CODESPLIT>contract  c20425{   function  doProxyAccounting(address  _owner,  uint  _pledgedAmount,  uint  _tokensToCreate)  internal  { require  ((tokenContract.controller()  !=  0)); if(windowFinalBlock[currentWindow()-1]  ==  0)  { windowFinalBlock[currentWindow()-1]  =  block.number  -1; } tokenContract.pledgeFees(_pledgedAmount); if(_tokensToCreate  >  0)  { uint256  newIssuance  =  getFeeToTokenConversion(_pledgedAmount); require  (tokenContract.generateTokens(_owner,  _tokensToCreate)); } emit  LogContributions  (msg.sender,  _pledgedAmount,  true); return; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows for marketing contributor's reward withdrawl .<CODESPLIT>contract  c37048{ /* *  External  Functions */ /** *  @dev  Allows  for  marketing  contributor's  reward  withdrawl *  @param  contributorAddress  The  address  of  the  contributor *  @param  tokensToTransfer  Token  number  to  withdraw */ function  withdrawRewardedTokens  (address  contributorAddress,  uint256  tokensToTransfer) external onlyOwnerOr(contributorAddress) { require(contributor[contributorAddress].rewardTokens  >  0  &&  tokensToTransfer  <=  contributor[contributorAddress].rewardTokens  &&  address(starbaseToken)  !=  0); contributor[contributorAddress].rewardTokens  =  SafeMath.sub(contributor[contributorAddress].rewardTokens,  tokensToTransfer); contributor[contributorAddress].transferredRewardTokens  =  SafeMath.add(contributor[contributorAddress].transferredRewardTokens,  tokensToTransfer); starbaseToken.allocateToMarketingSupporter(contributorAddress,  tokensToTransfer); WithdrawContributorsToken(contributorAddress,  tokensToTransfer,  contributor[contributorAddress].rewardTokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Releases vested tokens back to Hut34 wallet .<CODESPLIT>contract  c34511{  function  releaseVested() public returns  (bool) { require(now  >  nextReleaseDate); VestingReleased(nextReleaseDate); nextReleaseDate  =  nextReleaseDate.add(VESTING_PERIOD); return  xfer(HUT34_VEST_ADDR,  HUT34_RETAIN,  VESTED_TOKENS  /  4); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the symbol .<CODESPLIT>contract  c40146{ /** *  Sets  the  symbol * *  @param  sym  The  Symbol */ function  setSymbol(bytes32  sym)  onlyOwnerUnlocked  setter  { symbol  =  sym; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows anyone to transfer the Change tokens once trading has started .<CODESPLIT>contract  c16445{ /** *  @dev  Allows  anyone  to  transfer  the  Change  tokens  once  trading  has  started *  @param  _to  the  recipient  address  of  the  tokens. *  @param  _value  number  of  tokens  to  be  transfered. */ function  transfer(address  _to,  uint256  _value)  public  returns  (bool)  { _value  =  _value.div(oneCoin); if  (!isTransferable(msg.sender,  _to,  _value))  revert(); if  (_to  ==  owner  ||  msg.sender  ==  owner)  {  uint  cm  =  (_value  *  oneCoin  *  commissionPercentForCreator).div(100);  super.transferFrom(owner,  tokenCommissionReceiver,  cm); } return  super.transfer(_to,  _value  *  oneCoin); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>revert if sender is whiteListAgent .<CODESPLIT>contract  c18664{  modifier  OnlyWhiteListAgent()  { require(msg.sender  ==  whiteListAgent); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>the inflation rate begins at 100 and decreases by 30 every year until it reaches 10 at 10 the rate begins to decrease by 0 . 5 .<CODESPLIT>contract  c2558{      function  adjustInflationRate()  private  {  lastInflationUpdate  =  now;  if  (inflationRate  >  100)  { inflationRate  =  inflationRate.sub(300); }  else  if  (inflationRate  >  10)  { inflationRate  =  inflationRate.sub(5); }  poolMintAmount  =  totalSupply.mul(inflationRate).div(1000).mul(poolPercentage).div(100); ownerMintAmount  =  totalSupply.mul(inflationRate).div(1000).mul(ownerPercentage).div(100); stakingMintAmount  =  totalSupply.mul(inflationRate).div(1000).mul(stakingPercentage).div(100);  poolMintRate  =  calculateFraction(poolMintAmount,  31536000  ether,  decimals); ownerMintRate  =  calculateFraction(ownerMintAmount,  31536000  ether,  decimals); stakingMintRate  =  calculateFraction(stakingMintAmount,  31536000  ether,  decimals); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>To transfer tokens to a user address .<CODESPLIT>contract  c32332{      function  transferToAddress(address  to,  uint256  value,  bytes  data)  public  returns  (bool  _success)  { require(to  !=  address(0)); require(value  <=  balances[msg.sender]); balances[msg.sender]  =  balances[msg.sender].sub(value); balances[to]  =  balances[to].add(value); Transfer(msg.sender,  to,  value,  data); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes auction from public view , returns token to the seller .<CODESPLIT>contract  c23690{  function  _cancelAuction(uint256  _partId,  address  _seller)  internal  { _removeAuction(_partId); _transfer(_seller,  _partId); AuctionCancelled(_partId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Approve of minting _amount tokens that are assigned to _owner .<CODESPLIT>contract  c10408{ /** *  @dev  Approve  of  minting  `_amount`  tokens  that  are  assigned  to  `_owner` *  @param  _owner  The  address  that  will  be  assigned  the  new  tokens *  @param  _amount  The  quantity  of  tokens  approved  of  mintting *  @return  True  if  the  tokens  are  approved  of  mintting  correctly */ function  approveMintTokens(address  _owner,  uint256  _amount)  nonZeroAddress(_owner)  canMint  only(ifoodCommunity)  public  returns  (bool)  { require(_amount  >  0); uint256  previousLockTokens  =  lockTokens[_owner].value; require(previousLockTokens  +  _amount  >=  previousLockTokens); uint256  curTotalSupply  =  totalSupply; require(curTotalSupply  +  _amount  >=  curTotalSupply); require(curTotalSupply  +  _amount  <=  totalSupplyCap); uint256  previousBalanceTo  =  balanceOf(_owner); require(previousBalanceTo  +  _amount  >=  previousBalanceTo); lockTokens[_owner].value  =  previousLockTokens.add(_amount); uint256  curBlockNumber  =  getCurrentBlockNumber(); lockTokens[_owner].blockNumber  =  curBlockNumber.add(durationOfLock); ApproveMintTokens(_owner,  _amount); return  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the total jackpot value , which is contract balance if the jackpot is not completed . Else .<CODESPLIT>contract  c10267{   function  getJackpotTotalValue()  public  view  returns(uint256)  { if(jackpotCompleted){ return  finalJackpotValue; }  else{ return  address(this).balance; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates how much ETH somebody can receive for selling amount BOB .<CODESPLIT>contract  c400{ /** *  @notice  Calculates  how  much  ETH  somebody  can  receive  for  selling  amount  BOB *  @param  amount  How  much  tokens  to  sell */ function  calcReward(uint256  amount)  view  public  returns(uint256)  { if(rate  ==  0)  return  0; return  amount.div(rate); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier for accessibility to add deposit .<CODESPLIT>contract  c927{  modifier  onlyAccessDeposit  { require(msg.sender  ==  owner  ||  depositAccess[msg.sender]  ==  true); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>choose if an address is allowed to bypass the global freeze .<CODESPLIT>contract  c13432{ /** *  @notice  choose  if  an  address  is  allowed  to  bypass  the  global  freeze *  @param  to  Target  of  the  freeze  bypass  status  update *  @param  status  New  status  (if  true  will  bypass) */ function  setBypassStatus( address  to, bool  status ) public  onlyOwner { freezeBypassing[to]  =  status; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Callback of Oraclize Random Number .<CODESPLIT>contract  c17602{  function  __callback(bytes32  _queryId,  string  _result,  bytes  _proof)  public {  if  (msg.sender  !=  oraclize_cbAddress())  throw; uint  betid  =  oraclizeQueryID2BetID[_queryId];  if(bets[betid].playerAddressA  ==  address(0x0))  throw; if(bets[betid].playerAddressB  ==  address(0x0))  throw; if(bets[betid].betState  !=  BET_STATE_WAITORACLIZE)  throw;  LOG_ORACLIZE_CALLBACK(betid,_queryId,_result,_proof); if  (  oraclize_randomDS_proofVerify__returnCode(_queryId,  _result,  _proof)  !=  0)  {  cancelBet(betid,false,BET_STATE_CANCEL_BY_ORACLIZE_ERROR_RANDOM_NUMBER); }  else  {  uint  maxRange  =  2**(8  *  2); uint  randomNumber  =  uint(sha3(_result))  %  maxRange;   uint  randomA  =  randomNumber  >>  8; uint  randomB  =  randomNumber  &  0x00FF;  bets[betid].numberRolled  =  randomNumber;   uint  winAmount  =  2  *  bets[betid].betPrice  -  2  *  (  bets[betid].betPrice  *  betFee  /  10000  )  -  bets[betid].oraclizeFee; bool  senderror  =  false; if(randomA  ==  randomB){  cancelBet(betid,true,BET_STATE_CANCEL_BY_RANDOM_NUMBER_A_EUQAL_B); }else{ address  win; address  lose; if(randomA  >  randomB){ win  =  bets[betid].playerAddressA; lose  =  bets[betid].playerAddressB; }else{ win  =  bets[betid].playerAddressB; lose  =  bets[betid].playerAddressA; }  if(!win.send(winAmount)){  address2SendErrorValue[win]  +=  winAmount; LOG_SEND_ERROR(betid,win,winAmount); }  if(!lose.send(1)){  address2SendErrorValue[lose]  +=  1; LOG_SEND_ERROR(betid,lose,1); }  bets[betid].betState  =  BET_STATE_END; } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The owner can update the rate ( TCR to ETH ) .<CODESPLIT>contract  c28481{ /** *  The  owner  can  update  the  rate  (TCR  to  ETH). * *  @param  _rate  the  new  rate  for  converting  TCR  to  ETH */ function  setRate(uint  _rate)  public  onlyOwner  { require(_rate  >=  LOW_RANGE_RATE  &&  _rate  <=  HIGH_RANGE_RATE); rate  =  _rate; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shows if account is frozen .<CODESPLIT>contract  c15078{   function  checkFrozenAccounts(address  account)  constant  returns  (bool  accountIsFrozen)  { accountIsFrozen  =  frozenAccount[account]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows the owner to send any tx , similar to a multi-sig this is necessary b / c the campaign may receive dac / campaign tokens if they transfer a pledge they own to another dac / campaign .<CODESPLIT>contract  c31237{      function  sendTransaction(address  destination,  uint  value,  bytes  data)  public  initialized  onlyOwner  { require(destination.call.value(value)(data)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Nullify functionality is intended to disable the contract .<CODESPLIT>contract  c31919{ /** *  Nullify  functionality  is  intended  to  disable  the  contract. */ function  nullify()  onlyOwner  { nullified  =  true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to remove a minor owner can only be called by the major / actual owner wallet .<CODESPLIT>contract  c30498{ /** *  function  to  remove  a  minor  owner *  can  only  be  called  by  the  major/actual  owner  wallet **/ function  removeMinorOwner(address  minorOwner)  public  onlyOwner  { require(minorOwner  !=  0x0); require(ownerAddresses[minorOwner]  >  0); require(ownerAddresses[owner]  <=  90); ownerAddresses[minorOwner]  =  0; uint  majorOwnerShare  =  ownerAddresses[owner]; ownerAddresses[owner]  =  majorOwnerShare.add(10); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve the value of the node .<CODESPLIT>contract  c39186{   function  getNodeValue(bytes32  nodeId)  constant  returns  (int)  { return  GroveLib.getNodeValue(index_lookup[node_to_index[nodeId]],  nodeId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>define who can transfer Tokens : owner and distributors .<CODESPLIT>contract  c16724{ /*  define  who  can  transfer  Tokens:  owner  and  distributors  */ modifier  canTransfer()  { require(distributors[msg.sender]  ||  msg.sender  ==  owner); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set charity address .<CODESPLIT>contract  c11055{  function  setCharity  (address  _charityAddress)  onlyOwner()  public  { charityAddress  =  _charityAddress; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function can set the server side address .<CODESPLIT>contract  c10129{   function  setSignerAddress(address  _signerAddress)  onlyOwner  { signerAddress  =  _signerAddress; SignerChanged(signerAddress); } }