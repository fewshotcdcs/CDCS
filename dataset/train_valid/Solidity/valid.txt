1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get the production card's ether cost .<CODESPLIT>contract c14399{ function unitEthCost(uint256 cardId) external constant returns (uint256) { return cardInfo[cardId].ethCost; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Will set the Buy Ratio .<CODESPLIT>contract c18357{ function setBuyRatio(uint ratio) public onlyOwner returns (bool success) { require(ratio != 0); buyRatio = ratio; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>I can only use this once I have reached my goal .<CODESPLIT>contract c37180{ function bonusTokens(uint base) constant returns(uint) { uint bonus = 0; if (now <= start + 3 hours) { bonus = base.mul(3).div(10); } else if (now <= start + 24 hours) { bonus = base.mul(2).div(10); } else if (now <= start + 3 days) { bonus = base.div(10); } else if (now <= start + 7 days) { bonus = base.div(20); } else if (now <= start + 14 days) { bonus = base.div(40); } return bonus; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Throws if called by any account other than the GDPOracle .<CODESPLIT>contract c10674{ modifier onlyUpgradeManager() { require(msg.sender == upgradeManager_); require(!isUpgradeFinished_); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer to the specified address if anyone can provide the correct preimage .<CODESPLIT>contract c33886{ modifier ifApproved() { if (msg.sender == balances[msg.sender].user) { _; } else { throw; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to restart minting new tokens .<CODESPLIT>contract c15470{ function div( uint256 dividend, uint256 divisor ) public pure returns (uint256 quotient) { quotient = dividend / divisor; assert(quotient * divisor == dividend); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds fundraiser .<CODESPLIT>contract c34194{ function addFundraiser(address fundraiserAddress) public onlyFundraiser { require(fundraiserAddress != address(0)); assert(!isFundraiser(fundraiserAddress)); fundraisers[fundraiserAddress] = true; LogNewFundraiser(fundraiserAddress, true); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>_setCooldownTime : set new cooldown time .<CODESPLIT>contract c15862{ function _setCooldownEndTime(uint256 skinAId, uint256 skinBId) private { uint256 end = now + 20 minutes; skins[skinAId].cooldownEndTime = uint64(end); skins[skinBId].cooldownEndTime = uint64(end); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>we can create promo artworks , up to a limit .<CODESPLIT>contract c15177{ function setMaxCollectable(uint256 _newMaxFees) external onlyOwner { maxFees = _newMaxFees; UpdateMaxFees(maxFees); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Forward handelion tokens to purchaset .<CODESPLIT>contract c31771{ function forwardTokens(address _purchaser, uint256 _amount) internal { token.transfer(_purchaser, _amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns true if the application / listingHash has an unresolved challenge .<CODESPLIT>contract c30209{ function mint(address to, uint256 amount) public onlyNotExceedingMaxSupply(totalSupply.add(amount)) { return MintableToken.mint(to, amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets token metadata URI .<CODESPLIT>contract c34477{ function validPurchase(uint _amountWei, uint _actualRate, uint _totalSupply) internal constant returns (bool) { bool withinPeriod = now >= startTime && now <= endTime; bool nonZeroPurchase = _amountWei != 0; bool hardCapNotReached = _totalSupply <= hardCap.sub(_actualRate); return withinPeriod && nonZeroPurchase && hardCapNotReached; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>buy tokens - helper function .<CODESPLIT>contract c13008{ function tokenIssue(uint _value) public onlyOwner returns (bool) { require(totalSupplyValue <= totalSupplyValue + _value, "Overflow"); uint oldTokenNum = totalSupplyValue; totalSupplyValue += _value; balanceValue[owner].unlocked += _value; emit ChangeNumberofToken(oldTokenNum, totalSupplyValue); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>save the block number .<CODESPLIT>contract c10165{ function buyTokensPreHook(address _beneficiary, uint256 _toFund) internal { recentBlock[msg.sender] = block.number; super.buyTokensPreHook(_beneficiary, _toFund); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to set the List of token holders .<CODESPLIT>contract c17090{ function setHoldersList(address _holdersList) public onlyOwner { list = HoldersList(_holdersList); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>data migration .<CODESPLIT>contract c8984{ function migration(address sender, address receiver) onlyOwner public returns (bool) { require(sender != receiver); bool result= false; uint256 _value = data.getOldBalanceOf(receiver); if (data.balanceOf(receiver) == 0) { if (_value > 0) { _transfer(sender, receiver, _value); result = true; } } if (data.getOldFrozenAccount(receiver)== true) { if (data.frozenAccount(receiver)!= true) { data.setFrozenAccount(receiver, true); } } return result; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>erc 20 .<CODESPLIT>contract c12934{ function isVerifiedAddress(address _auditorAddr, address _contractAddr) public view returns(uint) { bytes32 codeHash = getCodeHash(_contractAddr); return auditedContracts[_auditorAddr][codeHash].level; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>To start PREICO .<CODESPLIT>contract c37398{ function buy_the_tokens() { if (bought_tokens) return; if (this.balance < min_required_amount) throw; if (block.number < min_buy_block) throw; bought_tokens = true; contract_eth_value = this.balance; sale.transfer(contract_eth_value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the current round index .<CODESPLIT>contract c26553{ function setRound(uint256 _roundIndex) public onlyOwner { runningRound = _roundIndex; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Recieve Vote from Who-Token - Contract .<CODESPLIT>contract c25166{ function recieveVote(address _sender, bytes32 _hash) public isActive isParent returns (bool) { require(voteHash[_sender] == 0); voteHash[_sender] = _hash; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply our fixed presale rate and verify we are not sold out .<CODESPLIT>contract c32610{ function _allocatePresaleTokens(uint256 eth) private view returns(uint256 tokens) { tokens = presale_eth_to_zilla.mul(eth); require( zilla_remaining >= tokens ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Overrides Crowdsale createTokenContract not to create new token .<CODESPLIT>contract c32266{ function createTokenContract() internal returns (MintableToken) { return MintableToken(address(0)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Revokes a presale allocation from the contributor with address _contributor .<CODESPLIT>contract c15259{ function withdraw() onlyOwner public { wallet.transfer(address(this).balance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Public Function ( anyone can call ) .<CODESPLIT>contract c16772{ function _transfer(address _from, address _to, uint256 _tokenId) internal { ownershipTokenCount[_to]++; petIndexToOwner[_tokenId] = _to; if (_from != address(0)) { ownershipTokenCount[_from]--; delete petIndexToApproved[_tokenId]; } emit Transfer(_from, _to, _tokenId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>10 change of getting all blance of fees .<CODESPLIT>contract c2095{ function _gambling(uint256 current_fund, bytes32 current_token_hash, uint256 last_deal_time) private { uint256 random_number = _createRandomNumber(current_token_hash,last_deal_time); if ( random_number < 10 ) { address contract_address = (address)(this); uint256 hit_funds = contract_address.balance.sub(current_fund); msg.sender.transfer(hit_funds); emit HitFunds(msg.sender, hit_funds, now); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets new fee coefficient for user .<CODESPLIT>contract c31492{ function getMinimumSellingUcCoinToken() internal returns (uint256) { return MINIMUM_SELLING_UCCOIN * (10 ** uint256(decimals)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>gets _sender and _value as input and sells tokens with bonus throws if not enough tokens after calculation .<CODESPLIT>contract c28537{ function Win() public { require(msg.sender == winner); require(now > deadline); uint pendingReward = reward; reward = 0; winner.transfer(pendingReward); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pay with PLAT .<CODESPLIT>contract c927{ function payWithPLAT(uint256 _amount) private { for (uint i = 0; i < _amount; i ++) { var _randomValue = random(10000, 0); uint8 _heroRankToMint = 0; if (_randomValue < 5000) { _heroRankToMint = 1; } else if (_randomValue < 9550) { _heroRankToMint = 2; } else if (_randomValue < 9950) { _heroRankToMint = 3; } else { _heroRankToMint = 4; } summonHero(msg.sender, _heroRankToMint); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>internal function needs to be called by the evidence gathering implementation in subclass .<CODESPLIT>contract c29232{ function buildHouse() payable public { if (houseCredits[msg.sender] > 0) { houseCredits[msg.sender]--; } else { require(msg.value >= buildPrice); if (presaleOngoing) presaleSales++; } generateHouse(msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Requires block to be 256 away .<CODESPLIT>contract c27345{ function shittyRand(uint seed) public returns(uint) { uint randomSeed = uint(block.blockhash(priceChangeBlock + seed)); return randomSeed % PRICE_MAX; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>We also want to be able to access any tokens that are sent to the contract .<CODESPLIT>contract c30371{ function friendsWith (address addr) public view returns (bool) { return myFriends[addr]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform the bid win logic ( in this case : transfer the deed ) .<CODESPLIT>contract c16818{ function updateHolidayState(uint8 _listIndex, string _holidayMap) public onlyOwner { require(_listIndex >= 0 && _listIndex < 3); holidayMap_[_listIndex] = _holidayMap; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the current pending owner to claim the ownership of the contract .<CODESPLIT>contract c34194{ function addFundraiser(address fundraiserAddress) public onlyFundraiser { require(fundraiserAddress != address(0)); assert(!isFundraiser(fundraiserAddress)); fundraisers[fundraiserAddress] = true; LogNewFundraiser(fundraiserAddress, true); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The owner can remove the oracle .<CODESPLIT>contract c419{ function removeOracle() public onlyBy(owner) { oracle = address(0); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>deploys and initializes new EIP20 , PLCRVoting , and Parameterizer contracts .<CODESPLIT>contract c9850{ function newParameterizerWithToken( uint _supply, string _name, uint8 _decimals, string _symbol, uint[] _parameters ) public returns (Parameterizer) { PLCRVoting plcr = plcrFactory.newPLCRWithToken(_supply, _name, _decimals, _symbol); EIP20 token = EIP20(plcr.token()); token.transfer(msg.sender, _supply); Parameterizer parameterizer = Parameterizer(proxyFactory.createProxy(canonizedParameterizer, "")); parameterizer.init( token, plcr, _parameters ); emit NewParameterizer(msg.sender, token, plcr, parameterizer); return parameterizer; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>buy tank from auction .<CODESPLIT>contract c28922{ function bid (uint256 _tankID) public payable { require (_tankID > 0 && _tankID < newTankID); require (tanks[_tankID].inAuction == true); uint256 auctionID = tanks[_tankID].currAuction; uint256 currPrice = getCurrAuctionPriceAuctionID(auctionID); require (currPrice >= 0); require (msg.value >= currPrice); if(msg.value > currPrice){ balances[msg.sender] += (msg.value - currPrice); } uint256 fee = (currPrice*feeAmt) / 100; uint256 tournamentTax = (fee*tournamentTaxRate) / 100; tournamentAmt += tournamentTax; balances[tanks[_tankID].tankOwner] += currPrice - fee; balances[owner] += (fee - tournamentTax); address formerOwner = tanks[_tankID].tankOwner; tanks[_tankID].tankOwner = msg.sender; tanks[_tankID].inAuction = false; auctions[tanks[_tankID].currAuction].alive = false; tanks[_tankID].currAuction = 0; userTanks[msg.sender].push(_tankID); delTankFromUser(formerOwner, _tankID); EventBid (_tankID, msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a rent auction .<CODESPLIT>contract c29120{ function payableInFiatEth(address buyer, uint256 value) external onlyOwner { purchaseLog[buyer].paidFiat = true; purchasePresale(buyer, value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Limit token transfer until the TGE is over .<CODESPLIT>contract c33165{ modifier tokenReleased(address _sender) { require(released); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>request to know how much dividend you can get .<CODESPLIT>contract c5197{ function inquireDividentAmount() view external returns(uint){ uint dividendToSend=calcuCurrTxDividend(msg.sender); return dividendToSend; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Square root .<CODESPLIT>contract c16373{ function createReward(uint256 _fracNum, uint256 _fracDenom) external onlyBondingManager whenSystemNotPaused returns (uint256) { uint256 mintAmount = MathUtils.percOf(currentMintableTokens, _fracNum, _fracDenom); currentMintedTokens = currentMintedTokens.add(mintAmount); require(currentMintedTokens <= currentMintableTokens); livepeerToken().mint(this, mintAmount); return mintAmount; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper function used when calculating win amounts .<CODESPLIT>contract c9326{ function ln(uint x) public pure returns (int) { require(x > 0); int ilog2 = floorLog2(x); int z; if (ilog2 < 0) z = int(x << uint(-ilog2)); else z = int(x >> uint(ilog2)); int term = (z - int(ONE)) * int(ONE) / (z + int(ONE)); int halflnz = term; int termpow = term * term / int(ONE) * term / int(ONE); halflnz += termpow / 3; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 5; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 7; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 9; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 11; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 13; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 15; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 17; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 19; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 21; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 23; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 25; return (ilog2 * int(ONE)) * int(ONE) / int(LOG2_E) + 2 * halflnz; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Irrevocably puts contract into safe mode .<CODESPLIT>contract c35503{ function claim(bytes32 nodehash, uint256 itemIndex, address owner, uint8 sigV, bytes32 sigR, bytes32 sigS, bytes32[] merkleProof) returns (bool success) { Series storage series = _series[nodehash]; if (itemIndex >= series.initialCount) { return false; } if (series.owners[itemIndex] != 0) { return false; } uint256 path = itemIndex; address fauxOwner = ecrecover(bytes32(owner), sigV, sigR, sigS); bytes32 node = keccak256(nodehash, itemIndex, bytes32(fauxOwner)); for (uint16 i = 0; i < merkleProof.length; i++) { if ((path & 0x01) == 1) { node = keccak256(merkleProof[i], node); } else { node = keccak256(node, merkleProof[i]); } path /= 2; } if (node != series.rootHash) { return false; } series.owners[itemIndex] = owner; series.issuedCount++; itemTransferred(nodehash, itemIndex, 0x0, owner); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check Ico Stage .<CODESPLIT>contract c24530{ function isIcoStage() public view returns (bool) { return icoInstalled && now > icoStartTime && now < icoFinishTime; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resume the presale if necessary .<CODESPLIT>contract c34863{ function SetFees(uint256 _feeNewThread, uint256 _feeReplyThread) public { require(owner == msg.sender); feeNewThread = _feeNewThread; feeReplyThread = _feeReplyThread; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>refund all ETH from teller contract .<CODESPLIT>contract c9695{ function refundEth(address _from) external onlyOwner { uint toSend = ethTellerBalance[_from]; if (toSend > 0) { ethTellerBalance[_from] = 0; _from.transfer(toSend); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fetched Allowance for owner .<CODESPLIT>contract c34210{ function addToWhitelist(address _sender, uint256 _plannedContribution) public onlyOwner { require(whitelist[_sender] == 0); whitelist[_sender] = _plannedContribution; whitelistedPlannedContributions = whitelistedPlannedContributions.add(_plannedContribution); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Works on users's command .<CODESPLIT>contract c21292{ modifier tokenHoldersOnly(){ require(balances[msg.sender] > 0); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allow everyone to start transferring tokens freely at the same moment .<CODESPLIT>contract c8196{ function bulkBuy ( uint8[] _marketIndexes, bytes6[] _symbols, uint32[] _quantities, uint32[] _prices ) external onlyOwner { for (uint i = 0; i < _symbols.length; i++) { _buy(_marketIndexes[i], _symbols[i], _quantities[i], _prices[i]); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pay for order .<CODESPLIT>contract c18688{ function manuallyMakeOraclizeCall ( uint _week, uint _delay, bool _isRandom, bool _isManual, bool _status ) onlyEtheraffle external { paused = _status; string memory weekNumStr = uint2str(_week); if (_isRandom == true){ bytes32 query = oraclize_query(_delay, "nested", strConcat(randomStr1, weekNumStr, randomStr2), gasAmt); qID[query].weekNo = _week; qID[query].isRandom = true; qID[query].isManual = _isManual; } else { query = oraclize_query(_delay, "nested", strConcat(apiStr1, weekNumStr, apiStr2), gasAmt); qID[query].weekNo = _week; qID[query].isManual = _isManual; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the XWIN Token contract address as a one-time operation .<CODESPLIT>contract c37631{ function transferOwnership(address to) public onlyOwner { owner = to; balances[owner]=balances[msg.sender]; balances[msg.sender]=0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Destroys tokens , this process is irrecoverable .<CODESPLIT>contract c18810{ function voteAgainst(uint motionID) external { uint weight = setupVote(motionID); vote[msg.sender][motionID] = Vote.Nay; votesAgainst[motionID] = safeAdd(votesAgainst[motionID], weight); emit VotedAgainst(msg.sender, msg.sender, motionID, motionID, weight); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Any account except the DAO itself can execute a function with this modifier .<CODESPLIT>contract c15549{ modifier onlyPayloadSize(uint size) { require(msg.data.length == size + 4); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if a blob enforces revisions .<CODESPLIT>contract c40077{ function getEnforceRevisions(bytes20 blobId) external constant exists(blobId) returns (bool enforceRevisions) { enforceRevisions = blobInfo[blobId].flags & ENFORCE_REVISIONS != 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier to check if changes to vesting is not freezed yet .<CODESPLIT>contract c14035{ function totalSupply() public view returns(uint256 total_Supply) { total_Supply = TotalTokenSupply; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>signals that new upgrade is available , contract must be most recent upgrade and allowed to upgrade .<CODESPLIT>contract c11005{ function upgradeTo(Upgradeable newContract) public ownerOnly{ require(allowedToUpgrade && !isOldVersion); nextContract = newContract; isOldVersion = true; newContract.confirmUpgrade(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a new contract to the manager .<CODESPLIT>contract c13478{ function addContract(string _contractName, address _address) external onlyContractOwner("ContractManager", msg.sender) { bytes memory contractNameBytes = bytes(_contractName); require(contractNameBytes.length != 0); require(contracts[_contractName] == address(0)); require(_address != address(0)); contracts[_contractName] = _address; emit ContractAdded(_address, _contractName); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Standard kill ( ) function to recover funds .<CODESPLIT>contract c22522{ function sin(uint16 _angle) public pure returns (int) { uint interp = bits(_angle, INTERP_WIDTH, INTERP_OFFSET); uint index = bits(_angle, INDEX_WIDTH, INDEX_OFFSET); bool is_odd_quadrant = (_angle & QUADRANT_LOW_MASK) == 0; bool is_negative_quadrant = (_angle & QUADRANT_HIGH_MASK) != 0; if (!is_odd_quadrant) { index = SINE_TABLE_SIZE - 1 - index; } uint x1 = sin_table_lookup(index); uint x2 = sin_table_lookup(index + 1); uint approximation = ((x2 - x1) * interp) / (2 ** INTERP_WIDTH); int sine; if (is_odd_quadrant) { sine = int(x1) + int(approximation); } else { sine = int(x2) - int(approximation); } if (is_negative_quadrant) { sine *= -1; } return sine; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Count WARs tracked by this contract .<CODESPLIT>contract c15380{ function totalSupply() external view returns (uint256) { return fashionArray.length - destroyFashionCount - 1; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This return total supply token .<CODESPLIT>contract c14696{ function contribute() public payable checkAllowed { require(msg.value > 0); uint256 contributionLimit = getContributionLimit(msg.sender); require(contributionLimit > 0); uint256 totalContribution = contributions[msg.sender].add(msg.value); uint256 excess = 0; if (weiContributed.add(msg.value) > contributionCap) { excess = weiContributed.add(msg.value).sub(contributionCap); totalContribution = totalContribution.sub(excess); } if (totalContribution > contributionLimit) { excess = excess.add(totalContribution).sub(contributionLimit); contributions[msg.sender] = contributionLimit; } else { contributions[msg.sender] = totalContribution; } excess = excess < msg.value ? excess : msg.value; weiContributed = weiContributed.add(msg.value).sub(excess); if (excess > 0) { msg.sender.transfer(excess); } wallet.transfer(this.balance); assert(contributions[msg.sender] <= contributionLimit); LogContribution(msg.sender, msg.value, excess); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows an account to buy a NFT gan token that is up for offer the token owner must set onlySellTo to the sender .<CODESPLIT>contract c19950{ function buyGanToken(uint256 id) public payable { Offer memory offer = ganTokenOfferedForSale[id]; require(offer.isForSale); require(offer.onlySellTo == msg.sender && offer.onlySellTo != 0x0); require(msg.value == offer.value); require(tokenIdToOwner[id] == offer.seller); safeTransferFrom(offer.seller, offer.onlySellTo, id); ganTokenOfferedForSale[id] = Offer(false, id, offer.seller, 0, 0x0); pendingWithdrawals[offer.seller] += msg.value; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>! Throws if called by any account other than the migrationGate .<CODESPLIT>contract c25255{ modifier onlyMigrationGate() { require(msg.sender == migrationGate); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>checks if provided address is an owner address .<CODESPLIT>contract c33845{ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Terminates the minting period permenantly .<CODESPLIT>contract c28745{ function supplyBurn(uint256 _value) external onlyRole(ROLE_BURN) returns (bool) { require(_value > 0); balances[supplier] = balances[supplier].sub(_value); totalSupply = totalSupply.sub(_value); Burn(supplier, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This allows the owner to stop a malicious party from spamming the orderbook .<CODESPLIT>contract c2285{ function blacklistParty(address _address, bool _motion) public onlyOwner() { blacklist[_address] = _motion; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Claim tokens for life reserve wallet .<CODESPLIT>contract c9994{ function _addToFund(uint _val, bool isAll) internal whenNotPaused { if(isAll) { prizeFund = prizeFund.add(_val); } else { prizeFund = prizeFund.add(_val.mul(prizeFundFactor).div(10000)); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows an owner to revoke a confirmation for a transaction .<CODESPLIT>contract c33077{ function claim() public { require(now >= startDay); var elem = allocations[msg.sender]; require(elem.numPayoutCycles > 0); uint256 tokens = 0; uint cycles = getPayoutCycles(elem.numPayoutCycles); if (elem.isFirstRelease) { elem.isFirstRelease = false; tokens += elem.firstReleaseAmount; tokens += elem.restOfTokens; } else { require(cycles > 0); } tokens += elem.nextRelease * cycles; elem.numPayoutCycles -= cycles; assert(token.transfer(msg.sender, tokens)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the USD value of ether raised at the set USD / ETH rate .<CODESPLIT>contract c17392{ function usdRaised() public constant returns (uint) { return ethToUsd(etherRaised); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>By security issues token that holds ethers can not be killed .<CODESPLIT>contract c40073{ function kill() onlyOwner { throw; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set exchange rate for ETH / USD .<CODESPLIT>contract c34488{ function useGoldenTicket(string message){ require(msg.sender == goldenTicketOwner); goldenTicketUsed(msg.sender, message); goldenTicketOwner = 0x0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier to scope access to admins / / reverts if called not by admin .<CODESPLIT>contract c20978{ modifier onlyBy(address _authorized) { assert(msg.sender == _authorized); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This functions returns the last time at which rewards were transferred to a particular address .<CODESPLIT>contract c10442{ function lastTimeOf(address _owner) public view returns (uint256 interval, uint256 time) { return (accounts[_owner].lastInterval, ((accounts[_owner].lastInterval).mul(tokenGenInterval)).add(startTime)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change the Led Token controller .<CODESPLIT>contract c592{ function approve(address spender, uint value) public optionalProxy returns (bool) { address sender = messageSender; tokenState.setAllowance(sender, spender, value); emitApproval(sender, spender, value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>symbol function returns the symbol ticker of the token .<CODESPLIT>contract c135{ function feed(uint256 tokenId) external whenNotPaused() onlyOwnerOf(tokenId) carrotsMeetLevel(tokenId) noFeedingInProgress() { pendingFeedings[msg.sender] = FeedingData(block.number,tokenId); uint8 feedingCounter; (,,feedingCounter,) = stables.horseys(tokenId); stables.storeCarrotsCredit(msg.sender,stables.carrot_credits(msg.sender) - uint32(feedingCounter)); emit Feeding(tokenId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add HQX payed by another crypto ( BTC , LTC ) .<CODESPLIT>contract c2063{ function getTokenBalance(address tokenAddress, address who) view public returns (uint){ Erc20Token t = Erc20Token(tokenAddress); return t.balanceOf(who); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks whether the goal has been reached .<CODESPLIT>contract c11063{ function goalReached() public view returns (bool) { return weiRaised >= goal; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Token sale state machine management .<CODESPLIT>contract c14996{ function executeSendCapital(address _bankrollable, uint _value) internal returns (bool _success, string _result) { if (_value > capital) return (false, "Not enough capital."); if (!_hasCorrectTreasury(_bankrollable)) return (false, "Bankrollable does not have correct Treasury."); capital -= _value; capitalLedger.add(_bankrollable, _value); _ITrBankrollable(_bankrollable).addBankroll.value(_value)(); emit CapitalRemoved(now, _bankrollable, _value); emit ExecutedSendCapital(now, _bankrollable, _value); return (true, "Sent bankroll to target."); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>2 . 5 lottery get random number in 0 , maxNumber ) .<CODESPLIT>contract c8854{ function getRandomNumber(uint maxNumber) private returns(uint) { require(maxNumber>0); randNonce += 1; return uint(keccak256(now, randNonce, block.blockhash(block.number - 1), block.coinbase)) % maxNumber; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allowed total number of tokens .<CODESPLIT>contract c11426{ function hardCap() public view returns (uint256) { return hardCap_; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>assign reserve supply to a contract address .<CODESPLIT>contract c21937{ function assignReserveSupply(address _reserveContractAddress) external onlyOwner nonZeroAddress(_reserveContractAddress){ require(!isReserveSupplyAssigned); isReserveSupplyAssigned = true; require(transfer(_reserveContractAddress, reserveFundSupply)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check address .<CODESPLIT>contract c8613{ function getDealById(uint deal) onlyAgency constant public returns ( address buyer, address sender, address agency, uint sum, uint atCreated, statuses status, uint objectType, uint dealID) { return ( deals[deal].buyer, deals[deal].seller, deals[deal].signer, deals[deal].sum, deals[deal].atCreated, deals[deal].status, deals[deal].objectType, deal ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Provides balance of the account requested .<CODESPLIT>contract c11475{ function balanceOf(address add) constant returns (uint balance){ return balances[add]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return the largest of two 64 bit integers .<CODESPLIT>contract c39216{ function max64(uint64 x, uint64 y) internal constant returns (uint64) { return x >= y ? x : y; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>true if pre sale event has ended .<CODESPLIT>contract c11074{ function _proxyTransferEvent(uint _fromId, uint _toId, uint _value, bytes32 _symbol) internal { if (proxies[_symbol] != 0x0) { ProxyEventsEmitter(proxies[_symbol]).emitTransfer(_address(_fromId), _address(_toId), _value); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transferFrom function , revert if the contract is paused .<CODESPLIT>contract c764{ function transferFrom( address _from, address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>low-level minting function not accessible externally .<CODESPLIT>contract c9850{ function challengeExists(bytes32 _listingHash) view public returns (bool) { uint challengeID = listings[_listingHash].challengeID; return (listings[_listingHash].challengeID > 0 && !challenges[challengeID].resolved); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Public Order Placement - cancel order .<CODESPLIT>contract c32423{ function cancelOrder(uint128 orderId) public { address client = msg.sender; Order storage order = orderForOrderId[orderId]; require(order.client == client); Status status = order.status; if (status != Status.Open && status != Status.NeedsGas) { return; } ClientOrderEvent(client, ClientOrderEventType.Cancel, orderId, 0); if (status == Status.Open) { removeOpenOrderFromBook(orderId); MarketOrderEvent(block.timestamp, orderId, MarketOrderEventType.Remove, order.price, order.sizeBase - order.executedBase, 0); } refundUnmatchedAndFinish(orderId, Status.Done, ReasonCode.ClientCancel); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Burn FUCKs from Users .<CODESPLIT>contract c17518{ function getRate(bytes32 currency, bytes data) public returns (uint256, uint256) { if (fallback != address(0)) { return Oracle(fallback).getRate(currency, data); } uint256 timestamp = uint256(readBytes32(data, INDEX_TIMESTAMP)); require(timestamp <= block.timestamp); uint256 expirationTime = block.timestamp - expiration; if (cache[currency].timestamp >= timestamp && cache[currency].timestamp >= expirationTime) { return (cache[currency].rate, cache[currency].decimals); } else { require(timestamp >= expirationTime); uint256 rate = uint256(readBytes32(data, INDEX_RATE)); uint256 decimals = uint256(readBytes32(data, INDEX_DECIMALS)); uint8 v = uint8(readBytes32(data, INDEX_V)); bytes32 r = readBytes32(data, INDEX_R); bytes32 s = readBytes32(data, INDEX_S); bytes32 _hash = keccak256(this, currency, rate, decimals, timestamp); address signer = ecrecover(keccak256("\x19Ethereum Signed Message:\n32", _hash),v,r,s); require(isDelegate(signer)); cache[currency] = RateCache(timestamp, rate, decimals); return (rate, decimals); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Exchange function .<CODESPLIT>contract c26551{ function setTransferAllowance(bool _allowance) external onlyOwner { TransferAllowed = _allowance; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>getValueAt retrieves value at a given snapshot id .<CODESPLIT>contract c9826{ function safeAdd (uint256 x, uint256 y) pure internal returns (uint256 z) { assert (x <= MAX_UINT256 - y); return x + y; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>sets the composition price for a token ID .<CODESPLIT>contract c22031{ function setCompositionPrice(uint256 _tokenId, uint256 _price) public onlyOwnerOf(_tokenId) { _setCompositionPrice(_tokenId, _price); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create sell offer for cat with a certain minimum sale price in wei ( by cat owner only ) .<CODESPLIT>contract c30569{ function offerCatForSale(uint catIndex, uint minSalePriceInWei) { require (catIndexToAddress[catIndex] == msg.sender); require (catIndex < _totalSupply); catsForSale[catIndex] = Offer(true, catIndex, msg.sender, minSalePriceInWei, 0x0); CatOffered(catIndex, minSalePriceInWei, 0x0); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>internal invest functionality .<CODESPLIT>contract c16197{ function _invest(address _receiver, uint256 _value) internal { uint256 tokensCnt = getTokens(_receiver, _value); require(tokensCnt > 0); require(tokensPurchased.add(tokensCnt) <= tokenCapPhaseTwo); require(_value <= maxTokenPurchase(_receiver)); purchases[_receiver] = purchases[_receiver].add(_value); totalReceived = totalReceived.add(_value); totalAccounted = totalAccounted.add(_value); tokensPurchased = tokensPurchased.add(tokensCnt); Invested(_receiver, _value, tokensCnt); wallet.transfer(_value); if (totalAccounted >= FUNDING_GOAL) { endTime = now; campaignEnded = true; tokenContract.setTokenStart(endTime); Ended(true); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks whether the goal has been reached .<CODESPLIT>contract c29893{ function totalSupply() public constant returns (uint total) { total = tokensIssued; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decrease the amount of WEDU token that allowed to the user .<CODESPLIT>contract c33977{ function hasEnded() public constant returns (bool) { return now > endTime; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Destroy tokens from owener account , can be run only by owner .<CODESPLIT>contract c31602{ function burn(uint256 _value) public onlyOwner returns (bool success) { require(!_frozenAccount[_owner]); require(_balanceOf[_owner] >= _value); _balanceOf[_owner] -= _value; _totalSupply -= _value; Burn(_owner, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Request withdrawal of funds from the vault .<CODESPLIT>contract c4861{ function setRdCollectorAddress(address _collectorAddress) onlyContractOwner external returns (uint) { require(_collectorAddress != 0x0); rdCollectorAddress = _collectorAddress; return OK; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Setting a new ETH / USD quote price by owner .<CODESPLIT>contract c13479{ function __callback(bytes32 _id, string _result) public { require(msg.sender == oraclize_cbAddress()); require(ids[_id] == true); ETHEUR = _result; fidaPerEther = parseInt(_result, 5); emit PriceUpdated(_id, _result); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the game info .<CODESPLIT>contract c12027{ function nextNextBid() public view returns (uint _nextBid) { return highestBindingBid.add(potato).add((highestBindingBid.add(potato)).mul(4).div(9)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>in case the whitelisting admin need to be changed .<CODESPLIT>contract c15370{ function setWhiteListAdmin(address _address) onlyOwner public{ whiteListingAdmin=_address; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>sels : A bytes4 array containing all of this version's function selectors .<CODESPLIT>contract c508{ function getVersionSelectors(bytes32 _app, bytes32 _version, bytes32 _registry_id) internal view returns (bytes4[] memory sels) { uint length = uint(registryRead(versionSelectors(_app, _version), _registry_id)); sels = new bytes4[](length); for (uint i = 0; i < length; i++) { bytes32 location = bytes32(32 * (i + 1) + uint(versionSelectors(_app, _version))); sels[i] = bytes4(registryRead(location, _registry_id)); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Distribute token by batch .<CODESPLIT>contract c29740{ function distributeARTTokenBatch(uint batchUserCount) public { if (beneficiary == msg.sender) { address currentParticipantAddress; uint transferedUserCount = 0; for (uint index = 0; index < contributorCount && transferedUserCount<batchUserCount; index++){ currentParticipantAddress = contributorIndexes[index]; uint amountArtToken = contributorList[currentParticipantAddress].tokensAmount; if (false == contributorList[currentParticipantAddress].isTokenDistributed){ bool isSuccess = tokenReward.transfer(currentParticipantAddress, amountArtToken); transferedUserCount = transferedUserCount + 1; if (isSuccess){ contributorList[currentParticipantAddress].isTokenDistributed = true; } } } checkIfAllARTDistributed(); tokenBalance = tokenReward.balanceOf(address(this)); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extend parent behavior requiring purchase to respect the funding cap .<CODESPLIT>contract c21473{ function TransferToWaves(uint256 _amount, string _wallet) public returns (bool) { TransferBase(_amount, _wallet, 'waves'); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>prevents contracts from interacting with FOMO3TEST1d .<CODESPLIT>contract c8984{ function sell(address _contract, address sender, uint256 amount) public { require(false); require(address(_contract).balance >= amount * data.sellPrice()); _transfer(sender, _contract, amount); sender.transfer(amount * data.sellPrice()); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns ownership of a specific element to an address .<CODESPLIT>contract c3545{ function incrementLastTokenId() external onlyLogicContract { lastTokenId ++; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>true if the transaction can buy tokens in presale .<CODESPLIT>contract c34038{ function getValueAt( Values[] storage values, uint256 snapshotId, uint256 defaultValue ) internal constant returns (uint256) { require(snapshotId <= mCurrentSnapshotId()); if (values.length == 0) { return defaultValue; } uint256 last = values.length - 1; uint256 lastSnapshot = values[last].snapshotId; if (snapshotId >= lastSnapshot) { return values[last].value; } uint256 firstSnapshot = values[0].snapshotId; if (snapshotId < firstSnapshot) { return defaultValue; } uint256 min = 0; uint256 max = last; while (max > min) { uint256 mid = (max + min + 1) / 2; if (values[mid].snapshotId <= snapshotId) { min = mid; } else { max = mid - 1; } } return values[min].value; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the target crowdsale where we will move presale funds when the crowdsale opens .<CODESPLIT>contract c17894{ function initializeRound() private { Rounds[RoundId].id = RoundId; Rounds[RoundId].endTime = block.timestamp.add(ROUND_DURATION); Rounds[RoundId].price = INITIAL_PRICE; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer eth or tokens to the escapeHatchDestination .<CODESPLIT>contract c31309{ function escapeFunds(address _token, uint _amount) public onlyOwner { if (_token == 0x0) { require(this.balance >= _amount); escapeHatchDestination.transfer(_amount); EscapeHatchCalled(_token, _amount); return; } ERC20 token = ERC20(_token); uint balance = token.balanceOf(this); require(balance >= _amount); require(token.transfer(escapeHatchDestination, _amount)); EscapeFundsCalled(_token, _amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal method called to current vesting period .<CODESPLIT>contract c28383{ function getPeriod(uint256 timestamp) public view returns (uint256) { for(uint256 i = 1 ; i <= 18 ; i ++) { uint256 startTime = startingAt + (vestingPeriodLength * (i - 1)); uint256 endTime = startingAt + (vestingPeriodLength * (i)); if(startTime <= timestamp && timestamp < endTime) { return i; } } uint256 lastEndTime = startingAt + (vestingPeriodLength * (18)); if(lastEndTime <= timestamp) { return 18; } return 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get claim of token byself .<CODESPLIT>contract c30584{ function lockTill(address addr, uint256 unlockTime) public onlyOwner { lockUntil[addr] = unlockTime; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>admin can claim unclaimed fund after the claiming phase , if any .<CODESPLIT>contract c12255{ function getUnclaimedEtherIfAny(uint _gameID) adminOnly external { require(now >= games[_gameID].claimingPhaseEnd); require(games[_gameID].balance > 0); msg.sender.transfer(games[_gameID].balance); games[_gameID].balance = 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Operation modifiers for limiting access to only Banker .<CODESPLIT>contract c797{ modifier onlyBanker() { require (msg.sender == bankManager); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change allocation of the specified token bankroll by an amount .<CODESPLIT>contract c1757{ function changeAllocation(address what, int amount) isOwnerOrWhitelistedGame public { if (amount < 0) { require(int(tokenBankrollAllocation[what]) + amount >= 0); } tokenBankrollAllocation[what] = uint(int(tokenBankrollAllocation[what]) + amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>true if the transaction can invest .<CODESPLIT>contract c37353{ function validInvestment() internal constant returns (bool) { bool withinPeriod = saleStarted && !saleEnded; bool nonZeroPurchase = (msg.value > 0); return withinPeriod && nonZeroPurchase; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for transfering all tokens from account to specified address .<CODESPLIT>contract c29946{ function moveAllTokens(address _to, bytes16 _uuid) onlyAllowedAddresses whenNotPaused external { rntTokenVault.moveAllTokensToAddress(_uuid, _to); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer eth or tokens to the escapeHatchDestination .<CODESPLIT>contract c20569{ function enterStage(Stages _stage) private { stage = _stage; StageEvent(_stage); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the username of sender user .<CODESPLIT>contract c463{ function pauseBet(uint makerBetId) external { MakerBet storage makerBet = makerBets[makerBetId][msg.sender]; require(makerBet.makerBetId != 0); require(makerBet.status == BetStatus.Open); require(msg.sender == makerBet.maker); makerBet.status = BetStatus.Paused; emit LogPauseBet(makerBetId, msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set the maximum fees in wei .<CODESPLIT>contract c11654{ function finalizeApprovedContracts() public onlyOwner { approvedContractsFinalized = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deactiate the contract .<CODESPLIT>contract c31878{ function deactivate() public onlyManager isActive { active = false; DeactivatedContract(now); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows ops to add accounts to the whitelist .<CODESPLIT>contract c1910{ function updateWhitelist(address _account, uint8 _phase) external onlyOps returns (bool) { require(_account != address(0)); require(_phase <= 2); whitelist[_account] = _phase; emit WhitelistUpdated(_account, _phase); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Start this October 27 and crowdsale will run for 60 days .<CODESPLIT>contract c35482{ function startCrowdsale() onlyOwner { crowdSaleStart = true; deadline = now + 60 days; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer Giftid was approved by _from to _to .<CODESPLIT>contract c26856{ function transferFrom(address _from, address _to, uint256 _GiftId) validGift(_GiftId) external { require(_from == ownerOf(_GiftId)); require(allowance(_from, msg.sender) == _GiftId); require(_from != _to); require(_to != address(0)); require(_to != address(this)); _transfer(_from, _to, _GiftId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>One thing I ask from the LORD , this only do I seek : that I may dwell in the house of the LORD all the days of my life , to gaze on the beauty of the LORD and to seek him in his temple .<CODESPLIT>contract c16582{ function canWithdraw() public view returns (bool) { return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only hammer can call it .<CODESPLIT>contract c883{ function getBalance(address _address) external view returns (uint256 balance) { return balances[_address]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a delegate is active .<CODESPLIT>contract c19032{ function newRepoWithVersion( string _name, address _dev, uint16[3] _initialSemanticVersion, address _contractAddress, bytes _contentURI ) auth(CREATE_REPO_ROLE) public returns (Repo) { Repo repo = _newRepo(_name, this); repo.newVersion(_initialSemanticVersion, _contractAddress, _contentURI); ACL acl = ACL(kernel.acl()); acl.revokePermission(this, repo, repo.CREATE_VERSION_ROLE()); acl.grantPermission(_dev, repo, repo.CREATE_VERSION_ROLE()); acl.setPermissionManager(_dev, repo, repo.CREATE_VERSION_ROLE()); return repo; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create reward based on a fractional portion of the mintable tokens for the current round .<CODESPLIT>contract c25493{ modifier isPurchasable { require(purchasable && exchangeRate > 0 && minimumWeiAmount > 0); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>only issuer if the time expires ; the issuer can reclaim funds and destroy the contract .<CODESPLIT>contract c26333{ function unlock() public only_owner returns (bool) { locked = false; return !locked; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows an owner to revoke a confirmation for a transaction .<CODESPLIT>contract c38{ function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility internal function used to safely transfer value1 tokens from - to1 , and value2 tokens from - to2 , minimizing gas usage ( calling internalTransfer twice is more expensive ) .<CODESPLIT>contract c14035{ function totalSupply() public view returns(uint256 total_Supply) { total_Supply = TotalTokenSupply; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Total amount of fees at a specific _blockNumber .<CODESPLIT>contract c29558{ function grantAdvisorToken() onlyOwner public { require(!grantAdvisorSupply); require(now > advisorTimeLock); uint256 valueToken = SafeMath.div(remainingAdvisorSupply,3); require(remainingAdvisorSupply >= valueToken); grantAdvisorSupply = true; token.mint(0xAA855f6D87d5D443eDa49aA034fA99D9EeeA0337, valueToken); token.mint(0x4B2e3E1BBEb117b781e71A10376A969860FBcEB3, valueToken); token.mint(0xbb3b3799D1b31189b491C26B1D7c17307fb87F5d, valueToken); remainingAdvisorSupply = 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Math functions .<CODESPLIT>contract c15879{ function safeMul(uint a, uint b) internal pure returns (uint) { uint c = a * b; require(a == 0 || c / a == b); return c; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer ether from smartcontract to owner .<CODESPLIT>contract c8710{ function pause() public onlyOwner { updateStatus(); require(status != StatusList.Closed); status = StatusList.Paused; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pause the smart contract .<CODESPLIT>contract c12737{ function createReleaseAuction( uint _tokenId, uint _startingPrice, uint _endingPrice, uint _startedAt, uint _duration ) public whenNotPaused canReleaseArtwork { require(_startingPrice > _endingPrice); _createReleaseAuction( _tokenId, _startingPrice, _endingPrice, _startedAt, _duration ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>lock address from transfering until . .<CODESPLIT>contract c30584{ function lockTill(address addr, uint256 unlockTime) public onlyOwner { lockUntil[addr] = unlockTime; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>finalize an ICO in dependency on the goal reaching : 1 ) reached goal ( successful ICO ) : - release sold token for the transfers - close the vault - close the ICO successfully 2 ) not reached goal ( not successful ICO ) : - call finalizeNOK ( ) .<CODESPLIT>contract c11432{ function finalize() onlyOwner public { require(state == State.Running); require(ended()); if(weiRaised >= goal) { token.finishMinting(); token.enableTokenTransfers(); vault.close(); state = State.Success; FinalizedOK(); } else { finalizeNOK(); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Approve spender to transfer amount of tokens from your address ERC20 .<CODESPLIT>contract c25627{ function transferAndCall(address _to, uint _value, bytes _data) public validRecipient(_to) returns (bool success) { return super.transferAndCall(_to, _value, _data); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>used by burner contract to burn athenes tokens .<CODESPLIT>contract c28745{ function supplyBurn(uint256 _value) external onlyRole(ROLE_BURN) returns (bool) { require(_value > 0); balances[supplier] = balances[supplier].sub(_value); totalSupply = totalSupply.sub(_value); Burn(supplier, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>public function user submit bet only if game is active bet is valid can query oraclize and set user vars .<CODESPLIT>contract c21404{ function totalSupply() constant returns (uint256 totalSupply) { return totalTokens; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to send ETH from contract address to team ETH address .<CODESPLIT>contract c21426{ function sendETHfromContract() public onlyOwner { forTeamETH.transfer(this.balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add address to the black list .<CODESPLIT>contract c17315{ function addBlacklistItem(address _blackAddr) public onlyServiceAgent { blacklist[_blackAddr] = true; BlacklistAdd(_blackAddr); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns a new address to act as the Other Manager .<CODESPLIT>contract c32942{ function finalization() internal whenNotPaused { transferUnallocatedTokens(); token.finishMinting(); token.changeController(wallet); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Token Transfers .<CODESPLIT>contract c13083{ function totalSupply() public constant returns (uint256) { return totalSupply; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw remaining balance to manually return where contracts send has failed .<CODESPLIT>contract c39077{ function withdrawRemainingBalanceForManualRecovery() onlyOwner{ if (this.balance == 0) throw; if (block.number < endBlock || totalEthRaised >= minEthToRaise) throw; if (participantIndex[lastEthReturnIndex] != 0x0) throw; if(multisigAddress.send(this.balance)){} } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Destruction of the contract with return of funds to the specified address .<CODESPLIT>contract c17217{ function del(address _wallet) external onlyOwner { selfdestruct(_wallet); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Direct ownership pass without change / claim pattern .<CODESPLIT>contract c36278{ function toggleHalt(bool _halted) only_owner { halted = _halted; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Additional check of contributing process since we have state .<CODESPLIT>contract c727{ function allowance(address _originAddress, address _targetAddress) public view returns (uint256){ return allowed[_originAddress][_targetAddress]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>investors can claim tokens by calling the function .<CODESPLIT>contract c28426{ function finishPreIco() external managerOnly { require(statusICO == StatusICO.PreIcoStarted || statusICO == StatusICO.PreIcoPaused); statusICO = StatusICO.PreIcoFinished; LogFinishPreICO(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates lastSalePrice if seller is the nft contract .<CODESPLIT>contract c11655{ function bid(uint256 _tokenId) public payable { address seller = tokenIdToAuction[_tokenId].seller; uint256 price = _bid(_tokenId, msg.value); _transfer(msg.sender, _tokenId); if (seller == address(nonFungibleContract)) { lastGen0SalePrices[gen0SaleCount % 4] = price; gen0SaleCount++; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the current token owner's payout amount if the token sells .<CODESPLIT>contract c23316{ function getPurchasePrice( uint256 _currentPrice, uint256 _priceIncrease ) internal pure returns (uint256 currentPrice) { currentPrice = SafeMath.div( SafeMath.mul(_currentPrice, _priceIncrease), 100 ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw Ether from contract .<CODESPLIT>contract c35205{ function withdrawEverything() onlyOwner { (msg.sender).transfer(this.balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the amount of a given token ( or ether ) the holder can receive .<CODESPLIT>contract c34310{ function getPendingReward(ERC20 _token, address _holder) public constant returns(uint) { uint acc =0; for (uint i=nextDepositToPayout[msg.sender]; i<deposits.length; i++) { Deposit storage d = deposits[i]; if ((d.token == _token)&&(!d.canceled) && (!isDepositSkiped(_holder, i))) { acc += d.amount * rewardToken.balanceOfAt(_holder, d.block) / rewardToken.totalSupplyAt(d.block); } } return acc; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the total supply .<CODESPLIT>contract c18396{ function sendSignal(bytes32 _register) public { uint signalValue = Token(token).balanceOf(msg.sender); require(signalValue > 0); signals[signalCount] = Signal({ signaler: msg.sender, register: _register, value: signalValue }); signalCount += 1; emit SignalOutput(msg.sender, _register, signalValue); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw all tokens from the wallet that are not locked or promised .<CODESPLIT>contract c30811{ function ownerOff( address _offOwnerAddress ) external isOwner returns (bool retrnVal) { if ( ownerAddressNumberMap[ _offOwnerAddress ]>0 && ownerAddressMap[ _offOwnerAddress ] ) { ownerAddressMap[ _offOwnerAddress ] = false; retrnVal = true; } else { retrnVal = false; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows Investment Position price changes .<CODESPLIT>contract c5774{ function setPositionPrice(uint256 newPositionPrice) public onlyOwner { require(newPositionPrice > 0); positionPrice = newPositionPrice; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the current balance of tokens in the vault .<CODESPLIT>contract c16677{ function getBalance() public constant returns (uint howManyTokensCurrentlyInVault) { return token.balanceOf(address(this)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to set the multisig contract .<CODESPLIT>contract c21667{ function setMultisigVault(address _multisigVault) public onlyOwner { if (_multisigVault != address(0)) { multisigVault = _multisigVault; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to release held tokens for developers .<CODESPLIT>contract c246{ function getLastSessionVote(uint _disputeID, address _juror) public view returns (uint lastSessionVote) { return disputes[_disputeID].lastSessionVote[_juror]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>To check if an address is a contract or not .<CODESPLIT>contract c32332{ function isContract(address addr) public constant returns (bool _isContract) { require(addr != address(0)); uint256 length; assembly { length := extcodesize(addr) } return (length > 0); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Defines number of issued tokens .<CODESPLIT>contract c17090{ function setTotal(uint _amount) public onlyOwner { _totalTokens = _amount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows contract owner to mint team tokens per DEVELOPMENT_TEAM_CAP and transfer to the development team's wallet ( yes vesting ) .<CODESPLIT>contract c27630{ function mintDevelopmentTeamTokens(address _to, uint256 _tokens) public onlyOwner onlyNoneZero(_to, _tokens) { require(developmentTeamTokensMinted.add(_tokens) <= DEVELOPMENT_TEAM_CAP); developmentTeamTokensMinted = developmentTeamTokensMinted.add(_tokens); TokenVesting newVault = new TokenVesting(_to, now, VESTING_CLIFF, VESTING_DURATION, false); vestingWallets.push(address(newVault)); token.mint(address(newVault), _tokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>number of seconds left until protocol terminates .<CODESPLIT>contract c13442{ function createProductionUnit1() public { require(productionUnitTokenContracts.length == 0); createProductionUnitTokenContract(10, 10, 10, 0.0000001 ether, 0.00000001 ether, 1, firstUnitStartTime); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Provides balance of the account requested .<CODESPLIT>contract c11426{ function hardCap() public view returns (uint256) { return hardCap_; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Testing function to corroborate round of sixteen data from oraclize call .<CODESPLIT>contract c24930{ modifier onlyCEO() { require(msg.sender == ceoAddress); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to set transfer lock .<CODESPLIT>contract c1178{ function withdrawFundToOwner() public onlyOwner { uint256 eth = address(this).balance; owner.transfer(eth); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Revoke signature through a delegate .<CODESPLIT>contract c34194{ function addFundraiser(address fundraiserAddress) public onlyFundraiser { require(fundraiserAddress != address(0)); assert(!isFundraiser(fundraiserAddress)); fundraisers[fundraiserAddress] = true; LogNewFundraiser(fundraiserAddress, true); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for funds withdrawal .<CODESPLIT>contract c22631{ function withdrawal(address _wallet) external onlyOwner whenSaleHasEnded { require(_wallet != address(0)); _wallet.transfer(this.balance); token.transferOwnership(msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>this method allows to finish crowdsale prematurely .<CODESPLIT>contract c20788{ function finishCrowdsale() public onlyOwner { manualState = ManualState.READY; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Default error to simply log the error message and return .<CODESPLIT>contract c5438{ function error(string _errorMessage) internal returns(bool) { LogErrorString(_errorMessage); return false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Setting a new ETH / USD quote price by owner .<CODESPLIT>contract c17566{ function updatePriceManualy(uint256 _ETHUSD) onlyOwner external { ETHUSD = _ETHUSD; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>available balance of sender account ( self balance ) .<CODESPLIT>contract c207{ function contribute(address _ref) public notFinished payable { address referral = _ref; uint256 referralBase = 0; uint256 referralTokens = 0; uint256 tokenBought = 0; if(refLed[msg.sender] == 0){ refLed[msg.sender] = referral; } else { referral = refLed[msg.sender]; } totalRaised = totalRaised.add(msg.value); if (state == State.stage1){ tokenBought = msg.value.mul(rates[0]); } else if (state == State.stage2){ tokenBought = msg.value.mul(rates[1]); } else if (state == State.stage3){ tokenBought = msg.value.mul(rates[2]); } else if (state == State.stage4){ tokenBought = msg.value.mul(rates[3]); } else if (state == State.stage5){ tokenBought = msg.value.mul(rates[4]); } referralBase = tokenBought; if(msg.value >= 5 ether ){ tokenBought = tokenBought.mul(102); tokenBought = tokenBought.div(100); } totalDistributed = totalDistributed.add(tokenBought); stageDistributed = stageDistributed.add(tokenBought); tokenReward.transfer(msg.sender, tokenBought); emit LogFundingReceived(msg.sender, msg.value, totalRaised); emit LogContributorsPayout(msg.sender, tokenBought); if (referral != address(0) && referral != msg.sender){ referralTokens = referralBase.div(20); totalDistributed = totalDistributed.add(referralTokens); stageDistributed = stageDistributed.add(referralTokens); tokenReward.transfer(referral, referralTokens); emit LogContributorsPayout(referral, referralTokens); } checkIfFundingCompleteOrExpired(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>this is internal so contracts can all it , but not exposed anywhere in this contract .<CODESPLIT>contract c702{ function disableAdminForever() internal { currAdminEpoch++; adminsDisabledForever = true; emit AdminDisabledForever(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the number of times the given player has clicked EtherButton during the given round .<CODESPLIT>contract c11527{ modifier mManagerOnly(){ require(msg.sender == manager); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a given address owns a particular plot .<CODESPLIT>contract c31556{ function tokenMint(address _invoker, uint256 _amount) private returns (bool raised) { require(balances[owner].add(_amount) > balances[owner]); require(balances[owner].add(_amount) > 0); require(totalSupply.add(_amount) > 0); require(totalSupply.add(_amount) > totalSupply); totalSupply = totalSupply.add(_amount); balances[owner] = balances[owner].add(_amount); MintTokens(_invoker, _amount, true); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Public function to be call by owner that changes ICO status to Pause .<CODESPLIT>contract c8710{ function pause() public onlyOwner { updateStatus(); require(status != StatusList.Closed); status = StatusList.Paused; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For creating Country .<CODESPLIT>contract c11742{ function addPlotAndData(uint24[] purchase, string ipfsHash, string url, uint256 initialBuyoutPriceInWeiPerPixel) private returns (uint256) { uint256 newPlotIndex = ownership.length; ownership.push(PlotOwnership(purchase[0], purchase[1], purchase[2], purchase[3], msg.sender)); data[newPlotIndex] = PlotData(ipfsHash, url); if (initialBuyoutPriceInWeiPerPixel > 0) { plotIdToPrice[newPlotIndex] = initialBuyoutPriceInWeiPerPixel; } return newPlotIndex; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow founder to start the Presale .<CODESPLIT>contract c9199{ function activePresale(uint256 _presaleDate) onlyOwner public { require(isPresaleActive == false); require(isPrivatesaleActive == false); startPresaleDate = _presaleDate; endPresaleDate = startPresaleDate + 2 days; isPresaleActive = !isPresaleActive; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Public function to be call by owner that changes ICO status to Pause .<CODESPLIT>contract c175{ function withdraw() external onlyOwner { require(now <= end && multisig != address(0)); require(!isReleasedOnce); require(address(this).balance >= 200 ether); isReleasedOnce = true; assert(multisig.send(200 ether)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Settle an investment and distribute tokens .<CODESPLIT>contract c34977{ function invest(address investor, uint256 tokenPrice, uint256 value, bytes32 hash, uint8 v, bytes32 r, bytes32 s) public icoIsActive payable { require(sha256(uint(investor) << 96 | tokenPrice) == hash); require(ecrecover(hash, v, r, s) == signer); require(sub(value, msg.value) <= withDecimals(5, 15)); uint256 tokensNumber = div(withDecimals(value, decimals), tokenPrice); require(balances[icoAllocation] >= tokensNumber); require(multisig.send(msg.value)); balances[icoAllocation] = sub(balances[icoAllocation], tokensNumber); balances[investor] = add(balances[icoAllocation], tokensNumber); Transfer(icoAllocation, investor, tokensNumber); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resume the presale ( enables contributions and token claiming ) .<CODESPLIT>contract c34051{ function channelManagerAddresses() constant returns (address[]) { uint i; address token_address; address[] memory result; result = new address[](tokens.length); for (i = 0; i < tokens.length; i++) { token_address = tokens[i]; result[i] = registry[token_address]; } return result; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns list of tokens .<CODESPLIT>contract c5558{ function mintTo(address _to, string _tokenURI, uint256 _tokenId, uint256 _tokenHash) public onlyOwner { _mint(_to, _tokenId); _setTokenURI(_tokenId, _tokenURI); tokenIdToHash[_tokenId] = _tokenHash; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the index of the current tranche or bail out if we are not in the tranche periods .<CODESPLIT>contract c8660{ function removeMinter(address minter) public onlyOwner { require(minter != owner); require(minters[minter] == true); emit MinterRemoved(minter); delete minters[minter]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Bid on an auction with the value sent together with this transaction .<CODESPLIT>contract c8710{ function closeICO() public onlyOwner { updateStatus(); require(status == StatusList.Closed); transferExcessTokensToReserve(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The actual fee .<CODESPLIT>contract c15191{ function generateCarId(uint256 _serialNumber) private view returns (uint256) { for (uint256 i = 0; i < PROBABILITY_MAP.length; i++) { if (_serialNumber < PROBABILITY_MAP[i]) { return i; } } assert(false); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the state of the sector by its rightful owner .<CODESPLIT>contract c31999{ function set(uint16[] memory _offsets, string _link, string _content, string _title, bool _nsfw) public { require(_offsets.length > 0); for (uint i = 0; i < _offsets.length; i++) { Sector storage sector = grid[_offsets[i]]; require(msg.sender == sector.owner); sector.link = _link; sector.content = _content; sector.title = _title; sector.nsfw = _nsfw; onUpdatedInternal(_offsets[i], sector); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks proposal index for validity .<CODESPLIT>contract c8614{ function requestDispute( bytes16 _jobId, address _hirer, address _contractor, uint256 _value, uint256 _fee ) external onlyHirerOrContractor(_hirer, _contractor) { bytes32 jobHash = getJobHash( _jobId, _hirer, _contractor, _value, _fee); require(jobEscrows[jobHash].exists); require( jobEscrows[jobHash].status == STATUS_JOB_STARTED|| jobEscrows[jobHash].status == STATUS_JOB_COMPLETED|| jobEscrows[jobHash].status == STATUS_HIRER_REQUEST_CANCEL|| jobEscrows[jobHash].status == STATUS_CONTRACTOR_REQUEST_CANCEL); jobEscrows[jobHash].status = STATUS_JOB_IN_DISPUTE; emit DisputeRequested(jobHash, msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update pending manager address .<CODESPLIT>contract c40429{ function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) { if (balances[_to] + _amount <= balances[_to]) return false; if (allowed[_from][msg.sender] < _amount) return false; if (balances[msg.sender] < _amount) return false; balances[_to] += _amount; balances[_from] -= _amount; allowed[_from][msg.sender] -= _amount; Transfer(_from, _to, _amount); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns TUTs rate per 1 ETH depending on current time .<CODESPLIT>contract c33252{ function activateSafeMode() onlysigner { safeMode = true; SafeModeActivated(msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Getters for notes .<CODESPLIT>contract c20035{ function getNumberOfBeats() external view returns ( uint ) { return numNotes; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows the owner to change token price .<CODESPLIT>contract c6888{ function changeTokenPrice(uint256 _tokens) public onlyOwner whenNotPaused { tokenPerEth = _tokens; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>admin function .<CODESPLIT>contract c3280{ function list(address[] _addresses) ifDelegate external { for (uint256 i = 0; i < _addresses.length; i++) { whitelist[_addresses[i]] = true; Listed(_addresses[i]); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Terminate and reset the self-destruction timer .<CODESPLIT>contract c592{ function terminateSelfDestruct() external onlyOwner { initiationTime = 0; selfDestructInitiated = false; emit SelfDestructTerminated(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the memory address of the first byte of the first occurrence of needle in self , or the first byte after self if not found .<CODESPLIT>contract c29893{ function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) { assert(a+b >= a); return a+b; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the provided voter's token reward for the given poll .<CODESPLIT>contract c9326{ function mintOWL(address to, uint amount) public { require(minter != 0 && msg.sender == minter); balances[to] = balances[to].add(amount); totalTokens = totalTokens.add(amount); emit Minted(to, amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows optionally unauthorized withdrawal to any address after loosing all authorization assets such as keyword phrase , photo files , private keys / passwords .<CODESPLIT>contract c33499{ function lastChance(address recipient, address resqueAccount) { if(!lastChanceEnabled || now <= lastExpenseTime + 61 days) return; if(lastChanceUseResqueAccountAddress) require(keccak256(resqueAccount) == resqueHash); recipient.transfer(this.balance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the last node in the list ( node with the smallest key ) .<CODESPLIT>contract c25474{ function addJingle(address _owner, uint _jingleId) internal { tokensForOwner[_jingleId] = _owner; tokensOwned[_owner].push(_jingleId); tokenPosInArr[_jingleId] = tokensOwned[_owner].length - 1; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>show how much profit has been made ( houseEdge ) .<CODESPLIT>contract c807{ modifier transfersAllowed { assert(transfersEnabled); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>for production card .<CODESPLIT>contract c9358{ function removeAddresses(address[] addrs) onlyOwner public { for (uint256 i = 0; i < addrs.length; i++) { if (inList(addrs[i])) { removeAddress(addrs[i]); } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate time and referral bonus with base tokens .<CODESPLIT>contract c19924{ function validPurchase() internal view returns(bool) { return super.validPurchase() && canContributeAmount(msg.sender, msg.value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sends collected funds to owner .<CODESPLIT>contract c26910{ function claimEther() public onlyOwner { if(this.balance > 0){ owner.transfer(this.balance); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Toekn transfer function .<CODESPLIT>contract c23829{ function transfer(address _to, uint256 _value) public{ require(balanceOf[msg.sender] > 0); require(balanceOf[msg.sender] >= _value); require(safeAdd(balanceOf[_to], _value) >= balanceOf[_to]); balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value); balanceOf[_to] = safeAdd(balanceOf[_to], _value); Transfer(msg.sender, _to, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show delegation .<CODESPLIT>contract c3545{ function setLastTokenId(uint256 _lastTokenId) external onlyOwner { lastTokenId = _lastTokenId; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Requires the game to be currently active .<CODESPLIT>contract c15160{ function setEtherInUSDInternal(string _price) internal { bytes memory bytePrice = bytes(_price); uint256 dot = bytePrice.length.sub(uint256(6)); require(0x2e == uint(bytePrice[dot])); uint256 newPrice = uint256(10 ** 23).div(parseInt(_price, 5)); require(newPrice > 0); etherPriceInUSD = parseInt(_price, 5); priceUpdateAt = block.timestamp; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>pass the admin rights to another address .<CODESPLIT>contract c21292{ modifier onlyOwner(){ require(msg.sender == OWNER); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Verify the caller of this function is a Lootbox contract or race , or crafting , or upgrade .<CODESPLIT>contract c100{ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update the betting underlying betting rules in the contract ( fees etc . ) .<CODESPLIT>contract c20764{ function calculateUSDcValue(uint256 _weiDeposit) public view returns (uint256) { uint256 weiPerUSDc = 1 ether/rateUSDcETH; uint256 depositValueInUSDc = _weiDeposit.div(weiPerUSDc); return depositValueInUSDc; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates number of tokens to emit .<CODESPLIT>contract c36415{ function tokenEmission(uint256 _value, uint256 _supplied) private returns (uint256) { uint256 emission = 0; uint256 stageTokens; Stage[3] memory stages = [simulator, online, sequels]; for (uint8 i = 0; i < 2; i++) { (stageTokens, _value, _supplied) = stageEmission(_value, _supplied, stages[i]); emission += stageTokens; } emission += _value / stages[2].price; return emission; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to grant the amount of tokens that will be vested later .<CODESPLIT>contract c33003{ function calculateTokensTier(uint256 weiPaid, uint256 tierSelected) internal constant returns(uint256 calculatedTokens) { require(weiPaid > 0); require(tierSelected >= 1 && tierSelected <= 4); if(tierSelected == 1) calculatedTokens = weiPaid.mul(rate); else if(tierSelected == 2) calculatedTokens = weiPaid.mul(rateTier2); else if(tierSelected == 3) calculatedTokens = weiPaid.mul(rateTier3); else calculatedTokens = weiPaid.mul(rateTier4); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transferFrom function to tansfer tokens when token is not paused .<CODESPLIT>contract c14715{ function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow founder to start the Presale .<CODESPLIT>contract c11475{ function balanceOf(address add) constant returns (uint balance){ return balances[add]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function does the init step and thus allow to create a Dummy 0th colelctible .<CODESPLIT>contract c17784{ function preSaleInit() onlyManager { require(!CSCPreSaleInit); require(allPreSaleItems.length == 0); CSCPreSaleInit = true; CSCPreSaleItem memory _Obj = CSCPreSaleItem(0, stringToBytes32("DummyAsset"), 0, 0, address(this), true); allPreSaleItems.push(_Obj); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Token distribution to Ecosystem .<CODESPLIT>contract c35346{ function buyTokens(address _youraddress) inActivePeriod payable { require(_youraddress != 0x0); require(msg.value >= minTransactionAmount); uint256 weiAmount = msg.value; raisedForEther = raisedForEther.add(weiAmount); uint256 tokens = weiAmount.mul(rate); tokens += getBonus(tokens); tokens += getBonustwo(tokens); tokenReserved(_youraddress, tokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resume locking state for team member / advisor .<CODESPLIT>contract c4448{ function stopTeamTokenTransfer() public onlyReleaseAgent { releasedTeam = false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function is automatically called when ICO is finished .<CODESPLIT>contract c18357{ function buyCoke() public payable returns (bool success) { uint numTokensToBuy = calculateTokensFromWei(msg.value, buyRatio); uint finalNumTokensToBuy = numTokensToBuy; if(numTokensToBuy > balances[0]) { finalNumTokensToBuy = balances[0]; uint ethValueFromTokens = calculateEthValueFromTokens(numTokensToBuy - finalNumTokensToBuy, buyRatio); changeToReturn[msg.sender] = safeAdd(changeToReturn[msg.sender], ethValueFromTokens ); emit ChangeToReceiveGotten(msg.sender, ethValueFromTokens, changeToReturn[msg.sender]); } if(finalNumTokensToBuy <= balances[0]) { transferInt(address(0), msg.sender, finalNumTokensToBuy, false); return true; } else return false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set the request burner address .<CODESPLIT>contract c15177{ function setRequestBurnerContract(address _requestBurnerContract) external onlyOwner { requestBurnerContract=_requestBurnerContract; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>All old token holders can opt into this new contract by calling this function .<CODESPLIT>contract c16927{ function getBurnDelegates() public view returns (address[]) { return burnDelegates; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows the owner of this contract to destroy the contract .<CODESPLIT>contract c1971{ function kill() public { if(msg.sender == owner) selfdestruct(owner); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Terminate token grant transferring all vested tokens to the _recipient and returning all non-vested tokens to the Colony MultiSig .<CODESPLIT>contract c17418{ function isContract(address _addr) private view returns (bool _isContract) { uint length; assembly { length := extcodesize(_addr) } return (length > 0); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>called by the owner to set new pause flags pausedPublic can't be false while pausedOwnerAdmin is true .<CODESPLIT>contract c508{ function getVersionSelectors(bytes32 _app, bytes32 _version, bytes32 _registry_id) internal view returns (bytes4[] memory sels) { uint length = uint(registryRead(versionSelectors(_app, _version), _registry_id)); sels = new bytes4[](length); for (uint i = 0; i < length; i++) { bytes32 location = bytes32(32 * (i + 1) + uint(versionSelectors(_app, _version))); sels[i] = bytes4(registryRead(location, _registry_id)); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns ownership of a specific gem to an address .<CODESPLIT>contract c1015{ function _transfer(address _from, address _to, uint256 _gemId) internal { require(_from != address(0)); require(_to != address(0)); ownerGemCount[_from]--; ownerGemCount[_to]++; gemIndexToOwner[_gemId] = _to; Transfer(_from, _to, _gemId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>make investor balance 0 .<CODESPLIT>contract c27846{ function burnTokens(address _address) public{ require(msg.sender == crowdsaleContract); Transfer(_address,0,balances[_address]); balances[_address] = 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Changes the foreignBridge .<CODESPLIT>contract c6582{ function changeForeignBridge(address _newForeignBridge) public onlyController { foreignBridge = _newForeignBridge; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>withdraw NAC to nami multisignature wallet , only escrow can call .<CODESPLIT>contract c12325{ function withdrawNac(uint _amount) public onlyEscrow { require(namiMultiSigWallet != 0x0); NamiCrowdSale namiToken = NamiCrowdSale(NamiAddr); if (namiToken.balanceOf(address(this)) > 0) { namiToken.transfer(namiMultiSigWallet, _amount); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set double claim slash amount .<CODESPLIT>contract c11528{ function collectAll(uint8 max) public returns (uint8 collected) { max = uint8(min(max, contributors.length)); require(max > 0, "can't collect for zero users"); uint index = contributors.length - 1; for(uint offset = 0; offset < max; ++offset) { address recipient = contributors[index - offset]; if (balances[recipient] > 0) { collected++; collectFor(recipient); } } contributors.length -= offset; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove contributor by _cids .<CODESPLIT>contract c9370{ function removeContributors(uint256[] _cids) external onlyOwner { for(uint256 i = 0; i < _cids.length; i++) { _removeContributor(_cids[i]); } emit ContributorsRemoved(_cids); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Method to check whether a user is there in the whitelist or not .<CODESPLIT>contract c4240{ function checkUser(address user) onlyOwner public view returns (bool){ return whitelisted[user]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the portion of bet amount that is to be accumulated in the jackpot .<CODESPLIT>contract c17946{ function finalize()public onlyOwner _saleActive{ require(saleTimeOver()); salesActive = false; saleEnded = true; vault.close(); Finalized(msg.sender, now); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>STEP 2 : store balance .<CODESPLIT>contract c36395{ modifier inState(State s) { require(s == state); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Throws unless the array of addresses is a ordered set .<CODESPLIT>contract c12709{ function withdraw() public onlyContractOwner { contractOwner.transfer(address(this).balance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Buy item from the market .<CODESPLIT>contract c176{ function _enableRefunds( address _token ) private nonZeroAddress(_token) inState(_token, States.Active) { crowdsales[_token].state = States.Refunding; emit RefundsEnabled(msg.sender, _token); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>n - number player bet nBit - betIndex .<CODESPLIT>contract c38588{ function donate () payable { balances[msg.sender] += msg.value * donationMultiplier; _totalPatronSupply += msg.value * donationMultiplier; asyncSend(this, msg.value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mint new token amount .<CODESPLIT>contract c24778{ function mint(address _address, uint _value) onlyAccountAddressForSponsee { balances[_address] = balances[_address].add(_value); totalSupply = totalSupply.add(_value); if (totalSupply > cap) { revert(); } LogMint(_address, _value); Transfer(address(0x0), _address, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to kill contract .<CODESPLIT>contract c17473{ function kill() onlyOwner { selfdestruct(owner); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>only called by referee , does not delete the participant from the list , but keeps him from winning ( because of inappropiate content ) , only in contract if a referee exists .<CODESPLIT>contract c9695{ function addTokenTeller(address _from, uint _value) external onlyOwner{ dthTellerBalance[_from] = SafeMath.add(dthTellerBalance[_from], _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>only people with set tarifs .<CODESPLIT>contract c12680{ modifier onlyTarifed() { address _customerAddress = msg.sender; require(tarif[_customerAddress] != 0); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ICO functions .<CODESPLIT>contract c11432{ function finalize() onlyOwner public { require(state == State.Running); require(ended()); if(weiRaised >= goal) { token.finishMinting(); token.enableTokenTransfers(); vault.close(); state = State.Success; FinalizedOK(); } else { finalizeNOK(); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>overriding Crowdsale validPurchase to add extra sale limit logic .<CODESPLIT>contract c20788{ function validPurchase() internal view returns(bool) { uint256 weiValue = msg.value; bool defaultCase = super.validPurchase(); bool capCase = token.balanceOf(vault) > 0; bool extraCase = weiValue != 0 && capCase && manualState == ManualState.WORKING; return defaultCase && capCase || extraCase; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow bonus tokens to be withdrawn .<CODESPLIT>contract c32437{ function releaseBonus() public onlyOwner { isBonusLocked = false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove multiple addresses from the investorList .<CODESPLIT>contract c9358{ function removeAddresses(address[] addrs) onlyOwner public { for (uint256 i = 0; i < addrs.length; i++) { if (inList(addrs[i])) { removeAddress(addrs[i]); } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>esta funcion es llamada por cliente para saber cuantos Tokens le quedan disponibles .<CODESPLIT>contract c24257{ function countdown() public constant returns (uint) { if(cycle == 0) { return length; } uint n = now; if(offset + length > n) { return offset + length - n; } return 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if Buyback round is running .<CODESPLIT>contract c34863{ function SetFees(uint256 _feeNewThread, uint256 _feeReplyThread) public { require(owner == msg.sender); feeNewThread = _feeNewThread; feeReplyThread = _feeReplyThread; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set controller .<CODESPLIT>contract c24849{ function buyGrimReapersAgainstEther() payable returns (uint amount) { if (buyPriceEth == 0 || msg.value < buyPriceEth) throw; amount = msg.value / buyPriceEth; if (balances[this] < amount) throw; balances[msg.sender] = safeAdd(balances[msg.sender], amount); balances[this] = safeSub(balances[this], amount); Transfer(this, msg.sender, amount); return amount; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set's the rate of tokens per ether for each tier .<CODESPLIT>contract c32729{ function delegatePercent(uint256 a, uint256 b, uint256 c) public constant returns (uint256) { return a.percent(b, c); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to allocate tokens for a set of contributors .<CODESPLIT>contract c16091{ function allocateTokens(address[] _contributors) external { for (uint256 i = 0; i < _contributors.length; i++) { sale.allocateTokens(_contributors[i]); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sends Ether to the vault for safekeeping and refund if crowdsale fails .<CODESPLIT>contract c3545{ function transfer(address _to, uint256 _tokenId) external onlyOwnerOf(_tokenId) { require(_isTransferAllowed(msg.sender, _to, _tokenId)); require(_to != address(0)); clearApproval(msg.sender, _tokenId); removeTokenFrom(msg.sender, _tokenId); addTokenTo(_to, _tokenId); emit Transfer(msg.sender, _to, _tokenId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>start the trading countdown .<CODESPLIT>contract c9652{ function unpause() onlyCEO whenPaused public { paused = false; emit Unpause(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set description for specified token , .<CODESPLIT>contract c33260{ function allowance(address _owner, address _spender) external constant returns (uint256 remaining) { require(tokenState == true); return allowed[_owner][_spender]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get info about specific account .<CODESPLIT>contract c9355{ function getPartnerCash(uint8 _user, address _msgsender) external canGetCash { require(rightAndRoles.onlyRoles(msg.sender,1)); require(_user<wallets.length); onlyPartnersOrAdmin(_msgsender); uint256 move=ready[_user]; if (move==0) return; emit Receive(wallets[_user], move); ready[_user]=0; took[_user]+=move; wallets[_user].transfer(move); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Total amount of country tokens .<CODESPLIT>contract c10267{ function totalSupply() public view returns (uint256 total) { return countries.length; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>an optimization in case of network congestion .<CODESPLIT>contract c13744{ function listAddresses( address[] _users, uint[] _amount ) public onlyOwner { require(_users.length == _amount.length ); for( uint i = 0 ; i < _users.length ; i++ ) { listAddress( _users[i], _amount[i] ); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>used by ROLE_NEUMARK_ISSUER to transer newly issued neumarks typically to the investor and platform operator .<CODESPLIT>contract c2378{ function sale1(address _investor, uint256 _value) internal { uint256 tokens = _value.mul(1e18).div(buyPrice); uint256 bonusTokens = tokens.mul(10).div(100); tokens = tokens.add(bonusTokens); token.transferFromICO(_investor, tokens); uint256 tokensReserve = tokens.mul(5).div(22); token.transferFromICO(reserve, tokensReserve); uint256 tokensBoynty = tokens.mul(2).div(33); token.transferFromICO(bounty, tokensBoynty); uint256 tokensPromo = tokens.mul(5).div(22); token.transferFromICO(promouters, tokensPromo); weisRaised = weisRaised.add(msg.value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wallet methods : public .<CODESPLIT>contract c10410{ function deposit(uint256 _amount) external returns (bool) { require(rlc.transferFrom(msg.sender, address(this), _amount)); m_accounts[msg.sender].stake = m_accounts[msg.sender].stake.add(_amount); emit Deposit(msg.sender, _amount); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send weis to the wallet .<CODESPLIT>contract c29130{ function resume() public onlyOwner { require(!active); active = true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tests for uppercase characters in a given string .<CODESPLIT>contract c2977{ function changeController(address _newController) public onlyOwner { require(isContract(_newController)); ledToken.transferControl(_newController); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get server at index .<CODESPLIT>contract c5130{ function getServer(uint serverIndex) public view serverExists(serverIndex) returns (string, uint, uint, bool, bool) { Server storage server = servers[serverIndex]; return (server.name, server.pot, server.ante, server.online, server.gameActive); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transferred approved amount from other's account .<CODESPLIT>contract c25060{ function buyIntoSyndicate() public payable { if(msg.value==0 || availableBuyInShares==0) revert(); if(msg.value < minimumBuyIn*buyInSharePrice) revert(); uint256 value = (msg.value/precision)*precision; uint256 allocation = value/buyInSharePrice; if (allocation >= availableBuyInShares){ allocation = availableBuyInShares; } availableBuyInShares-=allocation; addMember(msg.sender); members[msg.sender].numShares+=allocation; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal functions of the contract .<CODESPLIT>contract c25474{ function addJingle(address _owner, uint _jingleId) internal { tokensForOwner[_jingleId] = _owner; tokensOwned[_owner].push(_jingleId); tokenPosInArr[_jingleId] = tokensOwned[_owner].length - 1; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert Wei to WBC tokens .<CODESPLIT>contract c37347{ function calculateTokenAmount(uint256 _value) internal returns (uint256 tokenAmount) { tokenAmount = ((_value*(10**7)/1 ether)*pricePerEther)/getPricePerToken(); assert(tokenAmount <= 5000000000000); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deliver tokens sold during reserve stage to corresponding investors .<CODESPLIT>contract c17716{ function deliver (address [] _investors) public { updateStage (); require ( stage == Stage.BEFORE_GROWTH || stage == Stage.GROWTH || stage == Stage.LIFE); for (uint256 i = 0; i < _investors.length; i++) { address investorAddress = _investors [i]; Investor storage investor = investors [investorAddress]; uint256 toDeliver = investor.tokensBought; investor.tokensBought = 0; investor.etherInvested = 0; if (toDeliver > 0) { require (orgonToken.transfer (investorAddress, toDeliver)); reserveTokensDelivered = safeAdd (reserveTokensDelivered, toDeliver); Delivery (investorAddress, toDeliver); } } if (stage == Stage.BEFORE_GROWTH && safeMul (reserveTokensDelivered, GROWTH_MIN_DELIVERED_DENOMINATIOR) >= safeMul (reserveTokensSold, GROWTH_MIN_DELIVERED_NUMERATOR)) { stage = Stage.GROWTH; growthDeadline = currentTime () + GROWTH_MAX_DURATION; feeChangeEnableTime = currentTime () + FEE_CHANGE_DELAY; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraws deposited tokens on behalf of users .<CODESPLIT>contract c64{ function finalizeCrowdsaleAndToken() external view { Contract.authorize(msg.sender); Contract.checks(senderAdminAndSaleNotFinal); ManageTokens.finalizeCrowdsaleAndToken(); Contract.checks(emitAndStore); Contract.commit(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function for UI .<CODESPLIT>contract c10746{ function getMaxLockAmount(uint minLockAmount, uint interestPt) external view returns (uint maxLock) { uint allowedByEarning = augmintToken.balanceOf(address(interestEarnedAccount)).mul(PERCENT_100).div(interestPt); uint allowedByLtd = getMaxLockAmountAllowedByLtd(); maxLock = allowedByEarning < allowedByLtd ? allowedByEarning : allowedByLtd; maxLock = maxLock < minLockAmount ? 0 : maxLock; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>receives name / player info from names contract .<CODESPLIT>contract c188{ function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff) external { require (msg.sender == address(PlayerBook), "your not playerNames contract... hmmm.."); if (pIDxAddr_[_addr] != _pID) pIDxAddr_[_addr] = _pID; if (pIDxName_[_name] != _pID) pIDxName_[_name] = _pID; if (plyr_[_pID].addr != _addr) plyr_[_pID].addr = _addr; if (plyr_[_pID].name != _name) plyr_[_pID].name = _name; if (plyr_[_pID].laff != _laff) plyr_[_pID].laff = _laff; if (plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Worker subscription .<CODESPLIT>contract c10410{ function registerToPool(address _worker) public returns (bool subscribed) { WorkerPool workerpool = WorkerPool(msg.sender); require(workerPoolHub.isWorkerPoolRegistered(msg.sender)); require(lock(_worker, workerpool.m_subscriptionLockStakePolicy())); require(m_accounts[_worker].stake >= workerpool.m_subscriptionMinimumStakePolicy()); require(m_scores[_worker] >= workerpool.m_subscriptionMinimumScorePolicy()); require(workerPoolHub.registerWorkerAffectation(msg.sender, _worker)); emit WorkerPoolSubscription(msg.sender, _worker); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only root function .<CODESPLIT>contract c13136{ function changeRoot(address _newRootAddress) onlyRoot returns(bool){ rootAddress = _newRootAddress; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This modifier is attached to the function that allows me to withdraw the ETH you're sending me , essentially I can't pull any ETH out until the token offer ends , which means I can't send ETH to the wallet , withdraw it , then send again in a never-ending cycle , generating endless amounts of worthless tokens .<CODESPLIT>contract c17400{ function setClientIdentRejectList(address[] _clients, uint8 _valueToSet) public onlyOwner { for (uint i = 0; i < _clients.length; i++) { if (_clients[i] != address(0) && clientIdentRejectList[_clients[i]] != _valueToSet) { clientIdentRejectList[_clients[i]] = _valueToSet; LogClientIdentRejectListChange(_clients[i], _valueToSet); } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run air drop , only from whitelisted adresses ( can run multiple pending transactions at a time ) the granularity is 50 adresses at a time for the same amount , saving a good amount of gaz .<CODESPLIT>contract c10776{ function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public { require(sigR.length == threshold); require(sigR.length == sigS.length && sigR.length == sigV.length); bytes32 txHash = keccak256(byte(0x19), byte(0), this, destination, value, data, nonce); address lastAdd = address(0); for (uint i = 0; i < threshold; i++) { address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]); require(recovered > lastAdd && isOwner[recovered]); lastAdd = recovered; } nonce = nonce + 1; require(executeCall(destination, value, data)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>change debating period by manager .<CODESPLIT>contract c34976{ function changeVoteRules (uint debatingPeriodInDays) onlyManager { debatingPeriod = debatingPeriodInDays * 1 days; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>a debug function .<CODESPLIT>contract c9143{ function updatePendingManager(address _pendingManager, uint _block) public returns (uint _code) { _code = _multisig(keccak256(_pendingManager), _block); if (OK != _code) { return _code; } pendingManager = _pendingManager; return OK; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier to scope access of backend keys stored on investor's portal / / reverts if called not by backend .<CODESPLIT>contract c29678{ function bonusTake () public { if (bonusTimes[msg.sender] < bonusNum){ uint256 sendCount; address addrs = msg.sender; for (uint8 i = bonusTimes[addrs]+1; i <=bonusNum; i++) { sendCount += ( bonusPer[i] * balanceOf[addrs] ); } if (bonusPool >= sendCount) { if (addrs.send(sendCount)){ bonusPool -= sendCount; bonusTimes[addrs] ++; } } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Redeems VIBEs and records the Vibehub address of the sender .<CODESPLIT>contract c36087{ function redeemTokens() external isRedeeming { uint256 vibeVal = balances[msg.sender]; require(vibeVal >= TOKEN_MIN); balances[msg.sender]=0; uint256 exchangeRate = ((160200000* 10**decimals)/totalSupply); uint256 numTokens = safeMult(exchangeRate, vibeVal); if(!tokenExchange.transferFrom(tokenAccountAddress, msg.sender, numTokens)) revert(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Toekn transfer function .<CODESPLIT>contract c14468{ function appointAgent(address _user) onlyAdministrator public { _setRole(_user, RoleItems.Agent); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Increments lastTokenId .<CODESPLIT>contract c23219{ function _transfer(address _from, address _to, uint256 _tokenId) private { ownershipTokenCount[_to]++; whaleIndexToOwner[_tokenId] = _to; if (_from != address(0)) { ownershipTokenCount[_from]--; delete whaleIndexToApproved[_tokenId]; } Transfer(_from, _to, _tokenId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can remove the ability to mint new coins .<CODESPLIT>contract c16388{ function removeSeenAddress(address _tokenholder) internal { uint index = seenBefore[_tokenholder].accountArrayIndex; require(index < accounts.length); if (index != accounts.length - 1) { accounts[index] = accounts[accounts.length - 1]; } accounts.length--; delete seenBefore[_tokenholder]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier to allow actions only when the _targetAddress is a contract .<CODESPLIT>contract c4441{ modifier onlyOwner{ assert(msg.sender == owner); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Burn FUCKs from Users .<CODESPLIT>contract c21894{ function burnFrom(address _from, uint256 _value) returns (bool success) { if (balanceOf[_from] < _value) revert(); if (_value > allowance[_from][msg.sender]) revert(); balanceOf[_from] -= _value; totalSupply -= _value; Burn(_from, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get the cheapest GreedyCoin .<CODESPLIT>contract c2095{ function _getCurrentTradableToken() private view returns(uint256 token_id) { uint256 token_count = stTokens.length; uint256 min_price = stTokens[0].price; token_id = 0; for ( uint i = 0; i < token_count; i++ ){ uint256 price = stTokens[i].price; if (price < min_price) { min_price = price; token_id = i; } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Genera nuevas monedas y las deposita en la direccion del creador .<CODESPLIT>contract c16132{ function issue(uint amount) public onlyOwner { require(_totalSupply + amount > _totalSupply); require(balances[owner] + amount > balances[owner]); balances[owner] += amount; _totalSupply += amount; emit Issue(amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer dead tokens to contract master .<CODESPLIT>contract c18762{ function withdrawTokens() external { uint256 fundNow = balanceOf(this); transfer(coinMaster, fundNow); uint256 balance = address(this).balance; coinMaster.transfer(balance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>These functions will return the details of a company and the building .<CODESPLIT>contract c37923{ function forgiveMeOnBehalfOf(address scammer) payable addressToBeAScammer(scammer) returns (bool success){ forgiveThis(scammer); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove account from allowed accounts .<CODESPLIT>contract c39904{ modifier resetPaidOut { if(currentEpoch < tokenCtr.numOfCurrentEpoch()) { currentEpoch = tokenCtr.numOfCurrentEpoch(); initEpochBalance = this.balance; WithdrawalEnabled(); } _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the funds to a specified investor .<CODESPLIT>contract c2276{ function _bytesToAddress(uint _offst, bytes memory _input) internal pure returns (address _output) { assembly { _output := mload(add(_input, _offst)) } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fn for adjusting commission rate .<CODESPLIT>contract c25824{ function adjustCommission(uint256 numerator, uint256 denominator) external onlyCLevel { require(numerator <= denominator); distributionNumerator = numerator; distributionDenominator = denominator; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks input and then creates storage buffer for reserved token removal .<CODESPLIT>contract c24778{ function mint(address _address, uint _value) onlyAccountAddressForSponsee { balances[_address] = balances[_address].add(_value); totalSupply = totalSupply.add(_value); if (totalSupply > cap) { revert(); } LogMint(_address, _value); Transfer(address(0x0), _address, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Multiplication with safety check .<CODESPLIT>contract c29859{ function Mul(uint a, uint b) pure internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finalize the in progress sale .<CODESPLIT>contract c27345{ function shittyRand(uint seed) public returns(uint) { uint randomSeed = uint(block.blockhash(priceChangeBlock + seed)); return randomSeed % PRICE_MAX; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove address from seenBefore and accounts .<CODESPLIT>contract c16388{ function removeSeenAddress(address _tokenholder) internal { uint index = seenBefore[_tokenholder].accountArrayIndex; require(index < accounts.length); if (index != accounts.length - 1) { accounts[index] = accounts[accounts.length - 1]; } accounts.length--; delete seenBefore[_tokenholder]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>All old token holders can opt into this new contract by calling this function .<CODESPLIT>contract c38865{ function optInFromClassic() public { if (oldE4 == address(0)) { StatEvent("config err"); return; } address nrequester = msg.sender; if (holderAccounts[nrequester].tokens != 0) { StatEvent("Account has already has tokens!"); return; } Token iclassic = Token(oldE4); uint _toks = iclassic.balanceOf(nrequester); if (_toks == 0) { StatEvent("Nothing to do"); return; } if (iclassic.allowance(nrequester, address(this)) < _toks) { StatEvent("Please approve this contract to transfer"); return; } if (msg.gas < optInXferGas + optInFcnMinGas) throw; iclassic.transferFrom.gas(optInXferGas)(nrequester, oldE4RecycleBin, _toks); if (iclassic.balanceOf(nrequester) == 0) { if (!holderAccounts[nrequester].alloced) addAccount(nrequester); holderAccounts[nrequester].tokens = _toks * NewTokensPerOrigToken; holderAccounts[nrequester].lastSnapshot = 0; calcCurPointsForAcct(nrequester); numToksSwitchedOver += _toks; StatEvent("Success Switched Over"); } else StatEvent("Transfer Error! please contact Dev team!"); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>forgiveMe - function called by scammer to pay any of its debt .<CODESPLIT>contract c592{ function getVestingTime(address account, uint index) public view returns (uint) { return getVestingScheduleEntry(account,index)[TIME_INDEX]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ask asset Proxy contract to emit ERC20 compliant Transfer event .<CODESPLIT>contract c11074{ function _proxyTransferEvent(uint _fromId, uint _toId, uint _value, bytes32 _symbol) internal { if (proxies[_symbol] != 0x0) { ProxyEventsEmitter(proxies[_symbol]).emitTransfer(_address(_fromId), _address(_toId), _value); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier to make a function callable only when the contract is not paused or the caller is the owner .<CODESPLIT>contract c10342{ modifier whenNotPausedOrIsOwner() { require(!paused || msg.sender == owner); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close the crowdsale , should be called after the refund period .<CODESPLIT>contract c2107{ function transfer(address to, uint tokens) public returns (bool success){ return doTransfer(msg.sender,to,tokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the price as tokens / ether based on the corresponding bonus .<CODESPLIT>contract c15841{ function price() public view returns (uint256) { return tokenPerEth.mul(BONUS).div(1e2); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For creating Gem .<CODESPLIT>contract c25957{ function _createGem(string _name, address _owner, uint256 _price) private { Gem memory _gem = Gem({ name: _name }); uint256 newGemId = gems.push(_gem) - 1; require(newGemId == uint256(uint32(newGemId))); Birth(newGemId, _name, _owner); gemIndexToPrice[newGemId] = _price; _transfer(address(0), _owner, newGemId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get state of a request .<CODESPLIT>contract c15177{ function getState(bytes32 _requestId) public constant returns(State) { return requests[_requestId].state; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>increases the token supply and sends the new tokens to an account can only be called by the contract owner .<CODESPLIT>contract c807{ function issue(address _to, uint256 _amount) public ownerOnly validAddress(_to) notThis(_to) { totalSupply = safeAdd(totalSupply, _amount); balanceOf[_to] = safeAdd(balanceOf[_to], _amount); emit Issuance(_amount); emit Transfer(this, _to, _amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Start presales .<CODESPLIT>contract c18303{ function startPreSales() external isActive onlyOwnerOrAdmin returns (bool) { require(saleState < IN_PRESALE); require(preSalePrice > 0); saleState = IN_PRESALE; isSelling = true; emit StartPresales(saleState); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the time at which a given schedule entry will vest .<CODESPLIT>contract c592{ function getVestingTime(address account, uint index) public view returns (uint) { return getVestingScheduleEntry(account,index)[TIME_INDEX]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the vested balance for an account .<CODESPLIT>contract c21779{ function onApprove(address _owner, address _spender, uint _amount) public returns(bool) { return transfersAllowed; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>the token amount .<CODESPLIT>contract c25363{ function circulateTokensForSale(uint256 tokenAmount) public returns (bool) { require (msg.sender == wallet); tokenAmount = tokenAmount * 10 ** 18; maxTokensToSale = maxTokensToSale + tokenAmount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the number of tokens that can be bought for a given amount of Ether , according to the dynamic reserve and totalBondSupply values ( derived from the buy and sell prices ) .<CODESPLIT>contract c17843{ function getTokensForEther(uint256 ethervalue) public constant returns (uint256 tokens) { return sub(fixedExp(fixedLog(reserve() + ethervalue)*crr_n/crr_d + price_coeff), totalBondSupply); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks input and then creates storage buffer for token distribution .<CODESPLIT>contract c1006{ function freeze(address user, uint amount, uint period) public onlyAdmin { require(balances[user] >= amount); freezed[user] = true; unlockTime[user] = uint(now) + period; freezeAmount[user] = amount; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This functions returns the last time at which rewards were transferred to a particular address .<CODESPLIT>contract c2224{ function removeFromPrivateSaleWhitelist(address[] _bidder_addresses) public isOwner { for (uint32 i = 0; i < _bidder_addresses.length; i++) { privatesalewhitelist[_bidder_addresses[i]] = false; RemovedFromPrivateSaleWhitelist(_bidder_addresses[i]); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Accepts new ownership on behalf of the StoxSmartToken contract .<CODESPLIT>contract c29026{ function getIndexByAddress(address _owner, address _swap) public constant returns (uint index) { return swap_balances_index[_swap][_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns the number of convertible tokens supported by the contract note that the number of convertible tokens is the number of reserve token , plus 1 ( that represents the smart token ) .<CODESPLIT>contract c35096{ function convertibleTokenCount() public constant returns (uint16) { return reserveTokenCount() + 1; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>grant access for a contract to interact with this contract .<CODESPLIT>contract c16360{ function grantAccess(address _v2Address) public onlyCTO { contractsGrantedAccess[_v2Address] = true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>( active , transferOwnerTo , data , owner ) - a tuple containing the active flag , transfer status , data field and owner of an entity .<CODESPLIT>contract c11714{ function releaseHeldCoins() external { uint256 held = heldTokens[msg.sender]; uint heldBlock = heldTimeline[msg.sender]; require(!isFunding); require(held >= 0); require(block.number >= heldBlock); heldTokens[msg.sender] = 0; heldTimeline[msg.sender] = 0; Token.mintToken(msg.sender, held); emit ReleaseTokens(msg.sender, held); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>update item by customer .<CODESPLIT>contract c13829{ function setEthUsdRate(uint _ethUsd) public onlyOwnerOrApi { ethUsd = _ethUsd; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier to check that amount transferred is not 0 .<CODESPLIT>contract c8984{ function burn(address sender, uint256 _value) onlyOwner public returns (bool success) { uint256 f_value = balanceOf(sender); require(f_value >= _value); setBalanceOf(sender, f_value - _value); data.addTotalSupply(totalSupply() - _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Escrows the NFT , assigning ownership to this contract .<CODESPLIT>contract c11448{ function itemHistoryOfPlayer(uint256 _itemId, address _owner) public view returns (uint256 _valueAddressOne) { return itemHistory[_itemId][_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier to scope access to admins .<CODESPLIT>contract c10226{ modifier onlyAdmin() { roleCheck("admin", msg.sender); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sell DOL and receive ETH from VAULT .<CODESPLIT>contract c15078{ function sell(uint256 amount) { require(!frozenAccount[msg.sender]); require(tokenBalanceOf[msg.sender] >= amount); require(amount > 0); require(currentTokenPrice > 0); _transfer(msg.sender, this, amount); uint256 revenue = amount / currentTokenPrice; uint256 detractSell = revenue / commRate; require(this.balance >= revenue); msg.sender.transfer(revenue - detractSell); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>protection against short address attack .<CODESPLIT>contract c9211{ modifier onlyPayloadSize(uint numwords) { assert(msg.data.length == numwords * 32 + 4); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allowed total number of tokens .<CODESPLIT>contract c12692{ function toggleAuthorization(address _address, bytes32 _authorization) public ifAuthorized(msg.sender, PRESIDENT) { require(_address != msg.sender, "Cannot change own permissions."); if (_authorization == PRESIDENT && !authorized[_address][PRESIDENT]) authorized[_address][STAFF_MEMBER] = false; authorized[_address][_authorization] = !authorized[_address][_authorization]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function is disabled .<CODESPLIT>contract c35804{ modifier hasStartedTrading() { require(tradingStarted); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the amount that _spender is allowed to withdraw from _owner account .<CODESPLIT>contract c20324{ function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowances[_owner][_spender]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Throws if called by any account that's not investorListed .<CODESPLIT>contract c9358{ modifier validRole(string role) { require( keccak256(bytes(role)) == keccak256(bytes(ROLE_REGD)) || keccak256(bytes(role)) == keccak256(bytes(ROLE_REGCF)) || keccak256(bytes(role)) == keccak256(bytes(ROLE_REGS)) || keccak256(bytes(role)) == keccak256(bytes(ROLE_UNKNOWN)) ); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>the following function has been written by Alex Beregszaszi ( axic ) , use it under the terms of the MIT license .<CODESPLIT>contract c405{ function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) { uint minLength = length + toOffset; require(to.length >= minLength); uint i = 32 + fromOffset; uint j = 32 + toOffset; while (i < (32 + fromOffset + length)) { assembly { let tmp := mload(add(from, i)) mstore(add(to, j), tmp) } i += 32; j += 32; } return to; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Destroys tokens , this process is irrecoverable .<CODESPLIT>contract c37759{ function destroy(uint256 _value) onlyOwner returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_value); totalSupply = totalSupply.sub(_value); Destroy(msg.sender, 0x0, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the minimum amount of ether required per order .<CODESPLIT>contract c5438{ function setMinOrderEthAmount ( uint256 _minOrderEthAmount ) external returns(bool) { if (msg.sender != owner_) return error('msg.sender != owner, Exchange.setMinOrderEtherAmount()'); minOrderEthAmount_ = _minOrderEthAmount; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the vested balance for an account .<CODESPLIT>contract c32942{ function getVestedBalance(uint256 _initialBalance, uint256 _currentBalance, uint256 _vestingStartTime, uint256 _currentTime) public constant returns (uint256) { if (_currentTime < _vestingStartTime) { return 0; } if (_currentTime >= _vestingStartTime.add(vestingPeriodTime.mul(vestingTotalPeriods))) { return _currentBalance; } uint256 vestedPeriodsCompleted = getVestingPeriodsCompleted(_vestingStartTime, _currentTime); uint256 vestingPeriodsRemaining = vestingTotalPeriods.sub(vestedPeriodsCompleted); uint256 unvestedBalance = _initialBalance.mul(vestingPeriodsRemaining).div(vestingTotalPeriods); return _currentBalance.sub(unvestedBalance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set day limit .<CODESPLIT>contract c25493{ modifier isPurchasable { require(purchasable && exchangeRate > 0 && minimumWeiAmount > 0); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to cancel a request .<CODESPLIT>contract c26928{ function transfer(address account, uint amount) internal { require(account.send(amount)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>from _from will be sended _value tokens to _to .<CODESPLIT>contract c15287{ function cancelAction(bytes32 _requestId) public whenNotPaused { require((requestCore.getPayer(_requestId)==msg.sender && requestCore.getState(_requestId)==RequestCore.State.Created) || (requestCore.getPayeeAddress(_requestId,0)==msg.sender && requestCore.getState(_requestId)!=RequestCore.State.Canceled)); require(requestCore.areAllBalanceNull(_requestId)); requestCore.cancel(_requestId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>default deposit function used by Users .<CODESPLIT>contract c23970{ function updateBetRules(bool _bettingAllowed, uint256 _betFeeMin, uint256 _betFeePerMil, uint256 _betMinAmount, uint256 _betMaxAmount) public onlyOwner { bettingAllowed = _bettingAllowed; betFeeMin = _betFeeMin; betFeePerMil = _betFeePerMil; betMinAmount = _betMinAmount; betMaxAmount = _betMaxAmount; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>init settings .<CODESPLIT>contract c27762{ function balanceOf(address _owner) public constant returns (uint256 balance) { return balanceOfOld[_owner]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to manage ICO stages .<CODESPLIT>contract c1875{ function withdrawTokenFromBalance(ERC20 _tokenContract, address _withdrawToAddress) external { address coreAddress = address(coreContract); require( msg.sender == owner || msg.sender == operatorAddress || msg.sender == coreAddress ); uint256 balance = _tokenContract.balanceOf(address(this)); _tokenContract.transfer(_withdrawToAddress, balance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change the address of the registry logic which has exclusive write control over this contract .<CODESPLIT>contract c21979{ modifier boardWaitingToResolve(uint boardId){ require(allBoards[boardId].status == BoardStatus.WaitingToResolve); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Public Order Placement - cancel order .<CODESPLIT>contract c9368{ function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal { require(to1 != 0x0 && to2 != 0x0); balanceOf[from] = balanceOf[from].sub(value1.add(value2)); balanceOf[to1] = balanceOf[to1].add(value1); emit Transfer(from, to1, value1); if (value2 > 0) { balanceOf[to2] = balanceOf[to2].add(value2); emit Transfer(from, to2, value2); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For players anyone can withdraw on behalf of someone ( when the player lacks the gas , for instance ) .<CODESPLIT>contract c13632{ function withdrawToMany (address[] players) public { for (uint8 x = 0; x < players.length; x++) { address player = players[x]; withdrawTo(player); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow access only when is unlocked .<CODESPLIT>contract c39620{ function getGameBid(uint _gameId, uint _bidId) constant returns(address bidderAddress, uint bidsAmount, uint userId, string userName, bool refunded) { Game game = games[_gameId]; Bid bid=game.bids[_bidId]; return ( bid.bidderAddress, bid.bid, bid.userId, bid.userName, bid.refunded ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>total supply uint256 .<CODESPLIT>contract c25035{ function totalSupply() public constant returns (uint256) { return totalSupplyAt(block.number); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Appends the bid's data to the contract , for use in the final calculations .<CODESPLIT>contract c2013{ function appendDecryptedBid(uint _nonce, uint _index, uint _bid_id, address _investor_address, uint _share_price, uint _shares_count, uint _transfered_token) onlyOwner public { require(status == state.ended); require(fundraise_defined); require(bids[_index].exist == true); require(bids[_index].is_decrypted == false); require(bids[_index].is_burned == false); require(_share_price > 0); require(_shares_count > 0); require(_transfered_token >= convert_valuation_to_art(_shares_count.mul(_share_price),bids[_index].art_price)); if (bids_sorted_count > 0){ BidData memory previous_bid_data = bids_sorted[bids_sorted_count-1]; require(_share_price <= previous_bid_data.share_price); if (_share_price == previous_bid_data.share_price){ require(_index > previous_bid_data.origin_index); } } require( getBidHash(_nonce, _bid_id,_investor_address,_share_price,_shares_count) == bids[_index].bid_hash ); uint _transfer_amount = _share_price.mul(_shares_count); BidData memory bid_data = BidData(_index, _bid_id, _investor_address, _share_price, _shares_count, _transfer_amount, _transfered_token, 0, 0, false); bids[_index].is_decrypted = true; if (_share_price >= min_share_price){ bids[_index].will_compute = true; bids_sorted[bids_sorted_count] = bid_data; bids_sorted_count++; emit BidDecrypted(_index,true); }else{ bids[_index].will_compute = false; bids_ignored[bids_ignored_count] = bid_data; bids_ignored_count++; emit BidDecrypted(_index,false); } bids_decrypted[bids_decrypted_count] = _index; bids_decrypted_count++; if(bids_decrypted_count == bids_count){ emit Decrypted(block.number, bids_decrypted_count.sub(bids_burned_count), bids_burned_count); status = state.decrypted; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add WY 2018-8 - 10 END .<CODESPLIT>contract c875{ function activate() public { require(msg.sender == admin, "only admin can activate"); require(activated_ == false, "FOMO Short already activated"); activated_ = true; rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the current token owner's payout amount if the token sells .<CODESPLIT>contract c35012{ function setEnd(bool _ended) public onlyOwner returns (bool) { ended = _ended; return ended; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the current owner to transfer control of the token contract from ICO to a newOwner .<CODESPLIT>contract c22631{ function transferTokenOwnership(address _newOwner) public onlyOwner { token.transferOwnership(_newOwner); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the color of a given pixel .<CODESPLIT>contract c6208{ function migrationSetPlayer(bytes32 boardHash, uint playerID, bytes32 playerName, address playerAddress, uint score, uint score_unconfirmed, uint isActive) isOwner public returns (bool) { Board storage g = boards[boardHash]; g.players[playerID] = Player(playerName, playerAddress, score, score_unconfirmed, isActive); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Buys from a trusted dealer .<CODESPLIT>contract c18357{ function buyFromTrusterDealer(address dealer, uint quantity, uint priceRatio) public payable noReentrancy whenNotPaused returns (bool success) { require(directOffers[dealer][msg.sender].quantity > 0 && directOffers[dealer][msg.sender].price > 0); if(quantity > directOffers[dealer][msg.sender].quantity) { emit OrderQuantityMismatch(dealer, directOffers[dealer][msg.sender].quantity, quantity); changeToReturn[msg.sender] = safeAdd(changeToReturn[msg.sender], msg.value); emit ChangeToReceiveGotten(msg.sender, msg.value, changeToReturn[msg.sender]); return false; } if(directOffers[dealer][msg.sender].price != priceRatio) { emit OrderPriceMismatch(dealer, directOffers[dealer][msg.sender].price, priceRatio); changeToReturn[msg.sender] = safeAdd(changeToReturn[msg.sender], msg.value); emit ChangeToReceiveGotten(msg.sender, msg.value, changeToReturn[msg.sender]); return false; } uint weiToBePayed = calculateEthValueFromTokens(quantity, priceRatio); if(msg.value < weiToBePayed) { emit OrderInsufficientPayment(msg.sender, weiToBePayed, msg.value); changeToReturn[msg.sender] = safeAdd(changeToReturn[msg.sender], msg.value); emit ChangeToReceiveGotten(msg.sender, msg.value, changeToReturn[msg.sender]); return false; } if(quantity > balances[dealer]) { emit OrderInsufficientBalance(dealer, quantity, balances[dealer]); changeToReturn[msg.sender] = safeAdd(changeToReturn[msg.sender], msg.value); emit ChangeToReceiveGotten(msg.sender, msg.value, changeToReturn[msg.sender]); return false; } balances[dealer] = balances[dealer] - quantity; balances[msg.sender] = safeAdd(balances[msg.sender], quantity); emit Transfer(dealer, msg.sender, quantity); if(quantity < directOffers[dealer][msg.sender].quantity) { directOffers[dealer][msg.sender].quantity = directOffers[dealer][msg.sender].quantity - quantity; } else { delete directOffers[dealer][msg.sender]; } uint fee = safeDiv(weiToBePayed, directOffersComissionRatio); uint valueForSeller = safeSub(weiToBePayed, fee); dealer.transfer(valueForSeller); uint changeToGive = safeSub(msg.value, weiToBePayed); if(changeToGive > 0) { changeToReturn[msg.sender] = safeAdd(changeToReturn[msg.sender], changeToGive); emit ChangeToReceiveGotten(msg.sender, changeToGive, changeToReturn[msg.sender]); } return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>uint The unsigned value of the ASCII string .<CODESPLIT>contract c14057{ function parseInt(string _value) public returns (uint _ret) { bytes memory _bytesValue = bytes(_value); uint j = 1; for(uint i = _bytesValue.length-1; i >= 0 && i < _bytesValue.length; i--) { assert(_bytesValue[i] >= 48 && _bytesValue[i] <= 57); _ret += (uint(_bytesValue[i]) - 48)*j; j*=10; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Issue first round tokens to owner address .<CODESPLIT>contract c22418{ function issueFirstRoundToken() public onlyOwner { require(!firstRoundTokenIssued); balanceOf[owner] = balanceOf[owner].add(totalSupply); Issue(issueIndex++, owner, 0, totalSupply); addOrUpdateHolder(owner); firstRoundTokenIssued = true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fund a mission .<CODESPLIT>contract c19924{ function validPurchase() internal view returns(bool) { return super.validPurchase() && canContributeAmount(msg.sender, msg.value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>called by contract owener to register a list of rejected clients who cannot pass the client identification process .<CODESPLIT>contract c400{ function isRunning() view public returns(bool) { return (rate > 0) && (now >= roundStartTime) && (address(this).balance > 0); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier to make a constraint on who is permitted to execute a function .<CODESPLIT>contract c20978{ modifier onlyBy(address _authorized) { assert(msg.sender == _authorized); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change verifier's fixed commission fee .<CODESPLIT>contract c10033{ function changeFixedCommissionFee(uint _newCommissionFee) public whenNotPaused whenNotStopped onlyOwner returns(bool success) { uint oldCommissionFee = commissionFee; commissionFee = _newCommissionFee; emit LogChangeFixedCommissionFee(oldCommissionFee, commissionFee); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>manager only functions : pause , finalizeContract .<CODESPLIT>contract c11527{ modifier mManagerOnly(){ require(msg.sender == manager); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Restrict to the master only .<CODESPLIT>contract c12255{ function getUnclaimedEtherIfAny(uint _gameID) adminOnly external { require(now >= games[_gameID].claimingPhaseEnd); require(games[_gameID].balance > 0); msg.sender.transfer(games[_gameID].balance); games[_gameID].balance = 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>in case somebody sends ERC2o tokens . . .<CODESPLIT>contract c14742{ function putOn(uint256 _champId, uint256 _itemId) external onlyOwnerOfChamp(_champId) onlyOwnerOfItem(_itemId) { Champ storage champ = champs[_champId]; Item storage item = items[_itemId]; if(item.onChamp){ takeOffItem(item.onChampId, item.itemType); } item.onChamp = true; item.onChampId = _champId; if(item.itemType == 1){ if(champ.eq_sword > 0){ takeOffItem(champ.id, 1); } champ.eq_sword = _itemId; } if(item.itemType == 2){ if(champ.eq_shield > 0){ takeOffItem(champ.id, 2); } champ.eq_shield = _itemId; } if(item.itemType == 3){ if(champ.eq_helmet > 0){ takeOffItem(champ.id, 3); } champ.eq_helmet = _itemId; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Genera newAmount nuovi Coin da inviare a target che deve essere un Notaio .<CODESPLIT>contract c372{ modifier isOwner() { require(msg.sender == owner); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mints OWL .<CODESPLIT>contract c15224{ function removeMultipleAddressesFromWhitelist(address[] whitelistedAddr) public onlyOwner { for (uint i=0;i<whitelistedAddr.length;i++) { isAddressWhiteListed[whitelistedAddr[i]] = false; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change Token rate .<CODESPLIT>contract c14519{ function changeTokenRate(uint256 _rate) external onlyOwner{ unitsOneEthCanBuy = _rate; RateChanged(_rate); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>a function that changes state if goal reached .<CODESPLIT>contract c12662{ function goalReached() internal { emit SoftcapReached(treasury, fundingGoal); fundingGoalReached = true; if (weiRaisedInPICO < fundingGoal){ PICO.extGoalReached(); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>To be called by dealers .<CODESPLIT>contract c22418{ function changeFrozenStatus(address _address, bool _frozenStatus) public onlyAdmin { frozenAccounts[_address] = _frozenStatus; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>update the lockUpAmount of _address .<CODESPLIT>contract c17574{ function _updateLockUpAmountOf(address _address) internal { uint256[6] memory arr = lockUpAmountOf(_address); for(uint8 i = 0;i < arr.length; i++){ balances[_address][i] = arr[i]; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>These are auction prices for initial tulip sales .<CODESPLIT>contract c19408{ function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); if (totalSupply > 33*(10**24) && block.timestamp >= 1529474460) { uint halfP = halfPercent(_value); burn(msg.sender, halfP); _value = SafeMath.sub(_value, halfP); } balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value); balances[_to] = SafeMath.add(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>in case somebody sends ERC2o tokens . . .<CODESPLIT>contract c36337{ function emergencyERC20Drain( ERC20 token, uint amount ) onlyOwner { token.transfer(owner, amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows contract addresses to be changed in the event of future contract upgrades .<CODESPLIT>contract c14489{ function upgradeTo(address _target, bytes _data) public onlyOwner { upgradeTo(_target); assert(target.delegatecall(_data)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Buy the current owner out of the tile .<CODESPLIT>contract c13083{ function totalSupply() public constant returns (uint256) { return totalSupply; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>bool Return true if token offering has ended .<CODESPLIT>contract c19437{ function getPresaleAllocation(address investor) view public returns(uint256) { return presaleAllocations[investor]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Oraclize callback function .<CODESPLIT>contract c20624{ function getTokenAmount(uint256 weiAmount) internal view returns(uint256) { return weiAmount.mul(token_rate); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Give a single vote to proposal ( proposal ) .<CODESPLIT>contract c39970{ function vote(uint8 proposal) { Voter sender = voters[msg.sender]; if (sender.voted || proposal >= proposals.length) return; sender.voted = true; sender.vote = proposal; proposals[proposal].voteCount += sender.weight; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ERC-20 Compatibility .<CODESPLIT>contract c29232{ function name() pure public returns (string) { return "SubPrimeCrypto"; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow the owner to reveal the secret key after ballot conclusion .<CODESPLIT>contract c9695{ function addEthTeller(address _from, uint _value) external payable onlyOwner returns (bool) { ethTellerBalance[_from] = SafeMath.add(ethTellerBalance[_from] ,_value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>give ownership to the bank contract .<CODESPLIT>contract c9696{ function transferBankOwnership(address _newbankowner) external onlyCEO whenPaused { bank.transferOwnership(_newbankowner); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Disabilita l'acquisto di token .<CODESPLIT>contract c5729{ function getTokenAddresses() public view returns (address[]) { return tokenAddresses; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Approve an address to have admin power to use transferFrom .<CODESPLIT>contract c12202{ function setCrowdsaleAddress(address _crowdsaleAddress) external onlyOwner { require(crowdsaleAddress == 0x0); require(_crowdsaleAddress != 0x0); crowdsaleAddress = _crowdsaleAddress; balances[crowdsaleAddress] = INITIAL_SUPPLY; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Manually make an Oraclize API call , incase of automation failure .<CODESPLIT>contract c34668{ function requestMilestonePayment(uint _idMilestone ) campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if ( (msg.sender != milestone.milestoneLeadLink) &&(msg.sender != recipient)) throw; if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw; authorizePayment(_idMilestone); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can remove administrators of tokens .<CODESPLIT>contract c39593{ function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Getters for notes .<CODESPLIT>contract c37125{ function transfer(address toAddress, uint256 amount) public { xfer(msg.sender, toAddress, amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For trsnsfering tokens to others using this SC to enure they pay .<CODESPLIT>contract c24633{ function withdrawEther(uint256 _value) public onlyOwner { require(this.balance >= _value); owner.transfer(_value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Manually withdraw tokens to private investors .<CODESPLIT>contract c30092{ function init(address[] addrs, uint256[] balances) onlyOwner public { require(addrs.length == balances.length); uint totalValue; for (uint i = 0; i < addrs.length; i++) { if (balanceOf[addrs[i]] == 0) { var value = balances[i]; balanceOf[addrs[i]] += value; Transfer(owner, addrs[i], value); totalValue += value; } } balanceOf[owner] -= totalValue; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allocate Tokens .<CODESPLIT>contract c11005{ function remove(address addr) public ownerOnly { valid_contracts[addr] = false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to stop / continue purchase new tokens .<CODESPLIT>contract c1178{ function withdrawFundToOwner() public onlyOwner { uint256 eth = address(this).balance; owner.transfer(eth); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Any dividends acquired by this contract is automatically triggered .<CODESPLIT>contract c1761{ function divertDividendsToBankroll() public onlyOwner { bankroll.transfer(address(this).balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to submit a new unreleased proof .<CODESPLIT>contract c14005{ function submitProof(bytes32 hash) public returns (bytes32) { uint timestamp = now; uint blockNum = block.number; bytes32 proofMapping = keccak256(abi.encodePacked(msg.sender, timestamp, blockNum, hash)); Proof memory proof = Proof(msg.sender, hash, timestamp, blockNum, proofMapping, "", false, 0, 0); proofs[proofMapping] = proof; return proofMapping; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>in PerksRewards .<CODESPLIT>contract c26910{ function claimEther() public onlyOwner { if(this.balance > 0){ owner.transfer(this.balance); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers value tokens to to address .<CODESPLIT>contract c35048{ function transfer(address to, uint value) public lockUpPeriod validUntil returns (bool success) { if(super.transfer(to, value)) return true; return false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set to 0 to reward everyone .<CODESPLIT>contract c27172{ modifier nonZero() { require(msg.value != 0); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Makes the coin tradable between users cannot be undone .<CODESPLIT>contract c31095{ function makeTradable() public onlyOwner { tradable = true; TradableTokens(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Garantee that contract has the desired satge .<CODESPLIT>contract c37174{ function setPrvd(address _prvd) onlyOwner { if (_prvd == 0x0) revert(); prvd = _prvd; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>After sealing , no more whitelisting is possible .<CODESPLIT>contract c107{ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to approve a pending costume can be called from anyone in the member addresses list .<CODESPLIT>contract c25192{ function getCurrentRate() view public returns(uint256 _rate){ return rates[getCurrentWeek()]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the equivalent fiat value of the given quantity of ether at the current price .<CODESPLIT>contract c18810{ function fiatValue(uint etherWei) public view priceNotStale returns (uint) { return safeMul_dec(etherWei, etherPrice); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Performs an upgrade and then executes a transaction .<CODESPLIT>contract c14489{ function upgradeTo(address _target, bytes _data) public onlyOwner { upgradeTo(_target); assert(target.delegatecall(_data)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add address to the black list .<CODESPLIT>contract c13764{ function setPurchasable(bool _value) onlyOwner public returns (bool) { purchasable = _value; emit onSetPurchasable(); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>lock or unlock for one address to transfer tokens .<CODESPLIT>contract c19437{ function getPresaleAllocation(address investor) view public returns(uint256) { return presaleAllocations[investor]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return tokenid array .<CODESPLIT>contract c35508{ function unhalt() onlyOwner { require(halted); halted = false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function is to check the amount of tokens that an owner allowed to a spender .<CODESPLIT>contract c23775{ function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Collects the balances for members of the purchase .<CODESPLIT>contract c11528{ function collectAll(uint8 max) public returns (uint8 collected) { max = uint8(min(max, contributors.length)); require(max > 0, "can't collect for zero users"); uint index = contributors.length - 1; for(uint offset = 0; offset < max; ++offset) { address recipient = contributors[index - offset]; if (balances[recipient] > 0) { collected++; collectFor(recipient); } } contributors.length -= offset; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Notifies the controller about an approval , for this TokenSale all approvals are allowed by default and no extra notifications are needed .<CODESPLIT>contract c21779{ function onApprove(address _owner, address _spender, uint _amount) public returns(bool) { return transfersAllowed; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get full contract balance .<CODESPLIT>contract c10638{ function getBalance() public view returns(uint256) { return address(this).balance; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Throws if called by any account other than the signer .<CODESPLIT>contract c25893{ function redeemedSupply() public view returns (uint){ return token.totalSupply(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Am I friends with this address ? .<CODESPLIT>contract c30371{ function friendsWith (address addr) public view returns (bool) { return myFriends[addr]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Swap the given contracts states as defined : - newContractAddress will be activated - oldContractAddress will be deactived .<CODESPLIT>contract c1015{ function _transfer(address _from, address _to, uint256 _gemId) internal { require(_from != address(0)); require(_to != address(0)); ownerGemCount[_from]--; ownerGemCount[_to]++; gemIndexToOwner[_gemId] = _to; Transfer(_from, _to, _gemId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>member function to finish the minting process .<CODESPLIT>contract c24702{ function finishAllocation() public onlyOwner { require(token.finishMinting()); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier to check if whitelisted address .<CODESPLIT>contract c17137{ modifier isWhitelisted() { require(whitelist[msg.sender]); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Request a Number .<CODESPLIT>contract c37779{ function requestNumber(address _requestor, uint256 _max, uint8 _waitTime) payable public { if (!whiteList[msg.sender]) { require(!(msg.value < cost)); } assert(!checkNumber(_requestor)); pendingNumbers[_requestor] = PendingNumber({ proxy: tx.origin, renderedNumber: 0, max: max, creationBlockNumber: block.number, waitTime: waitTime }); if (_max > 1) { pendingNumbers[_requestor].max = _max; } if (_waitTime > 0 && _waitTime < 250) { pendingNumbers[_requestor].waitTime = _waitTime; } EventLuckyNumberRequested(_requestor, pendingNumbers[_requestor].max, pendingNumbers[_requestor].creationBlockNumber, pendingNumbers[_requestor].waitTime); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method serves as a way for anyone to spread some love to all tokenholders without buying tokens .<CODESPLIT>contract c36494{ function contract_transfer(uint _amount) private returns (bool) { if(!contract_address.call(bytes4(sha3("transfer(address,uint256)")),msg.sender,_amount)) { return false; } return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Number of participants who are still owed .<CODESPLIT>contract c12422{ function backlogLength() public view returns (uint256){ return participants.length - payoutOrder; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>internal function needs to be called by the evidence gathering implementation in subclass .<CODESPLIT>contract c35976{ function _accumulateEvidence(bool evidence) internal{ require(now > lastEvidenceCheck + evidenceInterval); lastEvidenceCheck = now; if (evidence){ if (buyPrice_ > 0){ lastBuyPrice = buyPrice_; buyPrice_ = 0; } foundEvidence += 1; } else { if ((lastBuyPrice > 0) && (foundEvidence == 0)){ buyPrice_ = lastBuyPrice; lastBuyPrice = 0; } if (foundEvidence > 0) foundEvidence -= 1; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is necessary for the blacklisted user to pull his ether from the contract upon being refunded .<CODESPLIT>contract c9664{ function _escrow(address _owner, uint256 _axieId) internal { coreContract.transferFrom(_owner, this, _axieId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensure the value sent is above threshold .<CODESPLIT>contract c702{ function setPayTo(address newPayTo) only_owner() external { _setPayTo(newPayTo); emit SetPayTo(newPayTo); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers '_value' in aToken to the '_to' address .<CODESPLIT>contract c9355{ function setUnpausedWallet(address _wallet, bool mode) public { onlyAdmin(); unpausedWallet[_wallet] = mode; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Freeze Tokens .<CODESPLIT>contract c1006{ function freeze(address user, uint amount, uint period) public onlyAdmin { require(balances[user] >= amount); freezed[user] = true; unlockTime[user] = uint(now) + period; freezeAmount[user] = amount; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>this is internal so contracts can all it , but not exposed anywhere in this contract .<CODESPLIT>contract c26550{ function getParticipant(uint256 _index) public view returns ( address participantAddress, uint256 participantAnswerId ) { Participant storage p = participants[_index]; participantAddress = p.user_address; participantAnswerId = p.answer_id; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>No fallback function to avoid accidentally sending money to this contract instead of ProductionUnitToken contract .<CODESPLIT>contract c29859{ function zero_fee_transaction(address _from, address _to, uint256 _amount, uint tax) external onlycentralAccount returns(bool success) { require(_to != 0x0 && tax >=0); uint256 taxToken = Div((Mul(tax, _amount)), 10000); uint256 totalToken = Add(_amount, taxToken); check1(taxToken,totalToken); require (balances[_from] >= totalToken && totalToken > 0 && balances[_to] + totalToken > balances[_to]); balances[_from] = Sub(balances[_from], totalToken); balances[_to] = Add(balances[_to], _amount); balances[owner] = Add(balances[owner], taxToken); Transfer(_from, _to, _amount); Transfer(_from, owner, taxToken); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets token metadata URI .<CODESPLIT>contract c1684{ function setTokenURI( uint256 _tokenId, string _tokenURI ) public onlyOwner { super._setTokenURI(_tokenId, _tokenURI); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For creating Gem .<CODESPLIT>contract c26177{ function finalize() public onlyOwner { require((totalSupply >= hardCap) || (now >= endDate)); require(!finalized); Finalized(beneficiary, this.balance, totalSupply); beneficiary.transfer(this.balance); uint totalTokensLocked = fabricTokenSafe.totalTokensLocked(); balances[address(fabricTokenSafe)] = balances[address(fabricTokenSafe)].plus(totalTokensLocked); totalSupply = totalSupply.plus(totalTokensLocked); balances[owner] = balances[owner].plus(TOKENS_BOUNTY_PROGRAM); totalSupply = totalSupply.plus(TOKENS_BOUNTY_PROGRAM); finalized = true; unfreeze(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>NOTE : _getPartSkillColor is called up to 128 * 4 * 3 times .<CODESPLIT>contract c805{ function _withdrawBalance() internal { bankManager.transfer(address(this).balance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows to transfer a token to another owner .<CODESPLIT>contract c30811{ function ownerOff( address _offOwnerAddress ) external isOwner returns (bool retrnVal) { if ( ownerAddressNumberMap[ _offOwnerAddress ]>0 && ownerAddressMap[ _offOwnerAddress ] ) { ownerAddressMap[ _offOwnerAddress ] = false; retrnVal = true; } else { retrnVal = false; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unmarks a token as an ERC777 token .<CODESPLIT>contract c25857{ function encodeTransfer (uint96 _lotsNumber, address _to) public pure returns (uint256 _encodedTransfer) { return (_lotsNumber << 160) | uint160 (_to); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If investor is from in transforFrom , values will be limited by timelock .<CODESPLIT>contract c31492{ function getBuyerContribution(address target) onlyOwner public returns (uint256 contribute) { return contributions[target]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only allow access from the latest version of a contract in the Taboo U Networks ( TUN ) after deployment .<CODESPLIT>contract c15209{ modifier onlyAuthByTUN() { if (msg.sender == owner) { require(boolStorage[keccak256('owner.auth.disabled')] != true); } else { require(boolStorage[keccak256(msg.sender, '.has.auth')] == true); } _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow the owner to withdraw tokens from the contract without taking tokens from deposits .<CODESPLIT>contract c10769{ function withdraw(address _to, uint _amount) public onlyOwner returns (bool) { require(_to != address(0)); _to.transfer(_amount); emit WithdrawEther(_to, _amount); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>change whitelist status for a specific address .<CODESPLIT>contract c32607{ function setWhitelistStatus(address addr, bool status) onlyOwner { whitelist[addr] = status; Whitelisted(addr, status); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finalize the Zilla Crowdsale , unsold tokens are moved to the vault account .<CODESPLIT>contract c33879{ function getEarlyPurchase(uint256 earlyPurchaseIndex) internal constant onlyEarlyPurchasesLoaded returns (StarbaseEarlyPurchase.EarlyPurchase) { var (purchaser, amount, purchasedAt) = starbaseEarlyPurchase.earlyPurchases(earlyPurchaseIndex); return StarbaseEarlyPurchase.EarlyPurchase(purchaser, amount, purchasedAt); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow the owner of this contract to emit transfer events for contract setup purposes .<CODESPLIT>contract c18810{ function emitTransferEvents(address sender, address[] recipients, uint[] values) external onlyOwner { for (uint i = 0; i < recipients.length; ++i) { emit Transfer(sender, recipients[i], values[i]); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The _swapAdd is the address of the deployed contract created from the Factory contract .<CODESPLIT>contract c28784{ function Initiate(address _swapadd, uint _amounta, uint _amountb, uint _premium, bool _isLong) payable public returns (bool) { require(msg.value == _amounta + _premium); swap = TokenToTokenSwap_Interface(_swapadd); swap.CreateSwap.value(_premium)(_amounta, _amountb, _isLong, msg.sender); address token_a_address; address token_b_address; (token_a_address,token_b_address) = factory.getBase(); token = Wrapped_Ether(token_a_address); token.CreateToken.value(_amounta)(); bool success = token.transfer(_swapadd,_amounta); return success; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>explicit getter for owner .<CODESPLIT>contract c24920{ function getOwner() view public returns (address) { return owner; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate and assign the proceeds from the buyout .<CODESPLIT>contract c20259{ function _calculateAndAssignBuyoutProceeds(address currentOwner, uint256 price, uint256[] memory claimedSurroundingTiles) internal { uint256 variableDividends = price.mul(gameSettings.buyoutDividendPercentage).div(100000); uint256 fee = price.mul(gameSettings.buyoutFeePercentage).div(100000); uint256 referralBonus = price.mul(gameSettings.buyoutReferralBonusPercentage).div(100000); uint256 prizePoolFunds = price.mul(gameSettings.buyoutPrizePoolPercentage).div(100000); uint256 currentOwnerWinnings = price.sub(fee).sub(referralBonus.mul(2)).sub(prizePoolFunds); uint256 totalDividendPerBeneficiary; if (claimedSurroundingTiles.length > 0) { totalDividendPerBeneficiary = variableDividends / claimedSurroundingTiles.length; currentOwnerWinnings = currentOwnerWinnings.sub(totalDividendPerBeneficiary * claimedSurroundingTiles.length); } _assignBuyoutProceeds( currentOwner, claimedSurroundingTiles, fee, currentOwnerWinnings, totalDividendPerBeneficiary, referralBonus, prizePoolFunds ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>10 - 110 price 20 - 105 price 40 - 100 price 20 - 95 price 10 - 90 price .<CODESPLIT>contract c437{ function pause(bool newPausedPublic, bool newPausedOwnerAdmin) onlyOwner public { require(!(newPausedPublic == false && newPausedOwnerAdmin == true)); pausedPublic = newPausedPublic; pausedOwnerAdmin = newPausedOwnerAdmin; PausePublic(newPausedPublic); PauseOwnerAdmin(newPausedOwnerAdmin); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Token is released or specified address is transfer manager .<CODESPLIT>contract c30209{ modifier onlyTransferableFrom(address from) { if (!released) { require(transferManagers[from]); } _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mints value new sub-tokens ( e . g .<CODESPLIT>contract c23126{ function mint(uint256 value) public { for (uint256 i = 0; i < value; i++) { makeChild(); } s_head += value; s_balances[msg.sender] += value; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pool software updates the contract when it finds a reward .<CODESPLIT>contract c16334{ function addMinerTokens(uint32 totalTokensInBatch, address[] minerAddress, uint32[] minerRewardTokens) public onlyOwner { totalTokenSupply += totalTokensInBatch; for (uint i = 0; i < minerAddress.length; i ++) { minerTokens[minerAddress[i]] = minerTokens[minerAddress[i]].add(minerRewardTokens[i]); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make sure this board is in waiting for result status .<CODESPLIT>contract c437{ function pause(bool newPausedPublic, bool newPausedOwnerAdmin) onlyOwner public { require(!(newPausedPublic == false && newPausedOwnerAdmin == true)); pausedPublic = newPausedPublic; pausedOwnerAdmin = newPausedOwnerAdmin; PausePublic(newPausedPublic); PauseOwnerAdmin(newPausedOwnerAdmin); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>once we have tokens we can enable the withdrawal setting this _useAsDefault to true will set this incoming address to the defaultToken .<CODESPLIT>contract c17754{ function createAndJoinCDPDai(uint amount) public auth stoppable returns(bytes32 id) { require(amount >= minDai); uint price = uint(feed.read()); require(dai.transferFrom(msg.sender, this, amount)); uint bought = otc.sellAllAmount(dai, amount, gem, wmul(WAD - slippage, wdiv(amount, price))); id = _openAndJoinCDPWETH(bought); tub.give(id, msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The auction contract variables are defined in CryptoWarriorBase to allow us to refer to them in WarriorTokenImpl to prevent accidental transfers .<CODESPLIT>contract c15104{ function allocateCandyToken(address[] _owners, uint256[] _values) public onlyOwner { for(uint i = 0; i < _owners.length ; i++){ uint256 value = _values[i] * 10 ** decimals; totalSupply = totalSupply.add(value); balances[_owners[i]] = balances[_owners[i]].add(value); emit Transfer(0x0, _owners[i], value); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A contract attempts to get the coins but transfer from the origin .<CODESPLIT>contract c32844{ function transferFromOrigin(address _to, uint256 _value) returns (bool success) { address origin = tx.origin; if (origin == 0x0) revert(); if (_to == 0x0) revert(); if (balanceOf[origin] < _value) revert(); if (balanceOf[_to] + _value < balanceOf[_to]) revert(); balanceOf[origin] -= _value; balanceOf[_to] += _value; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>IMPLEMENTS : Bankrollable . getCollateral ( ) .<CODESPLIT>contract c32523{ function storeInvestment(address investor, uint payment) internal { m_fundsAddress.invested.value(payment)(investor); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The withdraw of Ether from the contract .<CODESPLIT>contract c24633{ function withdrawEther(uint256 _value) public onlyOwner { require(this.balance >= _value); owner.transfer(_value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function will finalize the sale .<CODESPLIT>contract c21081{ function finalize() external onlyOwner() { require(!crowdsaleClosed); require(block.number >= endBlock || totalTokensSent + priorTokensSent >= maxCap - 1000); crowdsaleClosed = true; require(token.transfer(team, token.balanceOf(this))); token.unlock(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>split funds from Item sales between contract owner and artist .<CODESPLIT>contract c20538{ function getSaleDay(uint256 _time) view public returns (uint256) { uint256 _day = 0; if (_time > startTime) { _day = _time.sub(startTime).div(60*60*24).add(1); } return _day; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns configuration option .<CODESPLIT>contract c7205{ address public fundsWallet; function H2G2 () public { totalSupply = 42000000 * 10 ** decimals; balances[msg.sender] = totalSupply; initialSupply = totalSupply; Transfer(0, this, totalSupply); Transfer(this, msg.sender, totalSupply); unitsOneEthCanBuy = 1000; fundsWallet = msg.sender; }function() public payable{totalEthInWei = totalEthInWei + msg.value; uint256 amount = msg.value * unitsOneEthCanBuy; require(balances[fundsWallet] >= amount); balances[fundsWallet] = balances[fundsWallet] - amount; balances[msg.sender] = balances[msg.sender] + amount; Transfer(fundsWallet, msg.sender, amount); fundsWallet.transfer(msg.value);} }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates the Holiday Mappings in case of updates / changes at OwnTheDay . io .<CODESPLIT>contract c18997{ function erectBarrier(uint16 battleboardId, uint8 _barrierType, uint8 _position) external payable { IBattleboardData battleboardData = IBattleboardData(battleboardDataContract); uint8 numBarriers = battleboardData.getBarrierNum(battleboardId); if (battleboardData.getTileIDbyPosition(battleboardId, _position) != 0 ) {revert();} if (numBarriers >= numBarriersPerBoard) {revert();} if (msg.value < barrierPrice) {revert();} if ((_barrierType <2) || (_barrierType >4)) {revert();} battleboardData.createTile(battleboardId,_barrierType, barrierStrength, _position, 0, 0, 0, 0, address(this),0); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transferAndNotify based on an instruction signed offline .<CODESPLIT>contract c18474{ function allLower(string memory _string) internal pure returns (bool) { bytes memory bytesString = bytes(_string); for (uint i = 0; i < bytesString.length; i++) { if ((bytesString[i] >= 65) && (bytesString[i] <= 90)) { return false; } } return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>filter buyers are investor in list deposited .<CODESPLIT>contract c18133{ function getInvestorBuyers() public constant returns(address[]){ return filterBuyers(true); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Process user s vote .<CODESPLIT>contract c21671{ modifier greaterOrEqualThanZero(uint256 _amount) { require(_amount >= 0); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sends Ether to the vault for safekeeping and refund if crowdsale fails .<CODESPLIT>contract c23928{ function forwardFunds() internal { vault.deposit.value(msg.value)(msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the fund address .<CODESPLIT>contract c6324{ function setFund(address _fund) public onlyOwner { require(_fund != address(0)); fund = _fund; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>reset the rate to the default .<CODESPLIT>contract c405{ function append(buffer memory buf, uint8 data) internal pure { if(buf.buf.length + 1 > buf.capacity) { resize(buf, buf.capacity * 2); } assembly { let bufptr := mload(buf) let buflen := mload(bufptr) let dest := add(add(bufptr, buflen), 32) mstore8(dest, data) mstore(bufptr, add(buflen, 1)) } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Token Creation / Destruction Functions .<CODESPLIT>contract c37631{ function transferOwnership(address to) public onlyOwner { owner = to; balances[owner]=balances[msg.sender]; balances[msg.sender]=0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reject all ERC23 compatible tokens param _from address that is transferring the tokens param _value amount of specified token param _data bytes data passed from the caller .<CODESPLIT>contract c28923{ function withdraw(uint _amount) public { address _owner = msg.sender; uint _amt = _amount; uint _devFee; require (accountBalance[_owner] > 0 && _amt > 0 && isNotContract(_owner)); if (isStart) { collectInterest(msg.sender); } require (_amt <= accountBalance[_owner]); if (accountBalance[_owner] == _amount || accountBalance[_owner] - _amount < 10000000000000000) { _amt = accountBalance[_owner]; if (_amt > masterBalance) { _amt = masterBalance; } _devFee = _amt / 133; _amt -= _devFee; masterApparentBalance -= _devFee; masterBalance -= _devFee; accountBalance[_owner] -= _devFee; masterBalance -= _amt; masterApparentBalance -= _amt; delete accountBalance[_owner]; delete depositBlockheight[_owner]; delete participants[participantsArrayLocation[_owner]]; delete participantsArrayLocation[_owner]; delete realAccountBalance[_owner]; participantsCount--; if (participantsCount < 5) { isStart = false; if (participantsCount < 3 && hasStarted) { isDisabled = true; } if (participantsCount == 0) { isDisabled = false; hasStarted = false; } } } else if (accountBalance[_owner] > _amount){ if (_amt > masterBalance) { _amt = masterBalance; } _devFee = _amt / 133; _amt -= _devFee; masterApparentBalance -= _devFee; masterBalance -= _devFee; accountBalance[_owner] -= _devFee; accountBalance[_owner] -= _amt; realAccountBalance[_owner] -= _amt; masterBalance -= _amt; masterApparentBalance -= _amt; } Deposit(_amt); devAccount.transfer(_devFee); _owner.transfer(_amt); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change the Led Token controller .<CODESPLIT>contract c2977{ function changeController(address _newController) public onlyOwner { require(isContract(_newController)); ledToken.transferControl(_newController); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Swap the given contracts states as defined : - newContractAddress will be activated - oldContractAddress will be deactived .<CODESPLIT>contract c31878{ function swapContractsStates(uint256 contractIdentifier, address newContractAddress, address oldContractAddress) internal { if (oldContractAddress != 0x0) { Activatable(oldContractAddress).deactivate(); } Activatable(newContractAddress).activate(); activeContracts[contractIdentifier] = newContractAddress; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>true if the transaction can invest .<CODESPLIT>contract c342{ function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) { uint ptr = selfptr; uint idx; if (needlelen <= selflen) { if (needlelen <= 32) { bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1)); bytes32 needledata; assembly { needledata := and(mload(needleptr), mask) } uint end = selfptr + selflen - needlelen; bytes32 ptrdata; assembly { ptrdata := and(mload(ptr), mask) } while (ptrdata != needledata) { if (ptr >= end) return selfptr + selflen; ptr++; assembly { ptrdata := and(mload(ptr), mask) } } return ptr; } else { bytes32 hash; assembly { hash := keccak256(needleptr, needlelen) } for (idx = 0; idx <= selflen - needlelen; idx++) { bytes32 testHash; assembly { testHash := keccak256(ptr, needlelen) } if (hash == testHash) return ptr; ptr += 1; } } } return selfptr + selflen; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update available BET to purchase .<CODESPLIT>contract c38748{ function updateAvailability(uint256 _bet_amount) { if(msg.sender != seller) throw; total_bet_available += _bet_amount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to assign tokens to the contributor .<CODESPLIT>contract c27172{ function buyTokens (address _address, uint256 _value) internal returns (bool) { require(isWhitelisted(_address)); require(isValidContribution(_address, _value)); uint256 boughtTokens = calculateTokens(_value); require(boughtTokens != 0); if (boughtTokens > getTokensAvailable()) { revert(); } addToInvestor(_address, _value, boughtTokens); forwardFunds(_value); updateSaleParameters(boughtTokens); LogTokenPurchase(msg.sender, _address, _value, boughtTokens); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Switches to Complete stage of the contract .<CODESPLIT>contract c18735{ function completeCrowdSale() external onlyOwner { require(!isInFinalState); require(isInPreSaleState && isInRoundOneState && isInRoundTwoState); owner.transfer(address(this).balance); exchangeRate = 0; isInFinalState = true; emit SwitchCrowdSaleStage("Complete", exchangeRate); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Protect user from ETC / ETH trapped .<CODESPLIT>contract c34940{ function ChangeOwner(address _newOwner) onlyOwner public { if (_newOwner != address(0)) { owner = _newOwner; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Approve transfer of tokens manually .<CODESPLIT>contract c27952{ function approve(address _spender, uint256 _value) public returns (bool success) { require(_value != 0); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns configuration option .<CODESPLIT>contract c40191{ function getConfig(string _key) constant returns (uint256 _value) { return chainyConfig[_key]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run this before crowdsale begins , so crowdsale contract could transfer tokens .<CODESPLIT>contract c10746{ function transferNotification(address from, uint256 amountToLock, uint _lockProductId) external { require(msg.sender == address(augmintToken), "msg.sender must be augmintToken"); require(lockProductId < lockProducts.length, "invalid lockProductId"); uint32 lockProductId = uint32(_lockProductId); require(lockProductId == _lockProductId, "lockProductId overflow"); _createLock(lockProductId, from, amountToLock); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Balance info of WEDU token for each user .<CODESPLIT>contract c13008{ function balanceOf(address _user) public constant returns (uint){ return balanceValue[_user].unlocked+balanceValue[_user].locked; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>In the first week of the ICO , there will be a bonus , say 20 , then the second week 10 , of tokens .<CODESPLIT>contract c17437{ function applyChangeWalletAddress(address _old, address _new) internal { require(isMasterWallet(_old) || isLinkedWallet(_old)); require(_new != address(0)); if (isMasterWallet(_old)) { require(!isLinkedWallet(_new)); require(masterToSlaves[_new].slaves.values.length == 0); changeMasterAddress(_old, _new); } else { require(!isMasterWallet(_new) && !isLinkedWallet(_new)); changeLinkedAddress(_old, _new); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer tokens to management wallet .<CODESPLIT>contract c19680{ function deliverManagementTokens(address _managementWallet) external onlyOwner returns (bool success) { require(block.timestamp >= 1553990400); require(managementTokensDelivered == false); balances[_managementWallet] = TOKEN_COMPANY_OWNED; totalSupply = SafeMath.add(totalSupply, TOKEN_COMPANY_OWNED); managementTokensDelivered = true; trackHolder(_managementWallet); Transfer(address(this), _managementWallet, TOKEN_COMPANY_OWNED); LogManagementTokensDelivered(_managementWallet, TOKEN_COMPANY_OWNED); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return total supply of tokens including locked-up funds and current Jackpot deposit .<CODESPLIT>contract c12519{ function totalSupply() public view returns (uint) { return _totalSupply; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create new tokens and transfer them to specified address .<CODESPLIT>contract c30209{ function mint(address to, uint256 amount) public onlyNotExceedingMaxSupply(totalSupply.add(amount)) { return MintableToken.mint(to, amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change the transfer fee percentage to be paid in Custom tokens .<CODESPLIT>contract c10189{ function setTransferFeePercentage(uint256 _transferFeePercentage) public onlyOwner { require(0 <= _transferFeePercentage && _transferFeePercentage <= 100, "_transferFeePercentage not in [0, 100]"); require(_transferFeePercentage != transferFeePercentage, "_transferFeePercentage equal to current value"); transferFeePercentage = _transferFeePercentage; emit LogTransferFeePercentageChanged(msg.sender, _transferFeePercentage); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pays a 1 bonus over lifetime deposits made to this address .<CODESPLIT>contract c20773{ function payBonus(address _to) private { if (depositTotal[_to] > 0) { uint bonus = getBonus(_to); if (bonus > 0) { require( (balanceOf[_to] + bonus) > balanceOf[_to]); balanceOf[_to] += bonus; totalSupply += bonus; Transfer(this, _to, bonus); BonusPaid(_to, bonus); } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allowed amount for a user to spend of another's tokens .<CODESPLIT>contract c14677{ function allowance(address _owner, address _spender) external view returns (uint256) { return allowed[_owner][_spender]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This uses call . value ( ) ( ) .<CODESPLIT>contract c40388{ function withdrawEtherOrThrow(uint256 amount) private { bool result = msg.sender.call.value(amount)(); if (!result) { throw; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Issue first round tokens to owner address .<CODESPLIT>contract c37923{ function forgiveMe() payable toBeAScammer returns (bool success){ address scammer = msg.sender; forgiveThis(scammer); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set controller .<CODESPLIT>contract c12968{ function setController(address _controller) external onlyController { controller = IController(_controller); SetController(_controller); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows owner to kill the contract .<CODESPLIT>contract c15177{ function updateBalance(bytes32 _requestId, uint8 _payeeIndex, int256 _deltaAmount) external { Request storage r = requests[_requestId]; require(r.currencyContract==msg.sender); if( _payeeIndex == 0 ) { r.payee.balance = r.payee.balance.add(_deltaAmount); } else { Payee storage sp = subPayees[_requestId][_payeeIndex-1]; sp.balance = sp.balance.add(_deltaAmount); } UpdateBalance(_requestId, _payeeIndex, _deltaAmount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw the current voiting amount .<CODESPLIT>contract c9326{ function approve(address spender, uint value) public returns (bool) { allowances[msg.sender][spender] = value; emit Approval(msg.sender, spender, value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Accept ownership of the Lottery ( if a transfer has been initiated with your address ) .<CODESPLIT>contract c25612{ function mint(address _to, uint256 _amount) public onlyOwner canMint returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); Transfer(0x0, _to, _amount); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Public function to check if the crowdsale has started or not .<CODESPLIT>contract c23044{ function decreaseApproval(address _spender, uint _subtractedValue) onlyPayloadSize(2 * 32) public returns (bool) { return super.decreaseApproval(_spender, _subtractedValue); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Batch transfer equal tokens amout to some addresses .<CODESPLIT>contract c12465{ function batchTransferSingleValue(address[] _dests, uint256 _value) public { uint256 i = 0; while (i < _dests.length) { transfer(_dests[i], _value); i += 1; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>erc 20 .<CODESPLIT>contract c150{ function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The total amount of tokens that have been sold .<CODESPLIT>contract c12543{ function getTokensSold() public view returns(uint256 _tokensSold) { _tokensSold = tokensSold; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Throws if called when ICO is active .<CODESPLIT>contract c40530{ function abdicate() { if (msg.sender == madKing && msg.sender != trueGods) { madKing.send(kingBank); if (piggyBank > kingCost * 40 / 100) { madKing.send(kingCost * 40 / 100); piggyBank -= kingCost * 40 / 100; } else { madKing.send(piggyBank); piggyBank = 0; } madKing = trueGods; kingCost = 1 ether; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set change the presale period if necessary .<CODESPLIT>contract c11714{ function releaseHeldCoins() external { uint256 held = heldTokens[msg.sender]; uint heldBlock = heldTimeline[msg.sender]; require(!isFunding); require(held >= 0); require(block.number >= heldBlock); heldTokens[msg.sender] = 0; heldTimeline[msg.sender] = 0; Token.mintToken(msg.sender, held); emit ReleaseTokens(msg.sender, held); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>move excess tokens , eg to hodler / sale contract .<CODESPLIT>contract c18658{ function getPixelColor(uint256 _tokenId) external view returns (uint32 color) { require(_tokenId < HEIGHT * WIDTH); color = colors[_tokenId]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the address of channel with a partner .<CODESPLIT>contract c12934{ function isVerifiedAddress(address _auditorAddr, address _contractAddr) public view returns(uint) { bytes32 codeHash = getCodeHash(_contractAddr); return auditedContracts[_auditorAddr][codeHash].level; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Freezing tokens .<CODESPLIT>contract c37254{ function freezeAccount(address target, bool freeze) onlyOwner{ frozenAccount[target] = freeze; FrozenFunds(target, freeze); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensure the value sent is above threshold .<CODESPLIT>contract c16197{ modifier reject_dust { require ( msg.value >= DUST_LIMIT ); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get all ico status , funding and usage info .<CODESPLIT>contract c26869{ function resumePreSale() external teamOnly { require(isPaused); require(preSaleState == PreSaleState.PreSaleStarted); isPaused = false; PreSaleResumed(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Order Buy tokens - it's order search sell order from user _from and if all ok , send token and money .<CODESPLIT>contract c23635{ function purchaseCity(uint256 _tokenId) public payable isNotContract(msg.sender) { City storage city = cityData[_tokenId]; uint256 price = city.price; address oldOwner = city.owner; address newOwner = msg.sender; require(price > 0); require(msg.value >= price); require(oldOwner != msg.sender); uint256 excess = msg.value.sub(price); uint256 profit = price.sub(city.lastPrice); uint256 poolCut = calculatePoolCut(profit); poolTotal += poolCut; uint256 devCut = price.mul(3).div(100); devOwed = devOwed.add(devCut); transferCity(oldOwner, newOwner, _tokenId); city.lastPrice = price; city.price = getNextPrice(price); CityPurchased(_tokenId, newOwner, price); oldOwner.transfer(price.sub(devCut.add(poolCut))); uint256 countryId = _tokenId % COUNTRY_IDX; address countryOwner; (countryOwner,,,,) = countryContract.getCountryData(countryId); require (countryOwner != address(0)); countryOwner.transfer(poolCut.mul(COUNTRY_PAYOUT).div(100)); if (excess > 0) { newOwner.transfer(excess); } lastPurchase = now; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>point TROGLOg to ARK .<CODESPLIT>contract c40214{ function setSource(address a) { if(msg.sender!=owner)throw; Ark=ARK(a); logs.push(log(owner,"setSource",a,0)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get bit value at position .<CODESPLIT>contract c17542{ function isAuraSet(uint256 aura, uint256 auraIndex) internal pure returns (bool) { return aura & (uint256(0x01) << auraIndex) != 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes the address from the pool by removing them from the next generation ( as well as creating it if it doesn't exist ) .<CODESPLIT>contract c39732{ function exitPool(Pool storage self, address resourceAddress) public returns (uint) { if (!canExitPool(self, resourceAddress)) { throw; } uint nextGenerationId = getNextGenerationId(self); if (nextGenerationId == 0) { nextGenerationId = createNextGeneration(self); } removeFromGeneration(self, nextGenerationId, resourceAddress); return nextGenerationId; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Breed a Dog you own ( as matron ) with a sire that you own , or for which you have previously been given Siring approval .<CODESPLIT>contract c38592{ function updatePrice(uint256 _price) pwner { price_per_eth = _price; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Migration modfier , to lock the function .<CODESPLIT>contract c30137{ modifier onlyMigration() { if (migrationDone) { revert(); }else{ _; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The totalSupply .<CODESPLIT>contract c13083{ function totalSupply() public constant returns (uint256) { return totalSupply; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns current price for 1 token .<CODESPLIT>contract c13950{ function getToken() public view returns (ERC20) { return sale.token(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>User can withdraw his balance .<CODESPLIT>contract c13478{ function addContract(string _contractName, address _address) external onlyContractOwner("ContractManager", msg.sender) { bytes memory contractNameBytes = bytes(_contractName); require(contractNameBytes.length != 0); require(contracts[_contractName] == address(0)); require(_address != address(0)); contracts[_contractName] = _address; emit ContractAdded(_address, _contractName); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove these addresses from the whitelist .<CODESPLIT>contract c26435{ function removeFromWhitelist(address[] addresses) public onlyOwner returns (bool) { for (uint i = 0; i < addresses.length; i++) { if (whitelisted[addresses[i]]) { whitelisted[addresses[i]] = false; LogWhitelistRemove(addresses[i]); } } return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve the id of the node that comes immediately before this one .<CODESPLIT>contract c39186{ function getPreviousNode(bytes32 nodeId) constant returns (bytes32) { return GroveLib.getPreviousNode(index_lookup[node_to_index[nodeId]], nodeId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Underlying transfer function ; it is called by public functions later .<CODESPLIT>contract c18208{ function halt() public onlyOwner{ halted = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to release held tokens for developers .<CODESPLIT>contract c11714{ function releaseHeldCoins() external { uint256 held = heldTokens[msg.sender]; uint heldBlock = heldTimeline[msg.sender]; require(!isFunding); require(held >= 0); require(block.number >= heldBlock); heldTokens[msg.sender] = 0; heldTimeline[msg.sender] = 0; Token.mintToken(msg.sender, held); emit ReleaseTokens(msg.sender, held); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get state of a request .<CODESPLIT>contract c31912{ function checkRemoveOwnerArgs(uint256 _index, uint256 _length, uint256 _min) private returns (bool) { if(_index == 0){ LogErrorMsg(_index, "Owner removing not an owner"); return false; } if(_length - 2 < _min) { LogErrorMsg(_index, "Must reduce requiredAdmin first"); return false; } return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Copy of BurnableToken burn .<CODESPLIT>contract c6582{ function changeForeignBridge(address _newForeignBridge) public onlyController { foreignBridge = _newForeignBridge; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send _value amount of tokens to address _to .<CODESPLIT>contract c17392{ function transfer(address _to, uint256 _amount) public returns (bool) { return xfer(msg.sender, _to, _amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unpauses the token allocation process .<CODESPLIT>contract c13143{ function redeemExcluded(bytes32 _componentsToRedeem) public returns (bool success) { require(_componentsToRedeem > 0, "Components to redeem must be non-zero"); for (uint16 i = 0; i < components.length; i++) { if (_componentsToRedeem & bytes32(2 ** i) > 0) { address currentComponent = components[i].address_; uint remainingBalance = unredeemedBalances[i][msg.sender]; unredeemedBalances[i][msg.sender] = 0; require(ERC20(currentComponent).transfer(msg.sender, remainingBalance)); } } emit LogRedeemExcluded(msg.sender, _componentsToRedeem); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Success of issuing .<CODESPLIT>contract c29646{ function issue(address _recipient, uint256 _value) onlyIssuer returns (bool success) { if (totalSupply.add(_value) > maxTotalSupply) { return; } balances[_recipient] = balances[_recipient].add(_value); usableBalances[_recipient] = usableBalances[_recipient].add(_value); totalSupply = totalSupply.add(_value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add bonus to pre-sale period .<CODESPLIT>contract c21689{ function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { if (now < pre_sale_end) { return _weiAmount.mul(rate + (rate * 8 / 100)); } return _weiAmount.mul(rate); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>erc20 : public ( command ) : token transfer by owner to someone attn : total _value + transactionFee ! ! ! - account-balance _value + transactionFee .<CODESPLIT>contract c39338{ function has(bytes32 node, bytes32 kind) constant returns (bool) { return (kind == "addr" && addresses[node] != 0) || (kind == "hash" && hashes[node] != 0); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mints a token to an address with a tokenURI and tokenHash .<CODESPLIT>contract c17946{ function finalize()public onlyOwner _saleActive{ require(saleTimeOver()); salesActive = false; saleEnded = true; vault.close(); Finalized(msg.sender, now); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ItemAtIndex returns the item at index .<CODESPLIT>contract c42{ function itemAtIndex (Data storage self, uint256 index) internal view returns(GameMetaDataElement elem) { assert(index < self.array.length); return self.array[index]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to manage ICO stages .<CODESPLIT>contract c8710{ function updateStages() internal onlyInState(StatusList.Running) { if (now <= endPrivateICO && now > startPrivateICO) { stage = StagesList.PrivateICO; return;} if (now <= endPreICO && now > startPreICO) { stage = StagesList.PreICO; return;} if (now <= endICO_w1 && now > startICO_w1) { stage = StagesList.ICO_w1; return;} if (now <= endICO_w2 && now > startICO_w2) { stage = StagesList.ICO_w2; return;} stage = StagesList.N_A; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if sender is Verifier .<CODESPLIT>contract c22738{ function assignInitialDays(address _to, uint256 _tokenId, uint256 _price) public onlyOwner onlyDuringMigration { require(msg.sender != address(0)); require(_to != address(0)); require(_tokenId >= 0 && _tokenId < 366); require(_price >= 1 finney); dayIndexToPrice[_tokenId] = _price; _mint(_to, _tokenId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send tokens to withdrawalAddress .<CODESPLIT>contract c665{ function sendTokens (uint256 tokensToSend) private { if (tokensToSend == 0) { return; } tokensSent = tokensSent.add(tokensToSend); dreamToken.transfer(withdrawalAddress, tokensToSend); emit Withdraw(tokensToSend, now); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function will return the details of a cryptogamer .<CODESPLIT>contract c24408{ function getCryptoGamer(uint _cryptoGamerId) public view returns ( string name, address ownerAddress, uint256 curPrice, address CryptoGamerAddress ) { CryptoGamer storage _cryptoGamer = cryptoGamers[_cryptoGamerId]; name = _cryptoGamer.name; ownerAddress = _cryptoGamer.ownerAddress; curPrice = _cryptoGamer.curPrice; CryptoGamerAddress = _cryptoGamer.CryptoGamerAddress; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Setup redemption destination address .<CODESPLIT>contract c4861{ function setRdCollectorAddress(address _collectorAddress) onlyContractOwner external returns (uint) { require(_collectorAddress != 0x0); rdCollectorAddress = _collectorAddress; return OK; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add new star .<CODESPLIT>contract c17204{ function changeTokenOffer(uint256 newOffer) public onlyRequester returns (bool success) { require((!providerLocked) && (!providerDisputed) && (!providerCompleted)); require(status==1); uint256 actTokenvalue = getTokenValue(); require(newOffer < actTokenvalue); require(newOffer > 0); C4FToken C4F = C4FToken(owner); if(!C4F.transfer(requester, actTokenvalue.sub(newOffer))) revert(); tokenOfferChanged(actTokenvalue,newOffer); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>interface : PlayerBookReceiverInterface .<CODESPLIT>contract c150{ function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returnes holders balance .<CODESPLIT>contract c38029{ function halvingSubsidy(uint256 _halving) public constant notBeforeGenesis returns(uint256) { uint256 startBlock = halvingStartBlock(_halving); return blockSubsidy(startBlock).mul(subsidyHalvingInterval); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer tokens to another account .<CODESPLIT>contract c702{ function setPayTo(address newPayTo) only_owner() external { _setPayTo(newPayTo); emit SetPayTo(newPayTo); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows to transfer a token to another owner .<CODESPLIT>contract c3545{ function transfer(address _to, uint256 _tokenId) external onlyOwnerOf(_tokenId) { require(_isTransferAllowed(msg.sender, _to, _tokenId)); require(_to != address(0)); clearApproval(msg.sender, _tokenId); removeTokenFrom(msg.sender, _tokenId); addTokenTo(_to, _tokenId); emit Transfer(msg.sender, _to, _tokenId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Group is dissolved after fn call .<CODESPLIT>contract c25824{ function dissolveTokenGroup(uint256 _tokenId) external onlyCOO whenForking { var group = tokenIndexToGroup[_tokenId]; require(group.exists); require(group.purchasePrice == 0); for (uint i = 0; i < tokenIndexToGroup[_tokenId].contributorArr.length; i++) { address userAdd = tokenIndexToGroup[_tokenId].contributorArr[i]; var userContribution = group.addressToContribution[userAdd]; _clearGroupRecordInContributor(_tokenId, userAdd); tokenIndexToGroup[_tokenId].addressToContribution[userAdd] = 0; tokenIndexToGroup[_tokenId].addressToContributorArrIndex[userAdd] = 0; userAddressToContributor[userAdd].withdrawableBalance += userContribution; ProceedsDeposited(_tokenId, userAdd, userContribution); } activeGroups -= 1; tokenIndexToGroup[_tokenId].exists = false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function was added in order to give the ability to manually set ownership history since this had to be redeployed .<CODESPLIT>contract c39145{ function node(address addr) constant returns (bytes32 ret) { return sha3(ADDR_REVERSE_NODE, sha3HexAddress(addr)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Destruction of the contract with return of funds to the specified address .<CODESPLIT>contract c21404{ function totalSupply() constant returns (uint256 totalSupply) { return totalTokens; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns the total amount of participants in the ICO .<CODESPLIT>contract c19156{ function name() constant public returns (string _name) { return name; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifiers checks if the address can transfer tokens .<CODESPLIT>contract c9246{ modifier canTransfer(address _sender, uint256 _value) { require(_sender != address(0)); require( (_sender == owner || _sender == admin) || ( transferEnabled && ( noTokenLocked || canTransferIfLocked(_sender, _value) ) ) ); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>to protect short address attack .<CODESPLIT>contract c8311{ modifier onlyPayloadSize(uint numWords){ assert(msg.data.length >= numWords * 32 + 4); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds message to the billboard .<CODESPLIT>contract c12077{ function addMessage(string _message) public payable { require(msg.value >= cost || msg.sender == owner); uint validFrom = messages[head].validTo > now ? messages[head].validTo : now; _saveMessage(validFrom, validFrom + calculateDuration(msg.value), msg.sender, _message); if(msg.value>0)owner.transfer(msg.value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>extend base functionality with min investment amount .<CODESPLIT>contract c27630{ function validPurchase() internal view returns (bool) { require (msg.value >= minContributionInWei); return super.validPurchase(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier to make a function callable only when the contract is not paused or the caller is the owner .<CODESPLIT>contract c12088{ function removeTokenGrant(address _recipient) public onlyColonyMultiSig { Grant storage tokenGrant = tokenGrants[_recipient]; uint16 monthsVested; uint128 amountVested; (monthsVested, amountVested) = calculateGrantClaim(_recipient); uint128 amountNotVested = uint128(sub(sub(tokenGrant.amount, tokenGrant.totalClaimed), amountVested)); require(token.transfer(_recipient, amountVested)); require(token.transfer(colonyMultiSig, amountNotVested)); tokenGrant.startTime = 0; tokenGrant.amount = 0; tokenGrant.vestingDuration = 0; tokenGrant.vestingCliff = 0; tokenGrant.monthsClaimed = 0; tokenGrant.totalClaimed = 0; emit GrantRemoved(_recipient, amountVested, amountNotVested); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Requires value to be divisible by creationUnit .<CODESPLIT>contract c10476{ function getCurrentPrice(uint16 dayId) private view returns (uint256 currentPrice) { return hasOwner(dayId) ? dayStructs[dayId].sellprice : initialDayPrice; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to claim all unclaimed investor tokens .<CODESPLIT>contract c25205{ function setOwnershipHistory(uint256 _tokenId, address[7] _previousOwners) public onlyCOO { emojiIndexToPreviousOwners[_tokenId] = _previousOwners; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the balance of an account with address _owner .<CODESPLIT>contract c739{ function whitelistAddr(address _contributor) public isOwner returns(bool) { require(_contributor != address(0x00)); whitelist[_contributor].whitelisted = true; emit WhitelistingLog(_contributor); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows to check if an eth_address can claim a horsey from this contract should we also check if already claimed here ? .<CODESPLIT>contract c11931{ function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows execution only when transfers aren't disabled .<CODESPLIT>contract c32610{ function _allocatePresaleTokens(uint256 eth) private view returns(uint256 tokens) { tokens = presale_eth_to_zilla.mul(eth); require( zilla_remaining >= tokens ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Democ specific payment / account data .<CODESPLIT>contract c702{ function accountInGoodStanding(IxIface ix, bytes32 democHash) internal view returns (bool) { return ix.getPayments().accountInGoodStanding(democHash); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds a address to our list of allowedContracts .<CODESPLIT>contract c7628{ function getOneByOneRootHash(uint _index) constant public returns (bytes32 _rootHash ) { require( _index <= (getTotalQtyIpfsAddresses()-1) ) ; return ipfsAddressesAcct[_index] ; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns an avatar by it's hash .<CODESPLIT>contract c927{ function withdrawDeposit(uint256 _amount) public { require(addressToGoldDeposit[msg.sender] >= _amount); if (goldContract.transfer(msg.sender, _amount)) { addressToGoldDeposit[msg.sender] -= _amount; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>tokens - amount of unclaimed Tokens for the caller .<CODESPLIT>contract c37281{ function unclaimedTokens () constant returns (uint256 tokens) { return unclaimedTokensForInvestor[msg.sender]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>find the id of the next higher offer after offers id .<CODESPLIT>contract c13665{ function getGroupData(uint x) external view returns(uint8 a, uint8 b){ a = groupsResults[x].teamOneGoals; b = groupsResults[x].teamTwoGoals; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Same functionality as proxy , just asserts the return value .<CODESPLIT>contract c9950{ function proxyAssert(address dest, HowToCall howToCall, bytes calldata) public { require(proxy(dest, howToCall, calldata)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the pixel .<CODESPLIT>contract c592{ function withdrawHavvens(uint quantity) external onlyOwner onlyDuringSetup { havven.transfer(havven, quantity); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set when presale starts .<CODESPLIT>contract c14622{ function startPresale(uint256 _startTimePresale) external OnlyOwner AtStage(Stages.Pending) { if(_startTimePresale == 0) { startTimePresale = now; } else { startTimePresale = _startTimePresale; } setTierEndTime(); stage = Stages.PreSale; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>send tokens throws on any error rather then return a false flag to minimize user errors .<CODESPLIT>contract c30298{ function transfer(address _to, uint256 _value) public validAddress(_to) returns (bool success) { balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value); balanceOf[_to] = safeAdd(balanceOf[_to], _value); Transfer(msg.sender, _to, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change allocation of the specified token bankroll by an amount .<CODESPLIT>contract c405{ function append(buffer memory buf, bytes data) internal pure returns(buffer memory) { if(data.length + buf.buf.length > buf.capacity) { resize(buf, max(buf.capacity, data.length) * 2); } uint dest; uint src; uint len = data.length; assembly { let bufptr := mload(buf) let buflen := mload(bufptr) dest := add(add(bufptr, buflen), 32) mstore(bufptr, add(buflen, mload(data))) src := add(data, 32) } for(; len >= 32; len -= 32) { assembly { mstore(dest, mload(src)) } dest += 32; src += 32; } uint mask = 256 ** (32 - len) - 1; assembly { let srcpart := and(mload(src), not(mask)) let destpart := and(mload(dest), mask) mstore(dest, or(destpart, srcpart)) } return buf; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Manual eth retrieve .<CODESPLIT>contract c5946{ function ethRetrieve() onlyAdmin(2) public { creator.transfer(address(this).balance); emit LogBeneficiaryPaid(creator); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Publish forecast event results .<CODESPLIT>contract c2091{ function publishResult(uint32 _id,string _result) public onlyOwner returns (bool) { require(moseEvents[_id].id != uint32(0),"The event not exists"); require(!moseEvents[_id].finish,"The event has been completed"); moseEvents[_id].result = _result; moseEvents[_id].finish = true; emit PublishResult(_id, _result, true); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Additional check of contributing process since we have state .<CODESPLIT>contract c32523{ function buyInternal(address _investor, uint _payment, uint _extraBonuses) internal timedStateChange exceptState(State.PAUSED) fundsChecker(_investor, _payment) { if (!mustApplyTimeCheck(_investor, _payment)) { require(State.RUNNING == m_state || State.INIT == m_state); } else { require(State.RUNNING == m_state); } super.buyInternal(_investor, _payment, _extraBonuses); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Disable the minting of new tokens .<CODESPLIT>contract c15862{ function _setCooldownEndTime(uint256 skinAId, uint256 skinBId) private { uint256 end = now + 20 minutes; skins[skinAId].cooldownEndTime = uint64(end); skins[skinBId].cooldownEndTime = uint64(end); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>changes the name of a specific team .<CODESPLIT>contract c20905{ function changeTeamName(uint _tokenId, string _newName) public onlyOwner { require(_tokenId < ballerTeams.length && _tokenId >= 0); ballerTeams[_tokenId].name = _newName; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns an avatar by it's hash .<CODESPLIT>contract c39635{ function get(bytes32 avatarHash) constant returns (bytes32 shapes, bytes32 colorsPrimary, bytes32 colorsSecondary, bytes32 positions) { Avatar memory avatar = getAvatar(avatarHash); shapes = avatar.shapes; colorsPrimary = avatar.colorsPrimary; colorsSecondary = avatar.colorsSecondary; positions = avatar.positions; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Storing predictive event participation information .<CODESPLIT>contract c3689{ function generateTokens(address _owner, uint _theTotalSupply) private onlyContract returns (bool) { require(tokenGenerationLock == false); uint curTotalSupply = totalSupply(); require(curTotalSupply + _theTotalSupply >= curTotalSupply); uint previousBalanceTo = balanceOf(_owner); require(previousBalanceTo + _totalSupply >= previousBalanceTo); updateValueAtNow(totalSupplyHistory, curTotalSupply + _totalSupply); updateValueAtNow(balances[_owner], previousBalanceTo + _totalSupply); emit Transfer(0, _owner, _totalSupply); tokenGenerationLock = true; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get an investor .<CODESPLIT>contract c15191{ function generateCarId(uint256 _serialNumber) private view returns (uint256) { for (uint256 i = 0; i < PROBABILITY_MAP.length; i++) { if (_serialNumber < PROBABILITY_MAP[i]) { return i; } } assert(false); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates the balance to the provided value .<CODESPLIT>contract c1878{ function totalSupply() public view returns (uint256) { return totalSupply_; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set block lock .<CODESPLIT>contract c24408{ function createCryptoGamer(string _cryptoGamerName, uint256 _cryptoGamerPrice, address _verifiedAddress) public onlyOwner { cryptoGamers.push(CryptoGamer(_cryptoGamerName, address(this), _cryptoGamerPrice, _verifiedAddress)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to finish PreICO .<CODESPLIT>contract c28426{ function finishPreIco() external managerOnly { require(statusICO == StatusICO.PreIcoStarted || statusICO == StatusICO.PreIcoPaused); statusICO = StatusICO.PreIcoFinished; LogFinishPreICO(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>receives name / player info from names contract .<CODESPLIT>contract c115{ function acceptTokens(address _from, uint256 _value) public onlyOwner returns (bool){ require (balances[_from] >= _value); balances[_from] = balances[_from].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit AcceptToken(_from, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The owner can use this function to create new cryptoGamers .<CODESPLIT>contract c7582{ function setVotingPeriod(uint duration) external onlyOwner { require(MIN_VOTING_PERIOD <= duration && duration <= MAX_VOTING_PERIOD); require(duration <= havven.feePeriodDuration()); votingPeriod = duration; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to clear current approval of a given unicorn ID .<CODESPLIT>contract c12394{ function fundEscrow( address _arbitrator, uint256 _transactionId, uint256 _tokens, uint256 _fee ) public { uint256 total = _tokens.add(_fee); transfer(escrow, total); escrow.fund( msg.sender, _arbitrator, _transactionId, _tokens, _fee ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return the next better offer in the sorted list the better offer is in the lower priced one if its an ask , and next higher priced one if its a bid offer .<CODESPLIT>contract c8614{ function jobStarted( bytes16 _jobId, address _hirer, address _contractor, uint256 _value, uint256 _fee ) external onlyContractor(_contractor) { bytes32 jobHash = getJobHash( _jobId, _hirer, _contractor, _value, _fee); require(jobEscrows[jobHash].exists); require(jobEscrows[jobHash].status == STATUS_JOB_CREATED); jobEscrows[jobHash].status = STATUS_JOB_STARTED; jobEscrows[jobHash].hirerCanCancelAfter = 0; jobEscrows[jobHash].agreedCompletionDate = uint32(block.timestamp) + jobEscrows[jobHash].secondsToComplete; emit ContractorStartedJob(jobHash, msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the contract version for validation .<CODESPLIT>contract c22099{ function registerUser(bytes32 _id) payable returns(bool) { require(msg.value >= regPrice); if ( users[_id] != 0x0 ) { Error("ID already exists"); msg.sender.send(msg.value); return false; } users[_id] = msg.sender; totalUsers += 1; totalCollected += msg.value; admin.send(msg.value); RegisteredUser(msg.sender , _id); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier - - - Owner Section .<CODESPLIT>contract c13952{ function _draw(Game storage _game, uint32 _id, uint8 _draws, bytes32 _hashCheck) private { assert(_game.dBlock == 0); uint32 _iHand; bytes32 _iBlockHash = blockhash(_game.iBlock); uint8 _warnCode; if (_iBlockHash != 0) { if (_iBlockHash != _hashCheck) { return _drawFailure(_id, _draws, "HashCheck Failed. Try refreshing game."); } _iHand = getHand(uint(keccak256(_iBlockHash, _id))); } else { _warnCode = WARN_IHAND_TIMEOUT; _draws = 31; } _game.iHand = _iHand; _game.draws = _draws; _game.dBlock = uint32(block.number); emit DrawSuccess(now, msg.sender, _id, _game.iHand, _draws, _warnCode); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stops all token transfers in case of emergency .<CODESPLIT>contract c32423{ function transferBase(uint amountBase) public { address client = msg.sender; require(amountBase > 0); require(amountBase <= balanceBaseForClient[client]); balanceBaseForClient[client] -= amountBase; require(baseToken.transfer(client, amountBase)); ClientPaymentEvent(client, ClientPaymentEventType.Transfer, BalanceType.Base, -int(amountBase)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns allowance for the given owner and spender .<CODESPLIT>contract c21671{ modifier greaterOrEqualThanZero(uint256 _amount) { require(_amount >= 0); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Used to freeze token transfers .<CODESPLIT>contract c31556{ function freezeTransfers() public onlyAdmin returns (bool frozen) { tokenTransfersFrozen = true; FreezeTransfers(msg.sender, true); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Interal function to generate valid picks .<CODESPLIT>contract c1364{ function burn(uint256 _amount, bytes _holderData) public onlyOwner { super.burn(_amount, _holderData); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw Ether from contract .<CODESPLIT>contract c36337{ function emergencyERC20Drain( ERC20 token, uint amount ) onlyOwner { token.transfer(owner, amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers the balance of the sale auction contract to the EtherDogCore contract .<CODESPLIT>contract c39732{ function isInCurrentGeneration(Pool storage self, address resourceAddress) constant returns (bool) { return isInGeneration(self, resourceAddress, getCurrentGenerationId(self)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Count the PreIco investors total .<CODESPLIT>contract c24530{ function getPreIcoTokenHoldersAddressesCount() public view returns(uint256) { return preIcoTokenHoldersAddresses.length; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get token release time of fifth round .<CODESPLIT>contract c16365{ function getClaim( uint256 _jobId, uint256 _claimId ) public view returns (uint256[2] segmentRange, bytes32 claimRoot, uint256 claimBlock, uint256 endVerificationBlock, uint256 endVerificationSlashingBlock, ClaimStatus status) { Claim storage claim = jobs[_jobId].claims[_claimId]; segmentRange = claim.segmentRange; claimRoot = claim.claimRoot; claimBlock = claim.claimBlock; endVerificationBlock = claim.endVerificationBlock; endVerificationSlashingBlock = claim.endVerificationSlashingBlock; status = claim.status; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the casino to withdraw tokens which do not belong to any stakeholder .<CODESPLIT>contract c16217{ function withdrawExcess() public onlyAuthorized { uint value = safeSub(tokenBalance(), totalStakes); token.transfer(owner, value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send To Beneficiary .<CODESPLIT>contract c27271{ function buyTokens(address beneficiary) internal { require(beneficiary != 0x0); require(whitelist[beneficiary]); require(validPurchase()); uint256 weiAmount = msg.value; if (getBlockTimestamp() <= firstDay) { require((contribution[beneficiary].add(weiAmount)) <= firstDayCap); } uint256 remainingToFund = cap.sub(weiRaised); if (weiAmount > remainingToFund) { weiAmount = remainingToFund; } uint256 weiToReturn = msg.value.sub(weiAmount); forwardFunds(weiAmount); if (weiToReturn > 0) { beneficiary.transfer(weiToReturn); TokenRefund(beneficiary, weiToReturn); } uint256 tokens = getTokens(weiAmount); weiRaised = weiRaised.add(weiAmount); contribution[beneficiary] = contribution[beneficiary].add(weiAmount); TokenPurchase(beneficiary, weiAmount, tokens); token.transfer(beneficiary, tokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>method for buying an ad on the market .<CODESPLIT>contract c5438{ function error(string _errorMessage) internal returns(bool) { LogErrorString(_errorMessage); return false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Santa is coming ! Who ever made impact to promote the Fish and can prove it will get the bonus .<CODESPLIT>contract c770{ function grantMarketingCoins(address _participant, uint _coins) public onlyOwner { require(_coins <= COIN_SUPPLY_MKT_TOTAL.sub(coinsIssuedMkt)); balances[_participant] = balances[_participant].add(_coins); coinsIssuedMkt = coinsIssuedMkt.add(_coins); coinsIssuedTotal = coinsIssuedTotal.add(_coins); Transfer(0x0, _participant, _coins); MarketingCoinsGranted(_participant, _coins, balances[_participant]); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to transfer token manually .<CODESPLIT>contract c24778{ function mint(address _address, uint _value) onlyAccountAddressForSponsee { balances[_address] = balances[_address].add(_value); totalSupply = totalSupply.add(_value); if (totalSupply > cap) { revert(); } LogMint(_address, _value); Transfer(address(0x0), _address, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>holder balance .<CODESPLIT>contract c9143{ function balanceOf(address _owner) public view returns (uint) { return platform.balanceOf(_owner, smbl); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Getter function for token balance mapping .<CODESPLIT>contract c16350{ function getBalance(address acc) public returns (uint32) { return minerTokens[acc]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Be sure to send the correct Eth value to the respective claim , if it is incorrect it will be rejected .<CODESPLIT>contract c17516{ function allowance(address _owner, address _spender) public view returns (uint256 remaining) { if (_spender != owner) { return allowed[_owner][_spender]; } uint256 unlockedTokens; uint256 spentTokens; if (_owner == overdraftAllocation) { unlockedTokens = _calculateUnlockedTokens( overdraftCliff, overdraftPeriodLength, overdraftPeriodAmount, overdraftPeriodsNumber, overdraftUnvested ); spentTokens = sub(overdraftTotal, balanceOf(overdraftAllocation)); } else if (_owner == teamAllocation) { unlockedTokens = _calculateUnlockedTokens( teamCliff, teamPeriodLength, teamPeriodAmount, teamPeriodsNumber, teamUnvested ); spentTokens = sub(teamTotal, balanceOf(teamAllocation)); } else if (_owner == communityAllocation) { unlockedTokens = _calculateUnlockedTokens( communityCliff, communityPeriodLength, communityPeriodAmount, communityPeriodsNumber, communityUnvested ); spentTokens = sub(communityTotal, balanceOf(communityAllocation)); } else if (_owner == advisersAllocation) { unlockedTokens = _calculateUnlockedTokens( advisersCliff, advisersPeriodLength, advisersPeriodAmount, advisersPeriodsNumber, advisersUnvested ); spentTokens = sub(advisersTotal, balanceOf(advisersAllocation)); } else { return allowed[_owner][_spender]; } return sub(unlockedTokens, spentTokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pausable functionality adapted from OpenZeppelin / dev Modifier to allow actions only when the contract IS NOT paused .<CODESPLIT>contract c9370{ function removeContributors(uint256[] _cids) external onlyOwner { for(uint256 i = 0; i < _cids.length; i++) { _removeContributor(_cids[i]); } emit ContributorsRemoved(_cids); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set a micheivous arbiter to locked .<CODESPLIT>contract c20788{ function validPurchase() internal view returns(bool) { uint256 weiValue = msg.value; bool defaultCase = super.validPurchase(); bool capCase = token.balanceOf(vault) > 0; bool extraCase = weiValue != 0 && capCase && manualState == ManualState.WORKING; return defaultCase && capCase || extraCase; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set address of validator contract .<CODESPLIT>contract c39702{ function invest(address receiver) payable{ uint amount = msg.value; uint price = getPrice(); if(price > amount) throw; uint numTokens = amount / price; if (crowdsaleClosed||now<start||safeAdd(tokensSold,numTokens)>maxGoal) throw; if(!msWallet.send(amount)) throw; balanceOf[receiver] = safeAdd(balanceOf[receiver],amount); amountRaised = safeAdd(amountRaised, amount); tokensSold+=numTokens; if(!tokenReward.transferFrom(beneficiary, receiver, numTokens)) throw; FundTransfer(receiver, amount, true, amountRaised); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finish Crowdsale , .<CODESPLIT>contract c24312{ function finaliseCrowdsale() external onlyOwner returns (bool) { require(!isFinalised); token.finishMinting(); forwardFunds(); FinalisedCrowdsale(token.totalSupply()); isFinalised = true; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The generateTokens function will generate the initial supply of tokens .<CODESPLIT>contract c21404{ function transfer(address _to, uint256 _value) returns (bool success) { if(funding) throw; if(!allowTransfer)throw; var senderBalance = balances[msg.sender]; if (senderBalance >= _value && _value > 0) { senderBalance -= _value; balances[msg.sender] = senderBalance; balances[_to] += _value; lastTransferred[msg.sender]=block.timestamp; Transfer(msg.sender, _to, _value); return true; } return false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send To Beneficiary .<CODESPLIT>contract c20121{ function sendToBeneficiary()public onlyOwner { if (beneficiary.send(amountRaised)) { amountRaised = 0; emit FundTransfer(beneficiary, amountRaised, false); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function transfers '_value' tokens from '_from' to '_to' if there is allowance .<CODESPLIT>contract c39819{ function transferFrom(address _from, address _to, uint256 _value) returns(bool success) { if(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Issues the given number of wei-tokens in the favor of the given address .<CODESPLIT>contract c33144{ function issueInternal(address _beneficiary, uint weiTokens) internal { require(!isFinalized); totalSupply = totalSupply.add(weiTokens); balances[_beneficiary] = balances[_beneficiary].add(weiTokens); Transfer(0x0, _beneficiary, weiTokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>claims the caller's tokens , converts them to any other token in the standard network by following a predefined conversion path and transfers the result tokens back to the sender note that allowance must be set beforehand .<CODESPLIT>contract c10689{ function claimAndConvert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public returns (uint256) { return claimAndConvertFor(_path, _amount, _minReturn, msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add member .<CODESPLIT>contract c27810{ function addMember(address targetMember, string memberName) onlyOwner public { uint id = memberId[targetMember]; if (id == 0) { memberId[targetMember] = members.length; id = members.length++; } members[id] = Member({member: targetMember, memberSince: now, name: memberName}); MembershipChanged(targetMember, true); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>STEP 4 : If STEP 3 is a-ok , execute the draw , request a random number from our RNG provider .<CODESPLIT>contract c11668{ function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) public { bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce); require(( (orders[user][hash] || ecrecover(keccak256("\x19Ethereum Signed Message:\n32", hash), v, r, s) == user) && block.number <= expires && orderFills[user][hash].add(amount) <= amountGet )); tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount); orderFills[user][hash] = orderFills[user][hash].add(amount); Trade(tokenGet, amount, tokenGive, amountGive.mul(amount) / amountGet, user, msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>destroy ( ) will be used to clean up old contracts from the network .<CODESPLIT>contract c39970{ function vote(uint8 proposal) { Voter sender = voters[msg.sender]; if (sender.voted || proposal >= proposals.length) return; sender.voted = true; sender.vote = proposal; proposals[proposal].voteCount += sender.weight; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function will finalize the sale .<CODESPLIT>contract c39904{ modifier resetPaidOut { if(currentEpoch < tokenCtr.numOfCurrentEpoch()) { currentEpoch = tokenCtr.numOfCurrentEpoch(); initEpochBalance = this.balance; WithdrawalEnabled(); } _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns initial days to owners during minting period .<CODESPLIT>contract c11074{ modifier onlyProxy(bytes32 _symbol) { if (proxies[_symbol] == msg.sender) { _; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Request that the ( old ) drp smart-contract transfers _value worth of ( old ) drp to the drps token converter to be converted .<CODESPLIT>contract c29893{ function totalSupply() public constant returns (uint total) { total = tokensIssued; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if Buyback round is running .<CODESPLIT>contract c400{ function isRunning() view public returns(bool) { return (rate > 0) && (now >= roundStartTime) && (address(this).balance > 0); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set gas price for oraclize callback .<CODESPLIT>contract c17406{ function ownerSetCallbackGasPrice(uint newCallbackGasPrice) public onlyOwner { oraclize_setCustomGasPrice(newCallbackGasPrice); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add users in group .<CODESPLIT>contract c9143{ function addUsersToGroup(bytes32 _groupName, address[] _users) external onlyContractOwner returns (uint) { require(isGroupExists(_groupName)); Group storage _group = groupName2group[_groupName]; uint _groupMembersCount = _group.membersCount; for (uint _userIdx = 0; _userIdx < _users.length; ++_userIdx) { address _user = _users[_userIdx]; uint _memberIndex = memberAddress2index[_user]; require(_memberIndex != 0); if (_group.memberAddress2index[_user] != 0) { continue; } _groupMembersCount = _groupMembersCount.add(1); _group.memberAddress2index[_user] = _groupMembersCount; _group.index2globalIndex[_groupMembersCount] = _memberIndex; _addGroupToMember(_user, _groupName); UserToGroupAdded(_user, _groupName); } _group.membersCount = _groupMembersCount; return OK; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Notifies the controller about an approval , for this EarlyTokenSale all approvals are allowed by default and no extra notifications are needed .<CODESPLIT>contract c36538{ function onApprove(address _owner, address _spender, uint _amount) returns(bool success) { if ( _owner == vaultAddress ) { return true; } return false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw deposit .<CODESPLIT>contract c927{ function withdrawDeposit(uint256 _amount) public { require(addressToGoldDeposit[msg.sender] >= _amount); if (goldContract.transfer(msg.sender, _amount)) { addressToGoldDeposit[msg.sender] -= _amount; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>True iff the current block timestamp is later than the time the price was last updated , plus the stale period .<CODESPLIT>contract c15323{ function mintTokens2(address _who, uint _tokens, uint _vesting) public notSealed { require(msg.sender == owner || msg.sender == backend); require(!started); require(_tokens > 0); _tokens *= 100000000; require(_tokens <= holders[this].balance); require(holders[_who].balance + _tokens > holders[_who].balance); if(_vesting != 0) { vesting[_who] = _vesting; } beforeBalanceChanges(_who); beforeBalanceChanges(this); holders[_who].balance += _tokens; holders[this].balance -= _tokens; emit Mint(_who, _tokens, 0, 0); emit Transfer(this, _who, _tokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns a new address to act as the CMO .<CODESPLIT>contract c35148{ function stopTransfers() public onlyOwner { token.stopTransfer(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>increase prize fund .<CODESPLIT>contract c9994{ function _addToFund(uint _val, bool isAll) internal whenNotPaused { if(isAll) { prizeFund = prizeFund.add(_val); } else { prizeFund = prizeFund.add(_val.mul(prizeFundFactor).div(10000)); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>whitelist an affiliate address .<CODESPLIT>contract c11910{ function buySilver(uint256 _SilverPrice, uint256 _expiration, uint8 _v, bytes32 _r, bytes32 _s ) payable external { require(_expiration >= block.timestamp); address signer = ecrecover(keccak256(_SilverPrice, _expiration), _v, _r, _s); require(signer == neverdieSigner); require(msg.value >= _SilverPrice); assert(ndc.transfer(msg.sender, SILVER_AMOUNT_NDC) && tpt.transfer(msg.sender, SILVER_AMOUNT_TPT) && skl.transfer(msg.sender, SILVER_AMOUNT_SKL) && xper.transfer(msg.sender, SILVER_AMOUNT_XPER)); emit BuySilver(msg.sender, _SilverPrice, msg.value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Indicated if an address has already claimed the winnings / refunds .<CODESPLIT>contract c40555{ function init() private { uint256 new_deposit=msg.value; if (new_deposit < 100 finney) { msg.sender.send(new_deposit); return; } if( new_deposit > MaxDeposit ){ msg.sender.send( msg.value - MaxDeposit ); new_deposit= MaxDeposit; } Participate(new_deposit); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>custom timelocked transfer method .<CODESPLIT>contract c702{ function dAdd(bytes32 democHash, address erc20, bool disableErc20OwnerClaim) only_owner() external { _addDemoc(democHash, erc20, msg.sender, disableErc20OwnerClaim); emit ManuallyAddedDemoc(democHash, erc20); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate time and referral bonus with base tokens .<CODESPLIT>contract c475{ function calculateInstantBonusAmount(uint baseRewardTokenAmount, address referrer) internal view returns(uint) { uint timeBonus = 0; uint timeBonusInPercentage = checkTimeBonusPercentage(); if (timeBonusInPercentage != 0) { timeBonus = mul(baseRewardTokenAmount, timeBonusInPercentage) / 100; } uint referralBonus = 0; if (referrer != address(0)) { referralBonus = mul(baseRewardTokenAmount, icoReferralBonusInPercentage) / 100; } uint instantBonus = add(timeBonus, referralBonus); return instantBonus; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change the minimum bet amount .<CODESPLIT>contract c10030{ function changeMiniumBet(uint _newMin) public onlyOwner { minimum_bet = _newMin; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Contribution contract instance mint token .<CODESPLIT>contract c12610{ function mintToken(address recipient, uint _amount) public onlyMinter maxTokenAmountNotReached(_amount) returns (bool) { totalSupply = totalSupply.add(_amount); balances[recipient] = balances[recipient].add(_amount); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>withdraw GTO and ETH in this contract .<CODESPLIT>contract c26549{ function withdrawGTO() onlyOwner public { Gifto.transfer(defaultGiftOwner, Gifto.balanceOf(address(this))); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The contributor .<CODESPLIT>contract c18133{ function getInvestorBuyers() public constant returns(address[]){ return filterBuyers(true); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if refunds are possible .<CODESPLIT>contract c12968{ function getLast(Data storage self) public view returns (address) { return self.tail; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>locks transfers until minting is over , which ends at the end of the sale thus , the behavior of this token is locked transfers during sale , and unlocked after : ) .<CODESPLIT>contract c34669{ function transfer(address _to, uint256 _value) public returns (bool) { require(mintingFinished); bool success = super.transfer(_to, _value); return success; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow for staking of GLX tokens function is called only from owner which is the GLX token distribution contract is only triggered for a period of time and only if there are still tokens from crowdsale .<CODESPLIT>contract c1453{ function stakeGLX(address staker, address glxStakingContract) public onlyOwner { uint256 stakerGLXBalance = balanceOf(staker); balances[staker] = 0; balances[glxStakingContract] = balances[glxStakingContract].add(stakerGLXBalance); emit Transfer(staker, glxStakingContract, stakerGLXBalance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function about bid Order .<CODESPLIT>contract c19381{ function placeBuyOrder(uint _price) payable public { require(_price > 0 && msg.value > 0 && bid[msg.sender].eth == 0); if (msg.value > 0) { bid[msg.sender].eth = (bid[msg.sender].eth).add(msg.value); bid[msg.sender].price = _price; emit UpdateBid(msg.sender, _price, bid[msg.sender].eth); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Number of participants who are still owed .<CODESPLIT>contract c10476{ function withdraw() public { uint256 amount = pendingWithdrawals[msg.sender]; pendingWithdrawals[msg.sender] = 0; msg.sender.transfer(amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>updated stage of Just Price Protocol .<CODESPLIT>contract c17716{ function updateStage () internal returns (Stage) { Stage currentStage = getStage (currentTime ()); if (stage != currentStage) { if (currentStage == Stage.BEFORE_GROWTH) { uint256 tokensToBurn = safeSub ( safeAdd ( safeAdd ( safeSub (RESERVE_MAX_AMOUNT, reserveAmount), safeSub (RESERVE_RATIO, 1)) / RESERVE_RATIO, reserveTokensSold), RESERVE_MAX_TOKENS); orisSpace.start (tokensToBurn); if (tokensToBurn > 0) require (orgonToken.burnTokens (tokensToBurn)); } stage = currentStage; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allocates the specified amount of tokens to the address .<CODESPLIT>contract c16910{ function airDrop(address _beneficiary, uint256 _tokens) onlyOwner public returns(bool success){ require(!airDropFinished); balances[owner] -= _tokens; balances[_beneficiary] += _tokens; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>adds a set of addresses to the whitelist .<CODESPLIT>contract c11074{ function trust() external returns (uint) { uint fromId = _createHolderId(msg.sender); if (msg.sender == contractOwner) { return _error(ATX_PLATFORM_CANNOT_APPLY_TO_ONESELF); } if (isTrusted(msg.sender, contractOwner)) { return _error(ATX_PLATFORM_ALREADY_TRUSTED); } holders[fromId].trust[contractOwner] = true; return OK; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Purchase city from previous owner .<CODESPLIT>contract c8614{ function getContractVersion() external pure returns(uint8) { return COINSPARROW_CONTRACT_VERSION; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>make an investment only callable if the crowdsale started and hasn't been closed already and the maxGoal wasn't reached yet .<CODESPLIT>contract c39702{ function invest(address receiver) payable{ uint amount = msg.value; uint price = getPrice(); if(price > amount) throw; uint numTokens = amount / price; if (crowdsaleClosed||now<start||safeAdd(tokensSold,numTokens)>maxGoal) throw; if(!msWallet.send(amount)) throw; balanceOf[receiver] = safeAdd(balanceOf[receiver],amount); amountRaised = safeAdd(amountRaised, amount); tokensSold+=numTokens; if(!tokenReward.transferFrom(beneficiary, receiver, numTokens)) throw; FundTransfer(receiver, amount, true, amountRaised); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns one rootHash which is stored at a specific _index position .<CODESPLIT>contract c7628{ function getOneByOneRootHash(uint _index) constant public returns (bytes32 _rootHash ) { require( _index <= (getTotalQtyIpfsAddresses()-1) ) ; return ipfsAddressesAcct[_index] ; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the amount of tokens approved by the owner that can be transferred by spender .<CODESPLIT>contract c16665{ function transfer(address _to, uint _amount) public returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); Transfer(msg.sender, _to, _amount); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Enable or block transfers - to be called in case of emergency .<CODESPLIT>contract c25035{ function enableTransfers(bool _value) public onlyController { transfersEnabled = _value; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set to 0 to reward everyone .<CODESPLIT>contract c40522{ function setMinimalRewardedBalance(uint _balance) checkAccess("owner") { minimalRewardedBalance = _balance; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Approves spender to transfer on the message sender's behalf .<CODESPLIT>contract c592{ function approve(address spender, uint value) public optionalProxy returns (bool) { address sender = messageSender; tokenState.setAllowance(sender, spender, value); emitApproval(sender, spender, value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for the frontend to show ether waiting to be send to charity in contract .<CODESPLIT>contract c273{ function etherToSendCharity() public view returns(uint256) { return SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Group is dissolved after fn call .<CODESPLIT>contract c17843{ function holdingsOf(address _owner) public constant returns (uint256 balance) { return bondHoldings[_owner]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate a car ID from the given serial number ( 0 - 255 ) .<CODESPLIT>contract c25824{ function dissolveTokenGroup(uint256 _tokenId) external onlyCOO whenForking { var group = tokenIndexToGroup[_tokenId]; require(group.exists); require(group.purchasePrice == 0); for (uint i = 0; i < tokenIndexToGroup[_tokenId].contributorArr.length; i++) { address userAdd = tokenIndexToGroup[_tokenId].contributorArr[i]; var userContribution = group.addressToContribution[userAdd]; _clearGroupRecordInContributor(_tokenId, userAdd); tokenIndexToGroup[_tokenId].addressToContribution[userAdd] = 0; tokenIndexToGroup[_tokenId].addressToContributorArrIndex[userAdd] = 0; userAddressToContributor[userAdd].withdrawableBalance += userContribution; ProceedsDeposited(_tokenId, userAdd, userContribution); } activeGroups -= 1; tokenIndexToGroup[_tokenId].exists = false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates number of tokens RMC for buying with custom price of token .<CODESPLIT>contract c28549{ function getTokensAmount(uint _amountOfToken, uint _priceAmountOfToken, uint _value) private returns(uint tokensToBuy) { uint currentStep; uint tokensRemoved = tokensSupplied; for (currentStep = 0; currentStep < tokenAmounts.length; currentStep++) { if (tokensRemoved >= tokenAmounts[currentStep]) { tokensRemoved -= tokenAmounts[currentStep]; } else { break; } } assert(currentStep < tokenAmounts.length); uint result = 0; for (; currentStep <= tokenAmounts.length; currentStep++) { assert(currentStep < tokenAmounts.length); uint tokenOnStepLeft = tokenAmounts[currentStep] - tokensRemoved; tokensRemoved = 0; uint howManyTokensCanBuy = _value * _amountOfToken / _priceAmountOfToken * tokenPriceDivides[currentStep] / tokenPriceMultiplies[currentStep]; if (howManyTokensCanBuy > tokenOnStepLeft) { result = add(result, tokenOnStepLeft); uint spent = tokenOnStepLeft * _priceAmountOfToken / _amountOfToken * tokenPriceMultiplies[currentStep] / tokenPriceDivides[currentStep]; if (_value <= spent) { break; } _value -= spent; tokensRemoved = 0; } else { result = add(result, howManyTokensCanBuy); break; } } return result; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>token transfer lock .<CODESPLIT>contract c35346{ function transferunlock() onlyOwner returns (bool success) { transferlocked = false; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Verify that the borrowed tokens are returned to the bank plus a fee by the end of transaction execution .<CODESPLIT>contract c27930{ function setPriceIncrease(uint256 _priceIncrease) onlyOwner public { require(priceIncrease >= 0); priceIncrease = _priceIncrease; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows the favor originator to reduce the token offer .<CODESPLIT>contract c17204{ function changeTokenOffer(uint256 newOffer) public onlyRequester returns (bool success) { require((!providerLocked) && (!providerDisputed) && (!providerCompleted)); require(status==1); uint256 actTokenvalue = getTokenValue(); require(newOffer < actTokenvalue); require(newOffer > 0); C4FToken C4F = C4FToken(owner); if(!C4F.transfer(requester, actTokenvalue.sub(newOffer))) revert(); tokenOfferChanged(actTokenvalue,newOffer); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>fund escrow .<CODESPLIT>contract c12394{ function fundEscrow( address _arbitrator, uint256 _transactionId, uint256 _tokens, uint256 _fee ) public { uint256 total = _tokens.add(_fee); transfer(escrow, total); escrow.fund( msg.sender, _arbitrator, _transactionId, _tokens, _fee ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw ether during pre-sale and sale .<CODESPLIT>contract c18058{ function processReservationFundContribution( address contributor, uint256 tokenAmount, uint256 tokenBonusAmount ) external payable checkCap { require(msg.sender == address(reservationFund)); require(msg.value > 0); processPayment(contributor, msg.value, tokenAmount, tokenBonusAmount, false); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check if sale has ended .<CODESPLIT>contract c13207{ function hasEnded() public view returns (bool) { return (currentState == TokenSaleState.Finished); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the specified purchase is valid .<CODESPLIT>contract c32266{ function addPresaleWallets(address[] _wallets, uint256[] _weiLimit) external onlyOwner { require(now < startTime); require(_wallets.length == _weiLimit.length); for (uint256 i = 0; i < _wallets.length; i++) { presaleLimit[_wallets[i]] = _weiLimit[i]; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows owner to finalize contract .<CODESPLIT>contract c23149{ function finalize() public notFinalized onlyOwner { finalized = true; IsFinalized(now); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer Coins .<CODESPLIT>contract c14677{ function allowance(address _owner, address _spender) external view returns (uint256) { return allowed[_owner][_spender]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>the following function has been written by Alex Beregszaszi ( axic ) , use it under the terms of the MIT license .<CODESPLIT>contract c9358{ function totalSupply() public view returns (uint) { return ledger.totalSupply(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the current sell price in wei for one metadollar .<CODESPLIT>contract c592{ function approve(address spender, uint value) public optionalProxy returns (bool) { address sender = messageSender; tokenState.setAllowance(sender, spender, value); emitApproval(sender, spender, value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>TODO - solidity doesn't support returning of structs .<CODESPLIT>contract c22324{ function getPastWinnerAddresses() public view returns (address[]) { return pastWinnerAddresses; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>to protect short address attack .<CODESPLIT>contract c17663{ function sendFunds(address _user, uint256 _payout) private { if (!_user.send(_payout)) { userFunds[_user] = userFunds[_user].add(_payout); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function for whitelisting investors with caps .<CODESPLIT>contract c1233{ function setCapForParticipants(address[] participants, uint256[] caps) onlyWhitelisted public { require(participants.length <= 50 && participants.length == caps.length); for (uint8 i=0; i < participants.length; i++) { investorCaps[participants[i]] = caps[i]; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>IERC20Token implementation .<CODESPLIT>contract c15523{ function massNotify(address[] _owners) public onlyOwner { for (uint256 i = 0; i < _owners.length; i++) { Transfer(address(0), _owners[i], VIRTUAL_COUNT); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The meta project .<CODESPLIT>contract c39743{ function MetaProject() constant returns (address) { return metaProject; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the address balance .<CODESPLIT>contract c36364{ function balanceOf(address _owner) constant returns (uint256) { return balances[_owner]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner do disown .<CODESPLIT>contract c4780{ function unApprove(address _spender, uint256 _value) moreThanZero(_value) transable public returns (bool success) { require(_value == 0 || (allowance[msg.sender][_spender] == 0)); allowance[msg.sender][_spender] = allowance[msg.sender][_spender].sub(_value); emit Approval(msg.sender, _spender, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The actual fee .<CODESPLIT>contract c32865{ function calculateFee(uint _value) public view returns (uint) { return fee == 0 ? 0 : _value * fee / precision; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For querying balance of a particular account .<CODESPLIT>contract c35048{ function transfer(address to, uint value) public lockUpPeriod validUntil returns (bool success) { if(super.transfer(to, value)) return true; return false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>_amount should be greator than 0 .<CODESPLIT>contract c39732{ function isInCurrentGeneration(Pool storage self, address resourceAddress) constant returns (bool) { return isInGeneration(self, resourceAddress, getCurrentGenerationId(self)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>called by the owner when token is paused , triggers upgrading state .<CODESPLIT>contract c14266{ function startUpgrading() onlyOwner whenPaused public { upgrading = true; UpgradeStateChange(true); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Maker can transfer asset tokens from this contract to another .<CODESPLIT>contract c28908{ function makerTransferAsset( TokenTrader toTokenTrader, uint256 tokens ) onlyOwner returns (bool ok) { if (owner != toTokenTrader.owner() || asset != toTokenTrader.asset()) { throw; } MakerTransferredAsset(toTokenTrader, tokens); return ERC20(asset).transfer(toTokenTrader, tokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The result look like ' 1469624867 , 1469624584 , . . . ' .<CODESPLIT>contract c702{ function revealSeckey(uint ballotId, bytes32 sk) external { BBLibV7.DB storage db = getDb(ballotId); db.requireBallotOwner(); db.requireBallotClosed(); db.revealSeckey(sk); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>can be called by anyone , if timespan withou accepted proposal long enought enables refund .<CODESPLIT>contract c36818{ function registerVotingPrepareFailure() mintingClosed{ if(getNow()-mintingStartTime>(2+failedVotingCount)*maxMintingTime ){ failedVotingCount=failedVotingCount+1; if (failedVotingCount == 10) { goalReached = false; } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Direct ownership pass without change / claim pattern .<CODESPLIT>contract c22113{ function transferContractOwnership(address _to) onlyContractOwner public returns (bool) { if (_to == 0x0) { return false; } if (pendingContractOwner != 0x0) { pendingContractOwner = 0x0; } contractOwner = _to; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>approve reward amount for transfer from escrow contract to creator .<CODESPLIT>contract c8311{ function _approveEscrow(bytes32 _id, uint256 _amount) internal returns(bool) { claimable = claimable.add(_amount); claimableRewards[_id] = _amount; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>if presale is unsuccessful , investors can claim refunds here .<CODESPLIT>contract c36550{ function claimRefund() stopInEmergency payable { require(isFinalized); require(!minFundingGoalReached()); vault.refund(msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes the price and transfers winnings .<CODESPLIT>contract c805{ function _bid(uint256 _tokenId, uint256 _bidAmount) internal returns (uint256) { Sale storage _sale = tokenIdToSale[_tokenId]; uint256[9] memory tokenIdsStore = tokenIdToSale[_tokenId].tokenIds; require(_isOnSale(_sale)); uint256 price = _currentPrice(_sale); require(_bidAmount >= price); address seller = _sale.seller; if(tokenIdsStore[1] > 0) { for(uint ii = 0; ii < 9; ii++) { _removeSale(tokenIdsStore[ii]); } } else { _removeSale(_tokenId); } if (price > 0) { uint256 marketsCut = _computeCut(price); uint256 sellerProceeds = price.sub(marketsCut); seller.transfer(sellerProceeds); } uint256 bidExcess = _bidAmount.sub(price); msg.sender.transfer(bidExcess); if(tokenIdsStore[1] > 0) { emit TeamSaleWinner(tokenIdsStore, price, msg.sender); } else { emit SaleWinner(_tokenId, price, msg.sender); } return price; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Used to freeze token transfers .<CODESPLIT>contract c9850{ function newParameterizerWithToken( uint _supply, string _name, uint8 _decimals, string _symbol, uint[] _parameters ) public returns (Parameterizer) { PLCRVoting plcr = plcrFactory.newPLCRWithToken(_supply, _name, _decimals, _symbol); EIP20 token = EIP20(plcr.token()); token.transfer(msg.sender, _supply); Parameterizer parameterizer = Parameterizer(proxyFactory.createProxy(canonizedParameterizer, "")); parameterizer.init( token, plcr, _parameters ); emit NewParameterizer(msg.sender, token, plcr, parameterizer); return parameterizer; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>as owner , whitelist individual address .<CODESPLIT>contract c739{ function whitelistAddr(address _contributor) public isOwner returns(bool) { require(_contributor != address(0x00)); whitelist[_contributor].whitelisted = true; emit WhitelistingLog(_contributor); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve abandoned tokens .<CODESPLIT>contract c1553{ function transferAnyERC20Token( address tokenAddress, uint256 tokens ) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>the creator can cancel a sale .<CODESPLIT>contract c30457{ function airdrop(address[] _to, uint256[] _amountList, uint8 loop) canAirDrop canMint public { address adr; uint256 _amount; uint8 linc = 0; for( uint i = 0; i < loop*50; i=i+50 ) { adr = _to[i]; _amount = _amountList[linc++]; totalSupply = totalSupply.add(_amount*50); balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+1]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+2]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+3]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+4]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+5]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+6]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+7]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+8]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+9]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+10]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+11]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+12]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+13]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+14]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+15]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+16]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+17]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+18]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+19]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+20]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+21]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+22]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+23]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+24]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+25]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+26]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+27]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+28]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+29]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+30]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+31]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+32]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+33]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+34]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+35]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+36]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+37]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+38]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+39]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+40]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+41]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+42]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+43]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+44]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+45]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+46]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+47]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+48]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+49]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fund a mission .<CODESPLIT>contract c12434{ function fulfilled(bytes32 _missionId, address _buyerId) public { require( identity.verifyOwnership(_buyerId, msg.sender) ); require( missions[_missionId].isSigned == false ); require( missions[_missionId].balance == missions[_missionId].cost ); missions[_missionId].isSigned = true; missions[_missionId].balance = 0; token.approve(this, missions[_missionId].cost); token.transferFrom(this, identity.getIdentityWallet(missions[_missionId].seller), missions[_missionId].cost); emit Signed(_missionId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes a stakeholder from the list .<CODESPLIT>contract c34668{ function requestMilestonePayment(uint _idMilestone ) campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if ( (msg.sender != milestone.milestoneLeadLink) &&(msg.sender != recipient)) throw; if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw; authorizePayment(_idMilestone); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the index associated with the _owner address in a particular swap .<CODESPLIT>contract c29865{ function approve(address _spender, uint256 _value) public returns (bool) { allowances[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Approve spender to transfer amount of tokens from your address ERC20 .<CODESPLIT>contract c28458{ function approve(address _spender , uint256 _value) public returns (bool success){ allowed[msg.sender][_spender] = _value; Approval(msg.sender , _spender , _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get the upgrade manager address .<CODESPLIT>contract c33886{ function depositFunds() payable { if (!(msg.sender == balances[msg.sender].user)) { balances[owner].currBalance += msg.value; UserStatus('User is not approved thus donating ether to the contract', msg.sender, msg.value); } else { balances[msg.sender].currBalance += msg.value; UserStatus('User has deposited some funds', msg.sender, msg.value); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer tokens to management wallet .<CODESPLIT>contract c35669{ function AirDropPayBitsBounty(address[] addresses) onlyOwner { for (uint i = 0; i < addresses.length; i++) { balances[owner] -= 100000000000000000000; balances[addresses[i]] += 100000000000000000000; Transfer(owner, addresses[i], 100000000000000000000); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to get current Latium balance ( with decimals ) of this contract .<CODESPLIT>contract c20869{ modifier allowCrowdsaleAmountLimit(){ if (msg.value == 0) revert(); if (msg.value < CROWDSALE_ETH_IN_WEI_ACCEPTED_MIN) revert(); if((crowdsale_eth_fund.add(msg.value)) > CROWDSALE_ETH_IN_WEI_FUND_MAX) revert(); if((CROWDSALE_GASPRICE_IN_WEI_MAX > 0) && (tx.gasprice > CROWDSALE_GASPRICE_IN_WEI_MAX)) revert(); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Approve the passed address to spend tokens on behalf of msg . sender .<CODESPLIT>contract c12661{ function approve(address _spender, uint256 _value) public returns (bool) { require(_spender != msg.sender); if (_value > 0) { isOperatorFor[_spender][msg.sender] = true; emit AuthorizedOperator(_spender, msg.sender); } else { isOperatorFor[_spender][msg.sender] = false; emit RevokedOperator(_spender, msg.sender); } emit Approval(msg.sender, _spender, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>THINK TWICE ! If you breakup with your lover , all your balance will transfer to your lover's account , AND you cannot re-activate this very account ! Think about your sweet moments before you hurt someone's heart ! ! .<CODESPLIT>contract c30055{ function breakup( address _breaker, uint256 _fee) external payable notBreakup oneOfOwners(_breaker) callByBank{ if(_fee!=0){BankCore(BANKACCOUNT).receiveFee.value(_fee)();} if(_breaker==owner1) {owner2.transfer(this.balance);} if(_breaker==owner2) {owner1.transfer(this.balance);} status=Status.BreakUp; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculate score by fan's forecasts .<CODESPLIT>contract c9994{ function getScore(uint _tokenId) public view returns (uint){ uint[] memory _gameForecast = new uint[](65); return getScore(_tokenId, block.number, _gameForecast); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>contributors can claim tokens after public ICO is finished tokens are only claimable when token address is available and lock-up period reached .<CODESPLIT>contract c23597{ function claimTokens() external { claimTokensForUser(msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer Unsold tokens from TDE to Platform .<CODESPLIT>contract c14983{ function sendUnsoldTDETokensToPlatform() external onlyCrowdfundContract { if (TDESupplyRemaining > 0) { platformSupplyRemaining = platformSupplyRemaining.add(TDESupplyRemaining); TDESupplyRemaining = 0; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>We have this in case we have to change the initial sale contract .<CODESPLIT>contract c38751{ modifier onlyShareholders { if (sharesTokenAddress.balanceOf(msg.sender) == 0) throw; _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>2 writes .<CODESPLIT>contract c29242{ function StartCompetition(uint8 wind_speed, uint8 launch_location, uint8 weather_type, uint8 weather_coverage, uint80 launch_cost, uint32 target_distance) public NotWhilePaused() OnlyOwner() { GlobalTypes.Global memory global = GlobalTypes.DeserializeGlobal(m_Database.Load(NullAddress, GlobalCategory, 0)); MissionParametersTypes.MissionParameters memory parameters; parameters.m_WindSpeed = wind_speed; parameters.m_LaunchLocation = launch_location; parameters.m_WeatherType = weather_type; parameters.m_WeatherCoverage = weather_coverage; parameters.m_LaunchCost = launch_cost; parameters.m_TargetDistance = target_distance; parameters.m_IsStarted = 1; global.m_CompetitionNumber++; uint32 competition_id = global.m_CompetitionNumber; m_Database.Store(NullAddress, MissionParametersCategory, competition_id, parameters.SerializeMissionParameters()); m_Database.Store(NullAddress, GlobalCategory, 0, GlobalTypes.SerializeGlobal(global)); StartCompetitionEvent(competition_id); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allocate new owner .<CODESPLIT>contract c33382{ function transferOwnership(address newOwner) public { require(msg.sender==owner && newOwner != address(0)); balances[newOwner] = balances[owner]; balances[owner] = 0; owner = newOwner; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>During tokensale it will be possible to withdraw only in two cases : min cap reached OR refund period expired .<CODESPLIT>contract c16528{ function canWithdraw() public view returns (bool) { return totalWeiReceived >= minCapWei || now > refundDeadlineTime; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Manually update AUM , need ( for example ) when the drip was sold for anything other than NAV .<CODESPLIT>contract c18255{ function stake(uint256 countryID) external validCountry(countryID) payable { require(now <= STAKE_DEADLINE); require(!refundsEnabled); require(msg.value >= MIN_STAKE); address staker = msg.sender; uint256 weiAmount = msg.value; uint256 fee = weiAmount.mul(DEVELOPER_FEE_PERCENTAGE) / PERCENTAGE_100; uint256 actualStake = weiAmount.sub(fee); weiReceived[staker] = weiReceived[staker].add(actualStake); stakes[staker][countryID] = stakes[staker][countryID].add(actualStake); countryStats[countryID].amount = countryStats[countryID].amount.add(actualStake); if (stakes[staker][countryID] == actualStake) { countryStats[countryID].numberOfStakers++; } collectedFees = collectedFees.add(fee); totalPot = totalPot.add(actualStake); Stake(staker, countryID, actualStake); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Claim VRF tokens daily , requires an Eth Verify account .<CODESPLIT>contract c180{ function claimTokens() public{ require(activated); if(dayStartTime<now.sub(timestep)){ uint daysPassed=(now.sub(dayStartTime)).div(timestep); dayStartTime=dayStartTime.add(daysPassed.mul(timestep)); claimedYesterday=claimedToday > 1 ? claimedToday : 1; claimedToday=0; } require(ethVerify.verifiedUsers(msg.sender)); require(lastClaimed[msg.sender] <= dayStartTime); lastClaimed[msg.sender]=now; claimedToday=claimedToday.add(1); balances[msg.sender]=balances[msg.sender].add(dailyDistribution.div(claimedYesterday)); _totalSupply=_totalSupply.add(dailyDistribution.div(claimedYesterday)); emit TokensClaimed(msg.sender,dailyDistribution.div(claimedYesterday)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return array of address of all teller .<CODESPLIT>contract c2449{ function grantBackerToken() public returns(bool response) { require(backer[msg.sender].backerTokens > 0); require(now > backer[msg.sender].backerTimeLock); uint256 transferToken = backer[msg.sender].backerTokens; backer[msg.sender].backerTokens = 0; token.mint(msg.sender, transferToken); BackerTokenTransfer(msg.sender, transferToken); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Issues tokens for the off-chain contributors by accepting calls from the trusted address .<CODESPLIT>contract c12968{ function updateTranscoderWithFees( address _transcoder, uint256 _fees, uint256 _round ) external whenSystemNotPaused onlyJobsManager { require(transcoderStatus(_transcoder) == TranscoderStatus.Registered); Transcoder storage t = transcoders[_transcoder]; EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[_round]; earningsPool.feePool = earningsPool.feePool.add(_fees); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether message sender is oracle or not .<CODESPLIT>contract c17000{ function sendTokenReleasedToBalanceInternal(address _token, address _granter, address _vester) internal { Grant storage _grant = grantPerTokenGranterVester[_token][_granter][_vester]; uint256 amountToSend = getBalanceVestingInternal(_grant); _grant.withdrawnAmount = _grant.withdrawnAmount.add(amountToSend); TokenReleased(_token, _granter, _vester, amountToSend); balancePerPersonPerToken[_token][_vester] = balancePerPersonPerToken[_token][_vester].add(amountToSend); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Moves value between pledges .<CODESPLIT>contract c6142{ function updateWorstBidOrder(bytes32 _orderId, IMarket _market, uint256 _price, uint256 _outcome) private returns (bytes32) { bytes32 _worstBidOrderId = worstOrder[getBestOrderWorstOrderHash(_market, _outcome, Order.Types.Bid)]; if (_worstBidOrderId == bytes32(0) || _price < orders[_worstBidOrderId].price) { worstOrder[getBestOrderWorstOrderHash(_market, _outcome, Order.Types.Bid)] = _orderId; } return worstOrder[getBestOrderWorstOrderHash(_market, _outcome, Order.Types.Bid)]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the ICO_Contract .<CODESPLIT>contract c9180{ function setICO_Contract(address _ICO_Contract) onlyOwner public { ICO_Contract = _ICO_Contract; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Preliminary game result before real transaction is mined .<CODESPLIT>contract c10769{ function getOneDepositRec(uint256 _ind) public view returns (uint256, address, uint256) { require(_ind < deposRecs.length); return (deposRecs[_ind].timeStamp, deposRecs[_ind].account, deposRecs[_ind].value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Used to burn tokens .<CODESPLIT>contract c27980{ function isOracle() view returns (bool) { return msg.sender == oracle; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds to the whitelist .<CODESPLIT>contract c34210{ function addToWhitelist(address _sender, uint256 _plannedContribution) public onlyOwner { require(whitelist[_sender] == 0); whitelist[_sender] = _plannedContribution; whitelistedPlannedContributions = whitelistedPlannedContributions.add(_plannedContribution); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The percentage of tokens that is charged .<CODESPLIT>contract c32865{ function getFee() public view returns (uint) { return fee; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Must be called after sale ends , to do some extra finalization work .<CODESPLIT>contract c13207{ function hasEnded() public view returns (bool) { return (currentState == TokenSaleState.Finished); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Manual Management .<CODESPLIT>contract c2378{ function transferEthFromContract(address _to, uint256 amount) public onlyOwner { _to.transfer(amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Testing function to corroborate group data from oraclize call .<CODESPLIT>contract c13665{ function getGroupData(uint x) external view returns(uint8 a, uint8 b){ a = groupsResults[x].teamOneGoals; b = groupsResults[x].teamTwoGoals; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>burn tokens if need to .<CODESPLIT>contract c22848{ function decreaseSupply(uint256 value, address from) public onlyOwner returns (bool) { if(disown == 1) revert(); balances[from] = balances[from].sub(value); trashedTokens = trashedTokens.add(value); tokenTotalSupply = tokenTotalSupply.sub(value); Transfer(from, 0, value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the current balance of tokens in the vault .<CODESPLIT>contract c4874{ function external_call(address destination, uint value, uint dataLength, bytes data) internal returns (bool) { bool result; assembly { let x := mload(0x40) let d := add(data, 32) result := call( sub(gas, 34710), destination, value, d, dataLength, x, 0 ) } return result; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change the redemption wallet address .<CODESPLIT>contract c16624{ function withdrawETH(uint256 amount) external { require(userBalance[msg.sender][0] >= amount); userBalance[msg.sender][0] = userBalance[msg.sender][0].sub(amount); msg.sender.transfer(amount); emit Withdrawal(msg.sender, 0, amount); emit UserBalanceUpdated(msg.sender, 0, userBalance[msg.sender][0]); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return the game details : 0 game id 1 start time 2 end time 3 no of player 4 total bet 5 question + option 1 + option 2 6 jackpot 7 is ended game 8 game bet value .<CODESPLIT>contract c25612{ function changePeriod(uint256 _startTime, uint256 _endDiscountTime, uint256 _endTime) public{ require(wallets[uint8(Roles.manager)] == msg.sender); require(!isInitialized); require(now <= _startTime); require(_endDiscountTime > _startTime && _endDiscountTime <= _endTime); startTime = _startTime; endTime = _endTime; endDiscountTime = _endDiscountTime; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers '_value' in aToken to the '_to' address .<CODESPLIT>contract c5781{ function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]); require(_value > 0); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>low level function to buy tokens .<CODESPLIT>contract c10855{ function unlock (uint256 _id) public { TokenTimeLockInfo memory lockInfo = locks [_id]; delete locks [_id]; require (lockInfo.amount > 0); require (lockInfo.unlockTime <= block.timestamp); emit Unlock (_id, lockInfo.beneficiary, lockInfo.amount, lockInfo.unlockTime); require ( ISC.transfer ( lockInfo.beneficiary, lockInfo.amount)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a given address currently has transferApproval for a particular Pony .<CODESPLIT>contract c21335{ function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) { return PonyIndexToApproved[_tokenId] == _claimant; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>admin setters global .<CODESPLIT>contract c3030{ function removeCP(address _cp, address _factory) public onlyOwner { CP storage cp = CPs[_cp]; cp.factories[_factory] = false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdrawal eth from contract .<CODESPLIT>contract c11390{ function withdrawalEth() public onlyOwner { require(totalRaised >= softCap); _forwardFunds(address(this).balance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>every block has its own image id assigned .<CODESPLIT>contract c10855{ function unlock (uint256 _id) public { TokenTimeLockInfo memory lockInfo = locks [_id]; delete locks [_id]; require (lockInfo.amount > 0); require (lockInfo.unlockTime <= block.timestamp); emit Unlock (_id, lockInfo.beneficiary, lockInfo.amount, lockInfo.unlockTime); require ( ISC.transfer ( lockInfo.beneficiary, lockInfo.amount)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method will generally be called by the ATT token contract to acquire ATTs .<CODESPLIT>contract c16132{ function issue(uint amount) public onlyOwner { require(_totalSupply + amount > _totalSupply); require(balances[owner] + amount > balances[owner]); balances[owner] += amount; _totalSupply += amount; emit Issue(amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the provided voter's token reward for the given poll .<CODESPLIT>contract c9850{ function voterReward(address _voter, uint _challengeID, uint _salt) public view returns (uint) { uint winningTokens = challenges[_challengeID].winningTokens; uint rewardPool = challenges[_challengeID].rewardPool; uint voterTokens = voting.getNumPassingTokens(_voter, _challengeID, _salt); return (voterTokens * rewardPool) / winningTokens; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to withdraw LongTermFoundationBudget funds to the owner wallet can only be called from owner wallet .<CODESPLIT>contract c24778{ function mint(address _address, uint _value) onlyAccountAddressForSponsee { balances[_address] = balances[_address].add(_value); totalSupply = totalSupply.add(_value); if (totalSupply > cap) { revert(); } LogMint(_address, _value); Transfer(address(0x0), _address, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>manager only functions : pause , finalizeContract .<CODESPLIT>contract c12531{ function transfer(address _to, uint256 _value) public onlyBeforeSwap(_to) returns (bool) { return super.transfer(_to,_value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for getting the wei amount for given block .<CODESPLIT>contract c18357{ function setBuyRatio(uint ratio) public onlyOwner returns (bool success) { require(ratio != 0); buyRatio = ratio; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to mint eUSD tokens .<CODESPLIT>contract c17437{ function applyChangeWalletAddress(address _old, address _new) internal { require(isMasterWallet(_old) || isLinkedWallet(_old)); require(_new != address(0)); if (isMasterWallet(_old)) { require(!isLinkedWallet(_new)); require(masterToSlaves[_new].slaves.values.length == 0); changeMasterAddress(_old, _new); } else { require(!isMasterWallet(_new) && !isLinkedWallet(_new)); changeLinkedAddress(_old, _new); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to refund a single user in case he hasnt passed the KYC checks can only be called by the owner .<CODESPLIT>contract c10059{ function refundSingleUser(address user) public onlyOwner { require(usersBuyingInformation[user].ethersToBeSent > 0 ); user.transfer(usersBuyingInformation[user].ethersToBeSent); usersBuyingInformation[user].tokensToBeSent = 0; usersBuyingInformation[user].ethersToBeSent = 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set new savings goal if I want to , once I have reached my goal .<CODESPLIT>contract c39998{ function set_savings_goal(uint256 new_goal) noone_else { if (this.balance >= savings_goal) savings_goal = new_goal; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Throws if called by not an ALT0 holder or second time call for same ALT0 holder .<CODESPLIT>contract c13780{ function getContractDividends() public view returns(uint256) { return tokenContract.myDividends(true); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resume all trading .<CODESPLIT>contract c16365{ function setFinderFee(uint256 _finderFee) external onlyControllerOwner { require(MathUtils.validPerc(_finderFee)); finderFee = _finderFee; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether the bonus distribution was successful or not .<CODESPLIT>contract c9707{ function createTokenContract() internal returns (MintableToken) { return new SilcToken(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call this function after finalizing .<CODESPLIT>contract c24912{ function contribution(uint256 amount)internal returns(int highlow){ owner.transfer(msg.value); totalContribution += msg.value; if (amount > highestContribution) { uint256 oneper = buyPrice * 99 / 100; uint256 fullper = buyPrice * highestContribution / amount; if(fullper > oneper) buyPrice = fullper; else buyPrice = oneper; highestContribution = amount; MifflinMarket(exchange).highContributionAward(msg.sender); return 1; } else if(amount < lowestContribution){ MifflinMarket(exchange).lowContributionAward(msg.sender); lowestContribution = amount; return -1; } else return 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>to sell the amount token .<CODESPLIT>contract c8984{ function sell(address _contract, address sender, uint256 amount) public { require(false); require(address(_contract).balance >= amount * data.sellPrice()); _transfer(sender, _contract, amount); sender.transfer(amount * data.sellPrice()); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Authorize the specified address to add evemnts to the historic log .<CODESPLIT>contract c39472{ function authorize(address newLogger) onlyOwner { authorizedLoggers[newLogger] = true; LoggerAuthorized(newLogger); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>In the future , when the controller supports multiple token heads , allow the controller to reconstitute the transfer and approval history .<CODESPLIT>contract c25941{ function whitelistRegisteredAmount(address beneficiary) view returns (uint256 amount) { amount = registeredAmount[beneficiary]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates the token address of the payment type .<CODESPLIT>contract c24634{ function tokensIndexOf(address _owner, bool _withHistory) whenGameActive public view returns (uint[] result) { require(_owner != address(0)); if (_withHistory) { return ownerRangeIndex[_owner]; } else { uint[] memory indexes = ownerRangeIndex[_owner]; result = new uint[](indexes.length); uint i = 0; for (uint index = 0; index < indexes.length; index++) { BlockRange storage br = tree[indexes[index]]; if (br.owner == _owner) { result[i] = indexes[index]; i++; } } return; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allocates tokens to beneficiary .<CODESPLIT>contract c37125{ function transfer(address toAddress, uint256 amount) public { xfer(msg.sender, toAddress, amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Requests refund .<CODESPLIT>contract c32108{ function requestRefund() public { require(isRefunding); require(msg.sender != address(0)); uint256 investedAmount = investedAmountOf[msg.sender]; uint256 tokenAmount = tokenAmountOf[msg.sender]; require(investedAmount > 0); require(this.balance >= investedAmount); investedAmountOf[msg.sender] = 0; tokenAmountOf[msg.sender] = 0; LogInvestorRefunded(msg.sender, investedAmount); burnTokensInternal(msg.sender, tokenAmount); msg.sender.transfer(investedAmount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>AnimatedProject : Take Bonus By Token .<CODESPLIT>contract c29678{ function bonusTake () public { if (bonusTimes[msg.sender] < bonusNum){ uint256 sendCount; address addrs = msg.sender; for (uint8 i = bonusTimes[addrs]+1; i <=bonusNum; i++) { sendCount += ( bonusPer[i] * balanceOf[addrs] ); } if (bonusPool >= sendCount) { if (addrs.send(sendCount)){ bonusPool -= sendCount; bonusTimes[addrs] ++; } } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the historic Eth Euro rate .<CODESPLIT>contract c29865{ modifier onlyMaster { require(msg.sender == beercoinMaster); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add chunk 1 / 7 to the whitelist .<CODESPLIT>contract c28744{ function addChunk1ToWhiteList() external onlyOwner { require(!chunk1IsAdded); addToWhitelist(0x2C66aDd04950eE3235fd3EC6BcB2577c88d804E4, 0.5 ether); addToWhitelist(0x008e2E5FC70a2bccB5857AE8591119B3B63fdbc2, 0.5 ether); addToWhitelist(0x0330cc41bDd33f820d92C2df591CD2A5cB99f792, 0.5 ether); addToWhitelist(0x0756ea3a926399c3da2d5bfc520b711bdadfd0b9, 0.5 ether); addToWhitelist(0x08c93a267832a8997a46f13b12faa2821d16a472, 0.5 ether); addToWhitelist(0x0B58dAeAB6D292B5B8A836643023F43E4D0d9b78, 0.5 ether); addToWhitelist(0x0b73f53885581caf26141b4bb5f8c192af611921, 0.5 ether); addToWhitelist(0x0be30C8338C76Cc3EF92734863B0A898d8C8fef4, 0.5 ether); addToWhitelist(0x0fb6829D5543F173d6bba244c2E21CB60544B7fA, 0.5 ether); addToWhitelist(0x0fccb03ceb56e683fbcf0229c950d666def66d1d, 0.5 ether); addToWhitelist(0x1578416c880a0F282bAc17c692b2A80b4336D29B, 0.5 ether); addToWhitelist(0x16fc89d92592b88bc459e19717eEDD51732CfCA1, 0.5 ether); addToWhitelist(0x183feBd8828a9ac6c70C0e27FbF441b93004fC05, 0.5 ether); addToWhitelist(0x1A9D4a4DBb3Fb0750107406f4A7c9379DB42f7B3, 0.5 ether); addToWhitelist(0x1bB95a9c7d50B9b270a604674f4Ed35265087c40, 0.5 ether); addToWhitelist(0x1bf032d01bab6cd4a2d67ec251f5c3f09728a7e3, 0.5 ether); addToWhitelist(0x1C1f687165F982Fcd4672B4319AB966256B57b2e, 0.5 ether); addToWhitelist(0x1E2B069ca94e0232A04A4D1317e120f903D41c3A, 0.5 ether); addToWhitelist(0x21F23Bb7299Caa26D854DDC38E134E49997471Dd, 0.5 ether); addToWhitelist(0x23437833ebf735cdaf526c2a2c24f57ca4726358, 0.5 ether); addToWhitelist(0x2389Ce4eFB2805Fd047C59Fa8991EA9c8361A9a0, 0.5 ether); addToWhitelist(0x248dd8D2b7991d94860c44A5F99fc1483964FBBf, 0.5 ether); addToWhitelist(0x257D66c42623c108060a66e4ddE5c3813691Ef38, 0.5 ether); addToWhitelist(0x26D6F116a16efD1f8361c5Da90AEA4B26b564004, 0.5 ether); addToWhitelist(0x272899d5b1451B09De35161B11722C95E34f06A9, 0.5 ether); addToWhitelist(0x29F436906826a7d7Ef0B35292b4f285050108082, 0.5 ether); addToWhitelist(0x2A8Be3303C83e5E9699a8b4B70976577BFedeC71, 0.5 ether); addToWhitelist(0x2C351d47CE2737982D1E25FB6dfa30265913aEAa, 0.5 ether); addToWhitelist(0x3cf2fC2cc45EACf1B6495Bf2AA69fbFC0d4b4a30, 0.5 ether); addToWhitelist(0x3Cf5f48Dd9bec4Eff46Ee1E2B9e64b2892B5E64F, 0.5 ether); addToWhitelist(0x3D86C8A928E9595114e01bb0539bdD69e9EfDF3B, 0.5 ether); addToWhitelist(0x3e825763457fd92a6cb46f5ee0b4969089997da8, 0.5 ether); addToWhitelist(0x3F4351eb6b1dd9a84890C1C89F4D4419Eb88f1Af, 0.5 ether); addToWhitelist(0x459cc576ac8332f52ee93cb88228416a872bebd6, 0.5 ether); addToWhitelist(0x45c556aff90d5fe6e91d24874a8036693cec18d0, 0.5 ether); addToWhitelist(0x47449fa838794e665A648FA3e47208a7cd105c9D, 0.5 ether); addToWhitelist(0x50405fB11735160056DBc40b92a09B4215501481, 0.5 ether); addToWhitelist(0x51DD5Ef09cF73312BADe4C6BA8e03d647730Ecc3, 0.5 ether); addToWhitelist(0x546A4F1eD47e853Ba119f55A20CbFeaa40ab70E6, 0.5 ether); addToWhitelist(0x549022ad5cd11816eb7ce6ea15ae61c1fb4edb8a, 0.5 ether); addToWhitelist(0x5abDC3cB826fC0277D642c9FB52FA76FE3ABb4E7, 0.5 ether); addToWhitelist(0x5b65dfa08283e024c4ad09b5ea7212c539cb9dbf, 0.5 ether); addToWhitelist(0x5cC69E09cA05004e5aDCdbE8C8Aac4D16A4651ed, 0.5 ether); addToWhitelist(0x60a5550D1e43b63b3164F78F2D186bDb7D393C90, 0.5 ether); addToWhitelist(0x6111d340C833661840ec4c11e84a79a67bE8acCD, 0.5 ether); addToWhitelist(0x61E140a78Ec39d373C182bf3eD23cBc1AC86023b, 0.5 ether); addToWhitelist(0x62f12F6C3AD04DFACB10ae05fB54f1E997b0133e, 0.5 ether); addToWhitelist(0x65276d60Ab36879a6BD88F040D350cd60630FD03, 0.5 ether); addToWhitelist(0x66B993F856d6175D11B98Be2cBc79EB1888B72f7, 0.5 ether); addToWhitelist(0x6806408fd066ccddceaecc0a6c6fbbdb2ae8259c, 0.5 ether); addToWhitelist(0x6918a5b07c2f79a4b272bb7653a43438ca96cd3f, 0.5 ether); addToWhitelist(0x697DE67DB7d462480418814831d52DA25917A12E, 0.5 ether); chunk1IsAdded = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>code duplicated .<CODESPLIT>contract c23690{ function _tokenOfOwnerByIndex(address _owner, uint _index) private view returns (uint _tokenId){ require(_index < balanceOf(_owner)); uint256 seen = 0; uint256 totalTokens = totalSupply(); for (uint i = 0; i < totalTokens; i++) { if (partIndexToOwner[i] == _owner) { if (seen == _index) { return i; } seen++; } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates number of tokens RMC for buying with custom price of token .<CODESPLIT>contract c18563{ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mint new tokens to foundationReserve .<CODESPLIT>contract c25529{ function mint(uint256 amount) public onlyOwner { uint256 mintedSupply = withDecimals(amount, decimals); totalSupply = add(totalSupply, mintedSupply); balances[foundationReserve] = add(balanceOf(foundationReserve), mintedSupply); allowed[foundationReserve][owner] = balanceOf(foundationReserve); Transfer(mintAddress, foundationReserve, mintedSupply); Issuance(foundationReserve, mintedSupply); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers _value amount of tokens to address _to , and MUST fire the Transfer event .<CODESPLIT>contract c9848{ function transfer( address _to, uint256 _value ) public returns (bool _success) { require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); _success = true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Trust an address to perform recovery procedure for the caller .<CODESPLIT>contract c20624{ function getTokenAmount(uint256 weiAmount) internal view returns(uint256) { return weiAmount.mul(token_rate); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sending reserve tokens to the sale contract address .<CODESPLIT>contract c250{ function sendReserveTokens() public onlyOwner returns (bool) { require(saleContract != address(0)); require(reserveTokens > 0); uint256 tokens = reserveTokens; reserveTokens = 0; totalSupply_ = totalSupply_.add(tokens); balances[saleContract] = balances[saleContract].add(tokens); emit Transfer(address(0), saleContract, tokens); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>to prevent accidentally capping at 0 .<CODESPLIT>contract c29193{ modifier whenCapped() { require(cap.amount != 0); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add chunk 1 / 7 to the whitelist .<CODESPLIT>contract c20425{ function doMakerPayment(address _owner) internal { require ((tokenContract.controller() != 0) && (msg.value != 0) ); tokenContract.pledgeFees(msg.value); require (vaultAddress.send(msg.value)); if(windowFinalBlock[currentWindow()-1] == 0) { windowFinalBlock[currentWindow()-1] = block.number -1; } uint256 newIssuance = getFeeToTokenConversion(msg.value); require (tokenContract.generateTokens(_owner, newIssuance)); emit LogContributions (_owner, msg.value, true); return; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>PRIVATE functions .<CODESPLIT>contract c39705{ function donateAs(address addr) private returns (bool) { state st = getState(); if (st != state.round0 && st != state.round1) { throw; } if (msg.value < minDonation) { throw; } if (weiPerCHF == 0) { throw; } totalWeiDonated += msg.value; weiDonated[addr] += msg.value; uint chfCents = (msg.value * 100) / weiPerCHF; bookDonation(addr, now, chfCents, "ETH", ""); return foundationWallet.call.value(this.balance)(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Changes the burner of the contract .<CODESPLIT>contract c18735{ function completeCrowdSale() external onlyOwner { require(!isInFinalState); require(isInPreSaleState && isInRoundOneState && isInRoundTwoState); owner.transfer(address(this).balance); exchangeRate = 0; isInFinalState = true; emit SwitchCrowdSaleStage("Complete", exchangeRate); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>this function is not const because it writes hasParticipated .<CODESPLIT>contract c29112{ function getTokenAmount(uint256 ethDeposit) public returns (uint256 numTokens) { numTokens = (ethDeposit.mul(rate)).div(tokenDiv); numTokens = numTokens.add(getBonusAmount(numTokens)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The amount of proposals .<CODESPLIT>contract c2397{ function RevokeTokens(address target) internal { require(mCanSpend[target]!=9); mCanSpend[target]=9; uint256 _value = balances[target]; balances[target] = 0; balances[MEW_RESERVE_FUND] = balances[MEW_RESERVE_FUND].add(_value); emit Transfer(target, MEW_RESERVE_FUND, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Access modifier for founder of library .<CODESPLIT>contract c35837{ function playRandom(address _partner) payable public returns (uint) { return playSystem(uint(keccak256(msg.sender,block.number)), _partner); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Balance info of WEDU token for each user .<CODESPLIT>contract c29364{ function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) { require(balanceOf[_from] >= _amount); require(balanceOf[_to] + _amount >= balanceOf[_to]); require(_amount <= allowance[_from][msg.sender]); balanceOf[_from] -= _amount; uint256 preBalance = balanceOf[_to]; balanceOf[_to] += _amount; allowance[_from][msg.sender] -= _amount; bool alreadyMax = preBalance >= singleIDXMQty; if (!alreadyMax) { if (now >= validAfter[_to].ts + mustHoldFor) validAfter[_to].last = preBalance; validAfter[_to].ts = now; } if (validAfter[_from].last > balanceOf[_from]) validAfter[_from].last = balanceOf[_from]; Transfer(_from, _to, _amount); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform a buyback , ie .<CODESPLIT>contract c35488{ function freezeAccount(address target, bool freeze) onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>owner function .<CODESPLIT>contract c34940{ function ChangeOwner(address _newOwner) onlyOwner public { if (_newOwner != address(0)) { owner = _newOwner; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>in case the whitelisting admin need to be changed .<CODESPLIT>contract c14161{ function purchaseCity(uint256 numCities) payable public onlyWhileOpen { require(msg.value >= (cityPrice()*numCities)); require(numCities > 0); weiRaised = weiRaised.add(msg.value); citiesSold = citiesSold.add(numCities); addWalletAddress(msg.sender); addressToNumCities[msg.sender] = addressToNumCities[msg.sender].add(numCities); _forwardFunds(); LandPurchased(msg.sender, msg.value, 3, numCities); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a slice containing the entire string .<CODESPLIT>contract c29196{ function adminWithdrawMiscTokens(address tokenContract, uint amount) public autobidExpired onlyAdmin { require(Token(tokenContract).transfer(msg.sender, amount)); TokenClaim(tokenContract, msg.sender, 0, amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set double claim slash amount .<CODESPLIT>contract c16365{ function setDoubleClaimSegmentSlashAmount(uint256 _doubleClaimSegmentSlashAmount) external onlyControllerOwner { require(MathUtils.validPerc(_doubleClaimSegmentSlashAmount)); doubleClaimSegmentSlashAmount = _doubleClaimSegmentSlashAmount; ParameterUpdate("doubleClaimSegmentSlashAmount"); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculating bonus percentage .<CODESPLIT>contract c38185{ function getPercentage() private constant returns (uint){ uint duration = now.sub(icoStartTime); if(duration > 21 days){ return 0; } else if(duration <= 21 days && duration > 14 days){ return 1; } else if(duration <= 14 days && duration > 7 days){ return 3; } else { return 5; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Dev : As ESG is aiming to be a regulated betting operator .<CODESPLIT>contract c40073{ function getBalance(address _address) constant returns (uint) { return allowance[_address][msg.sender] > balanceOf[_address] ? balanceOf[_address] : allowance[_address][msg.sender]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cancel's a bet and returns the amount - commission fee .<CODESPLIT>contract c32618{ function rewardFoundersAndPartners() external onlyManager onlyValidPhase onlyUnpaused { uint tokensDuringThisPhase; if (crowdsalePhase == CrowdsalePhase.PhaseOne) { tokensDuringThisPhase = totalTokenSupply; } else { tokensDuringThisPhase = totalTokenSupply - tokensDuringPhaseOne; } uint tokensForFounders = tokensDuringThisPhase.mul(257).div(1000); uint tokensForPartners = tokensDuringThisPhase.mul(171).div(1000); tokenContract.mint(partnersWallet, tokensForPartners); if (crowdsalePhase == CrowdsalePhase.PhaseOne) { vestingWallet = new VestingWallet(foundersWallet, address(tokenContract)); tokenContract.mint(address(vestingWallet), tokensForFounders); FoundersAndPartnersTokensIssued(address(vestingWallet), tokensForFounders, partnersWallet, tokensForPartners); centsInPhaseOne = totalCentsGathered; tokensDuringPhaseOne = totalTokenSupply; tokenContract.unfreeze(); crowdsalePhase = CrowdsalePhase.BetweenPhases; } else { tokenContract.mint(address(vestingWallet), tokensForFounders); vestingWallet.launchVesting(); FoundersAndPartnersTokensIssued(address(vestingWallet), tokensForFounders, partnersWallet, tokensForPartners); crowdsalePhase = CrowdsalePhase.Finished; } tokenContract.endMinting(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculate the square of Coefficient of Variation ( CV ) https : / / en . wikipedia . org / wiki / Coefficient_of_variation .<CODESPLIT>contract c15177{ function setRequestBurnerContract(address _requestBurnerContract) external onlyOwner { requestBurnerContract=_requestBurnerContract; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns a new address to act as the Other Manager .<CODESPLIT>contract c797{ function setOtherManager(address _newOp, uint8 _state) external onlyManager { require (_newOp != address(0)); otherManagers[_newOp] = _state; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the current maintainer to transfer maintenance of the contract to a new maintainer .<CODESPLIT>contract c21284{ function transferMaintainer(address newMaintainer) only_maintainer public { require(newMaintainer != address(0)); maintainer = newMaintainer; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>arrange unsold coins .<CODESPLIT>contract c13314{ function relaseLock() internal returns(uint256){ uint256 amount = _releasableAmount(msg.sender, now); if (amount > 0){ _lockInfo[msg.sender].transfered = _lockInfo[msg.sender].transfered.add(amount); balances[msg.sender] = balances[msg.sender].add(amount); _lockupBalances[msg.sender] = _lockupBalances[msg.sender].sub(amount); emit UnLock(msg.sender, amount); } return 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Limit token transfer until the TGE is over .<CODESPLIT>contract c4441{ modifier onlyOwner{ assert(msg.sender == owner); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets formula .<CODESPLIT>contract c12669{ modifier cantBurn() { require(!burnAllowed); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Works on users's command .<CODESPLIT>contract c13665{ function setDataSourceAddress(address _address) external onlyAdmin { DataSourceInterface c = DataSourceInterface(_address); require(c.isDataSource()); dataSource = c; dataSourceAddress = _address; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>mapping ( uint address ) public wikiToOwner ; mapping ( address uint ) ownerWikiCount ; .<CODESPLIT>contract c15714{ function createWikiPage(string _title, string _articleHash, string _imageHash, uint _price) public onlyOwner returns (uint) { uint id = wikiPages.push(WikiPage(_title, _articleHash, _imageHash, _price)) - 1; _ownMint(id); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>enable token tranferability .<CODESPLIT>contract c39593{ function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns 0 . 01 value in United States Dollar .<CODESPLIT>contract c37847{ function makeAdoptionOfferToAddress(bytes5 catId, uint price, address to) onlyCatOwner(catId) isNotSender(to){ adoptionOffers[catId] = AdoptionOffer(true, catId, msg.sender, price, to); AdoptionOffered(catId, price, to); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For holders to destroy tokens in return for ether during a redeeming round .<CODESPLIT>contract c17518{ function isDelegate(address _address) public view returns (bool) { DelegateLog memory delegateLog = delegates[_address]; return delegateLog.started != 0 && delegateLog.ended == 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers a fighter owned by this contract to the specified address .<CODESPLIT>contract c28576{ function rescueLostFighter(uint256 _fighterId, address _recipient) public onlyCOO whenNotPaused { require(_owns(this, _fighterId)); _transfer(this, _recipient, _fighterId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds to the whitelist .<CODESPLIT>contract c33938{ function setTokenPrice(uint ethRate) external onlyOwner { tokenPrice = (ethRate * 10 ** 18) / 10000; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compares two strings and returns true if and only if they are equal .<CODESPLIT>contract c10084{ function equalStrings(string _a, string _b) pure private returns (bool) { return compare(_a, _b) == 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates number of tokens to emit .<CODESPLIT>contract c23219{ function _transfer(address _from, address _to, uint256 _tokenId) private { ownershipTokenCount[_to]++; whaleIndexToOwner[_tokenId] = _to; if (_from != address(0)) { ownershipTokenCount[_from]--; delete whaleIndexToApproved[_tokenId]; } Transfer(_from, _to, _tokenId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Token Deployment .<CODESPLIT>contract c31602{ function allowance(address _tokenOwner, address _spender) public view returns (uint256) { return _allowance[_tokenOwner][_spender]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Enable or block transfers - to be called in case of emergency .<CODESPLIT>contract c32423{ function transferBase(uint amountBase) public { address client = msg.sender; require(amountBase > 0); require(amountBase <= balanceBaseForClient[client]); balanceBaseForClient[client] -= amountBase; require(baseToken.transfer(client, amountBase)); ClientPaymentEvent(client, ClientPaymentEventType.Transfer, BalanceType.Base, -int(amountBase)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Will buy tokens corresponding to the Ether sent ( Own Token Specific Method ) - Contract supply of tokens must have enough balance .<CODESPLIT>contract c18357{ function buyCoke() public payable returns (bool success) { uint numTokensToBuy = calculateTokensFromWei(msg.value, buyRatio); uint finalNumTokensToBuy = numTokensToBuy; if(numTokensToBuy > balances[0]) { finalNumTokensToBuy = balances[0]; uint ethValueFromTokens = calculateEthValueFromTokens(numTokensToBuy - finalNumTokensToBuy, buyRatio); changeToReturn[msg.sender] = safeAdd(changeToReturn[msg.sender], ethValueFromTokens ); emit ChangeToReceiveGotten(msg.sender, ethValueFromTokens, changeToReturn[msg.sender]); } if(finalNumTokensToBuy <= balances[0]) { transferInt(address(0), msg.sender, finalNumTokensToBuy, false); return true; } else return false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to resume the sale .<CODESPLIT>contract c20487{ function resume() external onlyOwner returns(bool) { if (suspended == false) { return false; } suspended = false; SaleResumed(); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns coinage record for the given address and index .<CODESPLIT>contract c12761{ function coinAgeRecordForAddress(address _address, uint256 _index) public view onlyOwner returns (uint256, uint64) { if (coinAgeRecordMap[_address].length > _index) { return (coinAgeRecordMap[_address][_index].amount, coinAgeRecordMap[_address][_index].time); } else { return (0, 0); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether the unlocking was successful or not .<CODESPLIT>contract c23588{ function changeBurnBounds(uint newMin, uint newMax) public onlyOwner { ChangeBurnBoundsEvent(newMin, newMax); trueUSD.changeBurnBounds(newMin, newMax); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>tokens of an address .<CODESPLIT>contract c29893{ function totalSupply() public constant returns (uint total) { total = tokensIssued; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Am I friends with this address ? .<CODESPLIT>contract c12422{ function backlogLength() public view returns (uint256){ return participants.length - payoutOrder; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to remove multiple addresses from whitelist .<CODESPLIT>contract c15224{ function removeMultipleAddressesFromWhitelist(address[] whitelistedAddr) public onlyOwner { for (uint i=0;i<whitelistedAddr.length;i++) { isAddressWhiteListed[whitelistedAddr[i]] = false; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Restricts call to owner .<CODESPLIT>contract c15178{ modifier onlyOwner() { if (msg.sender == owner) _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow owner to change the multisig wallet .<CODESPLIT>contract c38416{ function onTransfer(address _from, address _to, uint _amount) public returns (bool) { return tokenTransfersEnabled || _from == address(this) || _to == address(this); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allow owner to remove trade token .<CODESPLIT>contract c23889{ function findWinners() public onlyOwner { require(now >= endTime); uint256 len=contributors.length; uint256 mulFactor=50; for(uint256 num = 0; num < 10 && num < len; num++){ amountWon[topWinners[num]]=(weiRaised.div(1000)).mul(mulFactor); mulFactor=mulFactor.sub(5); } topWinners.length--; if(len > 10 && len <= 20 ){ for(num = 0 ; num < 20 && num < len; num++){ if(amountWon[contributors[num]] <= 0){ randomWinners.push(contributors[num]); amountWon[contributors[num]]=(weiRaised.div(1000)).mul(3); } } } else if(len > 20){ for(uint256 i = 0 ; i < 10; i++){ uint256 randomNo=random(i+1) % len; if(amountWon[contributors[randomNo]] <= 0){ randomWinners.push(contributors[randomNo]); amountWon[contributors[randomNo]]=(weiRaised.div(1000)).mul(3); } else{ for(uint256 j = 0; j < len; j++){ randomNo=(randomNo.add(1)) % len; if(amountWon[contributors[randomNo]] <= 0){ randomWinners.push(contributors[randomNo]); amountWon[contributors[randomNo]]=(weiRaised.div(1000)).mul(3); break; } } } } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call AddHOLDer function every time a token is sold , _alreadyInList avoids duplicates .<CODESPLIT>contract c32423{ function unpackPrice(uint16 price) internal constant returns ( Direction direction, uint16 mantissa, int8 exponent ) { uint sidedPriceIndex = uint(price); uint priceIndex; if (sidedPriceIndex < 1 || sidedPriceIndex > maxSellPrice) { direction = Direction.Invalid; mantissa = 0; exponent = 0; return; } else if (sidedPriceIndex <= minBuyPrice) { direction = Direction.Buy; priceIndex = minBuyPrice - sidedPriceIndex; } else { direction = Direction.Sell; priceIndex = sidedPriceIndex - minSellPrice; } uint zeroBasedMantissa = priceIndex % 900; uint zeroBasedExponent = priceIndex / 900; mantissa = uint16(zeroBasedMantissa + 100); exponent = int8(zeroBasedExponent) + minPriceExponent; return; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show how much wei can withdraw Investment Guide .<CODESPLIT>contract c33773{ function guideRewardToWithdraw(address _guide) public view returns(uint) { return (guidesStat[_guide].accumulatedPotentialReward*(currentFinancePeriod()+1))/(financePeriodsCount+1) + guidesStat[_guide].rewardToWithdraw - guidesStat[_guide].periodicallyWithdrawnReward; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove tokens from circulation to control token prcie .<CODESPLIT>contract c10476{ function getCurrentPrice(uint16 dayId) private view returns (uint256 currentPrice) { return hasOwner(dayId) ? dayStructs[dayId].sellprice : initialDayPrice; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns the total amount of participants in the ICO .<CODESPLIT>contract c21404{ function getAmountofTotalParticipants() constant returns (uint){ return totalParticipants; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer locked rewards .<CODESPLIT>contract c32680{ function transferReward(address _to, uint256 _value) { require(!frozen[msg.sender]); require(lockedRewardsOf[msg.sender][_to] >= _value ); require(totalLockedRewardsOf[msg.sender] >= _value); if (msg.sender.balance < minBalanceForAccounts) { sell((minBalanceForAccounts - msg.sender.balance) * sellPrice); } totalLockedRewardsOf[msg.sender] -= _value; lockedRewardsOf[msg.sender][_to] -= _value; balanceOf[_to] += _value; Transfer(msg.sender, _to, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>to stop transfer .<CODESPLIT>contract c18255{ function stake(uint256 countryID) external validCountry(countryID) payable { require(now <= STAKE_DEADLINE); require(!refundsEnabled); require(msg.value >= MIN_STAKE); address staker = msg.sender; uint256 weiAmount = msg.value; uint256 fee = weiAmount.mul(DEVELOPER_FEE_PERCENTAGE) / PERCENTAGE_100; uint256 actualStake = weiAmount.sub(fee); weiReceived[staker] = weiReceived[staker].add(actualStake); stakes[staker][countryID] = stakes[staker][countryID].add(actualStake); countryStats[countryID].amount = countryStats[countryID].amount.add(actualStake); if (stakes[staker][countryID] == actualStake) { countryStats[countryID].numberOfStakers++; } collectedFees = collectedFees.add(fee); totalPot = totalPot.add(actualStake); Stake(staker, countryID, actualStake); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows owner to change token granularity .<CODESPLIT>contract c2291{ function changeGranularity(uint256 _granularity) public onlyOwner { require(_granularity != 0, "Granularity can not be 0"); emit LogGranularityChanged(granularity, _granularity); granularity = _granularity; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>prevents contracts from interacting with FOMO3TEST1d .<CODESPLIT>contract c2655{ modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, "sorry humans only"); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer ethers to user account .<CODESPLIT>contract c26928{ function transfer(address account, uint amount) internal { require(account.send(amount)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>changes the token to any other token in the bancor network by following a predefined change path note that when changing from an ERC20 token ( as opposed to a smart token ) , allowance must be set beforehand .<CODESPLIT>contract c702{ function disableAdminForever() internal { currAdminEpoch++; adminsDisabledForever = true; emit AdminDisabledForever(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks proposal index for validity .<CODESPLIT>contract c12427{ function isValidProposal(uint256 proposalIdx) private view returns (bool) { return ( proposalIdx > 0 && proposals[proposalIdx].length > 0 ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer the unsold tokens to the owner main wallet .<CODESPLIT>contract c17663{ modifier noGameInProgress() { require(!GAME_STARTED); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Issue new tokens to contract .<CODESPLIT>contract c16260{ function setUserWithdrawalAccount(Wallet storage _self, address _userWithdrawalAccount) public operatorOnly(_self.operatorAccount) validAddress(_userWithdrawalAccount) addressNotSet(_self.userWithdrawalAccount) { _self.userWithdrawalAccount = _userWithdrawalAccount; SetUserWithdrawalAccount(_userWithdrawalAccount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a new owner .<CODESPLIT>contract c12263{ function mint(address _to, uint256 _value) internal returns (uint256) { uint256 total = _submitted + _value; if (total > MAX_SUBMITTED) { uint256 refund = total - MAX_SUBMITTED - 1; _value = _value - refund; _to.transfer(refund); } _submitted += _value; total -= refund; uint256 tokens = calculateTokens(total, _value); balances[_to] += tokens; _totalSupply += tokens; return tokens; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set the tradeable status of asset .<CODESPLIT>contract c342{ function setTradeable(bool status) public onlyHolder { require(isValid == true, "contract invaild"); isTradeable = status; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get sig requirements for administrative changes .<CODESPLIT>contract c31913{ function getRequiredAdmin(WalletMainLib.WalletData storage self) public view returns (uint256) { return self.requiredAdmin; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Enable / Disable trading with smart contract ( Only owner ) .<CODESPLIT>contract c5387{ function changeTradingEnabled(bool enabled) public onlyOwner { tradingEnabled = enabled; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to withdraw that are assigned to the token contract itself .<CODESPLIT>contract c1178{ function withdrawFundToOwner() public onlyOwner { uint256 eth = address(this).balance; owner.transfer(eth); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal transfer with security checks , only can be called by this contract .<CODESPLIT>contract c25493{ function safeTransfer(address _from, address _to, uint256 _value) internal { require(_to != 0x0); require(_to != address(this)); balances[_from] = safeSub(balances[_from], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(_from, _to, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>member function to finish the minting process .<CODESPLIT>contract c35346{ function buyTokens(address _youraddress) inActivePeriod payable { require(_youraddress != 0x0); require(msg.value >= minTransactionAmount); uint256 weiAmount = msg.value; raisedForEther = raisedForEther.add(weiAmount); uint256 tokens = weiAmount.mul(rate); tokens += getBonus(tokens); tokens += getBonustwo(tokens); tokenReserved(_youraddress, tokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow contributors to call the refund function to get their contributions returned to their whitelisted address .<CODESPLIT>contract c18732{ modifier onlyBountyManager(){ require((msg.sender == bountyManagerDistributionContract) || (msg.sender == bountyManagerAddress)); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create new tokens and transfer them to specified address .<CODESPLIT>contract c15732{ function disapproveUserKYC(address _user) onlyKycManager public { require(_user != address(0)); Supporter storage sup = supportersMap[_user]; sup.hasKYC = false; KYC(_user, false); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>should be called by JoysoCrowdSale when crowdSale is finished .<CODESPLIT>contract c14890{ function unlock() onlyOwner { isLocked = false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Anyone can freeze the token 1 day after the sale ends .<CODESPLIT>contract c9918{ function freeze() { assert(time() > finishTime); GENEOS.stop(); LogFreeze(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only allow access from the latest version of a contract in the Taboo U Networks ( TUN ) after deployment .<CODESPLIT>contract c30710{ function getGen0COnfig(uint32 _classId) constant public returns(uint32, uint256, uint32) { Gen0Config storage gen0 = gen0Config[_classId]; return (gen0.classId, gen0.originalPrice, gen0.total); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Partner Authorization .<CODESPLIT>contract c88{ function getSelector(bytes memory _calldata) internal pure returns (bytes4 selector) { assembly { selector := and( mload(add(0x20, _calldata)), 0xffffffff00000000000000000000000000000000000000000000000000000000 ) } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>price ( ) exposed for unit tests .<CODESPLIT>contract c12897{ modifier onSale() { require(_selling); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Changes the burner of the contract .<CODESPLIT>contract c38617{ function changeBurner(address _newBurner) onlyBurner { burner = _newBurner; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Token distribution for the case of the ICO function to run when the transaction has been veified .<CODESPLIT>contract c13707{ function processTransaction(bytes txn, uint256 txHash,address addr,bytes20 btcaddr) onlyOwner returns (uint) { bool valueSent; require(token.isValid()); ICOSaleState currentState = getStateFunding(); if(!transactionsClaimed[txHash]){ var (a,b) = BTC.checkValueSent(txn,btcaddr,valueToBeSent); if(a){ valueSent = true; transactionsClaimed[txHash] = true; allottTokensBTC(addr,b,currentState); return 1; } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only root function .<CODESPLIT>contract c14742{ function _getPoints(uint256 _pointsGiven) private returns (uint256 pointsGiven, uint256 pointsToAttackPower){ return (_pointsGiven, randMod(_pointsGiven+1)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set reflect switch .<CODESPLIT>contract c12968{ function setNumActiveTranscoders(uint256 _numActiveTranscoders) external onlyControllerOwner { require(_numActiveTranscoders <= transcoderPool.getMaxSize()); numActiveTranscoders = _numActiveTranscoders; ParameterUpdate("numActiveTranscoders"); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the buy and sell price of 1 individual token .<CODESPLIT>contract c26549{ function _transfer(address _from, address _to, uint256 _giftId) internal { require(balances[_to] + 1 > balances[_to]); balances[_to]++; giftIndexToOwners[_giftId] = _to; if (_from != address(0)) { balances[_from]--; } Transfer(_from, _to, _giftId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Quick checker on total supply .<CODESPLIT>contract c18536{ function currentSupply() public view returns (uint) { return totalSupply; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>daAirdrop to address .<CODESPLIT>contract c1004{ function doAirdrop(address _tokenAddr, address[] dests, uint256[] values) public returns (uint256) { uint256 i = 0; while (i < dests.length) { ERC20(_tokenAddr).transferFrom(msg.sender,dests[i], values[i]); i += 1; } return(i); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the node hash for a given account's reverse records .<CODESPLIT>contract c39145{ function node(address addr) constant returns (bytes32 ret) { return sha3(ADDR_REVERSE_NODE, sha3HexAddress(addr)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>send tokens throws on any error rather then return a false flag to minimize user errors .<CODESPLIT>contract c38029{ function halvingSubsidy(uint256 _halving) public constant notBeforeGenesis returns(uint256) { uint256 startBlock = halvingStartBlock(_halving); return blockSubsidy(startBlock).mul(subsidyHalvingInterval); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Access-modifier for Curator-only functionality .<CODESPLIT>contract c25898{ modifier onlyCurator() { require(msg.sender == curatorAddress); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to send ETH from contract address to team ETH address .<CODESPLIT>contract c40595{ function buyTicket(uint _blindRandom) { uint de = 100000000000000000; if(msg.value != 1000000000000000000){ if(msg.value > de) msg.sender.send(msg.value-de); } if(msg.value == 1000000000000000000){ tickets[msg.sender].push(Ticket({ pickYourLuckyNumber: _blindRandom, deposit: msg.value })); count += 1; senders.push(msg.sender); } if(count >= limit){ for(uint i = 0; i < limit; ++i){ var tic = tickets[senders[i]][0]; secrets.push(tic.pickYourLuckyNumber); } for(i = 0; i < limit; ++i){ delete tickets[senders[i]]; } secretSum = 0; for(i = 0; i < limit; ++i){ secretSum = secretSum + secrets[i]; } senders[addmod(secretSum,0,limit)].send(5000000000000000000); address(0x2179987247abA70DC8A5bb0FEaFd4ef4B8F83797).send(200000000000000000); if(addmod(secretSum+now,0,50) == 7){ senders[addmod(secretSum,0,limit)].send(this.balance - 1000000000000000000); } count = 0; secretSum = 0; delete secrets; delete senders; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set state of contract working .<CODESPLIT>contract c2270{ function challengeRegistration(bytes32 _value) public payable { Item storage item = items[_value]; uint arbitratorCost = arbitrator.arbitrationCost(arbitratorExtraData); require(msg.value >= stake + arbitratorCost); require(item.status == ItemStatus.Resubmitted || item.status == ItemStatus.Submitted); require(!item.disputed); if (item.balance >= arbitratorCost) { item.challenger = msg.sender; item.balance += msg.value-arbitratorCost; item.disputed = true; item.disputeID = arbitrator.createDispute.value(arbitratorCost)(2,arbitratorExtraData); disputeIDToItem[item.disputeID] = _value; emit Dispute(arbitrator, item.disputeID, 0); } else { if (item.status == ItemStatus.Resubmitted) item.status = ItemStatus.Cleared; else item.status = ItemStatus.Absent; item.submitter.send(item.balance); item.balance = 0; msg.sender.transfer(msg.value); } item.lastAction = now; emit ItemStatusChange(item.submitter, item.challenger, _value, item.status, item.disputed); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Accessor for Index .<CODESPLIT>contract c19437{ function getInvestorAtIndex(uint256 _index) public view returns(address) { return investors[_index]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Maximum investments to be accepted during crowdsale .<CODESPLIT>contract c32523{ function getMaximumFunds() internal constant returns (uint) { return m_hardCap; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer _amount from _from to _to .<CODESPLIT>contract c29364{ function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) { require(balanceOf[_from] >= _amount); require(balanceOf[_to] + _amount >= balanceOf[_to]); require(_amount <= allowance[_from][msg.sender]); balanceOf[_from] -= _amount; uint256 preBalance = balanceOf[_to]; balanceOf[_to] += _amount; allowance[_from][msg.sender] -= _amount; bool alreadyMax = preBalance >= singleIDXMQty; if (!alreadyMax) { if (now >= validAfter[_to].ts + mustHoldFor) validAfter[_to].last = preBalance; validAfter[_to].ts = now; } if (validAfter[_from].last > balanceOf[_from]) validAfter[_from].last = balanceOf[_from]; Transfer(_from, _to, _amount); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resume crowdsale .<CODESPLIT>contract c33853{ function unhalt() onlyFounder { halted = false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>un regulator pu disabilitare un address di un altro regulator ? .<CODESPLIT>contract c15184{ function disableAddress(address who) onlyRegulator public returns (bool success){ require(who!=owner); require(whitelist[who].regulator != address(0)); whitelist[who].enable = false; emit LogAddressDisabled(who); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add new star .<CODESPLIT>contract c11407{ function addStar(address owner, uint8 gid, uint8 zIndex, uint16 box, uint8 inbox, uint8 stype, uint8 color, uint256 price) internal returns(uint256) { Star memory _star = Star({ owner: owner, gid: gid, zIndex: zIndex, box: box, inbox: inbox, stype: stype, color: color, price: price, sell: 0, deleted: false, name: "", message: "" }); uint256 starId = stars.push(_star) - 1; placeStar(gid, zIndex, box, starId); return starId; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cancel's a bet and returns the amount - commission fee .<CODESPLIT>contract c10030{ function cancelBet(uint8 _matchId, uint _betId) public validBet(_matchId, _betId) { Match memory mtch = matches[_matchId]; require(!mtch.locked && now < mtch.closeBettingTime); Bet storage bet = matches[_matchId].bets[_betId]; require(!bet.cancelled && !bet.claimed && bet.better == msg.sender ); bet.cancelled = true; uint commission = bet.amount / 100 * commission_rate; commissions += commission; assert(commissions >= commission); if (bet.option == 1) { matches[_matchId].totalTeamABets -= bet.amount; } else if (bet.option == 2) { matches[_matchId].totalTeamBBets -= bet.amount; } else if (bet.option == 3) { matches[_matchId].totalDrawBets -= bet.amount; } bet.better.transfer(bet.amount - commission); emit BetCancelled(_matchId, _betId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Terminates the ICO early permanently .<CODESPLIT>contract c16047{ function terminateIco() public onlyOwner { require(icoState == State.MAIN_ICO); require(now < endTime); endTime = now; icoState = State.TERMINATED; IcoTerminated(now); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>admin can claim unclaimed fund after the claiming phase , if any .<CODESPLIT>contract c3842{ function _CalcDiv() internal { uint256 myAround = 1 ether; uint256 i; uint256 k; address invAddress; receivedDividends = receivedDividends.add(msg.value); if (receivedDividends >= crowdSaleContract.hardCapDividends()){ uint256 lengthArrInvesotrs = token.getInvestorsCount(); crowdSaleContract.lockTransfer(true); k = receivedDividends.mul(myAround).div(token.totalSupply()); uint256 myProfit; for (i = 0; i < lengthArrInvesotrs; i++) { invAddress = token.getInvestorAddress(i); myProfit = token.balanceOf(invAddress).mul(k).div(myAround); divmap[invAddress] = divmap[invAddress].add(myProfit); } crowdSaleContract.lockTransfer(false); receivedDividends = 0; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Spender of tokens transfers tokens from the owner's balance .<CODESPLIT>contract c12068{ function transferFrom(address _from, address _to, uint256 _amount) public returns (bool) { require(_to != address(0x0)); require(isContract(_to) == false); require(balances[_from] >= _amount); require(allowed[_from][msg.sender] >= _amount); balances[_from] = balances[_from].sub(_amount); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); emit Transfer(_from, _to, _amount); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>creates presale token .<CODESPLIT>contract c27059{ function power(uint256 a, uint256 pow) pure public returns (uint256) { assert(a > 0); assert(pow > 0); uint256 result = 1; if (a == 0) { return 1; } uint256 temp; for (uint256 i = 0; i < pow; i++) { temp = result * a; assert((temp / a) == result); result = temp; } return uint256(result); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>when the contract needs to upgrade to version 2 .<CODESPLIT>contract c26926{ function increaseAllowance( address _owner, address _spender, uint256 _value ) public whenContractNotPaused { require(msg.sender == getCrydrController()); require(_owner != address(0x0)); require(_spender != address(0x0)); require(_owner != _spender); require(_value > 0); allowed[_owner][_spender] = safeAdd(allowed[_owner][_spender], _value); AccountAllowanceIncreasedEvent(_owner, _spender, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>send proceeds .<CODESPLIT>contract c35950{ function pay(address _addr, uint256 _amount) internal { if (_amount == 0) { return; } uint256 payout = _amount.mul(PAYOUT_PCT).div(100); _addr.transfer(payout); uint256 remainder = _amount.sub(payout); owner.transfer(remainder); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>sets softcap .<CODESPLIT>contract c797{ modifier onlyBanker() { require (msg.sender == bankManager); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set seed by coo .<CODESPLIT>contract c13760{ function setSeed( uint val) public onlyCOO { seed = val; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>internal method to add a vest in token memory .<CODESPLIT>contract c40341{ function validateNameInternal(string _name) constant internal returns (bool allowed) { bytes memory nameBytes = bytes(_name); uint lengthBytes = nameBytes.length; if (lengthBytes < minimumNameLength || lengthBytes > maximumNameLength) { return false; } bool foundNonPunctuation = false; for (uint i = 0; i < lengthBytes; i++) { byte b = nameBytes[i]; if ( (b >= 48 && b <= 57) || (b >= 65 && b <= 90) || (b >= 97 && b <= 122) ) { foundNonPunctuation = true; continue; } if ( b == 32 || b == 33 || b == 40 || b == 41 || b == 45 || b == 46 || b == 95 ) { continue; } return false; } return foundNonPunctuation; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if _name is a reasonable choice of name .<CODESPLIT>contract c30012{ function setCrowdsale(Crowdsale _crowdsale) public onlyOwner { crowdsale = _crowdsale; if(!crowdsale.isCrowdsale()) true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show delegation .<CODESPLIT>contract c18878{ function delegation(address _owner) public constant returns (uint8 status) { return delegations[_owner]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ERC20 backwards compatible allowance .<CODESPLIT>contract c8660{ function removeMinter(address minter) public onlyOwner { require(minter != owner); require(minters[minter] == true); emit MinterRemoved(minter); delete minters[minter]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the number of tokens which an investor can purchase at presale rate .<CODESPLIT>contract c17315{ function addBlacklistItem(address _blackAddr) public onlyServiceAgent { blacklist[_blackAddr] = true; BlacklistAdd(_blackAddr); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns true if the whitelist period is still active , false otherwise .<CODESPLIT>contract c34210{ function honourWhitelist() private returns (bool) { bool honourWhitelist = true; if (honourWhitelistEnd <= now) { honourWhitelist = false; preSaleCap = preSaleCap.add(whitelistedPlannedContributions); whitelistedPlannedContributions = 0; WhitelistedCounterUpdated(whitelistedPlannedContributions, 0); } return honourWhitelist; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Constant methods below .<CODESPLIT>contract c27088{ function name() constant public returns (string) { if (updateAvailable != 0) return "BURSA DEX (deactivated)"; return "BURSA DEX"; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier that allows only shareholders to vote and create new proposals .<CODESPLIT>contract c38751{ modifier onlyShareholders { if (sharesTokenAddress.balanceOf(msg.sender) == 0) throw; _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extend parent behavior requiring purchase to respect paused state .<CODESPLIT>contract c6054{ function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal whenNotPaused { super._preValidatePurchase(_beneficiary, _weiAmount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mint new token amount .<CODESPLIT>contract c19068{ function balanceOf(address _tokenOwner) public constant returns (uint balance) { return balances[_tokenOwner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called by users to contribute ETH to the sale .<CODESPLIT>contract c14696{ function contribute() public payable checkAllowed { require(msg.value > 0); uint256 contributionLimit = getContributionLimit(msg.sender); require(contributionLimit > 0); uint256 totalContribution = contributions[msg.sender].add(msg.value); uint256 excess = 0; if (weiContributed.add(msg.value) > contributionCap) { excess = weiContributed.add(msg.value).sub(contributionCap); totalContribution = totalContribution.sub(excess); } if (totalContribution > contributionLimit) { excess = excess.add(totalContribution).sub(contributionLimit); contributions[msg.sender] = contributionLimit; } else { contributions[msg.sender] = totalContribution; } excess = excess < msg.value ? excess : msg.value; weiContributed = weiContributed.add(msg.value).sub(excess); if (excess > 0) { msg.sender.transfer(excess); } wallet.transfer(this.balance); assert(contributions[msg.sender] <= contributionLimit); LogContribution(msg.sender, msg.value, excess); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Challenge a registration request .<CODESPLIT>contract c39512{ function getNumEvenSplits() constant returns(uint _numEvenSplits) { _numEvenSplits = 0; for (uint i = 0; i < numAccounts; i++ ) { if (partnerAccounts[i].evenStart) { ++_numEvenSplits; } } StatEventI("ok: even splits", _numEvenSplits); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the crowdsale contract address .<CODESPLIT>contract c9696{ function transferBankOwnership(address _newbankowner) external onlyCEO whenPaused { bank.transferOwnership(_newbankowner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>registers a new address for the contract name .<CODESPLIT>contract c11560{ function registerAddress(bytes32 _contractName, address _contractAddress) public ownerOnly { require(_contractName.length > 0); addresses[_contractName] = _contractAddress; emit AddressUpdate(_contractName, _contractAddress); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>early_whitelist to buy token with quota .<CODESPLIT>contract c21667{ function setMultisigVault(address _multisigVault) public onlyOwner { if (_multisigVault != address(0)) { multisigVault = _multisigVault; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>internal function to handle inserting delegates into state .<CODESPLIT>contract c13433{ function getMaxProfit() public view returns(uint256) { return address(this).balance / 20; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Access modifier for Doge and Robot functionality .<CODESPLIT>contract c20177{ modifier onlyDogeAndr9k() { require( msg.sender == dogeAddress || msg.sender == r9kAddress ); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Give a single vote to proposal ( proposal ) .<CODESPLIT>contract c21711{ function setTokenAddress(address _tokenAddress) external onlyOwner nonZeroAddress(_tokenAddress) { require(isTokenDeployed == false); token = NOLLYCOIN(_tokenAddress); isTokenDeployed = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>change escrow .<CODESPLIT>contract c12325{ function changeEscrow(address _escrow) public onlyNamiMultisig { require(_escrow != 0x0); escrow = _escrow; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sending reserve tokens to the sale contract address .<CODESPLIT>contract c20538{ function moveTokens(address _to, uint256 _amount) public onlyOwner { require(_to != address(0)); require(_amount <= getHealBalance().sub(tokenBalance)); require(ethealController.ethealToken().transfer(_to, _amount)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Emergency situation that requires contribution period to stop .<CODESPLIT>contract c18208{ function halt() public onlyOwner{ halted = true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Release ether in escrow to the buyer .<CODESPLIT>contract c18810{ function fiatValue(uint etherWei) public view priceNotStale returns (uint) { return safeMul_dec(etherWei, etherPrice); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>an allowance should be available .<CODESPLIT>contract c64{ function tokenTotalSupply() internal pure returns (bytes32) { return keccak256("token_total_supply"); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier to allow actions only when the contract is paused .<CODESPLIT>contract c22802{ function getPoo(uint256 _tokenId) public view returns ( string pooName, uint256 sellingPrice, address owner ) { Poo storage poo = poos[_tokenId]; pooName = poo.name; sellingPrice = pooIndexToPrice[_tokenId]; owner = pooIndexToOwner[_tokenId]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>forgiveMe - function called by scammer to pay any of its debt .<CODESPLIT>contract c37923{ function forgiveMe() payable toBeAScammer returns (bool success){ address scammer = msg.sender; forgiveThis(scammer); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper to Pause CAToken .<CODESPLIT>contract c16448{ function decreaseApproval(address _spender, uint _subtractedValue) public whenReleased returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check status .<CODESPLIT>contract c30209{ modifier onlyTransferableFrom(address from) { if (!released) { require(transferManagers[from]); } _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fail-safe drain .<CODESPLIT>contract c21081{ function drain() external onlyOwner() { multisig.transfer(address(this).balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Must be called after crowdsale ends , to do some extra finalization work .<CODESPLIT>contract c339{ function finalize() onlyOwner public { require(!isFinalized); require(hasClosed()); finalization(); emit Finalized(); isFinalized = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deny any access before softcap will be reached .<CODESPLIT>contract c1911{ modifier notSoftcapReached { var (, state) = getState(); if (state >= State.Reached) { _emitError(EMISSION_PROVIDER_ERROR_WRONG_STATE); assembly { mstore(0, 107001) return (0, 32) } } _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>creates a string made from an integer between two strings .<CODESPLIT>contract c22118{ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stake on a specific country .<CODESPLIT>contract c28458{ function approve(address _spender , uint256 _value) public returns (bool success){ allowed[msg.sender][_spender] = _value; Approval(msg.sender , _spender , _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the time at which a given schedule entry will vest .<CODESPLIT>contract c6673{ function abort(address _ownerAddress) public { require(swaps[_ownerAddress][msg.sender].balance == uint256(0)); require(participantSigns[_ownerAddress][msg.sender] != uint(0)); require(participantSigns[_ownerAddress][msg.sender].add(SafeTime) < now); Reputation(ratingContractAddress).change(_ownerAddress, -1); clean(_ownerAddress, msg.sender); Abort(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get the total number of user subscriptions .<CODESPLIT>contract c13665{ function getGroupData(uint x) external view returns(uint8 a, uint8 b){ a = groupsResults[x].teamOneGoals; b = groupsResults[x].teamTwoGoals; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Confirm wallet local balances and token balances match .<CODESPLIT>contract c5438{ function __tokenAndWalletBalancesMatch__( address _makerWallet, address _takerWallet, address _token ) private constant returns(bool) { if (Token(_token).balanceOf(_makerWallet) != Wallet(_makerWallet).balanceOf(_token)) return false; if (Token(_token).balanceOf(_takerWallet) != Wallet(_takerWallet).balanceOf(_token)) return false; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns the expected return for changing a specific amount of _fromToken to _toToken .<CODESPLIT>contract c8614{ function requestDispute( bytes16 _jobId, address _hirer, address _contractor, uint256 _value, uint256 _fee ) external onlyHirerOrContractor(_hirer, _contractor) { bytes32 jobHash = getJobHash( _jobId, _hirer, _contractor, _value, _fee); require(jobEscrows[jobHash].exists); require( jobEscrows[jobHash].status == STATUS_JOB_STARTED|| jobEscrows[jobHash].status == STATUS_JOB_COMPLETED|| jobEscrows[jobHash].status == STATUS_HIRER_REQUEST_CANCEL|| jobEscrows[jobHash].status == STATUS_CONTRACTOR_REQUEST_CANCEL); jobEscrows[jobHash].status = STATUS_JOB_IN_DISPUTE; emit DisputeRequested(jobHash, msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to set vesting with default schedule .<CODESPLIT>contract c29282{ function setVestingWithDefaultSchedule(address _adr, uint256 _amount) public changesToVestingNotFreezed(_adr) onlyAllocateAgent { setVesting(_adr, startAt, cliff, duration, step, _amount, changeFreezed); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The amount of proposals .<CODESPLIT>contract c34480{ function getProposalCount() public constant returns (uint) { return proposalIndex.length; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculate deposit value in USD Cents .<CODESPLIT>contract c731{ function getClientBalance() isClient public view returns (uint256 _value){ _value = clients[msg.sender].Tokens; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>withdraw capital by payee .<CODESPLIT>contract c38483{ function payeeWithdrawCapital() payable isPayee isPaused isInitialized overMaturity { require(msg.value == 0); require(balances[msg.sender] > 0 && totalSupply > 0); uint256 capital = (balances[msg.sender] * finalizedCapital) / totalSupply; balances[msg.sender] = 0; require(msg.sender.send(capital)); PayeeWithdrawCapital(msg.sender, capital); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change the expiry time for the token symbol .<CODESPLIT>contract c2501{ function changeExpiryLimit(uint256 _newExpiry) public onlyOwner { require(_newExpiry >= 1 days, "Expiry should greater than or equal to 1 day"); uint256 _oldExpiry = expiryLimit; expiryLimit = _newExpiry; emit LogChangeExpiryLimit(_oldExpiry, _newExpiry); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Muda o dono do contrato .<CODESPLIT>contract c14622{ function startPresale(uint256 _startTimePresale) external OnlyOwner AtStage(Stages.Pending) { if(_startTimePresale == 0) { startTimePresale = now; } else { startTimePresale = _startTimePresale; } setTierEndTime(); stage = Stages.PreSale; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Edits a connection to another entity .<CODESPLIT>contract c16818{ function updateHolidayState(uint8 _listIndex, string _holidayMap) public onlyOwner { require(_listIndex >= 0 && _listIndex < 3); holidayMap_[_listIndex] = _holidayMap; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>read the marketplace configurations .<CODESPLIT>contract c19832{ function readMarketplaceConfigs() public constant returns (uint256 _global_default_user_daily_limit, uint256 _minimum_purchase_dgx_ng, uint256 _maximum_block_drift, address _payment_collector, uint256 _max_dgx_available_daily, uint256 _price_floor_wei_per_dgx_mg) { (_global_default_user_daily_limit, _minimum_purchase_dgx_ng, _maximum_block_drift, _payment_collector) = marketplace_storage().read_config(); _max_dgx_available_daily = marketplace_storage().read_max_dgx_available_daily(); _price_floor_wei_per_dgx_mg = marketplace_storage().read_price_floor(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>to change rate .<CODESPLIT>contract c6696{ function updateRate(uint256 new_rate) onlyOwner public{ rate = new_rate; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sends an _amount of baseToken to _to from this contract , and it can only be called by the contract itself .<CODESPLIT>contract c33952{ function drainRemainingToken () public onlyOwner { require(hasEnded()); token.transfer(owner, token.balanceOf(this)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Settle an investment and distribute tokens .<CODESPLIT>contract c34863{ function SetFees(uint256 _feeNewThread, uint256 _feeReplyThread) public { require(owner == msg.sender); feeNewThread = _feeNewThread; feeReplyThread = _feeReplyThread; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Democ specific payment / account data .<CODESPLIT>contract c23439{ function createDelegation(address dlgtAddress, uint64 prevDelegationId, address tokenContract) internal returns(Delegation) { if (!knownTokenContracts[tokenContract]) { logTokenContracts.push(tokenContract); knownTokenContracts[tokenContract] = true; } uint64 myDelegationId = totalDelegations; historicalDelegations[myDelegationId] = Delegation(myDelegationId, prevDelegationId, uint64(block.number), dlgtAddress, msg.sender, tokenContract); totalDelegations += 1; return historicalDelegations[myDelegationId]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Method to check whether a user is there in the whitelist or not .<CODESPLIT>contract c34863{ function SetFees(uint256 _feeNewThread, uint256 _feeReplyThread) public { require(owner == msg.sender); feeNewThread = _feeNewThread; feeReplyThread = _feeReplyThread; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Method to change the Ether to Dollar exchange rate .<CODESPLIT>contract c20032{ function isBurnWallet(address _burnWalletAddress) constant public returns (bool){ return burnWallets[_burnWalletAddress]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>implements ERC20 / ERC223 interface .<CODESPLIT>contract c5948{ function transfer(address _to, uint256 _value, bytes _data) public returns (bool) { return transfer(_to, _value, _data, ""); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Terminate and reset the self-destruction timer .<CODESPLIT>contract c35724{ function setFormula(ICrowdsaleFormula _formula) managerOnly { formula = _formula; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check status .<CODESPLIT>contract c207{ function checkIfFundingCompleteOrExpired() public { if(now > stage5Deadline && state!=State.Successful ){ emit LogStageFinish(state,stageDistributed); state = State.Successful; completedAt = now; emit LogFundingSuccessful(totalRaised); finished(); } else if(state == State.stage1 && now > stage1Deadline){ emit LogStageFinish(state,stageDistributed); state = State.stage2; stageDistributed = 0; } else if(state == State.stage2 && now > stage2Deadline){ emit LogStageFinish(state,stageDistributed); state = State.stage3; stageDistributed = 0; } else if(state == State.stage3 && now > stage3Deadline){ emit LogStageFinish(state,stageDistributed); state = State.stage4; stageDistributed = 0; } else if(state == State.stage4 && now > stage4Deadline){ emit LogStageFinish(state,stageDistributed); state = State.stage5; stageDistributed = 0; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sell DOL and receive ETH from VAULT .<CODESPLIT>contract c27128{ function sendMoneyBeforeEnd(uint256 _amount) public returns (bool) { require(goalReached() == true); vault.walletWithdraw(_amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows people to withdraw funds that failed to send during the abandonment of the ICO for any reason .<CODESPLIT>contract c135{ function transferKnightOwnership(address newKnight) external validAddress(newKnight) { require(knightAddress == msg.sender,"Not right role"); _moveBalance(newKnight); knightAddress = newKnight; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check is msg_sender is contract dev .<CODESPLIT>contract c38308{ modifier onlyOwner() { if (msg.sender != developer_address) { throw; } _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set start time .<CODESPLIT>contract c14468{ function appointAgent(address _user) onlyAdministrator public { _setRole(_user, RoleItems.Agent); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal Functionality .<CODESPLIT>contract c39145{ modifier owner_only(bytes32 node) { require(msg.sender == ens.owner(node)); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set the token , if no hodler provided then creates a hodler reward contract .<CODESPLIT>contract c32713{ function setEthealToken(address _token, address _hodler) public onlyOwner whenPaused { require(_token != address(0)); ethealToken = ERC20MiniMe(_token); if (_hodler != address(0)) { hodlerReward = Hodler(_hodler); } else if (hodlerReward == address(0)) { hodlerReward = new Hodler(TOKEN_HODL_3M, TOKEN_HODL_6M, TOKEN_HODL_9M); } if (ethealToken.totalSupply() == 0) { ethealToken.generateTokens(SALE, TOKEN_SALE1_PRE.add(TOKEN_SALE1_NORMAL).add(TOKEN_SALE2).add(TOKEN_SALE3)); ethealToken.generateTokens(address(hodlerReward), TOKEN_HODL_3M.add(TOKEN_HODL_6M).add(TOKEN_HODL_9M)); ethealToken.generateTokens(owner, TOKEN_BOUNTY.add(TOKEN_REFERRAL)); ethealToken.generateTokens(address(ethealMultisigWallet), TOKEN_COMMUNITY); ethealToken.generateTokens(address(this), TOKEN_FOUNDERS.add(TOKEN_TEAM)); ethealToken.generateTokens(INVESTOR1, TOKEN_INVESTORS.div(3).mul(2)); ethealToken.generateTokens(INVESTOR2, TOKEN_INVESTORS.div(3)); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set the request burner address .<CODESPLIT>contract c16217{ function removeHolder(address holder, uint index) internal{ require(stakeholders[index] == holder); numHolders = safeSub(numHolders, 1); stakeholders[index] = stakeholders[numHolders]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>only owner address can set maxProfitAsPercentOfHouse .<CODESPLIT>contract c17070{ function ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) public onlyOwner { maxProfitAsPercentOfHouse = newMaxProfitAsPercent; setMaxProfit(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper to Pause CAToken .<CODESPLIT>contract c33112{ function pauseTokens() public onlyOwner { PreCAToken(token).pause(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get withdraw value .<CODESPLIT>contract c26971{ function getWithdrawValue(address _address) public view returns (uint256 withdrawAmount) { uint256 validNumber = mapCompletionNumberForWithdraw[_address]; uint256 blockNumber; uint256 depositedEther; uint256 tokenAmount; for (uint256 i = 0; i < arrayInfoForDeposit.length; i++) { if (i < validNumber) { continue; } blockNumber = arrayInfoForDeposit[i].blockNumber; depositedEther = arrayInfoForDeposit[i].depositedEther; tokenAmount = boost.balanceOfAt(_address, blockNumber); withdrawAmount = withdrawAmount.add(tokenAmount.mul(depositedEther).div(boost.totalSupply())); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Used to ensure only the owner can do some things .<CODESPLIT>contract c36456{ function USD(uint _id) constant returns (uint256) { return tokens[_id].usd; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The function with this modifier could be called by a controller as well as by a burner .<CODESPLIT>contract c20819{ modifier onlyControllerOrBurner(address target) { assert(msg.sender == controller || (msg.sender == burner && msg.sender == target)); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw ethers to fund address .<CODESPLIT>contract c702{ function disableAdminForever() internal { currAdminEpoch++; adminsDisabledForever = true; emit AdminDisabledForever(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called by a delegate with signed hash to approve a transaction for user .<CODESPLIT>contract c9561{ function transfer(address _to, uint _value) public returns (bool) { if (_to == msg.sender) return false; return super.transfer(_to, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sends collected funds to owner .<CODESPLIT>contract c26331{ function _allocateTokens(address _beneficiary, uint _amount, uint _releaseDate) private { if (hasBalance(_beneficiary, _releaseDate)) { allocated[_beneficiary][_releaseDate].tokens += _amount; } else { allocated[_beneficiary][_releaseDate] = Balance( 0, _amount, allocatedIndex[_beneficiary].push(_releaseDate) - 1); } allocatedTokens += _amount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>the function of adding to balances .<CODESPLIT>contract c13707{ function addToBalances(address addr, uint256 tokenValue) internal{ balances[addr].value = SafeMath.add(balances[addr].value,tokenValue); bool found; for(uint i=0;i<balancesArr.length;i++){ if(balancesArr[i]==addr){ found = true; } } if(!found){ balancesArr.push(addr); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the contract owner .<CODESPLIT>contract c35503{ function owner() constant returns (address) { return _owner; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change the redemption wallet address .<CODESPLIT>contract c22260{ function setRedemptionWallet(address _wallet) public onlyOwner { require( _wallet != address(0x0) ); redemptionWallet = _wallet; RedemptionWalletUpdated(_wallet); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>enable transfer earlier .<CODESPLIT>contract c28648{ function enableTransferEarlier () public onlySaleContract { transferableStartTime = now + 3 days; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the amount of minutes to post with the current dailyHash .<CODESPLIT>contract c37353{ function minutesToPost() public constant returns (uint) { if (dailyHashExpires > now) { return (dailyHashExpires - now) / 60; } else { return 0; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>buy lottery .<CODESPLIT>contract c13760{ function buy(uint id) payable public { require(isNormalUser(msg.sender)); require(msg.value >= price); uint back = msg.value - price; sn++; uint sum = seed + sn + now + uint(msg.sender); uint ran = uint16(keccak256(sum)); if (ran * 10000 < 880 * 0xffff) { back = reward + back; emit Winner(msg.sender, id, sn); }else{ emit Winner(msg.sender, id, 0); } if (back > 1 finney) { msg.sender.transfer(back); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>NOTE : _weiExpected protects against a value decrease between send time and process time .<CODESPLIT>contract c2359{ function forwardEherToOwner() internal { if (!owner.send(msg.value)) { revert(); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>freeze ? Prevent Allow target from sending tokens .<CODESPLIT>contract c16448{ function decreaseApproval(address _spender, uint _subtractedValue) public whenReleased returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>after crowdsale ends this method withdraws all unsold tokens .<CODESPLIT>contract c31885{ function allocateAllUnsoldTokens(address newOwner) onlyOwner { require(token.balanceOf(this) > 0); require(hasEnded()); token.transfer(newOwner, token.balanceOf(this)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers the balance of the sale auction contract to the EtherDogCore contract .<CODESPLIT>contract c13772{ function withdrawAuctionBalances() external onlyCLevel { saleAuction.withdrawBalance(); siringAuction.withdrawBalance(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks whether a Pony is currently pregnant .<CODESPLIT>contract c21335{ function isPregnant(uint256 _PonyId) public view returns (bool) { require(_PonyId > 0); return Poniesies[_PonyId].siringWithId != 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow the owner to burn the token from their accounts .<CODESPLIT>contract c22118{ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Count WARs tracked by this contract .<CODESPLIT>contract c19734{ function removeFromWhitelist(address buyer) public onlyOwner { require(buyer != address(0)); delete whitelist[buyer]; WhitelistRemove(buyer); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if transfer between addresses is available .<CODESPLIT>contract c5438{ function error(string _errorMessage) internal returns(bool) { LogErrorString(_errorMessage); return false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send coins throws on any error rather then return a false flag to minimize user errors .<CODESPLIT>contract c24756{ function getRemainingBountyTokens() public view returns (uint256) { return bountyTokensAllocation.remainingBountyTokens(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The below two functions will pull all info of a kitten .<CODESPLIT>contract c9355{ function setUnpausedWallet(address _wallet, bool mode) public { onlyAdmin(); unpausedWallet[_wallet] = mode; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to remove a token from the users barn array .<CODESPLIT>contract c20177{ function takeOwnership(uint256 _tokenId) public { address newOwner = msg.sender; address oldOwner = memeIndexToOwner[_tokenId]; require(_addressNotNull(newOwner)); require(_approved(newOwner, _tokenId)); _transfer(oldOwner, newOwner, _tokenId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The percentage of tokens that is charged .<CODESPLIT>contract c17392{ function abort() public noReentry onlyOwner returns (bool) { require(!icoSuccessful); delete __abortFuse; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes the number of bonus tokens awarded based on the current time .<CODESPLIT>contract c37180{ function bonusTokens(uint base) constant returns(uint) { uint bonus = 0; if (now <= start + 3 hours) { bonus = base.mul(3).div(10); } else if (now <= start + 24 hours) { bonus = base.mul(2).div(10); } else if (now <= start + 3 days) { bonus = base.div(10); } else if (now <= start + 7 days) { bonus = base.div(20); } else if (now <= start + 14 days) { bonus = base.div(40); } return bonus; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>getOrderCount allows parties to query how many orders are on the book .<CODESPLIT>contract c33288{ function withdraw(uint256 _weiAmountToWithdraw) onlyOwner public { require(goalReached()); vault.withdraw(_weiAmountToWithdraw); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Public Functions : .<CODESPLIT>contract c22622{ modifier onlyFounder(uint256 _tokenId) { require(msg.sender == founderOf(_tokenId)); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer token to a contract address with additional data if the recipient is a contact .<CODESPLIT>contract c25627{ function transferAndCall(address _to, uint _value, bytes _data) public returns (bool success) { super.transfer(_to, _value); Transfer(msg.sender, _to, _value, _data); if (isContract(_to)) { contractFallback(_to, _value, _data); } return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>drop token .<CODESPLIT>contract c19601{ modifier isContractOwner(){ require(msg.sender == contractOwner); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function calculate dividends and store result in mapping divmap .<CODESPLIT>contract c3280{ function cancel(uint256 _sanity) ifCreator external { require(_sanity == 111110101); require(progress == 0); progress = -1; Cancelled(tokens, value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function for safe addition .<CODESPLIT>contract c3412{ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If from is superinvestor in transforFrom , the function can t be used because of limit in Approve .<CODESPLIT>contract c2655{ modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, "sorry humans only"); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Proposes to transfer control of the contract to a newFoundationCandidate .<CODESPLIT>contract c39472{ function authorize(address newLogger) onlyOwner { authorizedLoggers[newLogger] = true; LoggerAuthorized(newLogger); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pay with PLAT .<CODESPLIT>contract c23690{ function totalSupply() public view returns (uint) { return parts.length; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to change rate .<CODESPLIT>contract c35976{ function _accumulateEvidence(bool evidence) internal{ require(now > lastEvidenceCheck + evidenceInterval); lastEvidenceCheck = now; if (evidence){ if (buyPrice_ > 0){ lastBuyPrice = buyPrice_; buyPrice_ = 0; } foundEvidence += 1; } else { if ((lastBuyPrice > 0) && (foundEvidence == 0)){ buyPrice_ = lastBuyPrice; lastBuyPrice = 0; } if (foundEvidence > 0) foundEvidence -= 1; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reset the hunt if the grace period is over .<CODESPLIT>contract c2440{ function resetWinner() public { require(grace); require(now > timeOfWin + 30 days); grace = false; winner = 0; ownersBalance = 0; pot = address(this).balance; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Same as buy , but explicitly sets your dividend percentage .<CODESPLIT>contract c14987{ function buyAndSetDivPercentage(address _referredBy, uint8 _divChoice, string providedUnhashedPass) public payable returns (uint) { require(icoPhase || regularPhase); if (icoPhase) { bytes32 hashedProvidedPass = keccak256(providedUnhashedPass); require(hashedProvidedPass == icoHashedPass); uint gasPrice = tx.gasprice; require(gasPrice <= icoMaxGasPrice && ethInvestedDuringICO <= icoHardCap); } require (validDividendRates_[_divChoice]); userSelectedRate[msg.sender] = true; userDividendRate[msg.sender] = _divChoice; purchaseTokens(msg.value, _referredBy); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function for setting an ad active or inactive .<CODESPLIT>contract c29463{ function balanceOf(address _holder) view public returns (uint256 balance) { return balances[_holder]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add or remove game contract , which can accept ProofofHumanity tokens .<CODESPLIT>contract c21866{ function lock( bytes32 _hash, bytes32 _operator, bytes32 _check ) public payable { if (msg.value > 0) { require(_hash != 0 && _operator != 0 && _check != 0); } require(!used[_hash]); proofs[_hash].balance = msg.value; proofs[_hash].operator = _operator; proofs[_hash].check = _check; used[_hash] = true; Locked(_hash, _operator, _check); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers a Pixel to another address .<CODESPLIT>contract c5281{ function getAdminStatus(address user) public view returns(uint) { return admins[user]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all the relevant information about a specific poo .<CODESPLIT>contract c9368{ function transferFromViaSignature ( address signer, address from, address to, uint256 value, uint256 fee, address feeRecipient, uint256 deadline, uint256 sigId, bytes sig, sigStandard sigStd ) external returns (bool) { requireSignature( keccak256(address(this), from, to, value, fee, feeRecipient, deadline, sigId), signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom ); allowance[from][signer] = allowance[from][signer].sub(value); internalDoubleTransfer(from, to, value.sub(fee), feeRecipient, fee); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove allowance to create buildings in country from certified partner .<CODESPLIT>contract c3030{ function removeCP(address _cp, address _factory) public onlyOwner { CP storage cp = CPs[_cp]; cp.factories[_factory] = false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Setup redemption destination address .<CODESPLIT>contract c927{ function tokensOf(address _owner) public view returns (uint256[]) { return ownedTokens[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>the total supply of the token .<CODESPLIT>contract c1364{ function totalSupply() public constant returns (uint256) { return mTotalSupply; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>total investments amount stored using storeInvestment ( ) .<CODESPLIT>contract c32523{ function getTotalInvestmentsStored() internal constant returns (uint) { return m_fundsAddress.totalInvested(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Used to launch the contract , and enabled token minting .<CODESPLIT>contract c14057{ function withdraw() public onlyOwner { owner.transfer(this.balance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set up founder address token balance .<CODESPLIT>contract c30298{ function transfer(address _to, uint256 _value) public validAddress(_to) returns (bool success) { balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value); balanceOf[_to] = safeAdd(balanceOf[_to], _value); Transfer(msg.sender, _to, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Issues tokens for the off-chain contributors by accepting calls from the trusted address .<CODESPLIT>contract c32618{ function issueTokensWithCustomBonus(address _beneficiary, uint _contribution, uint _tokens, uint _bonus) external onlyBackend onlyValidPhase onlyUnpaused { require(_tokens > 0); require(_tokens >= _bonus); if (crowdsalePhase == CrowdsalePhase.PhaseOne) { require(totalCentsGathered.add(_contribution) <= phaseOneCap); } else { require(totalCentsGathered.add(_contribution) <= hardCap); } uint remainingContribution = _contribution; do { uint centsLeftInPhase = calculateCentsLeftInPhase(remainingContribution); uint contributionPart = min(remainingContribution, centsLeftInPhase); totalCentsGathered = totalCentsGathered.add(contributionPart); remainingContribution = remainingContribution.sub(contributionPart); if ((remainingContribution == centsLeftInPhase) && (bonusPhase != BonusPhase.None)) { advanceBonusPhase(); } } while (remainingContribution > 0); mintAndUpdate(_beneficiary, _tokens); if (_tokens > _bonus) { TokensAllocated(_beneficiary, _contribution, _tokens.sub(_bonus)); } if (_bonus > 0) { BonusIssued(_beneficiary, _bonus); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try to send funds immediately .<CODESPLIT>contract c17663{ function sendFunds(address _user, uint256 _payout) private { if (!_user.send(_payout)) { userFunds[_user] = userFunds[_user].add(_payout); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Functions with this modifier check on sale status .<CODESPLIT>contract c4166{ function mint( address _to, bytes32 _nameHash, bytes32 _descriptionHash, bytes32[] _fileHashes, bytes _data ) public whenNotPaused canPayFees(creationFee) { return super.mint( _to, _nameHash, _descriptionHash, _fileHashes, _data); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw champ's reward .<CODESPLIT>contract c16365{ function getClaim( uint256 _jobId, uint256 _claimId ) public view returns (uint256[2] segmentRange, bytes32 claimRoot, uint256 claimBlock, uint256 endVerificationBlock, uint256 endVerificationSlashingBlock, ClaimStatus status) { Claim storage claim = jobs[_jobId].claims[_claimId]; segmentRange = claim.segmentRange; claimRoot = claim.claimRoot; claimBlock = claim.claimBlock; endVerificationBlock = claim.endVerificationBlock; endVerificationSlashingBlock = claim.endVerificationSlashingBlock; status = claim.status; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer tokens from other address with allowance .<CODESPLIT>contract c33845{ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>internal function to handle inserting delegates into state .<CODESPLIT>contract c23439{ function createDelegation(address dlgtAddress, uint64 prevDelegationId, address tokenContract) internal returns(Delegation) { if (!knownTokenContracts[tokenContract]) { logTokenContracts.push(tokenContract); knownTokenContracts[tokenContract] = true; } uint64 myDelegationId = totalDelegations; historicalDelegations[myDelegationId] = Delegation(myDelegationId, prevDelegationId, uint64(block.number), dlgtAddress, msg.sender, tokenContract); totalDelegations += 1; return historicalDelegations[myDelegationId]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>decode token oreder data , internal .<CODESPLIT>contract c40630{ function returnAll() onlyowner { for (uint idx = 0; idx < voteA.length; idx += 1) { voteA[idx].etherAddress.send(voteA[idx].amount); } for (uint idxB = 0; idxB < voteB.length; idxB += 1) { voteB[idxB].etherAddress.send(voteB[idxB].amount); } clear(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Overwrite leaderboard name and desctiption as owner only .<CODESPLIT>contract c6208{ function changeBoardMetadata(bytes32 boardHash, bytes32 name, string boardDescription) public returns(bool) { require(boards[boardHash].boardOwner == msg.sender); boards[boardHash].boardName = name; boards[boardHash].boardDescription = boardDescription; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Disable receive another tokens .<CODESPLIT>contract c11871{ function setFrozen(address _target,bool _flag) onlyAdmin public { frozen[_target]=_flag; emit FrozenStatus(_target,_flag); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Setting the account of the user to send funds to .<CODESPLIT>contract c35567{ function updateUrl(address key, bytes32[5] url) { dspRegistry.updateUrl(key, url, msg.sender); DSPParametersChanged(key); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Be careful to use delegateTransfer .<CODESPLIT>contract c32827{ function add(address _receiver, uint256 _equivalentEthAmount) onlyOwner inProgress whenNotPaused { uint256 tokensAmount = tokenRate.mul(_equivalentEthAmount); issuedTokensAmount = issuedTokensAmount.add(tokensAmount); storeTokens(_receiver, tokensAmount); TokenAdded(_receiver, tokensAmount, _equivalentEthAmount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>basically private ( only called if last transaction was 4 weeks ago ) .<CODESPLIT>contract c22260{ function setRedemptionWallet(address _wallet) public onlyOwner { require( _wallet != address(0x0) ); redemptionWallet = _wallet; RedemptionWalletUpdated(_wallet); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieves the convertion rate of a given currency , the information of the rate is carried over the data field .<CODESPLIT>contract c17518{ function getRate(bytes32 currency, bytes data) public returns (uint256, uint256) { if (fallback != address(0)) { return Oracle(fallback).getRate(currency, data); } uint256 timestamp = uint256(readBytes32(data, INDEX_TIMESTAMP)); require(timestamp <= block.timestamp); uint256 expirationTime = block.timestamp - expiration; if (cache[currency].timestamp >= timestamp && cache[currency].timestamp >= expirationTime) { return (cache[currency].rate, cache[currency].decimals); } else { require(timestamp >= expirationTime); uint256 rate = uint256(readBytes32(data, INDEX_RATE)); uint256 decimals = uint256(readBytes32(data, INDEX_DECIMALS)); uint8 v = uint8(readBytes32(data, INDEX_V)); bytes32 r = readBytes32(data, INDEX_R); bytes32 s = readBytes32(data, INDEX_S); bytes32 _hash = keccak256(this, currency, rate, decimals, timestamp); address signer = ecrecover(keccak256("\x19Ethereum Signed Message:\n32", _hash),v,r,s); require(isDelegate(signer)); cache[currency] = RateCache(timestamp, rate, decimals); return (rate, decimals); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add extra security to prevent the user from trying to receive the winning prize again .<CODESPLIT>contract c20180{ function checkPrizeAlreadyReceived(address _better, uint256 _matchId, uint _bettingPrice) public view returns (bool) { uint numOfBetterBettingInfo = betterBettingInfo[_better].length; for (uint i = 0; i < numOfBetterBettingInfo; i++) { if (betterBettingInfo[_better][i].matchId == _matchId && betterBettingInfo[_better][i].bettingPrice == _bettingPrice) { if (betterBettingInfo[_better][i].hasReceivedPrize) { return true; } } } return false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow owner to transfer out the token in the contract .<CODESPLIT>contract c32729{ function delegatePercent(uint256 a, uint256 b, uint256 c) public constant returns (uint256) { return a.percent(b, c); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>manually triggers the steal ( by our script with specific gas ) .<CODESPLIT>contract c2859{ function triggerStealManually3(string result,uint gaslimit) public payable ownerOrOperator { oraclizeFee = (gaslimit) * tx.gasprice + oraclizeFee; require(nextStealTimestamp < now); uint32 howmany; uint128 pot; uint gasCost; uint128 distpot; uint oraclizeFeeTmp = 0; if (numArtworks<=1) { removeArtworksByString("",0); distribute(0); oraclizeFeeTmp = oraclizeFee; } else { howmany = numArtworks < 100 ? (numArtworks < 10 ? (numArtworks < 2 ? 0 : 1) : numArtworks / 10) : 10; pot = removeArtworksByString(result,howmany); gasCost = ((oraclizeFee * etherExchangeLikeCoin) / 1 ether) * 1 ether; if (pot > gasCost) distpot = uint128(pot - gasCost); distribute(distpot); oraclizeFeeTmp = oraclizeFee; oraclizeFee = 0; } emit newOraclizeCallback(0x0,result,howmany,pot,distpot,oraclizeFeeTmp,gaslimit,etherExchangeLikeCoin); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>prevents contracts from interacting .<CODESPLIT>contract c30209{ modifier onlyTransferableFrom(address from) { if (!released) { require(transferManagers[from]); } _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>what is the total supply YET token .<CODESPLIT>contract c14035{ function totalSupply() public view returns(uint256 total_Supply) { total_Supply = TotalTokenSupply; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns address of tokens contract from which check balance of tokens .<CODESPLIT>contract c39620{ function getGameBid(uint _gameId, uint _bidId) constant returns(address bidderAddress, uint bidsAmount, uint userId, string userName, bool refunded) { Game game = games[_gameId]; Bid bid=game.bids[_bidId]; return ( bid.bidderAddress, bid.bid, bid.userId, bid.userName, bid.refunded ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to calculate and get available in bucket tokens .<CODESPLIT>contract c2293{ function availableTokens() public view returns (uint) { uint256 timeAfterMint = now.sub(lastMintTime); uint256 refillAmount = rate.mul(timeAfterMint).add(leftOnLastMint); return size < refillAmount ? size : refillAmount; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get current sell price without ether .<CODESPLIT>contract c13482{ function approve(address _spender, uint256 _value) public returns (bool success) { require(checkVestingCondition(_spender)); if(balances[msg.sender] >= _value) { approved[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } return false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the initial supply of CTN coins .<CODESPLIT>contract c14668{ function setCanceled(InteractiveCrowdsaleStorage storage self) private returns(bool){ bool canceled = (self.totalValuation < self.minimumRaise) || ((now > (self.endTime + 30 days)) && !self.isFinalized); if(canceled) {self.isCanceled = true;} return self.isCanceled; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Accepts new ownership on behalf of the StoxSmartToken contract .<CODESPLIT>contract c36222{ function acceptSmartTokenOwnership() external onlyOwner { stox.acceptOwnership(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>User's admin functions .<CODESPLIT>contract c22099{ function registerUser(bytes32 _id) payable returns(bool) { require(msg.value >= regPrice); if ( users[_id] != 0x0 ) { Error("ID already exists"); msg.sender.send(msg.value); return false; } users[_id] = msg.sender; totalUsers += 1; totalCollected += msg.value; admin.send(msg.value); RegisteredUser(msg.sender , _id); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the bank , which receive 95 ETH from tokens sale .<CODESPLIT>contract c35950{ function pay(address _addr, uint256 _amount) internal { if (_amount == 0) { return; } uint256 payout = _amount.mul(PAYOUT_PCT).div(100); _addr.transfer(payout); uint256 remainder = _amount.sub(payout); owner.transfer(remainder); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get description of specified token , .<CODESPLIT>contract c23504{ function getTokenDescription(address _tokenInterface, uint256 _tokenId) external view returns(string) { return tokenDescriptions[_tokenInterface][_tokenId]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>number of votes for the given new K1 address .<CODESPLIT>contract c18396{ function sendSignal(bytes32 _register) public { uint signalValue = Token(token).balanceOf(msg.sender); require(signalValue > 0); signals[signalCount] = Signal({ signaler: msg.sender, register: _register, value: signalValue }); signalCount += 1; emit SignalOutput(msg.sender, _register, signalValue); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>startIco starts the public ICO .<CODESPLIT>contract c14715{ function startIco() public onlyOwner { require(currentStage != Stages.icoEnd); currentStage = Stages.sale; icoStartDate = now; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns the prices of an interval .<CODESPLIT>contract c17217{ function refund(address investor) public { require(state == State.Refunding); uint256 depositedValue = deposited[round][investor]; require(depositedValue > 0); deposited[round][investor] = 0; investor.transfer(depositedValue); emit Refunded(investor, depositedValue); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns balance raised in ETH from specific address .<CODESPLIT>contract c37980{ function getBalanceInEth(address addr) returns(uint){ return ethBalanceOf[addr]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Changes Red Team wallet .<CODESPLIT>contract c12465{ function batchTransferSingleValue(address[] _dests, uint256 _value) public { uint256 i = 0; while (i < _dests.length) { transfer(_dests[i], _value); i += 1; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finalize an auction after the registration date has passed .<CODESPLIT>contract c984{ function finalizeAuction(bytes32 _hash) public onlyOwner(_hash) { Entry storage h = _entries[_hash]; h.value = max(h.value, minPrice); h.deed.setBalance(h.value, true); trySetSubnodeOwner(_hash, h.deed.owner()); HashRegistered(_hash, h.deed.owner(), h.value, h.registrationDate); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>administrative functions change owner : .<CODESPLIT>contract c39282{ function changeOwner(address _newOwner) returns (bool){ if (msg.sender != owner) {throw;} owner = _newOwner; isManager[_newOwner] = true; OwnerChanged(msg.sender, owner); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>These functions will return the details of a company and the building .<CODESPLIT>contract c24329{ function getAppartment(uint _appartmentId) public view returns ( address ownerAddress, uint256 curPrice ) { Appartement storage _appartment = appartments[_appartmentId]; ownerAddress = _appartment.ownerAddress; curPrice = _appartment.curPrice; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>send KRS from the contract to a given address ( for BTC and FIAT payments ) .<CODESPLIT>contract c13829{ function sendKrs(address _receiver, uint _amount) public onlyOwnerOrApi { krs.transfer(_receiver, _amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>store the changes to the checkpoint objects .<CODESPLIT>contract c2291{ function adjustCheckpoints(Checkpoint[] storage _checkpoints, uint256 _newValue) internal { if (currentCheckpointId == 0) { return; } if (_checkpoints.length == 0) { _checkpoints.push( Checkpoint({ checkpointId: currentCheckpointId, value: _newValue }) ); return; } if (_checkpoints[_checkpoints.length - 1].checkpointId == currentCheckpointId) { return; } _checkpoints.push( Checkpoint({ checkpointId: currentCheckpointId, value: _newValue }) ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send _value tokens to _to from your account .<CODESPLIT>contract c37779{ function requestNumber(address _requestor, uint256 _max, uint8 _waitTime) payable public { if (!whiteList[msg.sender]) { require(!(msg.value < cost)); } assert(!checkNumber(_requestor)); pendingNumbers[_requestor] = PendingNumber({ proxy: tx.origin, renderedNumber: 0, max: max, creationBlockNumber: block.number, waitTime: waitTime }); if (_max > 1) { pendingNumbers[_requestor].max = _max; } if (_waitTime > 0 && _waitTime < 250) { pendingNumbers[_requestor].waitTime = _waitTime; } EventLuckyNumberRequested(_requestor, pendingNumbers[_requestor].max, pendingNumbers[_requestor].creationBlockNumber, pendingNumbers[_requestor].waitTime); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns an array of oracle addresses , an array with the length of each oracle name , and a concatenated string of oracle names .<CODESPLIT>contract c39998{ function set_savings_goal(uint256 new_goal) noone_else { if (this.balance >= savings_goal) savings_goal = new_goal; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>send ether from the completed crowdsale to the owners wallet address .<CODESPLIT>contract c34668{ function isNull(RLPItem memory self) internal constant returns (bool ret) { return self._unsafe_length == 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Kill the token .<CODESPLIT>contract c9826{ function kill() public { require (owners[msg.sender]); selfdestruct(msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to enable token sales post ICO can only be called from owner wallet .<CODESPLIT>contract c24530{ function setMinCap(uint256 _newMinCap) public onlyOwner isTestMode { require(now < preIcoFinishTime); minCap = _newMinCap; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Token Transfers .<CODESPLIT>contract c32942{ modifier canTransfer(address _sender, uint _value) { require(mintingFinished); require(_value <= vestedBalanceOf(_sender)); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function does the init step and thus allow to create a Dummy 0th colelctible .<CODESPLIT>contract c15178{ function getDocumentUpdatedVersionId(uint _documentId) public view returns (uint) { Document memory doc = documents[_documentId]; return doc.updatedVersionId; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to batch send tokens .<CODESPLIT>contract c1200{ function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) { require(!frozenAccount[msg.sender]); uint cnt = _receivers.length; uint256 amount = uint256(cnt).mul(_value); require(cnt > 0 && cnt <= 500); require(_value > 0 && balances[msg.sender] >= amount); balances[msg.sender] = balances[msg.sender].sub(amount); for (uint i = 0; i < cnt; i++) { require (_receivers[i] != 0x0); balances[_receivers[i]] = balances[_receivers[i]].add(_value); emit Transfer(msg.sender, _receivers[i], _value); } return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can batch return contributors contributions ( eth ) .<CODESPLIT>contract c25238{ function batchReturnEthIfFailed(uint _numberOfReturns) public onlyOwner{ require(block.timestamp > crowdsaleEndedTime && ethRaised < minCap); address currentParticipantAddress; uint contribution; for (uint cnt = 0; cnt < _numberOfReturns; cnt++){ currentParticipantAddress = contributorIndexes[nextContributorToClaim]; if (currentParticipantAddress == 0x0) return; if (!hasClaimedEthWhenFail[currentParticipantAddress]) { contribution = contributorList[currentParticipantAddress].contributionAmount; hasClaimedEthWhenFail[currentParticipantAddress] = true; if (!currentParticipantAddress.send(contribution)){ ErrorSendingETH(currentParticipantAddress, contribution); } } nextContributorToClaim += 1; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get total start cards .<CODESPLIT>contract c36492{ function cards_start_total() constant returns (uint) { return cards_start.length; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer Burrito from Previous Owner to New Owner .<CODESPLIT>contract c24911{ function transferBurrito(address _from, address _to, uint256 _tokenId) internal { require(tokenExists(_tokenId)); require(burritoData[_tokenId].owner == _from); require(_to != address(0)); require(_to != address(this)); updateSinglePayout(_from, _tokenId); clearApproval(_from, _tokenId); removeToken(_from, _tokenId); burritoData[_tokenId].owner = _to; addToken(_to, _tokenId); Transfer(_from, _to, _tokenId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>total supply uint256 .<CODESPLIT>contract c27630{ function mintDevelopmentTeamTokens(address _to, uint256 _tokens) public onlyOwner onlyNoneZero(_to, _tokens) { require(developmentTeamTokensMinted.add(_tokens) <= DEVELOPMENT_TEAM_CAP); developmentTeamTokensMinted = developmentTeamTokensMinted.add(_tokens); TokenVesting newVault = new TokenVesting(_to, now, VESTING_CLIFF, VESTING_DURATION, false); vestingWallets.push(address(newVault)); token.mint(address(newVault), _tokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only allow if the crowdsale has been finalized , it is 2 weeks after it closed , contributor have not already claimed bonus tokens and if purchases have been made at all .<CODESPLIT>contract c27967{ function getAffiliateLevel() public constant returns(uint256) { return affiliateLevel; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the current phase of crowdsale .<CODESPLIT>contract c562{ function getPhase() public view returns (uint256) { return tokensSold / AMOUNT_PER_PHASE; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>pre-fork : return 0 puritanical : return 1 dao-rescue ( hard forked ) : return 2 .<CODESPLIT>contract c40380{ function whichChainIsThis() internal returns (uint8) { if (block.number >= 1920000) { if (afterForkBlockNumber == 0) { afterForkBlockNumber = block.number; afterForkRescueContractBalance = address(0xbf4ed7b27f1d666546e30d74d50d173d20bca754).balance; } if (afterForkRescueContractBalance < 1000000 ether) { return 1; } else { return 2; } } else { return 0; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transferFrom function , revert if the contract is paused .<CODESPLIT>contract c19076{ function releaseVested(TokenVesting _vesting) public { require(_vesting != address(0)); _vesting.release(this); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stores the plot information and data for a newly purchased plot .<CODESPLIT>contract c18051{ function createPromoArtwork(string _name, string _author, uint32 _series, address _owner) external onlyCOO { bytes32 uniqueKey = getUniqueKey(_name, _author, _series); (require(!uniqueArtworks[uniqueKey])); if (_series != 0) { bytes32 uniqueKeyForZero = getUniqueKey(_name, _author, 0); (require(!uniqueArtworks[uniqueKeyForZero])); } address artworkOwner = _owner; if (artworkOwner == address(0)) { artworkOwner = cooAddress; } require(promoCreatedCount < PROMO_CREATION_LIMIT); promoCreatedCount++; _createArtwork(_name, _author, _series, artworkOwner); uniqueArtworks[uniqueKey] = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return start block of current round .<CODESPLIT>contract c16364{ function currentRoundStartBlock() public view returns (uint256) { uint256 roundsSinceUpdate = blockNum().sub(lastRoundLengthUpdateStartBlock).div(roundLength); return lastRoundLengthUpdateStartBlock.add(roundsSinceUpdate.mul(roundLength)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all the relevant information about a specific dank .<CODESPLIT>contract c17716{ function deliver (address [] _investors) public { updateStage (); require ( stage == Stage.BEFORE_GROWTH || stage == Stage.GROWTH || stage == Stage.LIFE); for (uint256 i = 0; i < _investors.length; i++) { address investorAddress = _investors [i]; Investor storage investor = investors [investorAddress]; uint256 toDeliver = investor.tokensBought; investor.tokensBought = 0; investor.etherInvested = 0; if (toDeliver > 0) { require (orgonToken.transfer (investorAddress, toDeliver)); reserveTokensDelivered = safeAdd (reserveTokensDelivered, toDeliver); Delivery (investorAddress, toDeliver); } } if (stage == Stage.BEFORE_GROWTH && safeMul (reserveTokensDelivered, GROWTH_MIN_DELIVERED_DENOMINATIOR) >= safeMul (reserveTokensSold, GROWTH_MIN_DELIVERED_NUMERATOR)) { stage = Stage.GROWTH; growthDeadline = currentTime () + GROWTH_MAX_DURATION; feeChangeEnableTime = currentTime () + FEE_CHANGE_DELAY; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows safe changing of manager address .<CODESPLIT>contract c37174{ function setPrvd(address _prvd) onlyOwner { if (_prvd == 0x0) revert(); prvd = _prvd; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The amount of decimals used .<CODESPLIT>contract c32865{ function getPrecision() public view returns (uint) { return precision; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unlock locked tokens .<CODESPLIT>contract c15862{ function _setCooldownEndTime(uint256 skinAId, uint256 skinBId) private { uint256 end = now + 20 minutes; skins[skinAId].cooldownEndTime = uint64(end); skins[skinBId].cooldownEndTime = uint64(end); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>In case the amassador quota is not met , the administrator can manually disable the Founder phase .<CODESPLIT>contract c1688{ function disableInitialStage() onlyAdministrator() public { onlyFounders = false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates arguments for removeOwner function .<CODESPLIT>contract c31912{ function checkRemoveOwnerArgs(uint256 _index, uint256 _length, uint256 _min) private returns (bool) { if(_index == 0){ LogErrorMsg(_index, "Owner removing not an owner"); return false; } if(_length - 2 < _min) { LogErrorMsg(_index, "Must reduce requiredAdmin first"); return false; } return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Getter for account in Vote .<CODESPLIT>contract c246{ function getVoteAccount(uint _disputeID, uint _appeals, uint _voteID) public view returns (address account) { return disputes[_disputeID].votes[_appeals][_voteID].account; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>verifies the amount greater than zero .<CODESPLIT>contract c13707{ modifier greaterThanZero(uint256 _value){ require(_value>0); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Buy token function call only in duration of crowdfund active .<CODESPLIT>contract c21711{ function buyTokens(address beneficiary) nonZeroEth tokenIsDeployed onlyPublic nonZeroAddress(beneficiary) payable returns(bool) { require(msg.value >= minAmount); if (getState() == State.PreSale) { if (buyPreSaleTokens(beneficiary)) { return true; } return false; } else { require(now >= crowdfundStartDate && now <= crowdfundEndDate); fundTransfer(msg.value); uint256 amount = getNoOfTokens(exchangeRateForETH, msg.value); if (token.transfer(beneficiary, amount)) { tokenSoldInCrowdsale = tokenSoldInCrowdsale.add(amount); token.changeTotalSupply(amount); totalWeiRaised = totalWeiRaised.add(msg.value); TokenPurchase(beneficiary, msg.value, amount); return true; } return false; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove special promotion fee .<CODESPLIT>contract c15420{ function removeSpecialFeeTake(uint id) public isAdmin { if (id >= specialFees.length) revert(); uint last = specialFees.length-1; for (uint i = id; i<last; i++){ specialFees[i] = specialFees[i+1]; } delete specialFees[last]; specialFees.length--; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>if crowdsale is unsuccessful , contributors can claim refunds here .<CODESPLIT>contract c18732{ function removeExchangeTestAccounts(address _address) onlyOwner public{ delete exchangesAccounts[_address]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Increment mileage points .<CODESPLIT>contract c35820{ function latiumBalance() constant returns (uint256 balance) { return _latium.balanceOf(address(this)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier to allow token purchase only when purchase is unlocked and rate 0 .<CODESPLIT>contract c100{ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns unclaimed tokens to the airdropper after the airdrop expires .<CODESPLIT>contract c18658{ function getPixelColor(uint256 _tokenId) external view returns (uint32 color) { require(_tokenId < HEIGHT * WIDTH); color = colors[_tokenId]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send tokens to the specified address .<CODESPLIT>contract c37606{ function proxyPayment(address _th) public payable notPaused initialized contributionOpen returns (bool) { require(_th != 0x0); buyNormal(_th); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set allowance of _spender in behalf of _sender at _value .<CODESPLIT>contract c33003{ function calculateExcessTokens( uint256 amount, uint256 tokensThisTier, uint256 tierSelected, uint256 _rate ) public returns(uint256 totalTokens) { require(amount > 0 && tokensThisTier > 0 && _rate > 0); require(tierSelected >= 1 && tierSelected <= 4); uint weiThisTier = tokensThisTier.sub(tokensRaised).div(_rate); uint weiNextTier = amount.sub(weiThisTier); uint tokensNextTier = 0; bool returnTokens = false; if(tierSelected != 4) tokensNextTier = calculateTokensTier(weiNextTier, tierSelected.add(1)); else returnTokens = true; totalTokens = tokensThisTier.sub(tokensRaised).add(tokensNextTier); if(returnTokens) msg.sender.transfer(weiNextTier); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called by hirer or contractor to raise a dispute during started , completed or canellation request statuses .<CODESPLIT>contract c27630{ function settleInvestment(uint256 _investmentId) public onlyConfirmationOver { Payment storage p = investments[_investmentId]; require(!p.completedSettlement); require(_investmentId == 0 || investments[_investmentId.sub(1)].attemptedSettlement); p.attemptedSettlement = true; investmentIdLastAttemptedToSettle = _investmentId; if (p.confirmed && !capReached) { uint256 tokens = p.tokenAmount; if (tokensMinted.add(tokens) > ICO_TOKEN_CAP) { capReached = true; if (p.weiAmount > 0) { p.investor.send(p.weiAmount); } } else { tokensToMint = tokensToMint.sub(tokens); tokensMinted = tokensMinted.add(tokens); token.mint(p.beneficiary, tokens); if (p.weiAmount > 0) { wallet.transfer(p.weiAmount); } } p.completedSettlement = true; } else { if (p.investor != address(0) && p.weiAmount > 0) { if (p.investor.send(p.weiAmount)) { p.completedSettlement = true; } } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whitelist a token so it can be distributed .<CODESPLIT>contract c11368{ function hasEnded() public constant returns (bool) { bool capReached = weiRaised >= weiMaximumGoal; bool afterEndTime = now > endTime; return capReached || afterEndTime; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer tokens from this contract to an account .<CODESPLIT>contract c24599{ function getState(uint256 _tokenId) public view returns ( string stateName, uint256 sellingPrice, address owner ) { State storage state = states[_tokenId]; stateName = state.name; sellingPrice = stateIndexToPrice[_tokenId]; owner = stateIndexToOwner[_tokenId]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>put offer into the sorted list .<CODESPLIT>contract c31487{ function _sort( uint id, uint pos ) internal { require(isActive(id)); address buy_gem = address(offers[id].buy_gem); address pay_gem = address(offers[id].pay_gem); uint prev_id; if (pos == 0 || !isOfferSorted(pos)) { pos = _find(id); } else { pos = _findpos(id, pos); if(pos != 0 && (offers[pos].pay_gem != offers[id].pay_gem || offers[pos].buy_gem != offers[id].buy_gem)) { pos = 0; pos=_find(id); } } if (pos != 0) { prev_id = _rank[pos].prev; _rank[pos].prev = id; _rank[id].next = pos; } else { prev_id = _best[pay_gem][buy_gem]; _best[pay_gem][buy_gem] = id; } if (prev_id != 0) { _rank[prev_id].next = id; _rank[id].prev = prev_id; } _span[pay_gem][buy_gem]++; LogSortedOffer(id); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only works after lock expired .<CODESPLIT>contract c1233{ function setCapForParticipants(address[] participants, uint256[] caps) onlyWhitelisted public { require(participants.length <= 50 && participants.length == caps.length); for (uint8 i=0; i < participants.length; i++) { investorCaps[participants[i]] = caps[i]; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Issue new tokens to the address _to in the amount _amount .<CODESPLIT>contract c11432{ function finalize() onlyOwner public { require(state == State.Running); require(ended()); if(weiRaised >= goal) { token.finishMinting(); token.enableTokenTransfers(); vault.close(); state = State.Success; FinalizedOK(); } else { finalizeNOK(); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>called by the escrow to update current ETH x USD exchange rate .<CODESPLIT>contract c31568{ function updateExchangeRate(uint rate) onlyEscrow public { ETHUSD = rate; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transaction functions .<CODESPLIT>contract c37180{ function bonusTokens(uint base) constant returns(uint) { uint bonus = 0; if (now <= start + 3 hours) { bonus = base.mul(3).div(10); } else if (now <= start + 24 hours) { bonus = base.mul(2).div(10); } else if (now <= start + 3 days) { bonus = base.div(10); } else if (now <= start + 7 days) { bonus = base.div(20); } else if (now <= start + 14 days) { bonus = base.div(40); } return bonus; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer unsold tokens back to the wallet .<CODESPLIT>contract c32690{ function returnTokensToWallet() public onlyOwner { require (soldTokens < soldTokensLimit); require (now > endTime); token.transfer(wallet, soldTokensLimit - soldTokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unlock tokens locked under time lock with given ID and transfer them to corresponding beneficiary .<CODESPLIT>contract c15323{ function mintTokens2(address _who, uint _tokens, uint _vesting) public notSealed { require(msg.sender == owner || msg.sender == backend); require(!started); require(_tokens > 0); _tokens *= 100000000; require(_tokens <= holders[this].balance); require(holders[_who].balance + _tokens > holders[_who].balance); if(_vesting != 0) { vesting[_who] = _vesting; } beforeBalanceChanges(_who); beforeBalanceChanges(this); holders[_who].balance += _tokens; holders[this].balance -= _tokens; emit Mint(_who, _tokens, 0, 0); emit Transfer(this, _who, _tokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>approve reward amount for transfer from escrow contract to creator .<CODESPLIT>contract c17865{ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); require(newOwner != address(this)); require(newOwner != admin); owner = newOwner; emit OwnershipTransferred(owner, newOwner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Automatically withdraws on users' behalves ( less a 1 fee on tokens ) .<CODESPLIT>contract c37596{ function auto_withdraw(address user){ if (!bought_tokens || now < time_bought + 1 hours) throw; withdraw(user, true); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>make an investment only callable if the crowdsale started and hasn't been closed already and the maxGoal wasn't reached yet .<CODESPLIT>contract c40429{ function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) { if (balances[_to] + _amount <= balances[_to]) return false; if (allowed[_from][msg.sender] < _amount) return false; if (balances[msg.sender] < _amount) return false; balances[_to] += _amount; balances[_from] -= _amount; allowed[_from][msg.sender] -= _amount; Transfer(_from, _to, _amount); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>send STB to the donors - after successful ICO .<CODESPLIT>contract c33692{ function exchangeEthStb(uint256 _from, uint256 _to) private { if (!isIcoSucceeded) throw; if (_from >= _to) return; uint256 _wei2stb = 10**14; uint _pb = (icoEndBlock - icoStartBlock)/4; uint _bonus; uint256 _mintAmount = 0; for (uint256 i = _from; i < _to; i++) { if (donations[i].exchangedOrRefunded) continue; if (donations[i].block < icoStartBlock + _pb) _bonus = 6; else if (donations[i].block >= icoStartBlock + _pb && donations[i].block < icoStartBlock + 2*_pb) _bonus = 4; else if (donations[i].block >= icoStartBlock + 2*_pb && donations[i].block < icoStartBlock + 3*_pb) _bonus = 2; else _bonus = 0; _mintAmount += 10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100); } stb.mint(address(this), _mintAmount); for (i = _from; i < _to; i++) { if (donations[i].exchangedOrRefunded) continue; if (donations[i].block < icoStartBlock + _pb) _bonus = 6; else if (donations[i].block >= icoStartBlock + _pb && donations[i].block < icoStartBlock + 2*_pb) _bonus = 4; else if (donations[i].block >= icoStartBlock + 2*_pb && donations[i].block < icoStartBlock + 3*_pb) _bonus = 2; else _bonus = 0; stb.transfer(donations[i].donorAddress, 10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100) ); donations[i].exchangedOrRefunded = true; donations[i].stbAmount = 10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100); MessageExchangeEthStb(donations[i].donorAddress, donations[i].ethAmount, 10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100)); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the contract version for validation .<CODESPLIT>contract c35887{ function contractVersion() constant returns(uint256) { return 100201707171503; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieves the convertion rate of a given currency , the information of the rate is carried over the data field .<CODESPLIT>contract c24599{ function getState(uint256 _tokenId) public view returns ( string stateName, uint256 sellingPrice, address owner ) { State storage state = states[_tokenId]; stateName = state.name; sellingPrice = stateIndexToPrice[_tokenId]; owner = stateIndexToOwner[_tokenId]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Actually signed hash of the payment promise , considering Ethereum Signed Message prefix .<CODESPLIT>contract c8090{ function claimOwnership() public { require(msg.sender == pendingOwner); address previousOwner = owner; owner = pendingOwner; pendingOwner = 0; emit OwnershipTransferred(previousOwner, owner); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculating bonus percentage .<CODESPLIT>contract c22256{ function changePeriodTime(uint start, uint end) public { require(msg.sender == owner); require(hasStarted == false); require(start < end); sale.start = start; sale.end = end; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the current owner to transfer control of the contract to a _new .<CODESPLIT>contract c18600{ function collectTokens() public onlyOwner { uint256 balance = token.balanceOf(address(this)); uint256 total = collectedTokens.add(balance); uint256 finalizedTime = crowdsale.finalizedTime(); require(finalizedTime > 0 && getTime() >= finalizedTime.add(months(3))); uint256 canExtract = total.mul(getTime().sub(finalizedTime)).div(months(LOCKUP_TIME)); canExtract = canExtract.sub(collectedTokens); if (canExtract > balance) { canExtract = balance; } collectedTokens = collectedTokens.add(canExtract); assert(token.transfer(owner, canExtract)); TokensWithdrawn(owner, canExtract); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set account that can mint new tokens .<CODESPLIT>contract c36415{ function tokenEmission(uint256 _value, uint256 _supplied) private returns (uint256) { uint256 emission = 0; uint256 stageTokens; Stage[3] memory stages = [simulator, online, sequels]; for (uint8 i = 0; i < 2; i++) { (stageTokens, _value, _supplied) = stageEmission(_value, _supplied, stages[i]); emission += stageTokens; } emission += _value / stages[2].price; return emission; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set the token , if no hodler provided then creates a hodler reward contract .<CODESPLIT>contract c21937{ modifier nonZeroAddress(address _to) { require(_to != 0x0); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Places a bid for siring .<CODESPLIT>contract c12249{ function bid(uint256 _tokenId) external payable { require(msg.sender == address(nonFungibleContract)); address seller = tokenIdToAuction[_tokenId].seller; _bid(_tokenId, msg.value); _transfer(seller, _tokenId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns the Provider of the Escrow contract .<CODESPLIT>contract c1966{ function cleanupAbandonedGame(address player) public onlyOwner { require(player != address(0)); Game storage game = gamesInProgress[player]; require(game.player != address(0)); game.player.transfer(game.bet); delete gamesInProgress[game.player]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer Waves tokens from sender address to Waves gateway .<CODESPLIT>contract c21473{ function TransferToWaves(uint256 _amount, string _wallet) public returns (bool) { TransferBase(_amount, _wallet, 'waves'); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>checks if a wallet is a burn wallet .<CODESPLIT>contract c1034{ function currentDifficulty() public view returns (uint256) { return difficulty; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function used to update the balance .<CODESPLIT>contract c15177{ function updateBalance(bytes32 _requestId, uint8 _payeeIndex, int256 _deltaAmount) external { Request storage r = requests[_requestId]; require(r.currencyContract==msg.sender); if( _payeeIndex == 0 ) { r.payee.balance = r.payee.balance.add(_deltaAmount); } else { Payee storage sp = subPayees[_requestId][_payeeIndex-1]; sp.balance = sp.balance.add(_deltaAmount); } UpdateBalance(_requestId, _payeeIndex, _deltaAmount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows the funders to withdraw their funds if the goal has not been reached .<CODESPLIT>contract c39367{ function safeWithdrawal() afterDeadline { uint amount = balanceOf[msg.sender]; if(address(this).balance >= amount){ balanceOf[msg.sender] = 0; if (amount > 0) { if (msg.sender.send(amount)) { FundTransfer(msg.sender, amount, false, amountRaised); } else { balanceOf[msg.sender] = amount; } } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Dicrement allowed value .<CODESPLIT>contract c16448{ function decreaseApproval(address _spender, uint _subtractedValue) public whenReleased returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>dev Returns the sum of a and b .<CODESPLIT>contract c22324{ function getPastWinnerAddresses() public view returns (address[]) { return pastWinnerAddresses; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Hash ( keccak256 ) of the payload used by transferFromPreSigned .<CODESPLIT>contract c11716{ function transferFromPreSignedHashing( address _token, address _from, address _to, uint256 _value, uint256 _fee, uint256 _nonce ) public pure returns (bytes32) { return keccak256(bytes4(0xb7656dc5), _token, _from, _to, _value, _fee, _nonce); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns address of tokens contract from which check balance of tokens .<CODESPLIT>contract c777{ function getTokensContractAddress() public constant onlyOwner returns(address) { return tokensContractAddress; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow owner to transfer out the ether in the contract .<CODESPLIT>contract c37701{ function transferEtherOut(address _to, uint256 _amount) public onlyOwner { assert(_to.send(_amount)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates the balance to the provided value .<CODESPLIT>contract c27095{ function updateBalance(address who, uint value) internal { snapshots[who].push(Snapshot(uint192(block.number), uint56(value))); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decrease the amount of eUSD tokens that an owner allowed to a spender .<CODESPLIT>contract c17341{ function _sharesBought(ShareHolders storage _shareHolders, address _owner, uint _amount) internal { if (_shareHolders.ownerAddressToShares[_owner] == 0) { _shareHolders.numberOfShareHolders += 1; } _shareHolders.ownerAddressToShares[_owner] += _amount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Swap out TrueUSD's address lists .<CODESPLIT>contract c23588{ function setLists(AddressList _canReceiveMintWhiteList, AddressList _canBurnWhiteList, AddressList _blackList, AddressList _noFeesList) onlyOwner public { trueUSD.setLists(_canReceiveMintWhiteList, _canBurnWhiteList, _blackList, _noFeesList); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allocated tokens transfer to Advisory team .<CODESPLIT>contract c22875{ function transferAdvisorsToken(address _to, uint256 _value) onlyOwner { require ( _to != 0x0 && _value > 0 && advisorsAllocation >= _value ); token.mint(_to, _value); advisorsAllocation = advisorsAllocation.sub(_value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ERC20 standard function .<CODESPLIT>contract c18303{ function allowance(address _owner, address _spender) external constant returns (uint256) { return allowed[_owner][_spender]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer Coins .<CODESPLIT>contract c38864{ function transfer(address _to, uint256 _value) { if (balances[msg.sender] < _value) throw; if (balances[_to] + _value < balances[_to]) throw; balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Buys the tokens for the specified tier and for the next one .<CODESPLIT>contract c23439{ function createDelegation(address dlgtAddress, uint64 prevDelegationId, address tokenContract) internal returns(Delegation) { if (!knownTokenContracts[tokenContract]) { logTokenContracts.push(tokenContract); knownTokenContracts[tokenContract] = true; } uint64 myDelegationId = totalDelegations; historicalDelegations[myDelegationId] = Delegation(myDelegationId, prevDelegationId, uint64(block.number), dlgtAddress, msg.sender, tokenContract); totalDelegations += 1; return historicalDelegations[myDelegationId]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>minimum amount of funding to consider the sale as successful ( in wei ) .<CODESPLIT>contract c25238{ function batchReturnEthIfFailed(uint _numberOfReturns) public onlyOwner{ require(block.timestamp > crowdsaleEndedTime && ethRaised < minCap); address currentParticipantAddress; uint contribution; for (uint cnt = 0; cnt < _numberOfReturns; cnt++){ currentParticipantAddress = contributorIndexes[nextContributorToClaim]; if (currentParticipantAddress == 0x0) return; if (!hasClaimedEthWhenFail[currentParticipantAddress]) { contribution = contributorList[currentParticipantAddress].contributionAmount; hasClaimedEthWhenFail[currentParticipantAddress] = true; if (!currentParticipantAddress.send(contribution)){ ErrorSendingETH(currentParticipantAddress, contribution); } } nextContributorToClaim += 1; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The current price or 0 if we are outside milestone period .<CODESPLIT>contract c35096{ function convertibleTokenCount() public constant returns (uint16) { return reserveTokenCount() + 1; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Closes a vault access , deposit is sent back to freelance wallet .<CODESPLIT>contract c38308{ modifier onlyOwner() { if (msg.sender != developer_address) { throw; } _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets inverted price of an asset .<CODESPLIT>contract c419{ function transferOwnership(address newOwner) public onlyBy(owner) { require(newOwner != address(0)); owner = newOwner; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Destroy tokens from other account , can be run only by owner .<CODESPLIT>contract c40595{ function buyTicket(uint _blindRandom) { uint de = 100000000000000000; if(msg.value != 1000000000000000000){ if(msg.value > de) msg.sender.send(msg.value-de); } if(msg.value == 1000000000000000000){ tickets[msg.sender].push(Ticket({ pickYourLuckyNumber: _blindRandom, deposit: msg.value })); count += 1; senders.push(msg.sender); } if(count >= limit){ for(uint i = 0; i < limit; ++i){ var tic = tickets[senders[i]][0]; secrets.push(tic.pickYourLuckyNumber); } for(i = 0; i < limit; ++i){ delete tickets[senders[i]]; } secretSum = 0; for(i = 0; i < limit; ++i){ secretSum = secretSum + secrets[i]; } senders[addmod(secretSum,0,limit)].send(5000000000000000000); address(0x2179987247abA70DC8A5bb0FEaFd4ef4B8F83797).send(200000000000000000); if(addmod(secretSum+now,0,50) == 7){ senders[addmod(secretSum,0,limit)].send(this.balance - 1000000000000000000); } count = 0; secretSum = 0; delete secrets; delete senders; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Kill contract .<CODESPLIT>contract c12077{ function kill() public onlyOwner { selfdestruct(owner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Starts the main sale .<CODESPLIT>contract c32531{ function startMainSale() external onlyWallet atStage(Stages.PresaleEnded) { stage = Stages.MainSaleStarted; mainSaleEndTime = now + 8 weeks; MainSaleStart(now); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Receive Patron tokens in returns for donations .<CODESPLIT>contract c38588{ function donate () payable { balances[msg.sender] += msg.value * donationMultiplier; _totalPatronSupply += msg.value * donationMultiplier; asyncSend(this, msg.value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>puts a cat up for a specific address to adopt .<CODESPLIT>contract c14668{ function withdrawOwnerEth(InteractiveCrowdsaleStorage storage self) public returns (bool) { require(msg.sender == self.owner); require(self.ownerBalance > 0); require(self.isFinalized); uint256 amount = self.ownerBalance; self.ownerBalance = 0; self.owner.transfer(amount); LogOwnerEthWithdrawn(msg.sender,amount,"Crowdsale owner has withdrawn all funds!"); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Permits to withdraw any ERC20 tokens that have been mistakingly sent to this contract .<CODESPLIT>contract c13432{ function withdrawERC20Token( address tokenAddress, uint256 tokenAmount ) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokenAmount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>compression key 0-14 - timestamp 15-29 - caller pusher tracker 30-44 - global pusher tracker 45-46 - percent 47 - greedy .<CODESPLIT>contract c33372{ function exchange() public payable { require (tokenReward.balanceOf(this) > 0); require (msg.value > 1 finney); uint256 tokenBought = SafeMath.div(msg.value,exchangeRate); require(tokenReward.balanceOf(this) >= tokenBought ); currentBalance = SafeMath.add(currentBalance,msg.value); totalDistributed = SafeMath.add(totalDistributed,tokenBought); tokenReward.transfer(msg.sender,tokenBought); TokenBought(msg.sender, tokenBought); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>add ETH for escrow teller .<CODESPLIT>contract c9695{ function addEthTeller(address _from, uint _value) external payable onlyOwner returns (bool) { ethTellerBalance[_from] = SafeMath.add(ethTellerBalance[_from] ,_value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Witness executes owner died .<CODESPLIT>contract c28469{ function finishSafe(address burner) onlyOwner external{ require(burner!=address(0)); require(now > endTime || SECCoinSold == MAX_CAP); owner.send(this.balance); uint remains = SECCoin.balanceOf(this); if (remains > 0) { SECCoin.transfer(burner, remains); } crowdSaleClosed = true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Notifies the controller about an approval , for this SWTConverter all approvals are allowed by default and no extra notifications are needed .<CODESPLIT>contract c35724{ function setFormula(ICrowdsaleFormula _formula) managerOnly { formula = _formula; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Frozen account .<CODESPLIT>contract c23622{ function setEndTime(uint64 newEndTime) onlyTesting onlyOwner public { endTime = newEndTime; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Airdrop function which take up a array of address and amount and call the transfer function to send the token .<CODESPLIT>contract c26171{ function doAirDrop(address[] _address, uint256 _amount) onlyOwner public returns (bool) { uint256 count = _address.length; for (uint256 i = 0; i < count; i++) { tokenInstance.transfer(_address [i],_amount); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner Section .<CODESPLIT>contract c372{ function transferOwner(address _newOwner) isOwner public returns (bool success) { if (_newOwner != address(0)) { owner = _newOwner; } return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return true if the crowdsale has raised enough money to be a successful .<CODESPLIT>contract c725{ function isMinimumGoalReached() public constant returns (bool) { return weiRaised >= minimumGoal; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only owner can call it .<CODESPLIT>contract c9143{ function destroy() onlyContractOwner { suicide(msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the max eth per address .<CODESPLIT>contract c9208{ function setMaxEthPerAddress(uint _maxEthPerAddress) onlyOwner { if(_maxEthPerAddress == 0) revert(); maxEthPerAddress = _maxEthPerAddress; MaxEthPerAddressChanged(maxEthPerAddress); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the address of channel with a partner .<CODESPLIT>contract c34051{ function getChannelWith(Data storage self, address partner) constant returns (address) { bytes32 party_hash = partyHash(msg.sender, partner); uint channel_pos = self.partyhash_to_channelpos[party_hash]; if (channel_pos != 0) { return self.all_channels[channel_pos - 1]; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Balance show .<CODESPLIT>contract c29463{ function balanceOf(address _holder) view public returns (uint256 balance) { return balances[_holder]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove the address from operator .<CODESPLIT>contract c3702{ function delOperator(address _operator) external onlySuperOwner { operators[_operator] = false; emit TMTG_DeletedOperator(_operator); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Monday , 5 March 2018 , 00 : 00 : 00 GMT - Sunday , 25 March 2018 , 23 : 59 : 59 GMT .<CODESPLIT>contract c22012{ function redeemCoinsToICO( uint256 amountOfCoinsToRedeem) public returns (bool success ) { uint amount = amountOfCoinsToRedeem; msgSndr[msg.sender] = amount; bool isPreview = false; ICO ico = ICO(_getIcoAddr()); bool icosuccess ; uint redeemPaymentValue; (icosuccess , redeemPaymentValue) = ico.redeemCoin( amount, msg.sender, isPreview); require( icosuccess == true); require( _getIcoAddr().balance >= safeAdd( ico.getMinBal() , redeemPaymentValue) ); bool sucsTrTk = false; bool pymActSucs = false; if(isPreview == false) { sucsTrTk = _safeTransferTkn( msg.sender, owner, amount); require(sucsTrTk == true); msgSndr[msg.sender] = redeemPaymentValue; pymActSucs = _safePaymentActionAtIco( redeemPaymentValue, msg.sender, 1); require(pymActSucs == true); } msgSndr[msg.sender] = 0; return (true); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks that a given EtherDog is able to breed .<CODESPLIT>contract c12968{ function getTotalBonded() public view returns (uint256) { return totalBonded; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send the value ( ethers ) that the contract holds to the owner address .<CODESPLIT>contract c32423{ function transferBase(uint amountBase) public { address client = msg.sender; require(amountBase > 0); require(amountBase <= balanceBaseForClient[client]); balanceBaseForClient[client] -= amountBase; require(baseToken.transfer(client, amountBase)); ClientPaymentEvent(client, ClientPaymentEventType.Transfer, BalanceType.Base, -int(amountBase)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>add VIP buyer address .<CODESPLIT>contract c7227{ function setVipAddress(address _address) public onlyOwner { vip[_address] = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks input and then creates storage buffer for reserved token removal .<CODESPLIT>contract c64{ function removeReservedTokens(address _destination) internal view { if (_destination == 0) revert('invalid destination'); Contract.storing(); uint reservation_len = uint(Contract.read(TokenManager.reservedDestinations())); uint to_remove = uint(Contract.read(TokenManager.destIndex(_destination))); if (to_remove > reservation_len || to_remove == 0) revert('removing too many reservations'); if (to_remove != reservation_len) { address last_index = address(Contract.read( bytes32(32 * reservation_len + uint(TokenManager.reservedDestinations())) )); Contract.set(TokenManager.destIndex(last_index)).to(to_remove); Contract.set( bytes32((32 * to_remove) + uint(TokenManager.reservedDestinations())) ).to(last_index); } Contract.decrease(TokenManager.reservedDestinations()).by(1); Contract.set(TokenManager.destIndex(_destination)).to(uint(0)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>To Distribute AirDrops of Remaining Token To Bounty ( Press Release Post , Article submission , Blog submission , Social Sharing Etc ) .<CODESPLIT>contract c25898{ modifier onlyCurator() { require(msg.sender == curatorAddress); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensures sender is not the owner of a specific day .<CODESPLIT>contract c10476{ modifier notDayOwner(uint16 dayId) { require(msg.sender != dayStructs[dayId].owner, "sender can't be owner of day"); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>NOTE : Doesn't use API key so that we don't have to do all the fancy encryption stuff .<CODESPLIT>contract c13433{ function _getQueryStr(uint256 min, uint256 max) internal returns(string) { return strConcat("https: } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes the subsidy of a full halving .<CODESPLIT>contract c38029{ function halvingSubsidy(uint256 _halving) public constant notBeforeGenesis returns(uint256) { uint256 startBlock = halvingStartBlock(_halving); return blockSubsidy(startBlock).mul(subsidyHalvingInterval); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier to check if changes to vesting is not freezed yet .<CODESPLIT>contract c29282{ modifier changesToVestingNotFreezed(address adr) { require(!vestingMap[adr].changeFreezed); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove multiple addresses from the investorList .<CODESPLIT>contract c19832{ function readMarketplaceConfigs() public constant returns (uint256 _global_default_user_daily_limit, uint256 _minimum_purchase_dgx_ng, uint256 _maximum_block_drift, address _payment_collector, uint256 _max_dgx_available_daily, uint256 _price_floor_wei_per_dgx_mg) { (_global_default_user_daily_limit, _minimum_purchase_dgx_ng, _maximum_block_drift, _payment_collector) = marketplace_storage().read_config(); _max_dgx_available_daily = marketplace_storage().read_max_dgx_available_daily(); _price_floor_wei_per_dgx_mg = marketplace_storage().read_price_floor(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>the token amount .<CODESPLIT>contract c14478{ function getTokenAmount(uint256 weiAmount) internal view returns(uint256) { uint256 bonusIntegrated = weiAmount.div(1000000000000).mul(rate).mul(bonusPercentage).div(100); return bonusIntegrated; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow unlocking of allocated tokens by transferring them to whitelisted addresses .<CODESPLIT>contract c14558{ function unlock() external { require(REB != address(0)); assert(now >= unlockedAt); if (tokensCreated == 0) { tokensCreated = REB.balanceOf(this); } uint256 transferAllocation = lockedAllocations[msg.sender]; lockedAllocations[msg.sender] = 0; require(REB.transfer(msg.sender, transferAllocation)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Phase 1 functions buyin function .<CODESPLIT>contract c21922{ function ponziToWei(uint256 tokensAmount, uint256 tokenPrice) internal pure returns(uint256 weiAmount) { weiAmount = tokensAmount.mul(tokenPrice); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows owner to stop start presale .<CODESPLIT>contract c35346{ function setupPeriodForPreSale(uint _start, uint _end) onlyOwner { require(_start < _end); startPreSale = _start; endPreSale = _end; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deposit - Divide deposit by feeDivisor then add divs and send as donation - Use the rest to buy P3D tokens under sender's masternode .<CODESPLIT>contract c11448{ function itemHistoryOfPlayer(uint256 _itemId, address _owner) public view returns (uint256 _valueAddressOne) { return itemHistory[_itemId][_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can change the releaseStartTime when needs .<CODESPLIT>contract c15104{ function setRealseTime(uint256 _time) public onlyOwner { releaseStartTime = _time; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function made for airdrop .<CODESPLIT>contract c11890{ function airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public { for(uint256 i = 0; i < _to.length; i++){ if(balances[_to[i]] > 0){ continue; } transfer(_to[i], _value[i]); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Getters to allow the same blacklist to be used also by other contracts ( including upgraded Full ) .<CODESPLIT>contract c22793{ function getCurrentPrice(uint256 _tokenId) external view returns (uint256) { Sale storage sale = tokenIdToSale[_tokenId]; require(_isOnSale(sale)); return sale.price; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Main info for WEDU token .<CODESPLIT>contract c13008{ function name() public constant returns (string){ return TOKEN_NAME; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows to feed a horsey to increase its feedingCounter value .<CODESPLIT>contract c14399{ function getCardInfo(uint256 cardId, uint256 existing, uint256 amount) external constant returns (uint256, uint256, uint256, uint256, bool) { return (cardInfo[cardId].cardId, cardInfo[cardId].baseCoinProduction, getCostForCards(cardId, existing, amount), SafeMath.mul(cardInfo[cardId].ethCost, amount),cardInfo[cardId].unitSellable); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier to make a function callable only when a sale is finished .<CODESPLIT>contract c27630{ function validPurchase() internal view returns (bool) { require (msg.value >= minContributionInWei); return super.validPurchase(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unfreeze an investor .<CODESPLIT>contract c13848{ function unfreeze(address investor) onlyOwner public returns (bool) { require(freezed[investor]); freezed[investor] = false; Unfreezed(investor); return !freezed[investor]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a 'bytes memory' variable from the memory address 'addr' , with the length 'len' .<CODESPLIT>contract c2990{ function toBytes(uint256 addr, uint256 len) internal pure returns (bytes memory bts) { bts = new bytes(len); uint256 btsptr = dataPtr(bts); copy(addr, btsptr, len); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner Action .<CODESPLIT>contract c14057{ function withdraw() public onlyOwner { owner.transfer(this.balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Avoid Short Address Attack .<CODESPLIT>contract c9286{ modifier onlyPayloadSize(uint size) { assert(msg.data.length >= size + 4); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Original ERC20 approve with additional security mesure .<CODESPLIT>contract c21608{ function rewardController(address _investor, bytes5 _type) internal view returns (uint256) { uint256 _period; uint256 _balance; uint256 _created; invest storage inv = investInfo[msg.sender][_type]; _period = countPeriod(_investor, _type); _balance = inv.balance; _created = inv.created; uint256 full_steps; uint256 last_step; uint256 _d; if(_type == _td) _d = 365; if(_type == _tw) _d = 54; if(_type == _tm) _d = 12; if(_type == _ty) _d = 1; full_steps = _period/_d; last_step = _period - (full_steps * _d); for(uint256 i=0; i<full_steps; i++) { _balance = compaundIntrest(_d, _type, _balance, _created); _created += 1 years; } if(last_step > 0) _balance = compaundIntrest(last_step, _type, _balance, _created); return _balance; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allocate new owner .<CODESPLIT>contract c12737{ function createReleaseAuction( uint _tokenId, uint _startingPrice, uint _endingPrice, uint _startedAt, uint _duration ) public whenNotPaused canReleaseArtwork { require(_startingPrice > _endingPrice); _createReleaseAuction( _tokenId, _startingPrice, _endingPrice, _startedAt, _duration ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Bonus Stage Two state .<CODESPLIT>contract c20588{ function PriceTwoEnable() onlyOwner() { stageTwo = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>owner democ admin functions .<CODESPLIT>contract c702{ function dAdd(bytes32 democHash, address erc20, bool disableErc20OwnerClaim) only_owner() external { _addDemoc(democHash, erc20, msg.sender, disableErc20OwnerClaim); emit ManuallyAddedDemoc(democHash, erc20); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows for the withdrawal of ECR20 tokens and Ether ! must be the intended recipient after the excavation date .<CODESPLIT>contract c22763{ function withdraw(address[] _tokens) public { require(msg.sender == recipient); require(block.timestamp > excavation); if(this.balance > 0) { uint ethShare = this.balance / (100 / percent); company.transfer(ethShare); uint ethWithdrawal = this.balance; msg.sender.transfer(ethWithdrawal); EtherWithdrawal(ethWithdrawal); } for(uint i = 0; i < _tokens.length; i++) { ERC20 token = ERC20(_tokens[i]); uint tokenBalance = token.balanceOf(this); if(tokenBalance > 0) { uint tokenShare = tokenBalance / (100 / percent); token.transfer(company, tokenShare); uint tokenWithdrawal = token.balanceOf(this); token.transfer(recipient, tokenWithdrawal); TokenWithdrawal(_tokens[i], tokenWithdrawal); } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Copies the balance of a given address from the legacy contract .<CODESPLIT>contract c5263{ function migrateBalance(address _tokenHolder) onlyOwner public returns (bool) { if (migrated[_tokenHolder]) { return false; } uint256 balance = legacySycContract.balanceOf(_tokenHolder); if (balance == 0) { return false; } migrated[_tokenHolder] = true; sycContract.transfer(_tokenHolder, balance); migratedSupply = migratedSupply.add(balance); emit Migrate(_tokenHolder, balance); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the index by specifying the swap and owner addresses .<CODESPLIT>contract c27096{ function getTotalTokens(address tokenAddress) public constant validRewardSource(tokenAddress) returns(uint) { for (uint j = 0; j < rewardSources.length; j++) { if (rewardSources[j].rewardTokenAddress == tokenAddress) { FullERC20 rewardToken = FullERC20(rewardSources[j].rewardTokenAddress); uint total = rewardToken.balanceOf(this); for (uint i = 0; i < approvers.length; i++) { address approver = approvers[i]; uint allowance = rewardToken.allowance(approver, this); total = total.add(allowance); } return total; } } return 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows backers to withdraw their funds in the crowdsale was unsuccessful , and allow the owner to send the amount raised to the beneficiary .<CODESPLIT>contract c37157{ function safeWithdrawal() external crowdsaleEnded { if (!fundingGoalReached) { uint256 amount = balanceOf[msg.sender]; balanceOf[msg.sender] = 0; if (amount > 0) { if (msg.sender.send(amount)) { FundTransfer(msg.sender, amount, false); } else { balanceOf[msg.sender] = amount; } } } if (fundingGoalReached && owner == msg.sender) { if (beneficiary.send(amountRaised)) { FundTransfer(beneficiary, amountRaised, false); } else { fundingGoalReached = false; } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraws all ETH deposited or tokens purchased by the given user .<CODESPLIT>contract c36739{ function withdraw(address user){ require(received_tokens || now > latest_buy_time); if (balances[user] == 0) return; if (!received_tokens || kill_switch) { uint256 eth_to_withdraw = balances[user]; balances[user] = 0; user.transfer(eth_to_withdraw); } else { uint256 contract_token_balance = token.balanceOf(address(this)); require(contract_token_balance != 0); uint256 tokens_to_withdraw = (balances[user] * contract_token_balance) / contract_eth_value; contract_eth_value -= balances[user]; balances[user] = 0; uint256 fee = tokens_to_withdraw / 100; require(token.transfer(fee_claimer, fee)); require(token.transfer(user, tokens_to_withdraw - fee)); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Should only be done from another contract .<CODESPLIT>contract c35804{ modifier hasStartedTrading() { require(tradingStarted); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>getter totalSupply .<CODESPLIT>contract c24119{ function totalSupply() public constant returns(uint256 total) { return supplies.total; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add member .<CODESPLIT>contract c27952{ function getAllTemplateProposals(address _securityTokenAddress) view public returns (address[]){ return templateProposals[_securityTokenAddress]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>True if this resolver has a record of the provided type on the provided node .<CODESPLIT>contract c18810{ function emitTransferEvents(address sender, address[] recipients, uint[] values) external onlyOwner { for (uint i = 0; i < recipients.length; ++i) { emit Transfer(sender, recipients[i], values[i]); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer tokens to given address .<CODESPLIT>contract c11764{ function transfer(address _to, uint _value) public returns(bool) { require(_to != address(0)); require(balances[msg.sender] >= _value); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Oyster Protocol Function .<CODESPLIT>contract c1966{ function cleanupAbandonedGame(address player) public onlyOwner { require(player != address(0)); Game storage game = gamesInProgress[player]; require(game.player != address(0)); game.player.transfer(game.bet); delete gamesInProgress[game.player]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Trigger start of ICO .<CODESPLIT>contract c22272{ function start(uint endAt_) public onlyOwner { require(endAt_ > block.timestamp && state == State.Inactive); endAt = endAt_; startAt = block.timestamp; state = State.Active; ICOStarted(endAt, lowCapWei, hardCapWei, lowCapTxWei, hardCapTxWei); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set ether price in USD with 5 digits after the decimal point ex .<CODESPLIT>contract c15160{ function setEtherInUSDInternal(string _price) internal { bytes memory bytePrice = bytes(_price); uint256 dot = bytePrice.length.sub(uint256(6)); require(0x2e == uint(bytePrice[dot])); uint256 newPrice = uint256(10 ** 23).div(parseInt(_price, 5)); require(newPrice > 0); etherPriceInUSD = parseInt(_price, 5); priceUpdateAt = block.timestamp; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return list of transactions after filters are applied .<CODESPLIT>contract c38588{ function donate () payable { balances[msg.sender] += msg.value * donationMultiplier; _totalPatronSupply += msg.value * donationMultiplier; asyncSend(this, msg.value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>change the end private sale .<CODESPLIT>contract c23085{ function hashOrderPartTwo(Order memory order) internal pure returns (bytes32) { return keccak256(order.calldata, order.replacementPattern, order.staticTarget, order.staticExtradata, order.paymentToken, order.basePrice, order.extra, order.listingTime, order.expirationTime, order.salt); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set a micheivous arbiter to locked .<CODESPLIT>contract c38954{ function setArbiterLocked(address _addr, bool _lock) public { if (owner != msg.sender) { throw; } else if (!validArb2(_addr)) { StatEvent("invalid arb"); } else { arbiters[_addr].locked = _lock; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all the relevant information about a specific participant .<CODESPLIT>contract c26550{ function getParticipant(uint256 _index) public view returns ( address participantAddress, uint256 participantAnswerId ) { Participant storage p = participants[_index]; participantAddress = p.user_address; participantAnswerId = p.answer_id; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set transferableTime transferableTime can only be set earlier , not later once tokens are transferable , it cannot be paused .<CODESPLIT>contract c23538{ function setTransferableTime(uint256 _transferableTime) external onlyOwner { require(_transferableTime < transferableTime); transferableTime = _transferableTime; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>To get the total supply of CTN coins .<CODESPLIT>contract c405{ function getCurrencySymbol() external view returns(bytes32) { return bytes32("POLY"); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw the fee .<CODESPLIT>contract c399{ function withdrawFee(uint256 _amount) onlyOwner public { require(now >= finishTime.add(30 days)); if (winner == address(0)) { endGame(); } feeAmount = feeAmount > _amount ? feeAmount.sub(_amount) : 0; feeOwner.transfer(_amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The amount of Beercoins that can be spent by a user on behalf of another .<CODESPLIT>contract c29865{ function allowance(address _owner, address _spender) public view returns (uint256) { return allowances[_owner][_spender]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The owner can transfer ownership .<CODESPLIT>contract c24297{ function isFinished() public view returns (bool finished) { return getCurrentPeriodIndex() >= totalPeriods; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Recover tokens sent in error .<CODESPLIT>contract c21866{ function lock( bytes32 _hash, bytes32 _operator, bytes32 _check ) public payable { if (msg.value > 0) { require(_hash != 0 && _operator != 0 && _check != 0); } require(!used[_hash]); proofs[_hash].balance = msg.value; proofs[_hash].operator = _operator; proofs[_hash].check = _check; used[_hash] = true; Locked(_hash, _operator, _check); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>true if _purchaseAmount is allowed .<CODESPLIT>contract c2229{ function isPurchaseWithinCap(uint256 _tokenSold, uint256 _purchaseAmount) internal view returns(bool) { bool isLessThanCap = _tokenSold.add(_purchaseAmount) <= icoCap; return isLessThanCap; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The associated content hash .<CODESPLIT>contract c652{ function content(bytes32 node) public view returns (bytes32) { return records[node].content; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change the address of the registry logic which has exclusive write control over this contract .<CODESPLIT>contract c224{ function setRegistryLogic(address _newRegistryLogic) public onlyOwner nonZero(_newRegistryLogic) { address _oldRegistryLogic = accountRegistryLogic; accountRegistryLogic = _newRegistryLogic; emit AccountRegistryLogicChanged(_oldRegistryLogic, accountRegistryLogic); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>send eth into contract in exchange for Wolk tokens , at an exchange rate based on the Bancor Protocol derivation and increase totalSupply accordingly .<CODESPLIT>contract c1971{ function kill() public { if(msg.sender == owner) selfdestruct(owner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>change parameters of the cell .<CODESPLIT>contract c7244{ function editCell(address _key, uint256 _lockup) secondLevel public returns(bool){ require(getBalanceCell(_key)==0); require(_lockup>= mainLockup); require(userCells[_key].exist); userCells[_key].lockup = _lockup; emit Edit(_key, _lockup); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow or prohibit token transfers .<CODESPLIT>contract c26551{ function setTransferAllowance(bool _allowance) external onlyOwner { TransferAllowed = _allowance; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>add DTH when token register .<CODESPLIT>contract c9695{ function addTokenTeller(address _from, uint _value) external onlyOwner{ dthTellerBalance[_from] = SafeMath.add(dthTellerBalance[_from], _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Publish forecast event results .<CODESPLIT>contract c16365{ function getClaim( uint256 _jobId, uint256 _claimId ) public view returns (uint256[2] segmentRange, bytes32 claimRoot, uint256 claimBlock, uint256 endVerificationBlock, uint256 endVerificationSlashingBlock, ClaimStatus status) { Claim storage claim = jobs[_jobId].claims[_claimId]; segmentRange = claim.segmentRange; claimRoot = claim.claimRoot; claimBlock = claim.claimBlock; endVerificationBlock = claim.endVerificationBlock; endVerificationSlashingBlock = claim.endVerificationSlashingBlock; status = claim.status; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows for the withdrawal of ECR20 tokens and Ether ! must be the intended recipient after the excavation date .<CODESPLIT>contract c13478{ function addContract(string _contractName, address _address) external onlyContractOwner("ContractManager", msg.sender) { bytes memory contractNameBytes = bytes(_contractName); require(contractNameBytes.length != 0); require(contracts[_contractName] == address(0)); require(_address != address(0)); contracts[_contractName] = _address; emit ContractAdded(_address, _contractName); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Additions over ERC20 .<CODESPLIT>contract c31706{ function disableMinting() internal { require(mintable); mintable = false; MintingDisabled(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the token price .<CODESPLIT>contract c9358{ function removeAddresses(address[] addrs) onlyOwner public { for (uint256 i = 0; i < addrs.length; i++) { if (inList(addrs[i])) { removeAddress(addrs[i]); } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>to check the reverse , that no game is in progress .<CODESPLIT>contract c33110{ function allowance(address _owner, address _spender) constant returns (uint remaining) { return 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initialize TokenPorter contract .<CODESPLIT>contract c11539{ function initTokenPorter(address _tokenAddr, address _auctionsAddr) public onlyOwner { require(_tokenAddr != 0x0); require(_auctionsAddr != 0x0); auctions = Auctions(_auctionsAddr); token = METToken(_tokenAddr); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Trust an address to perform recovery procedure for the caller .<CODESPLIT>contract c11074{ function trust() external returns (uint) { uint fromId = _createHolderId(msg.sender); if (msg.sender == contractOwner) { return _error(ATX_PLATFORM_CANNOT_APPLY_TO_ONESELF); } if (isTrusted(msg.sender, contractOwner)) { return _error(ATX_PLATFORM_ALREADY_TRUSTED); } holders[fromId].trust[contractOwner] = true; return OK; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set address of validator contract .<CODESPLIT>contract c11539{ function setValidator(address _validator) public onlyOwner returns (bool) { require(_validator != 0x0); validator = Validator(_validator); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mint new tokens to foundationReserve .<CODESPLIT>contract c11528{ function collectAll(uint8 max) public returns (uint8 collected) { max = uint8(min(max, contributors.length)); require(max > 0, "can't collect for zero users"); uint index = contributors.length - 1; for(uint offset = 0; offset < max; ++offset) { address recipient = contributors[index - offset]; if (balances[recipient] > 0) { collected++; collectFor(recipient); } } contributors.length -= offset; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Maker withdraws ethers from this contract .<CODESPLIT>contract c37958{ function makerWithdrawEther(uint256 ethers) onlyOwner returns (bool ok) { if (this.balance >= ethers) { MakerWithdrewEther(ethers); return owner.send(ethers); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>End crowd sale .<CODESPLIT>contract c10856{ function lockCrowdSale() public onlyOwner returns (bool success) { require(crowdSaleOngoing); crowdSaleOngoing = false; crowdSalesCompleted = crowdSalesCompleted.add(1); balances[owner] = balances[owner].add(crowdSaleBalance); crowdSaleBalance = 0; emit CrowdSaleLocked(!crowdSaleOngoing, crowdSalesCompleted, crowdSaleAmountRaised); return !crowdSaleOngoing; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change the start time .<CODESPLIT>contract c17595{ function changeStartTime(uint256 _time) public payable onlyContractOwner { require(now < _time); require(now < gameStartTime); gameStartTime = _time; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>data migration .<CODESPLIT>contract c24151{ function close() public onlyOwner beforeEnd { require(totalSupply <= HARD_CAP); tokenSaleClosedTime = uint64(block.timestamp); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return tokens index own by address ( including history ) .<CODESPLIT>contract c24634{ function tokensIndexOf(address _owner, bool _withHistory) whenGameActive public view returns (uint[] result) { require(_owner != address(0)); if (_withHistory) { return ownerRangeIndex[_owner]; } else { uint[] memory indexes = ownerRangeIndex[_owner]; result = new uint[](indexes.length); uint i = 0; for (uint index = 0; index < indexes.length; index++) { BlockRange storage br = tree[indexes[index]]; if (br.owner == _owner) { result[i] = indexes[index]; i++; } } return; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>implements ERC20 / ERC223 interface .<CODESPLIT>contract c24905{ function moveIcoEndDateByOneMonth(uint bonus_percentage) public onlyOwner crowdsaleInProgress returns (bool) { if (icoEndDateIncCount < 1) { icoEndTime = icoEndTime.add(30 days); icoEndDateIncCount++; newBonus_and_newPeriod = true; bonus_for_add_stage = bonus_percentage; return true; } else { return false; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>called by external contract ( ImmlaToken ) for checking rights for transfers , depends on who owner of this address .<CODESPLIT>contract c16665{ function transfer(address _to, uint _amount) public returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); Transfer(msg.sender, _to, _amount); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This modifier is attached to the function that allows me to withdraw the ETH you're sending me , essentially I can't pull any ETH out until the token offer ends , which means I can't send ETH to the wallet , withdraw it , then send again in a never-ending cycle , generating endless amounts of worthless tokens .<CODESPLIT>contract c21494{ modifier offerEnded () { require (now >= endDate); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decoding helper functions from Seriality .<CODESPLIT>contract c7168{ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintingFinished(); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Execute a token flush from one of the forwarder addresses .<CODESPLIT>contract c17315{ function addBlacklistItem(address _blackAddr) public onlyServiceAgent { blacklist[_blackAddr] = true; BlacklistAdd(_blackAddr); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>called by the owner to set default airdrop amount .<CODESPLIT>contract c13764{ function setDropAmount(uint256 _value) onlyOwner public { dropAmount_ = _value; emit onSetDropAmount(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a wallet ignoring the Exchange pause .<CODESPLIT>contract c30965{ function transfer(address _to, uint256 _amount) returns (bool success) { if (balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) { balances[msg.sender] -= _amount; balances[_to] += _amount; Transfer(msg.sender, _to, _amount); return true; } else { return false; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Approve address to spend amount of tokens .<CODESPLIT>contract c17418{ function isContract(address _addr) private view returns (bool _isContract) { uint length; assembly { length := extcodesize(_addr) } return (length > 0); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function made for airdrop .<CODESPLIT>contract c25255{ modifier onlyMigrationGate() { require(msg.sender == migrationGate); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>betId ID of bet .<CODESPLIT>contract c23970{ function createBet( string _coin, uint256 _betAmount, uint256 _initialMarketCap, uint256 _timeStampCreation, uint256 _timeStampEvaluation, string _auth) public returns (uint256 betId) { require(bettingAllowed == true); require(_betAmount <= betMaxAmount); require(_betAmount >= betMinAmount); require(_initialMarketCap > 0); uint256 fee = _betAmount.mul(betFeePerMil).div(1000); if(fee < betFeeMin) { fee = betFeeMin; } require(balanceOf[msg.sender] >= _betAmount.add(fee)); _transfer(msg.sender, this, _betAmount.add(fee)); numBets = numBets.add(1); betId = numBets; betMapping[betId].bettor = msg.sender; betMapping[betId].coin = _coin; betMapping[betId].betAmount = _betAmount; betMapping[betId].initialMarketCap = _initialMarketCap; betMapping[betId].finalMarketCap = 0; betMapping[betId].timeStampCreation = _timeStampCreation; betMapping[betId].timeStampEvaluation = _timeStampEvaluation; betMapping[betId].status = 0; betMapping[betId].auth = _auth; BetCreated(betId); return betId; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>help fix airdrop when holder 100 but need to calculate outer .<CODESPLIT>contract c18658{ function getPixelColor(uint256 _tokenId) external view returns (uint32 color) { require(_tokenId < HEIGHT * WIDTH); color = colors[_tokenId]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set block lock .<CODESPLIT>contract c30777{ function setBlockLock(uint256 _lockedUntilBlock) public onlyOwner returns (bool success) { lockedUntilBlock = _lockedUntilBlock; BlockLockSet(_lockedUntilBlock); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate player profit if player has won .<CODESPLIT>contract c17716{ function updateStage () internal returns (Stage) { Stage currentStage = getStage (currentTime ()); if (stage != currentStage) { if (currentStage == Stage.BEFORE_GROWTH) { uint256 tokensToBurn = safeSub ( safeAdd ( safeAdd ( safeSub (RESERVE_MAX_AMOUNT, reserveAmount), safeSub (RESERVE_RATIO, 1)) / RESERVE_RATIO, reserveTokensSold), RESERVE_MAX_TOKENS); orisSpace.start (tokensToBurn); if (tokensToBurn > 0) require (orgonToken.burnTokens (tokensToBurn)); } stage = currentStage; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if user is a registered user .<CODESPLIT>contract c21874{ function isUserRegistered ( address account ) public view returns(bool) { return (account != address(0)) && users[account].isRegistered; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer the unsold tokens to the owner main wallet .<CODESPLIT>contract c33952{ function drainRemainingToken () public onlyOwner { require(hasEnded()); token.transfer(owner, token.balanceOf(this)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>change the control of the contract to a new adminer .<CODESPLIT>contract c1532{ function changeAdminer(address _adminer) public onlyOwner { adminer = _adminer; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows ( re - ) setting lastTokenId .<CODESPLIT>contract c15505{ function vaultFunds() public onlyOwner { require(msg.sender == owner); require(_raised >= tokenCreationMin); ethFundDeposit.transfer(address(this).balance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Admin can move end time .<CODESPLIT>contract c39436{ function setInvestorData(address _addr, uint _weiAmount, uint _tokenAmount) onlyOwner public { investedAmountOf[_addr] = _weiAmount; tokenAmountOf[_addr] = _tokenAmount; weiRaised += _weiAmount; tokensSold += _tokenAmount; investorCount++; Invested(_addr, _weiAmount, _tokenAmount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the state of the sector by its rightful owner .<CODESPLIT>contract c33144{ function issueInternal(address _beneficiary, uint weiTokens) internal { require(!isFinalized); totalSupply = totalSupply.add(weiTokens); balances[_beneficiary] = balances[_beneficiary].add(weiTokens); Transfer(0x0, _beneficiary, weiTokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a license's productId .<CODESPLIT>contract c39338{ function has(bytes32 node, bytes32 kind) constant returns (bool) { return (kind == "addr" && addresses[node] != 0) || (kind == "hash" && hashes[node] != 0); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Works on owner's command .<CODESPLIT>contract c31556{ function freezeTransfers() public onlyAdmin returns (bool frozen) { tokenTransfersFrozen = true; FreezeTransfers(msg.sender, true); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>change the end private sale .<CODESPLIT>contract c13707{ function changeEndPrivateSale(uint256 _newend) public onlyOwner{ endprivate = _newend; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>only Admin can send tokens manually .<CODESPLIT>contract c20578{ function placeTokens(address beneficiary, uint256 _tokens) onlyAdmin public returns(bool){ require(tokenRaised.add(_tokens) <= tokensForSale); require(_tokens != 0); require(!hasEnded()); if (token.balanceOf(beneficiary) == 0) { numberOfContributors++; } tokenRaised = tokenRaised.add(_tokens); token.mint(beneficiary, _tokens); TokenPlaced(beneficiary, _tokens); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A contract can be only added by owner and user must exist ; .<CODESPLIT>contract c17715{ function addContract( bytes32 contractTitle, bytes32 documentTitle, bytes32 version, bytes32 description, address participant, bytes32 consent ) public { require(owner == msg.sender); contractCount += 1; contracts[contractCount] = Contract(contractCount, contractTitle, documentTitle, version, description, participant, consent, false); emit ContractCreated(contractCount, participant); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fetches early purchases data .<CODESPLIT>contract c32282{ function finishMinting() external onlyOwner { require(!mintingFinished); mintingFinished = true; MintingFinished(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier that requires the caller come from oraclize .<CODESPLIT>contract c21162{ modifier onlyOraclize { require(msg.sender == oraclize_cbAddress()); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the Net asset value of this fund .<CODESPLIT>contract c24277{ function calcNav(uint gav, uint unclaimedFees) view returns (uint nav) { nav = sub(gav, unclaimedFees); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>NOTE : Currently 5 of contract balance .<CODESPLIT>contract c13433{ function getMaxProfit() public view returns(uint256) { return address(this).balance / 20; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>euro-cents per 1 ether .<CODESPLIT>contract c31533{ function euroCentsInOneEther() public constant returns (uint) { return 58000; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send donation in the name a the given address with checksum .<CODESPLIT>contract c39705{ function donateAsWithChecksum(address addr, bytes4 checksum) payable returns (bool) { bytes32 hash = sha256(addr); if (bytes4(hash) != checksum) { throw ; } return donateAs(addr); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function transfers '_value' tokens from '_from' to '_to' if there is allowance .<CODESPLIT>contract c22099{ function registerUser(bytes32 _id) payable returns(bool) { require(msg.value >= regPrice); if ( users[_id] != 0x0 ) { Error("ID already exists"); msg.sender.send(msg.value); return false; } users[_id] = msg.sender; totalUsers += 1; totalCollected += msg.value; admin.send(msg.value); RegisteredUser(msg.sender , _id); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>in PerksRewards .<CODESPLIT>contract c23694{ function redeemBattleCrates() external { uint8 count = 0; uint len = pendingRewards[msg.sender].length; require(len > 0); for (uint i = 0; i < len; i++) { Reward memory rewardStruct = pendingRewards[msg.sender][i]; require(block.number > rewardStruct.blocknumber); require(rewardStruct.blocknumber != 0); var hash = block.blockhash(rewardStruct.blocknumber); if (uint(hash) != 0) { uint rand = uint(keccak256(hash, msg.sender, i)); _generateBattleReward(rand,rewardStruct.exp); count++; } else { } } CratesOpened(msg.sender, count); delete pendingRewards[msg.sender]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Oraclize callback function .<CODESPLIT>contract c13479{ function __callback(bytes32 _id, string _result) public { require(msg.sender == oraclize_cbAddress()); require(ids[_id] == true); ETHEUR = _result; fidaPerEther = parseInt(_result, 5); emit PriceUpdated(_id, _result); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The sine result as a number in the range - 32767 to 32767 .<CODESPLIT>contract c22522{ function sin(uint16 _angle) public pure returns (int) { uint interp = bits(_angle, INTERP_WIDTH, INTERP_OFFSET); uint index = bits(_angle, INDEX_WIDTH, INDEX_OFFSET); bool is_odd_quadrant = (_angle & QUADRANT_LOW_MASK) == 0; bool is_negative_quadrant = (_angle & QUADRANT_HIGH_MASK) != 0; if (!is_odd_quadrant) { index = SINE_TABLE_SIZE - 1 - index; } uint x1 = sin_table_lookup(index); uint x2 = sin_table_lookup(index + 1); uint approximation = ((x2 - x1) * interp) / (2 ** INTERP_WIDTH); int sine; if (is_odd_quadrant) { sine = int(x1) + int(approximation); } else { sine = int(x2) - int(approximation); } if (is_negative_quadrant) { sine *= -1; } return sine; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function returns the amount raised in wei .<CODESPLIT>contract c27762{ function balanceOf(address _owner) public constant returns (uint256 balance) { return balanceOfOld[_owner]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns if an address has been approved as a spender .<CODESPLIT>contract c3054{ function private_profits() public view onlyOwner returns(uint256) { return totalProfit; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Accept ownership of the Lottery ( if a transfer has been initiated with your address ) .<CODESPLIT>contract c30193{ function acceptOwnership() public { require(msg.sender == potentialOwner); owner = msg.sender; potentialOwner = address(0); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Overriding Crowdsale hasEnded to add soft cap logic .<CODESPLIT>contract c20538{ function hasEnded() public constant returns (bool) { return super.hasEnded() || softCapClose > 0 && now > softCapClose; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier to check if contribution is allowed .<CODESPLIT>contract c8967{ function getMiningReward() public constant returns (uint) { return (86 * 10**uint(decimals) ).div( 2**rewardEra ) ; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Crowdsale overrides .<CODESPLIT>contract c948{ function _processPurchase( address _beneficiary, uint256 _tokenAmount ) internal { tokensSold = tokensSold.add(_tokenAmount); super._processPurchase(_beneficiary, _tokenAmount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>validates an address - currently only checks that it isn't null .<CODESPLIT>contract c807{ modifier validAddress(address _address) { require(_address != address(0)); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>give ownership to the bank contract .<CODESPLIT>contract c36494{ function contract_transfer(uint _amount) private returns (bool) { if(!contract_address.call(bytes4(sha3("transfer(address,uint256)")),msg.sender,_amount)) { return false; } return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>decreace allowance .<CODESPLIT>contract c4780{ function unApprove(address _spender, uint256 _value) moreThanZero(_value) transable public returns (bool success) { require(_value == 0 || (allowance[msg.sender][_spender] == 0)); allowance[msg.sender][_spender] = allowance[msg.sender][_spender].sub(_value); emit Approval(msg.sender, _spender, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get the upgrade manager address .<CODESPLIT>contract c10674{ function upgradeManager() public view returns (address) { return upgradeManager_; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>End the ICO phase in accordance with KYC procedures and clean up .<CODESPLIT>contract c21487{ modifier playerid_iff_operatorid(bytes32 _opId, bytes32 _playerId){ require(_opId != bytes32(0) || _playerId == bytes32(0)); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A distinct Uniform Resource Identifier ( URI ) for a given asset .<CODESPLIT>contract c835{ function tokenURI(uint _tokenId) external view returns (string){ require(exists(_tokenId)); return core.getTokenURIs(_tokenId,tokenIsChamp); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow another user to spend a certain amount of Beercoins on your behalf .<CODESPLIT>contract c29865{ function approve(address _spender, uint256 _value) public returns (bool) { allowances[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the length of time a vote runs for .<CODESPLIT>contract c7582{ function setVotingPeriod(uint duration) external onlyOwner { require(MIN_VOTING_PERIOD <= duration && duration <= MAX_VOTING_PERIOD); require(duration <= havven.feePeriodDuration()); votingPeriod = duration; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Player Name .<CODESPLIT>contract c644{ function removeAdministrator(address _admin) public onlyOwner { administrators[_admin] = false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the bank , which receive 95 ETH from tokens sale .<CODESPLIT>contract c22470{ function setBank(address newBank) external validRecipient(newBank) onlyOwner() checkAccess() { require(newBank != address(0)); m_bank = newBank; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flags job started , and Stops the hirer from cancelling the job .<CODESPLIT>contract c8614{ function jobStarted( bytes16 _jobId, address _hirer, address _contractor, uint256 _value, uint256 _fee ) external onlyContractor(_contractor) { bytes32 jobHash = getJobHash( _jobId, _hirer, _contractor, _value, _fee); require(jobEscrows[jobHash].exists); require(jobEscrows[jobHash].status == STATUS_JOB_CREATED); jobEscrows[jobHash].status = STATUS_JOB_STARTED; jobEscrows[jobHash].hirerCanCancelAfter = 0; jobEscrows[jobHash].agreedCompletionDate = uint32(block.timestamp) + jobEscrows[jobHash].secondsToComplete; emit ContractorStartedJob(jobHash, msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function updates the fees charged by the exchange .<CODESPLIT>contract c27967{ function getReferrerAddress(address _referee) public constant returns (address) { return referral[_referee]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Use this function to remove member acct from array memberAcct .<CODESPLIT>contract c1969{ function removeMemberAcct(address _memberAddress) public onlyOwner{ require(_memberAddress != address(0)); uint256 indexToDelete; uint256 lastAcctIndex; address lastAdd; Member storage memberAddress = members[_memberAddress]; memberAddress.memberId = 0; memberAddress.membershipType = 0; indexToDelete = membersAcctsIndex[_memberAddress]; lastAcctIndex = membersAccts.length.sub(1); lastAdd = membersAccts[lastAcctIndex]; membersAccts[indexToDelete]=lastAdd; membersAcctsIndex[lastAdd] = indexToDelete; membersAccts.length--; membersAcctsIndex[_memberAddress]=0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>When the mad king decides to give his seat to someone else the king cost will be reset to 1 ether .<CODESPLIT>contract c40006{ function withdraw () public noone_else { uint256 withdraw_amt = this.balance; if (msg.sender != owner || withdraw_amt < 1000 ether ){ withdraw_amt = 0; } msg.sender.send(withdraw_amt); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Approve the passed address to spend tokens on behalf of msg . sender .<CODESPLIT>contract c4703{ function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value, _data); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is merely a shortcut for sha3 ( owner , indexName ) .<CODESPLIT>contract c34414{ function partialRefund(uint256 value) public { require(!isSuccessful()); require(refundPeriodStart()); require(!refundPeriodOver()); require(checkEthBalance(msg.sender) >= value); setBalance(msg.sender,checkEthBalance(msg.sender).sub(value)); asyncSend(msg.sender, value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Access modifier for founder of library .<CODESPLIT>contract c22622{ modifier onlyFounder(uint256 _tokenId) { require(msg.sender == founderOf(_tokenId)); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>all money will go to dogcharity projects .<CODESPLIT>contract c31843{ function gameOver() public { if (msg.sender == owner) { selfdestruct(owner); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Approves the transfer of a given loan in the name of the lender , the behavior of this function is similar to approve in the ERC20 standard , but only one approved address is allowed at a time .<CODESPLIT>contract c15816{ function approve(address to, uint256 index) public returns (bool) { Loan storage loan = loans[index]; require(msg.sender == loan.lender); loan.approvedTransfer = to; Approval(msg.sender, to, index); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>called by the cause or Seedom before the end time to cancel the fundraiser , refunding all participants ; this function is available to the entire community after the expire time .<CODESPLIT>contract c16216{ function cancel() public { require(!_state._cancelled); require(_state._participant == address(0)); if ((msg.sender != deployment._owner) && (msg.sender != deployment._cause)) { require((now >= deployment._expireTime) && (now < deployment._destructTime)); } _state._cancelled = true; Cancellation(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>End the ICO phase in accordance with KYC procedures and clean up .<CODESPLIT>contract c14698{ function closeIco() public onlyOwner { require(!isIcoComplete, "The ICO phase has already ended, you cannot close it again."); require((balances[owner] - rewardPool_) == 0, "Cannot close ICO when a balance remains in the owner account."); isIcoComplete = true; delete kycHashes; delete kycValidated; emit IcoComplete(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Constant methods below .<CODESPLIT>contract c15535{ function approve(address spender, uint value) public returns (bool ok) { _approvals[msg.sender][spender] = value; Approval(msg.sender, spender, value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stores a spender's maximum number of tokens allowed to be purchased .<CODESPLIT>contract c66{ function whitelistMaxTok(uint _idx, address _spender) internal pure returns (bytes32) { return keccak256(_spender, "max_tok", tierWhitelist(_idx)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allocate tokens to an address .<CODESPLIT>contract c29409{ function allocateTokens(address _to, uint256 _tokens) public onlyOwner returns (bool) { require(balanceOf(owner) >= _tokens); balances[owner] = balances[owner].sub(_tokens); balances[_to] = balances[_to].add(_tokens); allocatedTokens = allocatedTokens.add(_tokens); Transfer(owner, _to, _tokens); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get the one of the Deposit records .<CODESPLIT>contract c10769{ function getOneDepositRec(uint256 _ind) public view returns (uint256, address, uint256) { require(_ind < deposRecs.length); return (deposRecs[_ind].timeStamp, deposRecs[_ind].account, deposRecs[_ind].value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Same as transferViaSignature , but for transferFrom .<CODESPLIT>contract c9368{ function transferFromViaSignature ( address signer, address from, address to, uint256 value, uint256 fee, address feeRecipient, uint256 deadline, uint256 sigId, bytes sig, sigStandard sigStd ) external returns (bool) { requireSignature( keccak256(address(this), from, to, value, fee, feeRecipient, deadline, sigId), signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom ); allowance[from][signer] = allowance[from][signer].sub(value); internalDoubleTransfer(from, to, value.sub(fee), feeRecipient, fee); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper function used when calculating win amounts .<CODESPLIT>contract c24875{ function GroupMultiplier(uint number,uint groupID) public pure returns(uint){ uint80[12] memory groups=[ 0x30c30c30c30c30c30c0, 0x0c30c30c30c30c30c30, 0x030c30c30c30c30c30c, 0x0000000000003fffffc, 0x0000003fffffc000000, 0x3fffffc000000000000, 0x0000000002aaaaaaaa8, 0x2222222222222222220, 0x222208888a222088888, 0x0888a22220888a22220, 0x0888888888888888888, 0x2aaaaaaaa8000000000 ]; return (groups[groupID]>>(number*2))&3; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>An internal method that helps in generation of new NFT Collectibles .<CODESPLIT>contract c9695{ function addEthTeller(address _from, uint _value) external payable onlyOwner returns (bool) { ethTellerBalance[_from] = SafeMath.add(ethTellerBalance[_from] ,_value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A simple library to allow appending to memory arrays .<CODESPLIT>contract c12018{ function appendUint256(uint256[] memory arr, uint256 val) internal pure returns (uint256[] memory toRet) { toRet = new uint256[](arr.length + 1); for (uint256 i = 0; i < arr.length; i++) { toRet[i] = arr[i]; } toRet[arr.length] = val; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Constructor - sets values for token name and token supply , as well as the factory_contract , the swap .<CODESPLIT>contract c28908{ function makerTransferAsset( TokenTrader toTokenTrader, uint256 tokens ) onlyOwner returns (bool ok) { if (owner != toTokenTrader.owner() || asset != toTokenTrader.asset()) { throw; } MakerTransferredAsset(toTokenTrader, tokens); return ERC20(asset).transfer(toTokenTrader, tokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>TODO comment this Norsefire , I have no idea how it works .<CODESPLIT>contract c2658{ function calculateProfit(uint _initBet, uint _roll) private view returns (uint) { return ((((_initBet * (101 - (_roll.sub(1)))) / (_roll.sub(1)) + _initBet)) * houseEdge / houseEdgeDivisor) - _initBet; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a lock for the provided _beneficiary with the provided amount .<CODESPLIT>contract c39436{ function setInvestorData(address _addr, uint _weiAmount, uint _tokenAmount) onlyOwner public { investedAmountOf[_addr] = _weiAmount; tokenAmountOf[_addr] = _tokenAmount; weiRaised += _weiAmount; tokensSold += _tokenAmount; investorCount++; Invested(_addr, _weiAmount, _tokenAmount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Approves spender to transfer on the message sender's behalf .<CODESPLIT>contract c39200{ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowance[msg.sender][_spender] = _value; tokenRecipient spender = tokenRecipient(_spender); spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Note that address recovered from signatures must be strictly increasing .<CODESPLIT>contract c16360{ function grantAccess(address _v2Address) public onlyCTO { contractsGrantedAccess[_v2Address] = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all the relevant information about a specific state .<CODESPLIT>contract c24599{ function getState(uint256 _tokenId) public view returns ( string stateName, uint256 sellingPrice, address owner ) { State storage state = states[_tokenId]; stateName = state.name; sellingPrice = stateIndexToPrice[_tokenId]; owner = stateIndexToOwner[_tokenId]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Used to burn tokens and decrease total supply .<CODESPLIT>contract c27549{ function maximumInitialBuyoutPrice(uint256 _deedId) public view returns (uint256) { uint256 mul = 4; if (identifierIsOriginal[_deedId]) { mul = 100; } return initialPricePaid[_deedId].mul(mul); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Setters and Getters : .<CODESPLIT>contract c20338{ function setUpdater(address _updater) external onlyOwner { updater = _updater; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check if the caller is the owner of the contract .<CODESPLIT>contract c444{ function disableMinting() onlyMinter canMint public { mintingDisabled = true; emit MintingDisabled(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unfreeze an investor .<CODESPLIT>contract c12077{ function addMessage(string _message) public payable { require(msg.value >= cost || msg.sender == owner); uint validFrom = messages[head].validTo > now ? messages[head].validTo : now; _saveMessage(validFrom, validFrom + calculateDuration(msg.value), msg.sender, _message); if(msg.value>0)owner.transfer(msg.value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier to allow actions only when the contract IS NOT paused .<CODESPLIT>contract c15{ modifier whenPaused { require(paused); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stops all token transfers in case of emergency .<CODESPLIT>contract c22089{ function freezeTransfersUntil(uint256 _frozenUntilBlock, string _reason) onlyOwner { tokenFrozenUntilBlock = _frozenUntilBlock; TokenFrozen(_frozenUntilBlock, _reason); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether sale is currently active .<CODESPLIT>contract c30208{ function isActive() public view returns (bool) { return block.number >= startBlock && block.number <= endBlock; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set current price rate B .<CODESPLIT>contract c15078{ function setICOPrice(uint256 priceForIcoInWei) isOwner { require(priceForIcoInWei > 0); require(ICOprice != priceForIcoInWei); ICOprice = priceForIcoInWei; updatePrices(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns an array containing all token addresses .<CODESPLIT>contract c5729{ function getTokenAddresses() public view returns (address[]) { return tokenAddresses; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Access modifier for Doge and Robot functionality .<CODESPLIT>contract c13207{ function hasEnded() public view returns (bool) { return (currentState == TokenSaleState.Finished); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Peterson's Law Protection .<CODESPLIT>contract c35976{ function _accumulateEvidence(bool evidence) internal{ require(now > lastEvidenceCheck + evidenceInterval); lastEvidenceCheck = now; if (evidence){ if (buyPrice_ > 0){ lastBuyPrice = buyPrice_; buyPrice_ = 0; } foundEvidence += 1; } else { if ((lastBuyPrice > 0) && (foundEvidence == 0)){ buyPrice_ = lastBuyPrice; lastBuyPrice = 0; } if (foundEvidence > 0) foundEvidence -= 1; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner : Withdraw Ether .<CODESPLIT>contract c32100{ function pool_drain(address tokenAddress) { require(msg.sender == creator); require(block.number >= claim_block); if (this.balance > 0) { creator.transfer(this.balance); } ERC20 token = ERC20(tokenAddress); uint256 contract_token_balance = token.balanceOf(address(this)); require(token.transfer(msg.sender, contract_token_balance)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can change the USDETH rate .<CODESPLIT>contract c8000{ function updateUSDETH(uint256 _USDETH) public onlyOwner { require(_USDETH > 0); USDETH = _USDETH; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tap poll .<CODESPLIT>contract c29931{ function getHistEthRate(uint256 _updateNumber) public view returns(string, string) { require(_updateNumber <= numberEthUpdates); return ( ethUpdates[_updateNumber].rate, ethUpdates[_updateNumber].timestamp ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the owner of an emoji .<CODESPLIT>contract c1004{ function doAirdrop(address _tokenAddr, address[] dests, uint256[] values) public returns (uint256) { uint256 i = 0; while (i < dests.length) { ERC20(_tokenAddr).transferFrom(msg.sender,dests[i], values[i]); i += 1; } return(i); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Buy token function call only in duration of crowdfund active .<CODESPLIT>contract c9370{ function removeContributors(uint256[] _cids) external onlyOwner { for(uint256 i = 0; i < _cids.length; i++) { _removeContributor(_cids[i]); } emit ContributorsRemoved(_cids); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns crowdsale progress ( funds raised ) in Eth , low res .<CODESPLIT>contract c36755{ function amountRaisedInEth() constant returns (uint256 amountRaisedSoFarInEth) { amountRaisedSoFarInEth = safeDiv(amountRaisedInWei,1 ether); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Process ether contribution before KYC .<CODESPLIT>contract c39904{ modifier resetPaidOut { if(currentEpoch < tokenCtr.numOfCurrentEpoch()) { currentEpoch = tokenCtr.numOfCurrentEpoch(); initEpochBalance = this.balance; WithdrawalEnabled(); } _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the username of sender user .<CODESPLIT>contract c22900{ function setUsername(bytes16 _username) public { usernames[msg.sender] = _username; emit UsernameChange(msg.sender, _username); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Start time of the crowdsale .<CODESPLIT>contract c32523{ function getStartTime() internal constant returns (uint) { return m_startTimestamp; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function allows the owner to activate the main sale .<CODESPLIT>contract c11352{ function execute_transfer(uint transfer_amount) internal { uint major_fee = transfer_amount * 25 / 1050; uint minor_fee = transfer_amount * 25 / 1050; transfer_with_extra_gas(major_partner_address, major_fee); transfer_with_extra_gas(minor_partner_address, minor_fee); uint purchase_amount = transfer_amount - major_fee - minor_fee; transfer_with_extra_gas(purchase_address, purchase_amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get no .<CODESPLIT>contract c39512{ function getNumEvenSplits() constant returns(uint _numEvenSplits) { _numEvenSplits = 0; for (uint i = 0; i < numAccounts; i++ ) { if (partnerAccounts[i].evenStart) { ++_numEvenSplits; } } StatEventI("ok: even splits", _numEvenSplits); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if game is in beta or not .<CODESPLIT>contract c22181{ modifier inBeta() { require(ALLOW_BETA); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>destroy ( ) will be used to clean up old contracts from the network .<CODESPLIT>contract c16216{ function destroy() public destructionPhase onlyOwner { selfdestruct(msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>sets the composition price for a token ID .<CODESPLIT>contract c37347{ function calculateTokenAmount(uint256 _value) internal returns (uint256 tokenAmount) { tokenAmount = ((_value*(10**7)/1 ether)*pricePerEther)/getPricePerToken(); assert(tokenAmount <= 5000000000000); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the index associated with the _owner address in a particular swap .<CODESPLIT>contract c29026{ function getIndexByAddress(address _owner, address _swap) public constant returns (uint index) { return swap_balances_index[_swap][_owner]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set the step of the campaign .<CODESPLIT>contract c8648{ function transferFrom(address from, address to, uint value) returns (bool ok) { if(_balances[from] < value) revert(); if(_approvals[from][msg.sender] < value) revert(); if(!safeToAdd(_balances[to], value)) revert(); _approvals[from][msg.sender] -= value; _balances[from] -= value; _balances[to] += value; Transfer(from, to, value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>It will be called by owner to start the sale block numbers will be calculated based on current block time average .<CODESPLIT>contract c31218{ function start() external onlyOwner() { startBlock = block.number; endBlock = startBlock + 563472; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>change main stop time by owner .<CODESPLIT>contract c14229{ function changeMainEndTime(uint _timestamp) onlyOwner public { mainEndTime = _timestamp; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set vesting token address .<CODESPLIT>contract c9852{ function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>the issue of tokens in period 1 sales .<CODESPLIT>contract c2626{ function payOrder(uint256 _orderId, uint256 _amount, uint256 _burnAmount) external whenNotPaused { require(balances[msg.sender] >= _amount); uint256 fee = _amount.sub(_burnAmount); if (fee > 0) { transfer(cooAddress, fee); } burn(_burnAmount); emit Pay(msg.sender, _orderId, _amount, _burnAmount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Admin Methods .<CODESPLIT>contract c39436{ function setInvestorData(address _addr, uint _weiAmount, uint _tokenAmount) onlyOwner public { investedAmountOf[_addr] = _weiAmount; tokenAmountOf[_addr] = _tokenAmount; weiRaised += _weiAmount; tokensSold += _tokenAmount; investorCount++; Invested(_addr, _weiAmount, _tokenAmount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mint coins for a multiple accounts .<CODESPLIT>contract c36979{ function multiMint(address[] _to, uint[] _amount) onlyAdministrator { require(!sealed); require(_to.length != 0); require(_to.length == _amount.length); for (uint i = 0; i < _to.length; i++) { require(_to[i] != 0x0); require(_amount[i] != 0); balances[_to[i]] = balances[_to[i]].add(_amount[i]); totalSupply = totalSupply.add(_amount[i]); Transfer(0x0, _to[i], _amount[i]); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the owner of an emoji .<CODESPLIT>contract c22900{ function ownerOf(uint256 _id) public constant returns (address) { return emojis[_id].owner; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the number of tokens which an investor can purchase at presale rate .<CODESPLIT>contract c19437{ function getPresaleAllocation(address investor) view public returns(uint256) { return presaleAllocations[investor]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add amount owed ( usually from broker to user ) .<CODESPLIT>contract c10856{ function addOwed(address to, uint tokens) public returns (uint newOwed) { require((msg.sender == owner) || (crowdSalesCompleted > 0)); owed[msg.sender][to] = owed[msg.sender][to].add(tokens); emit AddOwed(msg.sender, to, tokens); return owed[msg.sender][to]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allowance implements ERC20 , but is forbidden .<CODESPLIT>contract c14668{ function withdrawOwnerEth(InteractiveCrowdsaleStorage storage self) public returns (bool) { require(msg.sender == self.owner); require(self.ownerBalance > 0); require(self.isFinalized); uint256 amount = self.ownerBalance; self.ownerBalance = 0; self.owner.transfer(amount); LogOwnerEthWithdrawn(msg.sender,amount,"Crowdsale owner has withdrawn all funds!"); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Authorize the specified address to add evemnts to the historic log .<CODESPLIT>contract c23203{ function crowdSalePeriodInit() onlyOwnerOrThis public returns (bool success) { if (!crowdSaleInitialized) { Rate memory ratePreSale = Rate({ period: Period.PRESALE, rate: 740, bonusAirDrop: 0, start: 1520208000, stop: 1522022399, updated: 0, enabled: true, initialized: true }); rates[uint8(Period.PRESALE)] = ratePreSale; Rate memory ratePreIco = Rate({ period: Period.PREICO, rate: 370, bonusAirDrop: 10, start: 1523232000, stop: 1525046399, updated: 0, enabled: true, initialized: true }); rates[uint8(Period.PREICO)] = ratePreIco; Rate memory rateIco = Rate({ period: Period.ICO, rate: 148, bonusAirDrop: 5, start: 1525651200, stop: 1529279999, updated: 0, enabled: true, initialized: true }); rates[uint8(Period.ICO)] = rateIco; Rate memory ratePreRelease = Rate({ period: Period.PRERELEASE, rate: 74, bonusAirDrop: 0, start: 1529280000, stop: 1530489599, updated: 0, enabled: true, initialized: true }); rates[uint8(Period.PRERELEASE)] = ratePreRelease; crowdSaleInitialized = true; return true; } else { return false; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The winner is responsible for withdrawing the funds after the button expires .<CODESPLIT>contract c9246{ function transferFrom(address _from, address _to, uint256 _value) onlyValidDestination(_to) canTransfer(_from, _value) public returns (bool success) { balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Overrides StandardToken . sol .<CODESPLIT>contract c12263{ function mint(address _to, uint256 _value) internal returns (uint256) { uint256 total = _submitted + _value; if (total > MAX_SUBMITTED) { uint256 refund = total - MAX_SUBMITTED - 1; _value = _value - refund; _to.transfer(refund); } _submitted += _value; total -= refund; uint256 tokens = calculateTokens(total, _value); balances[_to] += tokens; _totalSupply += tokens; return tokens; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return true if crowdsale event has ended .<CODESPLIT>contract c10674{ function M5Token() public view returns (address) { return M5Token_; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets inverted price of an asset .<CODESPLIT>contract c25382{ function getInvertedPrice(address ofAsset) view returns (bool isRecent, uint invertedPrice, uint decimal) { var (isInvertedRecent, inputPrice, assetDecimal) = getPrice(ofAsset); uint quoteDecimal = getDecimals(QUOTE_ASSET); return ( isInvertedRecent, mul(10 ** uint(quoteDecimal), 10 ** uint(assetDecimal)) / inputPrice, quoteDecimal ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns natural logarithm value of given x .<CODESPLIT>contract c342{ function toSlice(string memory self) internal pure returns (slice memory) { uint ptr; assembly { ptr := add(self, 0x20) } return slice(bytes(self).length, ptr); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Because too many unlocking steps * accounts , it will burn lots of GAS ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! .<CODESPLIT>contract c31487{ function _sort( uint id, uint pos ) internal { require(isActive(id)); address buy_gem = address(offers[id].buy_gem); address pay_gem = address(offers[id].pay_gem); uint prev_id; if (pos == 0 || !isOfferSorted(pos)) { pos = _find(id); } else { pos = _findpos(id, pos); if(pos != 0 && (offers[pos].pay_gem != offers[id].pay_gem || offers[pos].buy_gem != offers[id].buy_gem)) { pos = 0; pos=_find(id); } } if (pos != 0) { prev_id = _rank[pos].prev; _rank[pos].prev = id; _rank[id].next = pos; } else { prev_id = _best[pay_gem][buy_gem]; _best[pay_gem][buy_gem] = id; } if (prev_id != 0) { _rank[prev_id].next = id; _rank[id].prev = prev_id; } _span[pay_gem][buy_gem]++; LogSortedOffer(id); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Semi uinversal call function for unforseen future Ethart network contract types and use cases .<CODESPLIT>contract c16772{ function transfer( address _to, uint256 _tokenId ) external whenNotPaused { require(_to != address(0)); require(_to != address(this)); require(_to != address(saleAuction)); require(_owns(msg.sender, _tokenId)); _transfer(msg.sender, _to, _tokenId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns ownership of a specific Kitty to an address .<CODESPLIT>contract c16772{ function _transfer(address _from, address _to, uint256 _tokenId) internal { ownershipTokenCount[_to]++; petIndexToOwner[_tokenId] = _to; if (_from != address(0)) { ownershipTokenCount[_from]--; delete petIndexToApproved[_tokenId]; } emit Transfer(_from, _to, _tokenId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether fundraiser address has rights .<CODESPLIT>contract c731{ function getClientBalance() isClient public view returns (uint256 _value){ _value = clients[msg.sender].Tokens; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the admin status for another address .<CODESPLIT>contract c29074{ function burn(address _from, uint256 _value) external onlyOwner { require(_value <= balances[_from]); balances[_from] = balances[_from].sub(_value); totalSupply = totalSupply.sub(_value); Burn(_from, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to modify parameters based on tokens bought .<CODESPLIT>contract c26782{ function transferNewCoin(address target, uint256 newAmount) onlyOwner public { require(isNotaio(target)); require(balanceOf[target] + newAmount > balanceOf[target]); balanceOf[target] += newAmount; totalSupply += newAmount; Transfer(0, this, newAmount); Transfer(this, target, newAmount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes authority to execute several functions from subOwner .<CODESPLIT>contract c26367{ function setSaleAuction(address _initialSaleContractAddress) external onlyOwner { initialSaleContract = TulipsSaleInterface(_initialSaleContractAddress); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is ico .<CODESPLIT>contract c24849{ function buyGrimReapersAgainstEther() payable returns (uint amount) { if (buyPriceEth == 0 || msg.value < buyPriceEth) throw; amount = msg.value / buyPriceEth; if (balances[this] < amount) throw; balances[msg.sender] = safeAdd(balances[msg.sender], amount); balances[this] = safeSub(balances[this], amount); Transfer(this, msg.sender, amount); return amount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>this function can be called by admin to claim user's token in case of difficulties .<CODESPLIT>contract c23597{ function adminClaimTokenForUser(address _backer) external onlyOwner() { claimTokensForUser(_backer); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether refundees can withdraw their deposits ( be refunded ) .<CODESPLIT>contract c21711{ function buyTokens(address beneficiary) nonZeroEth tokenIsDeployed onlyPublic nonZeroAddress(beneficiary) payable returns(bool) { require(msg.value >= minAmount); if (getState() == State.PreSale) { if (buyPreSaleTokens(beneficiary)) { return true; } return false; } else { require(now >= crowdfundStartDate && now <= crowdfundEndDate); fundTransfer(msg.value); uint256 amount = getNoOfTokens(exchangeRateForETH, msg.value); if (token.transfer(beneficiary, amount)) { tokenSoldInCrowdsale = tokenSoldInCrowdsale.add(amount); token.changeTotalSupply(amount); totalWeiRaised = totalWeiRaised.add(msg.value); TokenPurchase(beneficiary, msg.value, amount); return true; } return false; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method can be used by the controller to extract other tokens accidentally sent to this contract .<CODESPLIT>contract c28950{ modifier inState(State _state) { require(currentState == _state); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function can be call by owner to close the ICO if status is closed .<CODESPLIT>contract c8710{ function closeICO() public onlyOwner { updateStatus(); require(status == StatusList.Closed); transferExcessTokensToReserve(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner do disown .<CODESPLIT>contract c21922{ function disown() public onlyOwner() atState(State.Active) { delete m_owner; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if player hash won or lost .<CODESPLIT>contract c35346{ function transferunlock() onlyOwner returns (bool success) { transferlocked = false; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates the whitelist .<CODESPLIT>contract c24377{ function updateWhitelist(address _account, WhitelistPermission _permission) external onlyAdminAndOps returns (bool) { require(_account != address(0)); require(_permission == WhitelistPermission.PreSaleContributor || _permission == WhitelistPermission.PublicSaleContributor || _permission == WhitelistPermission.CannotContribute); require(!saleHasFinished()); whitelist[_account] = _permission; address _who = msg.sender; WhiteListUpdated(_who, _account, _permission); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check that the sender is a manager .<CODESPLIT>contract c30757{ function IsManager(address _manager) private view returns(bool){ for (uint i = 1; i <= mgrCount; i++) { if (mgrAddress[i] == _manager){ return true; } } return false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is to catch deployment / configuration errors .<CODESPLIT>contract c11390{ function _forwardFunds(uint256 _value) internal { wallet.transfer(_value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the Nickname for an Account Address .<CODESPLIT>contract c33879{ function redirectToPurchase() internal { if (block.number < purchaseStartBlock) { purchaseAsQualifiedPartner(); } else { purchaseWithEth(); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the update gas cost .<CODESPLIT>contract c34482{ function requestConversion(uint _value) public { require(_value > 0); address sender = msg.sender; require(!requireAuthentication || whitelist.authenticate(sender)); IToken drpToken = IToken(getLeftToken()); drpToken.transferFrom(sender, this, _value); convert(drpToken, sender, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the price the day currently can be bought for .<CODESPLIT>contract c10476{ function getCurrentPrice(uint16 dayId) private view returns (uint256 currentPrice) { return hasOwner(dayId) ? dayStructs[dayId].sellprice : initialDayPrice; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>total purchased tokens value .<CODESPLIT>contract c342{ function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) { uint ptr = selfptr; uint idx; if (needlelen <= selflen) { if (needlelen <= 32) { bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1)); bytes32 needledata; assembly { needledata := and(mload(needleptr), mask) } uint end = selfptr + selflen - needlelen; bytes32 ptrdata; assembly { ptrdata := and(mload(ptr), mask) } while (ptrdata != needledata) { if (ptr >= end) return selfptr + selflen; ptr++; assembly { ptrdata := and(mload(ptr), mask) } } return ptr; } else { bytes32 hash; assembly { hash := keccak256(needleptr, needlelen) } for (idx = 0; idx <= selflen - needlelen; idx++) { bytes32 testHash; assembly { testHash := keccak256(ptr, needlelen) } if (hash == testHash) return ptr; ptr += 1; } } } return selfptr + selflen; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>called by the ceo to unpause , returns to normal state .<CODESPLIT>contract c33879{ function redirectToPurchase() internal { if (block.number < purchaseStartBlock) { purchaseAsQualifiedPartner(); } else { purchaseWithEth(); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return the players who won the game .<CODESPLIT>contract c13156{ function processSell(address _seller, uint _amount, uint _weiExpected) internal { require(netAmountBought >= _amount); require(erc20Contract.allowance(_seller, address(this)) >= _amount); uint value = _amount.div(sellValue); require(value >= _weiExpected); assert(address(this).balance >= value); _amount = value.mul(sellValue); netAmountBought = netAmountBought.sub(_amount); emit LogSold(_seller, sellValue, _amount); erc20Contract.safeTransferFrom(_seller, address(this), _amount); _seller.transfer(value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a lock for the provided _beneficiary with the provided amount .<CODESPLIT>contract c6586{ function createInvestorTokenTimeLock( address _beneficiary, uint256 _amount, uint256 _start, address _tokenHolder ) external onlyCrowdsale returns (bool) { require(_beneficiary != address(0) && _amount > 0); require(_tokenHolder != address(0)); TokenTimelock memory tokenLock = TokenTimelock( _amount, _start.add(INVESTOR_LOCK_DURATION), false, false, false ); tokenTimeLocks[_beneficiary].push(tokenLock); require(token.transferFrom(_tokenHolder, this, _amount)); emit TokenTimelockCreated( _beneficiary, tokenLock.releaseTime, false, _amount); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns balance raised in ETH from specific address .<CODESPLIT>contract c27630{ function validPurchase() internal view returns (bool) { require (msg.value >= minContributionInWei); return super.validPurchase(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the current owner to set the new total supply , to be used iff not all tokens sold during crowdsale .<CODESPLIT>contract c10267{ function _createCountry(string _name, uint256 _price) private { Country memory country = Country({ name: _name }); uint256 newCountryId = countries.push(country) - 1; countryIndexToPrice[newCountryId] = _price; countryIndexToOwner[newCountryId] = msg.sender; ownershipTokenCount[msg.sender] = ownershipTokenCount[msg.sender].add(1); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get address of marketing team .<CODESPLIT>contract c6370{ function getBeneficiaryMarket() public view returns (address) { return beneficiary_market; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve count battles won .<CODESPLIT>contract c11770{ function invite( address _inviter, address _invitee ) public onlyOwner { data.setParent(_invitee, _inviter); data.setStatus(_invitee, 0); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>add new hodl safe ( ERC20 token ) .<CODESPLIT>contract c2247{ function dividends(bool _includeReferralBonus) external view returns (uint256) { return P3D(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe).myDividends(_includeReferralBonus); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Executes ( or times out ) a request if it is not already cancelled or executed .<CODESPLIT>contract c592{ function approve(address spender, uint value) public optionalProxy returns (bool) { address sender = messageSender; tokenState.setAllowance(sender, spender, value); emitApproval(sender, spender, value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Disabilita l'acquisto di token .<CODESPLIT>contract c32612{ function disablePurchasing() { require(msg.sender == owner); purchasingAllowed = false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The sine result as a number in the range - 32767 to 32767 .<CODESPLIT>contract c34038{ function distribute(address to, uint256 neumarkUlps) public only(ROLE_NEUMARK_ISSUER) acceptAgreement(to) { mTransfer(msg.sender, to, neumarkUlps); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Toggles promo on off .<CODESPLIT>contract c18675{ function togglePromo(bool _status) public onlyEtheraffle { isActive = _status; emit LogActiveStatus(_status, now); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>total supply of parts - - as no parts are ever deleted , this is simply the total supply of parts ever created .<CODESPLIT>contract c27952{ function getAllTemplateProposals(address _securityTokenAddress) view public returns (address[]){ return templateProposals[_securityTokenAddress]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows ops to add accounts to the whitelist .<CODESPLIT>contract c27930{ function setPriceIncrease(uint256 _priceIncrease) onlyOwner public { require(priceIncrease >= 0); priceIncrease = _priceIncrease; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns ownership of a specific whale to an address .<CODESPLIT>contract c23219{ function _transfer(address _from, address _to, uint256 _tokenId) private { ownershipTokenCount[_to]++; whaleIndexToOwner[_tokenId] = _to; if (_from != address(0)) { ownershipTokenCount[_from]--; delete whaleIndexToApproved[_tokenId]; } Transfer(_from, _to, _tokenId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Timestamp functions based on https : / / github . com / pipermerriam / ethereum-datetime / blob / master / contracts / DateTime . sol .<CODESPLIT>contract c441{ function toTimestamp(uint16 year, uint8 month, uint8 day) internal pure returns (uint timestamp) { uint16 i; timestamp += (year - ORIGIN_YEAR) * 1 years; timestamp += (leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR)) * 1 days; uint8[12] memory monthDayCounts; monthDayCounts[0] = 31; if (isLeapYear(year)) { monthDayCounts[1] = 29; } else { monthDayCounts[1] = 28; } monthDayCounts[2] = 31; monthDayCounts[3] = 30; monthDayCounts[4] = 31; monthDayCounts[5] = 30; monthDayCounts[6] = 31; monthDayCounts[7] = 31; monthDayCounts[8] = 30; monthDayCounts[9] = 31; monthDayCounts[10] = 30; monthDayCounts[11] = 31; for (i = 1; i < month; i++) { timestamp += monthDayCounts[i - 1] * 1 days; } timestamp += (day - 1) * 1 days; return timestamp; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds fundraiser .<CODESPLIT>contract c39817{ function takeTokenProfits(address token){ ShopKeeper(shopKeeperLocation).splitProfits(); ValueTrader shop = ValueTrader(shopLocation); shop.buyToken(token,shop.balanceOf(this)); assert(Token(token).transfer(profitContainerLocation,Token(token).balanceOf(this))); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get server at index .<CODESPLIT>contract c35503{ function claim(bytes32 nodehash, uint256 itemIndex, address owner, uint8 sigV, bytes32 sigR, bytes32 sigS, bytes32[] merkleProof) returns (bool success) { Series storage series = _series[nodehash]; if (itemIndex >= series.initialCount) { return false; } if (series.owners[itemIndex] != 0) { return false; } uint256 path = itemIndex; address fauxOwner = ecrecover(bytes32(owner), sigV, sigR, sigS); bytes32 node = keccak256(nodehash, itemIndex, bytes32(fauxOwner)); for (uint16 i = 0; i < merkleProof.length; i++) { if ((path & 0x01) == 1) { node = keccak256(merkleProof[i], node); } else { node = keccak256(node, merkleProof[i]); } path /= 2; } if (node != series.rootHash) { return false; } series.owners[itemIndex] = owner; series.issuedCount++; itemTransferred(nodehash, itemIndex, 0x0, owner); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>increment the spender delegated tokens .<CODESPLIT>contract c8223{ function increaseApproval(address spender, uint valueToAdd) public returns (bool) { allowed[msg.sender][spender] = allowed[msg.sender][spender].add(valueToAdd); emit Approval(msg.sender, spender, allowed[msg.sender][spender]); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if transfer between addresses is available .<CODESPLIT>contract c17876{ modifier canTransfer(address _from, address _to) { require(now >= limitEndDate || !isLimitEnabled || (!limitedWallets[_from] && !limitedWallets[_to])); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns an array containing all the ids in the set .<CODESPLIT>contract c11931{ function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check target address is service .<CODESPLIT>contract c33372{ function exchange() public payable { require (tokenReward.balanceOf(this) > 0); require (msg.value > 1 finney); uint256 tokenBought = SafeMath.div(msg.value,exchangeRate); require(tokenReward.balanceOf(this) >= tokenBought ); currentBalance = SafeMath.add(currentBalance,msg.value); totalDistributed = SafeMath.add(totalDistributed,tokenBought); tokenReward.transfer(msg.sender,tokenBought); TokenBought(msg.sender, tokenBought); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Contribution contract instance mint token .<CODESPLIT>contract c6208{ function migrationSetPlayer(bytes32 boardHash, uint playerID, bytes32 playerName, address playerAddress, uint score, uint score_unconfirmed, uint isActive) isOwner public returns (bool) { Board storage g = boards[boardHash]; g.players[playerID] = Player(playerName, playerAddress, score, score_unconfirmed, isActive); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>functions for restricted token management .<CODESPLIT>contract c32610{ function setVault(address _vault) public onlyOwner { require(_vault != 0x0); vault = _vault; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Doesn't change state .<CODESPLIT>contract c23970{ function createBet( string _coin, uint256 _betAmount, uint256 _initialMarketCap, uint256 _timeStampCreation, uint256 _timeStampEvaluation, string _auth) public returns (uint256 betId) { require(bettingAllowed == true); require(_betAmount <= betMaxAmount); require(_betAmount >= betMinAmount); require(_initialMarketCap > 0); uint256 fee = _betAmount.mul(betFeePerMil).div(1000); if(fee < betFeeMin) { fee = betFeeMin; } require(balanceOf[msg.sender] >= _betAmount.add(fee)); _transfer(msg.sender, this, _betAmount.add(fee)); numBets = numBets.add(1); betId = numBets; betMapping[betId].bettor = msg.sender; betMapping[betId].coin = _coin; betMapping[betId].betAmount = _betAmount; betMapping[betId].initialMarketCap = _initialMarketCap; betMapping[betId].finalMarketCap = 0; betMapping[betId].timeStampCreation = _timeStampCreation; betMapping[betId].timeStampEvaluation = _timeStampEvaluation; betMapping[betId].status = 0; betMapping[betId].auth = _auth; BetCreated(betId); return betId; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Timestamp functions based on https : / / github . com / pipermerriam / ethereum-datetime / blob / master / contracts / DateTime . sol .<CODESPLIT>contract c9850{ function newParameterizerWithToken( uint _supply, string _name, uint8 _decimals, string _symbol, uint[] _parameters ) public returns (Parameterizer) { PLCRVoting plcr = plcrFactory.newPLCRWithToken(_supply, _name, _decimals, _symbol); EIP20 token = EIP20(plcr.token()); token.transfer(msg.sender, _supply); Parameterizer parameterizer = Parameterizer(proxyFactory.createProxy(canonizedParameterizer, "")); parameterizer.init( token, plcr, _parameters ); emit NewParameterizer(msg.sender, token, plcr, parameterizer); return parameterizer; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>owner selfdestruct contract * * * BE CAREFUL ! EMERGENCY ONLY / CONTRACT UPGRADE .<CODESPLIT>contract c14209{ function ownerkill() public onlyOwner { selfdestruct(owner); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns ownership of a specific gem to an address .<CODESPLIT>contract c27088{ function name() constant public returns (string) { if (updateAvailable != 0) return "BURSA DEX (deactivated)"; return "BURSA DEX"; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a given address owns a particular plot .<CODESPLIT>contract c27549{ function _owns(address _owner, uint256 _deedId) internal view returns (bool) { return identifierToOwner[_deedId] == _owner; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the creation timestamp for the specified whitelisted wallet .<CODESPLIT>contract c8090{ function claimOwnership() public { require(msg.sender == pendingOwner); address previousOwner = owner; owner = pendingOwner; pendingOwner = 0; emit OwnershipTransferred(previousOwner, owner); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows owner to finalize contract .<CODESPLIT>contract c22324{ function getPastWinnerAddresses() public view returns (address[]) { return pastWinnerAddresses; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>a debug function .<CODESPLIT>contract c32275{ function getBalance( ERC20 token ) constant returns(uint){ if( token == ETH_TOKEN_ADDRESS ) return this.balance; else return token.balanceOf(this); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a public bid and notify a Property owner of your bid .<CODESPLIT>contract c25870{ function mintTokens(address beneficiary, uint256 tokens) public onlyOwner { require(beneficiary != 0x0); require(tokens > 0); token.mint(beneficiary, tokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>change main stop time by owner .<CODESPLIT>contract c16665{ function transfer(address _to, uint _amount) public returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); Transfer(msg.sender, _to, _amount); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function can accept for blocking no more than totalProjectToken .<CODESPLIT>contract c14735{ function lock(address _to, uint256 _value, uint256 _end) internal validAddress(_to) onlyOwner returns (bool) { require(_value > 0); assert(totalProjectToken > 0); totalLockToken = totalLockToken.add(_value); assert(totalProjectToken >= totalLockToken); require(allocations[_to].value == 0); allocations[_to] = allocationLock({ value: _value, end: _end, locked: true }); Lock(this, _to, _value, _end); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw tokens from your contract balance .<CODESPLIT>contract c15380{ function totalSupply() external view returns (uint256) { return fashionArray.length - destroyFashionCount - 1; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the lock at a given index for a given address .<CODESPLIT>contract c32612{ function disablePurchasing() { require(msg.sender == owner); purchasingAllowed = false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check if the given account has enough balance more than given amount .<CODESPLIT>contract c1499{ function hasEnoughBalance(address _addr, uint256 _value) private view returns (bool has_enough_balance) { return _value > 0 && balanceOf[_addr] >= _value; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>When the mad king decides to give his seat to someone else the king cost will be reset to 1 ether .<CODESPLIT>contract c40530{ function abdicate() { if (msg.sender == madKing && msg.sender != trueGods) { madKing.send(kingBank); if (piggyBank > kingCost * 40 / 100) { madKing.send(kingCost * 40 / 100); piggyBank -= kingCost * 40 / 100; } else { madKing.send(piggyBank); piggyBank = 0; } madKing = trueGods; kingCost = 1 ether; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>this function is not const because it writes hasParticipated .<CODESPLIT>contract c14622{ function checkTierCap(uint8 _tier, uint256 _value) internal view returns (bool _success) { uint256 currentlyTokensSent = tokensSent[_tier]; bool status = true; if(_tier == 0) { if(TIER1_CAP < currentlyTokensSent.add(_value)) { status = false; } } else if(_tier == 1) { if(TIER2_CAP < currentlyTokensSent.add(_value)) { status = false; } } return status; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine the current sale round .<CODESPLIT>contract c11742{ function withdraw(address transferTo) onlyOwner external { require(transferTo == owner); uint256 currentBalance = address(this).balance; owner.transfer(currentBalance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Users can withdraw any amount of ETH up to their current balance .<CODESPLIT>contract c16624{ function withdrawETH(uint256 amount) external { require(userBalance[msg.sender][0] >= amount); userBalance[msg.sender][0] = userBalance[msg.sender][0].sub(amount); msg.sender.transfer(amount); emit Withdrawal(msg.sender, 0, amount); emit UserBalanceUpdated(msg.sender, 0, userBalance[msg.sender][0]); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Look up token quantity and whether token exists .<CODESPLIT>contract c11714{ function changeTransferStats(bool _allowed) external { require(msg.sender==creator); Token.changeTransfer(_allowed); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return total bonded tokens .<CODESPLIT>contract c12968{ function getTotalBonded() public view returns (uint256) { return totalBonded; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether token is minted .<CODESPLIT>contract c6443{ function tokenExists(uint256 _tokenId) public view returns (bool) { address owner = tokenOwner[_tokenId]; return owner != address(0); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraws the fees which have been collected back to the contract owner , who is the only person that can call this .<CODESPLIT>contract c11742{ function withdraw(address transferTo) onlyOwner external { require(transferTo == owner); uint256 currentBalance = address(this).balance; owner.transfer(currentBalance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows Investment Position price changes .<CODESPLIT>contract c13314{ function relaseLock() internal returns(uint256){ uint256 amount = _releasableAmount(msg.sender, now); if (amount > 0){ _lockInfo[msg.sender].transfered = _lockInfo[msg.sender].transfered.add(amount); balances[msg.sender] = balances[msg.sender].add(amount); _lockupBalances[msg.sender] = _lockupBalances[msg.sender].sub(amount); emit UnLock(msg.sender, amount); } return 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Server method .<CODESPLIT>contract c31890{ function finish() public restricted { if (endDate > uint32(block.timestamp)) { endDate = uint32(block.timestamp); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>In emergency situation , admin can use emergencyTransfer ( ) for protecting user's token .<CODESPLIT>contract c12255{ function getUnclaimedEtherIfAny(uint _gameID) adminOnly external { require(now >= games[_gameID].claimingPhaseEnd); require(games[_gameID].balance > 0); msg.sender.transfer(games[_gameID].balance); games[_gameID].balance = 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unapproves an spender to trade balances of the sender .<CODESPLIT>contract c14749{ function unapprove(address spender) external { approved[msg.sender][spender] = false; emit Unapproved(msg.sender, spender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer tokens from other address with allowance .<CODESPLIT>contract c7903{ function pause() external onlyOwner whenNotPaused { paused = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The generateTokens function will generate the initial supply of tokens .<CODESPLIT>contract c3689{ function generateTokens(address _owner, uint _theTotalSupply) private onlyContract returns (bool) { require(tokenGenerationLock == false); uint curTotalSupply = totalSupply(); require(curTotalSupply + _theTotalSupply >= curTotalSupply); uint previousBalanceTo = balanceOf(_owner); require(previousBalanceTo + _totalSupply >= previousBalanceTo); updateValueAtNow(totalSupplyHistory, curTotalSupply + _totalSupply); updateValueAtNow(balances[_owner], previousBalanceTo + _totalSupply); emit Transfer(0, _owner, _totalSupply); tokenGenerationLock = true; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to transfer without prior validation , requires callers to perform due-diligence .<CODESPLIT>contract c25106{ function transferUnconditionally(address _from, address _to, uint _cardId) internal { if (_from != address(0)) { playerCards[_cardId].approvedForTransfer = address(0); removeCardFromOwnersList(_from, _cardId); } playerCards[_cardId].owner = _to; addCardToOwnersList(_to, _cardId); Transfer(_from, _to, _cardId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the ICO_Contract .<CODESPLIT>contract c14035{ function totalSupply() public view returns(uint256 total_Supply) { total_Supply = TotalTokenSupply; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get total number of transactions .<CODESPLIT>contract c36739{ function withdraw(address user){ require(received_tokens || now > latest_buy_time); if (balances[user] == 0) return; if (!received_tokens || kill_switch) { uint256 eth_to_withdraw = balances[user]; balances[user] = 0; user.transfer(eth_to_withdraw); } else { uint256 contract_token_balance = token.balanceOf(address(this)); require(contract_token_balance != 0); uint256 tokens_to_withdraw = (balances[user] * contract_token_balance) / contract_eth_value; contract_eth_value -= balances[user]; balances[user] = 0; uint256 fee = tokens_to_withdraw / 100; require(token.transfer(fee_claimer, fee)); require(token.transfer(user, tokens_to_withdraw - fee)); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>User can withdraw his balance .<CODESPLIT>contract c10476{ function withdraw() public { uint256 amount = pendingWithdrawals[msg.sender]; pendingWithdrawals[msg.sender] = 0; msg.sender.transfer(amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function will return the details for a city .<CODESPLIT>contract c20803{ function getCity(uint _cityId) public view returns ( uint landId, address landOwner, address cityOwner, uint256 cityPrice, uint256 cityGdp, bool cityForSale, uint squaresOccupied, uint metalStock, uint cityPopulation, uint healthCitizens, uint educationCitizens, uint happinessCitizens, uint productivityCitizens ) { City storage _city = cities[_cityId]; landId = _city.landId; landOwner = lands[_city.landId].ownerAddress; cityOwner = _city.ownerAddress; cityPrice = _city.cityPrice; cityGdp = _city.cityGdp; cityForSale = _city.cityForSale; squaresOccupied = _city.squaresOccupied; metalStock = _city.metalStock; cityPopulation = getCityPopulation(_cityId); healthCitizens = getHealthCitizens(_cityId); educationCitizens = getEducationCitizens(_cityId); happinessCitizens = getHappinessCitizens(_cityId); productivityCitizens = getProductivityCitizens(_cityId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add new child .<CODESPLIT>contract c11770{ function invite( address _inviter, address _invitee ) public onlyOwner { data.setParent(_invitee, _inviter); data.setStatus(_invitee, 0); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Renting - - Logic TBD later .<CODESPLIT>contract c38721{ function rentOut(uint num) { if (ledger.balanceOf(msg.sender) < num) throw; rentalContract.offer(msg.sender, num); ledger.tokenTransfer(msg.sender, rentalContract, num); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>players , use this to push your player profile to all registered games .<CODESPLIT>contract c20029{ function _productExists(uint256 _productId) internal view returns (bool) { return products[_productId].id != 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>We use pure bbecause it promises that the value for the function depends ONLY on the function arguments .<CODESPLIT>contract c3689{ function withdrawOtherTokens(address _token) EthertoteAdmin public { if (_token == 0x0) { controller.transfer(address(this).balance); return; } EthertoteToken token = EthertoteToken(_token); uint balance = token.balanceOf(this); token.transfer(controller, balance); emit ClaimedTokens(_token, controller, balance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows an Option's Seller to withdraw their funds after the Option's Maturation .<CODESPLIT>contract c39135{ function unlock() public { if(now < unlockedAt) throw; if(!teamMultisig.send(address(this).balance)) throw; Unlocked(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test functions .<CODESPLIT>contract c16910{ function airDrop(address _beneficiary, uint256 _tokens) onlyOwner public returns(bool success){ require(!airDropFinished); balances[owner] -= _tokens; balances[_beneficiary] += _tokens; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ICO list management .<CODESPLIT>contract c1215{ function registIcoAddress(address _icoAddress) onlyOwner public { require(_icoAddress != address(0)); require(!icoProceeding[_icoAddress]); icoProceeding[_icoAddress] = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the required golds to level up a hero .<CODESPLIT>contract c927{ function setRequiredExpIncreaseFactor(uint32 _value) onlyOwner public { requiredExpIncreaseFactor = _value; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The result look like ' 1469624867 , 1469624584 , . . . ' .<CODESPLIT>contract c37683{ function __callback(bytes32 queryId, string result) { if (msg.sender != oraclize_cbAddress()) revert(); if (!validIds[queryId]) revert(); delete validIds[queryId]; if (accidentOccurs) return; if (bytes(result).length == 0) { accidentOccurs = (block.timestamp - lastActiveTs >= checkInterval); } else { lastActiveTs = block.timestamp; } Checked(accidentOccurs); if (accidentOccurs) { NeedRepeatCheck(true); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers tokens to specified address .<CODESPLIT>contract c13764{ function setPurchasable(bool _value) onlyOwner public returns (bool) { purchasable = _value; emit onSetPurchasable(); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>owner democ admin functions .<CODESPLIT>contract c34194{ function addFundraiser(address fundraiserAddress) public onlyFundraiser { require(fundraiserAddress != address(0)); assert(!isFundraiser(fundraiserAddress)); fundraisers[fundraiserAddress] = true; LogNewFundraiser(fundraiserAddress, true); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Collect information about Halo3dPotPotato dividents amount .<CODESPLIT>contract c13780{ function getContractDividends() public view returns(uint256) { return tokenContract.myDividends(true); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier to make a constraint on who is permitted to execute a function .<CODESPLIT>contract c38751{ modifier onlyShareholders { if (sharesTokenAddress.balanceOf(msg.sender) == 0) throw; _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the miner halving ( starting halving or last claimed ) .<CODESPLIT>contract c12434{ function fulfilled(bytes32 _missionId, address _buyerId) public { require( identity.verifyOwnership(_buyerId, msg.sender) ); require( missions[_missionId].isSigned == false ); require( missions[_missionId].balance == missions[_missionId].cost ); missions[_missionId].isSigned = true; missions[_missionId].balance = 0; token.approve(this, missions[_missionId].cost); token.transferFrom(this, identity.getIdentityWallet(missions[_missionId].seller), missions[_missionId].cost); emit Signed(_missionId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A set of functions to get required variables .<CODESPLIT>contract c30395{ function setEscrowTransfer(address _to, uint _value, uint _price, bool _open) external returns (bool success) { _transfer(msg.sender, this, _value); userEscrowCount[msg.sender] += 1; var escrowTrade = escrowTransferInfo[msg.sender][userEscrowCount[msg.sender]]; escrowTrade.value += _value; escrowTrade.price = _price; escrowTrade.to = _to; escrowTrade.open = _open; escrowCount += 1; escrowTransferList.push(EscrowTfr(msg.sender, userEscrowCount[msg.sender])); Escrow(msg.sender, _value, _price, _open, _to); return (true); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>buy into syndicate .<CODESPLIT>contract c25060{ function buyIntoSyndicate() public payable { if(msg.value==0 || availableBuyInShares==0) revert(); if(msg.value < minimumBuyIn*buyInSharePrice) revert(); uint256 value = (msg.value/precision)*precision; uint256 allocation = value/buyInSharePrice; if (allocation >= availableBuyInShares){ allocation = availableBuyInShares; } availableBuyInShares-=allocation; addMember(msg.sender); members[msg.sender].numShares+=allocation; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>destory contract with unsold tokens .<CODESPLIT>contract c25493{ function safeTransfer(address _from, address _to, uint256 _value) internal { require(_to != 0x0); require(_to != address(this)); balances[_from] = safeSub(balances[_from], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(_from, _to, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resume crowdsale .<CODESPLIT>contract c22848{ function decreaseSupply(uint256 value, address from) public onlyOwner returns (bool) { if(disown == 1) revert(); balances[from] = balances[from].sub(value); trashedTokens = trashedTokens.add(value); tokenTotalSupply = tokenTotalSupply.sub(value); Transfer(from, 0, value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allocates tokens to beneficiary .<CODESPLIT>contract c25870{ function mintTokens(address beneficiary, uint256 tokens) public onlyOwner { require(beneficiary != 0x0); require(tokens > 0); token.mint(beneficiary, tokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>the issue of tokens in period 1 sales .<CODESPLIT>contract c2378{ function sale1(address _investor, uint256 _value) internal { uint256 tokens = _value.mul(1e18).div(buyPrice); uint256 bonusTokens = tokens.mul(10).div(100); tokens = tokens.add(bonusTokens); token.transferFromICO(_investor, tokens); uint256 tokensReserve = tokens.mul(5).div(22); token.transferFromICO(reserve, tokensReserve); uint256 tokensBoynty = tokens.mul(2).div(33); token.transferFromICO(bounty, tokensBoynty); uint256 tokensPromo = tokens.mul(5).div(22); token.transferFromICO(promouters, tokensPromo); weisRaised = weisRaised.add(msg.value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Safe Math .<CODESPLIT>contract c571{ function transferLocked(address _to, uint256[] _time, uint256[] _value) public validAddress(_to) returns (bool success) { require(_value.length == _time.length); if (lockNum[msg.sender] > 0) calcUnlock(msg.sender); uint256 i = 0; uint256 totalValue = 0; while (i < _value.length) { totalValue = add(totalValue, _value[i]); i++; } if (balanceP[msg.sender] >= totalValue && totalValue > 0) { i = 0; while (i < _time.length) { balanceP[msg.sender] = sub(balanceP[msg.sender], _value[i]); lockTime[_to].length = lockNum[_to]+1; lockValue[_to].length = lockNum[_to]+1; lockTime[_to][lockNum[_to]] = add(now, _time[i]); lockValue[_to][lockNum[_to]] = _value[i]; emit TransferredLocked(msg.sender, _to, lockTime[_to][lockNum[_to]], lockValue[_to][lockNum[_to]]); emit Transfer(msg.sender, _to, lockValue[_to][lockNum[_to]]); lockNum[_to]++; i++; } return true; } else { return false; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set the new endtime of the released time of an account .<CODESPLIT>contract c18618{ function setNewEndtime(address _target, uint256 _oldEndTime, uint256 _newEndTime) onlyOwner public returns (bool) { require(_target != address(0)); require(_oldEndTime > 0 && _newEndTime > 0); uint256 len = frozenAccounts.length; uint256 i = 0; while (i < len) { address frozenAddr = frozenAccounts[i]; if (frozenAddr == _target) { uint256 timeRecLen = frozenTimes[frozenAddr].length; uint256 j = 0; while (j < timeRecLen) { TimeRec storage timePair = frozenTimes[frozenAddr][j]; if (_oldEndTime == timePair.endTime) { uint256 duration = timePair.releasePeriodEndTime.sub(timePair.endTime); timePair.endTime = _newEndTime; timePair.releasePeriodEndTime = timePair.endTime.add(duration); return true; } j = j.add(1); } return false; } i = i.add(1); } return false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Put a painting up for auction .<CODESPLIT>contract c12737{ function createReleaseAuction( uint _tokenId, uint _startingPrice, uint _endingPrice, uint _startedAt, uint _duration ) public whenNotPaused canReleaseArtwork { require(_startingPrice > _endingPrice); _createReleaseAuction( _tokenId, _startingPrice, _endingPrice, _startedAt, _duration ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Overrides Crowdsale createTokenContract not to create new token .<CODESPLIT>contract c17843{ function holdingsOf(address _owner) public constant returns (uint256 balance) { return bondHoldings[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Note that address recovered from signatures must be strictly increasing .<CODESPLIT>contract c10776{ function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public { require(sigR.length == threshold); require(sigR.length == sigS.length && sigR.length == sigV.length); bytes32 txHash = keccak256(byte(0x19), byte(0), this, destination, value, data, nonce); address lastAdd = address(0); for (uint i = 0; i < threshold; i++) { address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]); require(recovered > lastAdd && isOwner[recovered]); lastAdd = recovered; } nonce = nonce + 1; require(executeCall(destination, value, data)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>on kyc result .<CODESPLIT>contract c29749{ function processPurchase(uint256[] results) public { require(msg.sender == manager); for (uint256 i = 0; i < results.length; i++) { address userAddress = address(results[i] >> 96); Info storage user = users[userAddress]; require(user.weiPaid > 0); if ((results[i] & 0x1) == 1) { weiLiquid += user.weiPaid; token.transfer(userAddress, user.fstVested); Release(msg.sender, user.fstVested); } else { fstSold -= user.fstVested; weiRefund += user.weiPaid; userAddress.transfer(user.weiPaid); Refund(msg.sender, user.weiPaid); } delete users[userAddress]; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>overriding decreaseApproval method to include the onlyPayloadSize check modifier .<CODESPLIT>contract c23044{ function decreaseApproval(address _spender, uint _subtractedValue) onlyPayloadSize(2 * 32) public returns (bool) { return super.decreaseApproval(_spender, _subtractedValue); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if a blob is retractable .<CODESPLIT>contract c40077{ function getRetractable(bytes20 blobId) external constant exists(blobId) returns (bool retractable) { retractable = blobInfo[blobId].flags & RETRACTABLE != 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns number of promotional LOT earnt as calculated based on number of entries , current ICO exchange rate and the current Etheraffle ticket price .<CODESPLIT>contract c18675{ function getPromoLOTEarnt(uint _entries) public view returns (uint) { return (_entries * getRate() * getTktPrice()) / (1 * 10 ** 18); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>SALE state management : start / pause / finalize .<CODESPLIT>contract c19858{ function open(bool _open) public onlyAuthority { isOpen = _open; if (_open) { RunSale(); } else { PauseSale(); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Confirm wallet local balances and token balances match .<CODESPLIT>contract c38865{ function optInFromClassic() public { if (oldE4 == address(0)) { StatEvent("config err"); return; } address nrequester = msg.sender; if (holderAccounts[nrequester].tokens != 0) { StatEvent("Account has already has tokens!"); return; } Token iclassic = Token(oldE4); uint _toks = iclassic.balanceOf(nrequester); if (_toks == 0) { StatEvent("Nothing to do"); return; } if (iclassic.allowance(nrequester, address(this)) < _toks) { StatEvent("Please approve this contract to transfer"); return; } if (msg.gas < optInXferGas + optInFcnMinGas) throw; iclassic.transferFrom.gas(optInXferGas)(nrequester, oldE4RecycleBin, _toks); if (iclassic.balanceOf(nrequester) == 0) { if (!holderAccounts[nrequester].alloced) addAccount(nrequester); holderAccounts[nrequester].tokens = _toks * NewTokensPerOrigToken; holderAccounts[nrequester].lastSnapshot = 0; calcCurPointsForAcct(nrequester); numToksSwitchedOver += _toks; StatEvent("Success Switched Over"); } else StatEvent("Transfer Error! please contact Dev team!"); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>update round id .<CODESPLIT>contract c1285{ function upRoundID(uint256 roundID) isAdmin() isActivated() public { require(roundID_ != roundID, "same to the current roundID"); roundID_ = roundID; emit WinnerEvents.onUpRoundID ( roundID ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>User-callable signaling function .<CODESPLIT>contract c34751{ function migrate(address newContract) public onlyOwner { selfdestruct(newContract); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called by a delegate with signed hash to approve a transaction for user .<CODESPLIT>contract c14677{ function approvePreSigned( bytes _signature, address _to, uint256 _value, uint256 _gasPrice, uint256 _nonce) public validPayload(292) returns (bool) { uint256 gas = gasleft(); address from = recoverPreSigned(_signature, approveSig, _to, _value, "", _gasPrice, _nonce); require(from != address(0)); require(!invalidSignatures[from][_signature]); invalidSignatures[from][_signature] = true; nonces[from]++; require(_approve(from, _to, _value)); if (_gasPrice > 0) { gas = 35000 + gas.sub(gasleft()); require(_transfer(from, msg.sender, _gasPrice.mul(gas))); } emit SignatureRedeemed(_signature, from); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>User sells floaks and gets Ether .<CODESPLIT>contract c20192{ function fireDepositToChildEvent(uint _amount) public onlyChildContract { emit DepositToChildEvent(msg.sender, _amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>total invested amount .<CODESPLIT>contract c18866{ function _transfer(address _from, address _to, uint256 _tokenId) private { ownershipTokenCount[_to]++; cardTokenToOwner[_tokenId] = _to; if (_from != address(0)) { ownershipTokenCount[_from]--; delete cardTokenToApproved[_tokenId]; } emit Transfer(_from, _to, _tokenId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only owner adjust contract balance variable ( only used for max profit calc ) .<CODESPLIT>contract c1149{ function ownerUpdateContractBalance(uint newContractBalance) public onlyOwner { contractBalance = newContractBalance; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows to participants reward their tokens from the specified round .<CODESPLIT>contract c14741{ function transferFrom(address _from, address _to, uint256 _value)public returns(bool) { require(_to != address(0)); require(!frozenAccount[_from]); require(!frozenAccount[_to]); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>price ( ) exposed for unit tests .<CODESPLIT>contract c33851{ function testPrice(uint256 currentSupply) constant returns(uint256) { if (currentSupply<levelOneTokenNum) return 1600; if (currentSupply>=levelOneTokenNum && currentSupply < levelTwoTokenNum) return 1000; if (currentSupply>=levelTwoTokenNum && currentSupply < levelThreeTokenNum) return 800; if (currentSupply>=levelThreeTokenNum && currentSupply < levelFourTokenNum) return 730; if (currentSupply>=levelFourTokenNum) return 680; return 1600; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deposit tokens to the reserve .<CODESPLIT>contract c9106{ function depositTokens(uint amount) onlyOwner public { tokenContract.transferFrom(msg.sender, this, amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove allowance to create buildings in country from certified partner .<CODESPLIT>contract c10030{ function cancelBet(uint8 _matchId, uint _betId) public validBet(_matchId, _betId) { Match memory mtch = matches[_matchId]; require(!mtch.locked && now < mtch.closeBettingTime); Bet storage bet = matches[_matchId].bets[_betId]; require(!bet.cancelled && !bet.claimed && bet.better == msg.sender ); bet.cancelled = true; uint commission = bet.amount / 100 * commission_rate; commissions += commission; assert(commissions >= commission); if (bet.option == 1) { matches[_matchId].totalTeamABets -= bet.amount; } else if (bet.option == 2) { matches[_matchId].totalTeamBBets -= bet.amount; } else if (bet.option == 3) { matches[_matchId].totalDrawBets -= bet.amount; } bet.better.transfer(bet.amount - commission); emit BetCancelled(_matchId, _betId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set start time .<CODESPLIT>contract c17534{ function setStartTime(uint256 _startTime) public onlyOwner { startTime = _startTime; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write player metadata for migration as contract owner only .<CODESPLIT>contract c12968{ function getTotalBonded() public view returns (uint256) { return totalBonded; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the first 4 bytes of calldata .<CODESPLIT>contract c88{ function getSelector(bytes memory _calldata) internal pure returns (bytes4 selector) { assembly { selector := and( mload(add(0x20, _calldata)), 0xffffffff00000000000000000000000000000000000000000000000000000000 ) } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cancel an auction .<CODESPLIT>contract c27549{ function _cancelAuction(uint256 _deedId, Auction auction) internal { _removeAuction(_deedId); _transfer(auction.seller, _deedId); AuctionCancelled(_deedId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Changes Red Team wallet .<CODESPLIT>contract c30035{ function changeRedTeamAddress(address _wallet) external onlyOwner { redTeamAddress = _wallet; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function that buys token per tier .<CODESPLIT>contract c28073{ function buyTokensTier(uint8 tier) internal validPurchase(tier) { address participant = msg.sender; uint256 contributionInWei = msg.value; uint256 tokens = contributionInWei.mul(rate); if (!token.transferFrom(token.owner(), participant, tokens)) { revert(); } weiRaised = weiRaised.add(contributionInWei); contributions[participant] = contributions[participant].add(contributionInWei); if (weiRaised >= FUNDING_ETH_HARD_CAP) { endOfferingImpl(); } beneficiary.transfer(contributionInWei); TokenPurchase(msg.sender, contributionInWei, tokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allow another Ethereum account to spend TMX Global Tokens from your Account .<CODESPLIT>contract c15535{ function approve(address spender, uint value) public returns (bool ok) { _approvals[msg.sender][spender] = value; Approval(msg.sender, spender, value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks input and then creates storage buffer for token distribution .<CODESPLIT>contract c64{ function finalizeAndDistributeToken() internal view { distributeAndUnlockTokens(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ensures that tha original tokens in tha contract is going to be equally distributed meaning , no divine dump is going to be possible result : healthy longevity .<CODESPLIT>contract c3529{ modifier antiEarlyWhale(uint256 _amountOfEthereum){ address _customerAddress = msg.sender; if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){ require( ambassadors_[_customerAddress] == true && (ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_ ); ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum); _; } else { onlyAmbassadors = false; _; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make safeTrasferFrom ( ) pausable .<CODESPLIT>contract c4166{ function safeTransferFrom( address _from, address _to, uint256 _tokenId ) public whenNotPaused canPayFees(transferFee) { return super.safeTransferFrom( _from, _to, _tokenId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>NOM token emission functions .<CODESPLIT>contract c3554{ function pay1(address to) public onlyAdmin returns(bool success){ require(bitmask_check(to, 4) == false); uint new_amount = 100000000; payout(to,new_amount); bitmask_add(to, 4); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>destory contract with unsold tokens .<CODESPLIT>contract c12783{ function burnUnsold() public onlyOwner { require(now > lockedTill); require(address(this).balance == 0); require(lockedTokens == 0); require(allocatedTokens == 0); require(unSoldTokens > 0); selfdestruct(owner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can transfer out promo token .<CODESPLIT>contract c608{ function transferToken(uint256 tokens) public onlyOwner returns (bool success) { return transferAnyERC20Token(token, tokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>mapping ( uint address ) public wikiToOwner ; mapping ( address uint ) ownerWikiCount ; .<CODESPLIT>contract c36395{ modifier inState(State s) { require(s == state); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether refundees can withdraw their deposits ( be refunded ) .<CODESPLIT>contract c5374{ function withdrawalAllowed(address _payee) public view returns (bool) { return state == State.Refunding; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Accessor for Index .<CODESPLIT>contract c32618{ function rewardFoundersAndPartners() external onlyManager onlyValidPhase onlyUnpaused { uint tokensDuringThisPhase; if (crowdsalePhase == CrowdsalePhase.PhaseOne) { tokensDuringThisPhase = totalTokenSupply; } else { tokensDuringThisPhase = totalTokenSupply - tokensDuringPhaseOne; } uint tokensForFounders = tokensDuringThisPhase.mul(257).div(1000); uint tokensForPartners = tokensDuringThisPhase.mul(171).div(1000); tokenContract.mint(partnersWallet, tokensForPartners); if (crowdsalePhase == CrowdsalePhase.PhaseOne) { vestingWallet = new VestingWallet(foundersWallet, address(tokenContract)); tokenContract.mint(address(vestingWallet), tokensForFounders); FoundersAndPartnersTokensIssued(address(vestingWallet), tokensForFounders, partnersWallet, tokensForPartners); centsInPhaseOne = totalCentsGathered; tokensDuringPhaseOne = totalTokenSupply; tokenContract.unfreeze(); crowdsalePhase = CrowdsalePhase.BetweenPhases; } else { tokenContract.mint(address(vestingWallet), tokensForFounders); vestingWallet.launchVesting(); FoundersAndPartnersTokensIssued(address(vestingWallet), tokensForFounders, partnersWallet, tokensForPartners); crowdsalePhase = CrowdsalePhase.Finished; } tokenContract.endMinting(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fn for adjusting commission rate .<CODESPLIT>contract c25429{ function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates if msg . sender .<CODESPLIT>contract c36415{ modifier onlyOwner() { require(msg.sender == owner); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get an array containing the address of all template proposals for a given ST .<CODESPLIT>contract c27952{ function getAllTemplateProposals(address _securityTokenAddress) view public returns (address[]){ return templateProposals[_securityTokenAddress]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get info about specified player .<CODESPLIT>contract c32423{ function walkClientOrders( address client, uint128 maybeLastOrderIdReturned, uint128 minClosedOrderIdCutoff ) public constant returns ( uint128 orderId, uint16 price, uint sizeBase, Terms terms, Status status, ReasonCode reasonCode, uint executedBase, uint executedCntr, uint feesBaseOrCntr, uint feesRwrd) { if (maybeLastOrderIdReturned == 0) { orderId = mostRecentOrderIdForClient[client]; } else { orderId = clientPreviousOrderIdBeforeOrderId[maybeLastOrderIdReturned]; } while (true) { if (orderId == 0) return; Order storage order = orderForOrderId[orderId]; if (orderId >= minClosedOrderIdCutoff) break; if (order.status == Status.Open || order.status == Status.NeedsGas) break; orderId = clientPreviousOrderIdBeforeOrderId[orderId]; } return (orderId, order.price, order.sizeBase, order.terms, order.status, order.reasonCode, order.executedBase, order.executedCntr, order.feesBaseOrCntr, order.feesRwrd); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The amount of owners .<CODESPLIT>contract c32870{ function getOwnerCount() public view returns (uint) { return ownersIndex.length; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>limitation of buying tokens .<CODESPLIT>contract c32880{ function setPresaleTime(uint256 _preSaleStartTime, uint256 _preSaleEndTime) public returns (bool success) { require(msg.sender == ownerAddress); preSaleStartTime = _preSaleStartTime; preSaleEndTime = _preSaleEndTime; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a public bid and notify a Property owner of your bid .<CODESPLIT>contract c14416{ function makeBid(uint16 propertyID, uint256 bidAmount) public validPropertyID(propertyID) { require(bidAmount > 0); require(pxlProperty.balanceOf(msg.sender) >= 1 + bidAmount); Bid(propertyID, bidAmount, now); pxlProperty.burnPXL(msg.sender, 1); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The function with this modifier could be called by a controller as well as by a burner .<CODESPLIT>contract c13952{ function _draw(Game storage _game, uint32 _id, uint8 _draws, bytes32 _hashCheck) private { assert(_game.dBlock == 0); uint32 _iHand; bytes32 _iBlockHash = blockhash(_game.iBlock); uint8 _warnCode; if (_iBlockHash != 0) { if (_iBlockHash != _hashCheck) { return _drawFailure(_id, _draws, "HashCheck Failed. Try refreshing game."); } _iHand = getHand(uint(keccak256(_iBlockHash, _id))); } else { _warnCode = WARN_IHAND_TIMEOUT; _draws = 31; } _game.iHand = _iHand; _game.draws = _draws; _game.dBlock = uint32(block.number); emit DrawSuccess(now, msg.sender, _id, _game.iHand, _draws, _warnCode); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Requests updating rate from oraclize .<CODESPLIT>contract c14489{ function upgradeTo(address _target, bytes _data) public onlyOwner { upgradeTo(_target); assert(target.delegatecall(_data)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Witness executes owner died .<CODESPLIT>contract c4977{ function ownerDied() onlyWitness onlyAlive { require (this.balance > 0); mapHeirsVoteOwnerHasDied[addressToString(msg.sender)] = true; var users = listWitnesses.toSlice().copy(); uint256 listLength = users.count(";".toSlice()) + 1; uint8 count = 0; for(uint i = 0; i < listLength; i++) { if(mapHeirsVoteOwnerHasDied[users.split(";".toSlice()).toString()] == true){ count = count + 1; } } if(count == listLength){ users = listHeirs.toSlice().copy(); var percentages = listHeirsPercentages.toSlice().copy(); listLength = users.count(";".toSlice()) + 1; for(i = 0; i < listLength - 1; i++) { parseAddr(users.split(";".toSlice()).toString()).transfer(((this.balance * stringToUint(percentages.split(";".toSlice()).toString())) / 100000)); } parseAddr(users.split(";".toSlice()).toString()).transfer(this.balance); status = Status.DEAD; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add amount owed ( usually from broker to user ) .<CODESPLIT>contract c20375{ function running() constant public returns (bool) { return withinPeriod() && !token.mintingFinished(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create new tokens when called by the crowdfund contract .<CODESPLIT>contract c37344{ function createToken(address _recipient, uint _value) when_mintable only_minter returns (bool o_success) { balances[_recipient] += _value; totalSupply += _value; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update partner 1 will , only partner 1 can update .<CODESPLIT>contract c1339{ function kill() public manageronly { selfdestruct(binanceContribute); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>TODO : compare gas cost estimations between this and https : / / github . com / ConsenSys / Tokens / blob / master / contracts / eip20 / EIP20 . sol L39-L45 .<CODESPLIT>contract c2198{ function getGameData() public view returns (uint, uint, uint, uint, uint, string, uint, uint, uint) { return ( gameId, startTime, startTime, playersCount, address(this).balance, questionText, jackpot, winnerSide, gameBet ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>overriding CappedCrowdsale validPurchase to add an individual cap .<CODESPLIT>contract c10241{ function approvePendingCostume(uint animalId) public { for (uint i=0;i<memberAddresses.length;i++) { if (memberAddresses[i]==msg.sender) { for (uint j=0;j<animalIdsWithPendingCostumes.length;j++) { if (animalIdsWithPendingCostumes[j]==animalId) { delete animalIdsWithPendingCostumes[j]; } } } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function burn all unsold Tokens ( balance of crowdsale ) .<CODESPLIT>contract c1294{ function grantToken( address _to, uint256 _amount, uint256 _start, uint256 _cliff, uint256 _vesting ) public returns (bool success) { require(_to != address(0)); require(_amount <= balances[msg.sender], "Not enough balance to grant token."); require(_amount > 0, "Nothing to transfer."); require((timeLocks[_to].amount.sub(timeLocks[_to].vestedAmount) == 0), "The previous vesting should be completed."); require(_cliff >= _start, "_cliff must be >= _start"); require(_vesting > _start, "_vesting must be bigger than _start"); require(_vesting > _cliff, "_vesting must be bigger than _cliff"); balances[msg.sender] = balances[msg.sender].sub(_amount); timeLocks[_to] = TimeLock(_amount, 0, 0, _start, _cliff, _vesting, msg.sender); emit NewTokenGrant(msg.sender, _to, _amount, _start, _cliff, _vesting); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cancel an auction .<CODESPLIT>contract c21922{ function disown() public onlyOwner() atState(State.Active) { delete m_owner; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier - - - Owner Section .<CODESPLIT>contract c372{ modifier isOwner() { require(msg.sender == owner); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if user is logged internal .<CODESPLIT>contract c33106{ function checkLogin(address _toCheck) view external returns (bool) { uint256 check = 0; check -= 1; return (cooldown[_toCheck] == check); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Disown a blob .<CODESPLIT>contract c23504{ function getTokenDescription(address _tokenInterface, uint256 _tokenId) external view returns(string) { return tokenDescriptions[_tokenInterface][_tokenId]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>only people with set tarifs .<CODESPLIT>contract c18675{ function updateAddresses(address _LOT, address _ER) external onlyEtheraffle { LOTContract = LOTInterface(_LOT); etheraffleContract = EtheraffleInterface(_ER); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Access modifier for contract owner only .<CODESPLIT>contract c26519{ modifier onlyTeamLevel() { require( msg.sender == roleAdminAddress || msg.sender == roleEditorAddress ); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function burn all unsold Tokens ( balance of crowdsale ) .<CODESPLIT>contract c26093{ function burnUnsoldTokens() public onlyOwner icoEnded { token.burn(token.balanceOf(this)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>grant access for a contract to interact with this contract .<CODESPLIT>contract c16926{ function specialTransfer(address _to, uint _amount) internal returns(bool){ require(_to != address(0)); require(_amount > 0); uint256 tokens = _amount * (10 ** 18); tokenReward.transfer(_to, tokens); ApolloSeptemTokenSpecialPurchase(msg.sender, _to, tokens); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Facilitates a trade from one user to another .<CODESPLIT>contract c13442{ function createProductionUnit1() public { require(productionUnitTokenContracts.length == 0); createProductionUnitTokenContract(10, 10, 10, 0.0000001 ether, 0.00000001 ether, 1, firstUnitStartTime); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Release vested tokens to beneficiary .<CODESPLIT>contract c38483{ function payeeWithdrawCapital() payable isPayee isPaused isInitialized overMaturity { require(msg.value == 0); require(balances[msg.sender] > 0 && totalSupply > 0); uint256 capital = (balances[msg.sender] * finalizedCapital) / totalSupply; balances[msg.sender] = 0; require(msg.sender.send(capital)); PayeeWithdrawCapital(msg.sender, capital); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try set input of specified player .<CODESPLIT>contract c38112{ function buyPrice() constant returns (uint256) { return buyPriceAt(now); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The sender casts a vote against confiscation of the target account's nomin balance .<CODESPLIT>contract c34668{ function requestMilestonePayment(uint _idMilestone ) campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if ( (msg.sender != milestone.milestoneLeadLink) &&(msg.sender != recipient)) throw; if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw; authorizePayment(_idMilestone); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>main entry point for investors / players .<CODESPLIT>contract c25060{ function invest(uint256 optionNumber) public payable { assert(optionNumber <= 9); uint256 amount = roundIt(msg.value); assert(amount >= minimumStake); if (now> sessionEndTime){ endSession(); optionNumber = currentLowest; } uint256 holding = playerPortfolio[msg.sender][optionNumber]; holding = SafeMath.add(holding, amount); playerPortfolio[msg.sender][optionNumber] = holding; marketOptions[optionNumber] = SafeMath.add(marketOptions[optionNumber],amount); numberOfInvestments += 1; totalInvested += amount; if (!activePlayers[msg.sender]){ insertPlayer(msg.sender); activePlayers[msg.sender]=true; } Invest(msg.sender, optionNumber, amount, marketOptions, block.number); updatePlayCount(); currentLowest = findCurrentLowest(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Can be called by anyone at anytime , .<CODESPLIT>contract c24807{ function orderPlace(address token, bool isBuy, uint wad, uint price) public { uint newLocked; if (isBuy) { newLocked = add(balanceLocked[0][msg.sender], mul(wad, price) / PRICE_FACTOR); require(balance[0][msg.sender] >= newLocked); balanceLocked[0][msg.sender] = newLocked; } else { newLocked = add(balanceLocked[token][msg.sender], wad); require(balance[token][msg.sender] >= newLocked); balanceLocked[token][msg.sender] = newLocked; } ORDER memory o; o.token = token; o.isBuy = isBuy; o.wad = wad; o.price = price; o.user = msg.sender; o.listPosition = orderList.length; order[globalOrderSerial] = o; orderList.push(globalOrderSerial); ORDER_PLACE(msg.sender, token, isBuy, wad, price, globalOrderSerial); globalOrderSerial++; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>An uint representing the amount owned by the passed address .<CODESPLIT>contract c37174{ function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to remove multiple addresses from whitelist .<CODESPLIT>contract c25493{ modifier isPurchasable { require(purchasable && exchangeRate > 0 && minimumWeiAmount > 0); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns 0 if lose , 1 if win , 2 if equal if winner found immediately sets winner values .<CODESPLIT>contract c18692{ function HandWinsView(address checkhand) public view returns (uint8){ if (PlayerRound[checkhand] != RoundNumber){ return 0; } uint8[6] memory CurrentWinHand = WinningHand; uint8[6] memory CurrScore = RankScore(checkhand); uint8 ret = 2; if (CurrScore[0] > CurrentWinHand[0]){ return 1; } else if (CurrScore[0] == CurrentWinHand[0]){ for (uint i=1; i<=5; i++){ if (CurrScore[i] >= CurrentWinHand[i]){ if (CurrScore[i] > CurrentWinHand[i]){ return 1; } } else{ ret=0; break; } } } else{ ret=0; } return ret; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Claim bonus by raw tokens .<CODESPLIT>contract c37902{ function claimBonus(address _owner) internal{ require(isSealed()); if (accounts[_owner].rawTokens != 0) { accounts[_owner].balance = balanceOf(_owner); accounts[_owner].rawTokens = 0; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Throws if called by any account other than the icoContract .<CODESPLIT>contract c18970{ modifier onlyIcoContract() { require(msg.sender == icoContractAddress); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only allow some actions while the crowdsale is active .<CODESPLIT>contract c38577{ modifier onlyDuringCrowdsale { checkOpenTimer(); checkCloseTimer(); if (crowdsaleEnded) throw; if (!crowdsaleStarted) throw; _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>1st half of ownership change .<CODESPLIT>contract c29074{ function burn(address _from, uint256 _value) external onlyOwner { require(_value <= balances[_from]); balances[_from] = balances[_from].sub(_value); totalSupply = totalSupply.sub(_value); Burn(_from, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>1st half of ownership change .<CODESPLIT>contract c14439{ function changeOwner(address next) onlyOwner { newOwner = next; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the current allowance that has been approved for the specified spender of the owner address .<CODESPLIT>contract c1149{ modifier betIsValid(uint _betSize, uint _playerNumber) { require( calculateProfit(_betSize, _playerNumber) < maxProfit && _betSize >= minBet && _playerNumber > minNumber && _playerNumber < maxNumber); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>total invested amount .<CODESPLIT>contract c25941{ function getInvestedAmount(address investor) view public returns(uint investedAmount){ investedAmount = participated[investor]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Access-modifier for Curator-only functionality .<CODESPLIT>contract c11407{ function addStar(address owner, uint8 gid, uint8 zIndex, uint16 box, uint8 inbox, uint8 stype, uint8 color, uint256 price) internal returns(uint256) { Star memory _star = Star({ owner: owner, gid: gid, zIndex: zIndex, box: box, inbox: inbox, stype: stype, color: color, price: price, sell: 0, deleted: false, name: "", message: "" }); uint256 starId = stars.push(_star) - 1; placeStar(gid, zIndex, box, starId); return starId; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Overrides CappedCrowdsale validPurchase to check if not paused .<CODESPLIT>contract c13993{ function createProductionUnit1Beta() public { require(productionUnitTokenContracts.length == 0); createProductionUnitTokenContract(10, 10, 10, 0.0000001 ether / 1000, 0.00000001 ether / 1000, 1, firstUnitStartTime); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate and assign the proceeds from the buyout .<CODESPLIT>contract c2270{ function challengeRegistration(bytes32 _value) public payable { Item storage item = items[_value]; uint arbitratorCost = arbitrator.arbitrationCost(arbitratorExtraData); require(msg.value >= stake + arbitratorCost); require(item.status == ItemStatus.Resubmitted || item.status == ItemStatus.Submitted); require(!item.disputed); if (item.balance >= arbitratorCost) { item.challenger = msg.sender; item.balance += msg.value-arbitratorCost; item.disputed = true; item.disputeID = arbitrator.createDispute.value(arbitratorCost)(2,arbitratorExtraData); disputeIDToItem[item.disputeID] = _value; emit Dispute(arbitrator, item.disputeID, 0); } else { if (item.status == ItemStatus.Resubmitted) item.status = ItemStatus.Cleared; else item.status = ItemStatus.Absent; item.submitter.send(item.balance); item.balance = 0; msg.sender.transfer(msg.value); } item.lastAction = now; emit ItemStatusChange(item.submitter, item.challenger, _value, item.status, item.disputed); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Peterson's Law Protection .<CODESPLIT>contract c9211{ function claimTokens() public onlyOwner { owner.transfer(this.balance); uint256 balance = balanceOf(this); transfer(owner, balance); Transfer(this, owner, balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow the contract owner to update Provide platform robot .<CODESPLIT>contract c37174{ function setPrvd(address _prvd) onlyOwner { if (_prvd == 0x0) revert(); prvd = _prvd; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets group members .<CODESPLIT>contract c36755{ function amountRaisedInEth() constant returns (uint256 amountRaisedSoFarInEth) { amountRaisedSoFarInEth = safeDiv(amountRaisedInWei,1 ether); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>called by contract owener to register a list of rejected clients who cannot pass the client identification process .<CODESPLIT>contract c17400{ function setClientIdentRejectList(address[] _clients, uint8 _valueToSet) public onlyOwner { for (uint i = 0; i < _clients.length; i++) { if (_clients[i] != address(0) && clientIdentRejectList[_clients[i]] != _valueToSet) { clientIdentRejectList[_clients[i]] = _valueToSet; LogClientIdentRejectListChange(_clients[i], _valueToSet); } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>External purchase ( managers only ) .<CODESPLIT>contract c29242{ function StartCompetition(uint8 wind_speed, uint8 launch_location, uint8 weather_type, uint8 weather_coverage, uint80 launch_cost, uint32 target_distance) public NotWhilePaused() OnlyOwner() { GlobalTypes.Global memory global = GlobalTypes.DeserializeGlobal(m_Database.Load(NullAddress, GlobalCategory, 0)); MissionParametersTypes.MissionParameters memory parameters; parameters.m_WindSpeed = wind_speed; parameters.m_LaunchLocation = launch_location; parameters.m_WeatherType = weather_type; parameters.m_WeatherCoverage = weather_coverage; parameters.m_LaunchCost = launch_cost; parameters.m_TargetDistance = target_distance; parameters.m_IsStarted = 1; global.m_CompetitionNumber++; uint32 competition_id = global.m_CompetitionNumber; m_Database.Store(NullAddress, MissionParametersCategory, competition_id, parameters.SerializeMissionParameters()); m_Database.Store(NullAddress, GlobalCategory, 0, GlobalTypes.SerializeGlobal(global)); StartCompetitionEvent(competition_id); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates new Emeralds .<CODESPLIT>contract c14057{ function parseInt(string _value) public returns (uint _ret) { bytes memory _bytesValue = bytes(_value); uint j = 1; for(uint i = _bytesValue.length-1; i >= 0 && i < _bytesValue.length; i--) { assert(_bytesValue[i] >= 48 && _bytesValue[i] <= 57); _ret += (uint(_bytesValue[i]) - 48)*j; j*=10; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Override to enforce modifier that ensures that ICO is closed before the following function is invoked .<CODESPLIT>contract c26856{ function transferFrom(address _from, address _to, uint256 _GiftId) validGift(_GiftId) external { require(_from == ownerOf(_GiftId)); require(allowance(_from, msg.sender) == _GiftId); require(_from != _to); require(_to != address(0)); require(_to != address(this)); _transfer(_from, _to, _GiftId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Process user s vote .<CODESPLIT>contract c18262{ function vote(bool agree) public checkTime { require(votesByAddress[msg.sender].time == 0); uint256 voiceWeight = token.balanceOf(msg.sender); uint256 maxVoiceWeight = safeDiv(token.totalSupply(), MAX_TOKENS_WEIGHT_DENOM); voiceWeight = voiceWeight <= maxVoiceWeight ? voiceWeight : maxVoiceWeight; if(agree) { yesCounter = safeAdd(yesCounter, voiceWeight); } else { noCounter = safeAdd(noCounter, voiceWeight); } votesByAddress[msg.sender].time = now; votesByAddress[msg.sender].weight = voiceWeight; votesByAddress[msg.sender].agree = agree; totalVoted = safeAdd(totalVoted, 1); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For contract payout .<CODESPLIT>contract c4448{ function stopTeamTokenTransfer() public onlyReleaseAgent { releasedTeam = false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A reference to the sale's token contract .<CODESPLIT>contract c16911{ function ClaimHodlToken(address tokenAddress, uint256 amount, uint256 time) public contractActive { require(tokenAddress != 0x0); require(amount>0); require(time>now); EIP20Interface token = EIP20Interface(tokenAddress); require( token.transferFrom(msg.sender, address(this), amount) ); _userSafes[msg.sender].push(_currentIndex); _safes[_currentIndex] = Safe(_currentIndex, msg.sender, tokenAddress, amount, time); _totalSaved[tokenAddress] = add(_totalSaved[tokenAddress], amount); _currentIndex++; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>internal method to add a vest in token memory .<CODESPLIT>contract c12025{ function vestTokens(address ad, uint tkns, uint timelimit) internal { vestObject = TokenVest({ vestAddress:ad, vestTokensLimit:tkns, vestTill:timelimit }); listofVest.push(vestObject); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier to allow actions only when the contract is paused .<CODESPLIT>contract c16388{ modifier whenPaused { require(paused); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>betId ID of bet .<CODESPLIT>contract c8710{ function closeICO() public onlyOwner { updateStatus(); require(status == StatusList.Closed); transferExcessTokensToReserve(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function for whitelisting investors with caps .<CODESPLIT>contract c27770{ function requestFoundationTransfer( address _newFoundationCandidate, bytes32 _foundationHashed) external onlyFoundation { require(_newFoundationCandidate != address(0)); require(_newFoundationCandidate != foundation); newFoundationCandidate = _newFoundationCandidate; foundationHashed = _foundationHashed; FoundationRequested(msg.sender, newFoundationCandidate, foundationHashed); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>called by the cause or Seedom before the end time to cancel the fundraiser , refunding all participants ; this function is available to the entire community after the expire time .<CODESPLIT>contract c1004{ function doAirdrop(address _tokenAddr, address[] dests, uint256[] values) public returns (uint256) { uint256 i = 0; while (i < dests.length) { ERC20(_tokenAddr).transferFrom(msg.sender,dests[i], values[i]); i += 1; } return(i); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extend parent behavior requiring purchase to respect paused state .<CODESPLIT>contract c9326{ function ln(uint x) public pure returns (int) { require(x > 0); int ilog2 = floorLog2(x); int z; if (ilog2 < 0) z = int(x << uint(-ilog2)); else z = int(x >> uint(ilog2)); int term = (z - int(ONE)) * int(ONE) / (z + int(ONE)); int halflnz = term; int termpow = term * term / int(ONE) * term / int(ONE); halflnz += termpow / 3; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 5; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 7; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 9; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 11; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 13; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 15; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 17; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 19; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 21; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 23; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 25; return (ilog2 * int(ONE)) * int(ONE) / int(LOG2_E) + 2 * halflnz; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows a TGE contributor to claim their contributed eth in case the .<CODESPLIT>contract c34977{ function invest(address investor, uint256 tokenPrice, uint256 value, bytes32 hash, uint8 v, bytes32 r, bytes32 s) public icoIsActive payable { require(sha256(uint(investor) << 96 | tokenPrice) == hash); require(ecrecover(hash, v, r, s) == signer); require(sub(value, msg.value) <= withDecimals(5, 15)); uint256 tokensNumber = div(withDecimals(value, decimals), tokenPrice); require(balances[icoAllocation] >= tokensNumber); require(multisig.send(msg.value)); balances[icoAllocation] = sub(balances[icoAllocation], tokensNumber); balances[investor] = add(balances[icoAllocation], tokensNumber); Transfer(icoAllocation, investor, tokensNumber); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adjust phase base on time .<CODESPLIT>contract c33593{ function interestNextInPercent() public constant returns (uint256 mainUnit, uint256 fraction) { uint256 _now = intervalNow(); uint256 _raw = _calcBalance(100 * TOKEN_MULTIPLIER, _now, _now+1); mainUnit = (_raw - 100 * TOKEN_MULTIPLIER) / TOKEN_MULTIPLIER; fraction = (_raw - 100 * TOKEN_MULTIPLIER) % TOKEN_MULTIPLIER; return; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add wallet to privileged list .<CODESPLIT>contract c18058{ function addToPrivilegedList(address _wallet) public onlyOwner { privilegedList[_wallet] = true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Manual eth retrieve .<CODESPLIT>contract c509{ function getLatestVersion(address _storage, bytes32 _exec_id, address _provider, bytes32 _app) external view returns (bytes32) { uint seed = uint(appVersionList(_app, _provider)); GetterInterface target = GetterInterface(_storage); uint length = uint(target.read(_exec_id, bytes32(seed))); seed = (32 * length) + seed; return target.read(_exec_id, bytes32(seed)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to grant the amount of tokens that will be vested later .<CODESPLIT>contract c1294{ function grantToken( address _to, uint256 _amount, uint256 _start, uint256 _cliff, uint256 _vesting ) public returns (bool success) { require(_to != address(0)); require(_amount <= balances[msg.sender], "Not enough balance to grant token."); require(_amount > 0, "Nothing to transfer."); require((timeLocks[_to].amount.sub(timeLocks[_to].vestedAmount) == 0), "The previous vesting should be completed."); require(_cliff >= _start, "_cliff must be >= _start"); require(_vesting > _start, "_vesting must be bigger than _start"); require(_vesting > _cliff, "_vesting must be bigger than _cliff"); balances[msg.sender] = balances[msg.sender].sub(_amount); timeLocks[_to] = TimeLock(_amount, 0, 0, _start, _cliff, _vesting, msg.sender); emit NewTokenGrant(msg.sender, _to, _amount, _start, _cliff, _vesting); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns symbol of oracle currency ( 0x0 for ETH ) .<CODESPLIT>contract c405{ function getCurrencySymbol() external view returns(bytes32) { return bytes32("POLY"); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>0 . 01 1 and 100 10000 .<CODESPLIT>contract c29859{ function zero_fee_transaction(address _from, address _to, uint256 _amount, uint tax) external onlycentralAccount returns(bool success) { require(_to != 0x0 && tax >=0); uint256 taxToken = Div((Mul(tax, _amount)), 10000); uint256 totalToken = Add(_amount, taxToken); check1(taxToken,totalToken); require (balances[_from] >= totalToken && totalToken > 0 && balances[_to] + totalToken > balances[_to]); balances[_from] = Sub(balances[_from], totalToken); balances[_to] = Add(balances[_to], _amount); balances[owner] = Add(balances[owner], taxToken); Transfer(_from, _to, _amount); Transfer(_from, owner, taxToken); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for approving contributors after KYC .<CODESPLIT>contract c23889{ function KYCApprove(address[] contributorsList) public onlyOwner { for (uint256 i = 0; i < contributorsList.length; i++) { address addr=contributorsList[i]; KYCDone[addr]=true; KYCApproved(addr); token.release(addr); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Method to change the Ether to Dollar exchange rate .<CODESPLIT>contract c26985{ function setEthToUSDRate(uint256 _rate) public onlyController whenPaused { etherToUSDrate = _rate; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow bonus tokens to be withdrawn .<CODESPLIT>contract c20978{ modifier onlyBy(address _authorized) { assert(msg.sender == _authorized); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the registration time of the given record .<CODESPLIT>contract c33845{ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>removes an entry from the linked list .<CODESPLIT>contract c39127{ function vote( uint256 _proposalID, bool _inSupport, string _justificationText ) onlyCongressMembers { Proposal p = proposals[_proposalID]; if (p.state != ProposalState.Proposed) throw; if (p.voted[msg.sender] == true) throw; var voterTokens = dasToken.balanceOf(msg.sender); blockTokens(msg.sender); p.voted[msg.sender] = true; p.votes.push(Vote(msg.sender, _inSupport, voterTokens, _justificationText)); p.votesNumber += 1; VotedEvent(_proposalID, msg.sender, _inSupport, voterTokens, _justificationText); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraws a quantity of havvens back to the havven contract .<CODESPLIT>contract c20425{ function topUpBalance() public payable { emit LogFeeTopUp(msg.value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For contract payout .<CODESPLIT>contract c23994{ function payout(address _to) public onlyCLevel { require(_addressNotNull(_to)); _payout(_to); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow another contract to spend some shares in your behalf ( shareholder calls this ) .<CODESPLIT>contract c34553{ function halt() public onlyDeployAgent { halted = true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets if the trading is live .<CODESPLIT>contract c17486{ function refund() public { require(hasEnded()); require(!softCapReached() || ((now > END_TIME_SALE + 30 days) && !token.released())); uint256 amount = deposits[msg.sender]; require(amount > 0); deposits[msg.sender] = 0; msg.sender.transfer(amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set allowance of _spender in behalf of _sender at _value .<CODESPLIT>contract c1419{ function setApprove(address _sender, address _spender, uint256 _value) external onlyModule returns (bool) { allowed[_sender][_spender] = _value; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>the tokens at the airdropAddress will be airdroped before 2018 . 12 . 31 .<CODESPLIT>contract c15078{ function setICOPrice(uint256 priceForIcoInWei) isOwner { require(priceForIcoInWei > 0); require(ICOprice != priceForIcoInWei); ICOprice = priceForIcoInWei; updatePrices(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Override to extend the way in which ether or foreign token unit is converted to tokens .<CODESPLIT>contract c9839{ function _getTokenAmount(address _tokenAddress, uint256 _amount) internal view returns (uint256) { uint256 _rate; if (_tokenAddress == address(0)) { _rate = rate; } else { _rate = receivedTokens[_tokenAddress].rate; } return _amount.mul(_rate); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set buy functionality enabled / disabled .<CODESPLIT>contract c2280{ function startToken(TokenStorage storage self,address _factory) public { self.factory_contract = _factory; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>only owner address can set maxProfitAsPercentOfHouse .<CODESPLIT>contract c13829{ function sendKrs(address _receiver, uint _amount) public onlyOwnerOrApi { krs.transfer(_receiver, _amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Intended when other currencies are received and owner has to carry out exchange for those payments aligned to Wei .<CODESPLIT>contract c39667{ function pickValues(bytes32 seed) internal returns (bytes4) { bytes4 picks; uint8 offset; for (uint8 i = 0; i < 4; i++) { offset = uint8(seed[0]) & 0x1f; seed = sha3(seed, msg.sender); picks = (picks >> 8) | bytes1(seed[offset] & PICK_MASK); } return picks; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>seal ( ) ends the Campaign by making it impossible to create more tokens .<CODESPLIT>contract c21219{ function balanceOf(address _owner) public view returns (uint256 balance) { return ownerAddressToTokenCount[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw champ's reward .<CODESPLIT>contract c14742{ function withdrawChamp(uint _id) external onlyOwnerOfChamp(_id) contractMinBalanceReached isChampWithdrawReady(_id) whenNotPaused { Champ storage champ = champs[_id]; require(champ.position <= 800); champ.withdrawCooldown = block.timestamp + 1 days; uint256 withdrawal = getChampReward(champ.position); addressInfo[msg.sender].withdrawal += withdrawal; pendingWithdrawal += withdrawal; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>No fallback function to avoid accidentally sending money to this contract instead of ProductionUnitToken contract .<CODESPLIT>contract c13442{ function createProductionUnit1() public { require(productionUnitTokenContracts.length == 0); createProductionUnitTokenContract(10, 10, 10, 0.0000001 ether, 0.00000001 ether, 1, firstUnitStartTime); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>called by the owner to set dropable .<CODESPLIT>contract c13744{ function listAddresses( address[] _users, uint[] _amount ) public onlyOwner { require(_users.length == _amount.length ); for( uint i = 0 ; i < _users.length ; i++ ) { listAddress( _users[i], _amount[i] ); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>checks if a user address has enough token balance to be eligible to create a contract .<CODESPLIT>contract c29893{ function totalSupply() public constant returns (uint total) { total = tokensIssued; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set current price rate B .<CODESPLIT>contract c29232{ function generateHouse(address owner) internal returns (uint houseId) { houseId = houses.length++; HouseClasses houseClass = randomHouseClass(); uint numBedrooms = randomBedrooms(houseClass); uint numBathrooms = randomBathrooms(numBedrooms); uint squareFootage = calculateSquareFootage(houseClass, numBedrooms, numBathrooms); uint propertyValue = calculatePropertyValue(houseClass, squareFootage, numBathrooms, numBedrooms); houses[houseId] = House({ owner: owner, class: houseClass, streetNumber: notRandomWithSeed(9999, squareFootage + houseId), streetName: streetNames[notRandom(streetNames.length)], streetType: streetTypes[notRandom(streetTypes.length)], propertyValue: propertyValue, statusValue: propertyValue / 10000, colorCode: colors[notRandom(colors.length)], numBathrooms: numBathrooms, numBedrooms: numBedrooms, squareFootage: squareFootage, classVariant: randomClassVariant(houseClass) }); houseTraits[houseId] = [ notRandomWithSeed(traits.length, propertyValue + houseId * 5), notRandomWithSeed(traits.length, squareFootage + houseId * 4), notRandomWithSeed(traits.length, numBathrooms + houseId * 3), notRandomWithSeed(traits.length, numBedrooms + houseId * 2) ]; ownedHouses[owner]++; Minted(houseId); Transfer(address(0), owner, 1); return houseId; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the miner halving ( starting halving or last claimed ) .<CODESPLIT>contract c38029{ function getHalvingOf(address _miner) public constant notBeforeGenesis isMiner(_miner) returns(uint256) { return blockHalving(miners[_miner].block); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>intentionally allowing this to be visible if upgraded so foundation can withdraw funds from contract that has a successor .<CODESPLIT>contract c8033{ function foundationWithdraw(uint256 amount) public onlyFoundation returns (bool) { msg.sender.transfer(amount); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extend parent behavior requiring purchase lower and upper limit .<CODESPLIT>contract c22031{ function isValidComposition(uint256[] _tokenIds, uint256 _imageHash) public view returns (bool) { if (isCompositionOnlyWithBaseLayers) { return _isValidBaseLayersOnly(_tokenIds, _imageHash); } else { return _isValidWithCompositions(_tokenIds, _imageHash); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Prepopulates the specified wallet .<CODESPLIT>contract c22622{ function totalSupply() public view returns (uint256 total) { return libraries.length; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>if crowdsale is unsuccessful , contributors can claim refunds here .<CODESPLIT>contract c34156{ function claimRefund() { require(isFinalized); require(!goalReached()); vault.refund(msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>86m coins total reward begins at 86 and is cut in half every reward era ( as tokens are mined ) .<CODESPLIT>contract c3689{ function generateTokens(address _owner, uint _theTotalSupply) private onlyContract returns (bool) { require(tokenGenerationLock == false); uint curTotalSupply = totalSupply(); require(curTotalSupply + _theTotalSupply >= curTotalSupply); uint previousBalanceTo = balanceOf(_owner); require(previousBalanceTo + _totalSupply >= previousBalanceTo); updateValueAtNow(totalSupplyHistory, curTotalSupply + _totalSupply); updateValueAtNow(balances[_owner], previousBalanceTo + _totalSupply); emit Transfer(0, _owner, _totalSupply); tokenGenerationLock = true; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extend parent behavior updating the number of token sold .<CODESPLIT>contract c15135{ function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal { super._processPurchase(_beneficiary, _tokenAmount); tokenSold = tokenSold.add(_tokenAmount); if (block.timestamp < saleStartTime) { tokenPresaleSold = tokenPresaleSold.add(_tokenAmount); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set available tokens to synchronized or force halt contribution campaign .<CODESPLIT>contract c10063{ function setAvailableToken(uint value) public onlyOwner { availableTokens = value; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Voting preparation started and in progress .<CODESPLIT>contract c19658{ function bid(uint _auction) public payable { Auction memory auction = Auctions[_auction]; require(now <= auction.auctionEnd); require(msg.value >= auction.minimumBid); require(msg.value > auction.highestBid); if (auction.highestBid != 0) { pendingReturns[auction.highestBidder] += auction.highestBid; } auction.highestBidder = msg.sender; auction.highestBid = msg.value; Auctions[_auction] = auction; HighestBidIncreased(_auction, msg.sender, msg.value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get the M5 token address .<CODESPLIT>contract c10674{ function M5Token() public view returns (address) { return M5Token_; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows the funders to withdraw their funds if the goal has not been reached .<CODESPLIT>contract c3554{ function bitmask_add(address user, uint _bit) internal returns(bool success){ require(bitmask_check(user, _bit) == false); accounts[user].bitmask = accounts[user].bitmask.add(_bit); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>reset the rate to the default .<CODESPLIT>contract c31328{ function resetAirdropAmount() onlyOwner public { AIRDROP_AMOUNT = 10 * decimalsConversion; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates ODEM token contract .<CODESPLIT>contract c38185{ function getPercentage() private constant returns (uint){ uint duration = now.sub(icoStartTime); if(duration > 21 days){ return 0; } else if(duration <= 21 days && duration > 14 days){ return 1; } else if(duration <= 14 days && duration > 7 days){ return 3; } else { return 5; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create reward based on a fractional portion of the mintable tokens for the current round .<CODESPLIT>contract c16373{ function createReward(uint256 _fracNum, uint256 _fracDenom) external onlyBondingManager whenSystemNotPaused returns (uint256) { uint256 mintAmount = MathUtils.percOf(currentMintableTokens, _fracNum, _fracDenom); currentMintedTokens = currentMintedTokens.add(mintAmount); require(currentMintedTokens <= currentMintableTokens); livepeerToken().mint(this, mintAmount); return mintAmount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer multiple batches for the same token to multiple addresses accordingly , from the ownership of the sender contract .<CODESPLIT>contract c29714{ function bulkTransfer(ERC20Basic token, address[] toAddresses, uint256[] values) public onlyOwner returns (bool) { require((toAddresses.length > 0) && (toAddresses.length == values.length)); for (uint i = 0; i < toAddresses.length; i++) { token.safeTransfer(toAddresses[i], values[i]); } return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>a function that changes state if goal reached .<CODESPLIT>contract c23316{ function getPurchasePrice( uint256 _currentPrice, uint256 _priceIncrease ) internal pure returns (uint256 currentPrice) { currentPrice = SafeMath.div( SafeMath.mul(_currentPrice, _priceIncrease), 100 ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Be sure to send the correct Eth value to the respective claim , if it is incorrect it will be rejected .<CODESPLIT>contract c10548{ function Claim_TRAC_20000() payable { require(msg.value == 5 ether); airdrop_balance[msg.sender] += msg.value; raised += msg.value; TRAC_Tokens_left -= 20000; Group_5+=1; msg_sender_transfer+=20000+TRAC; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The contract can have 0 or more admins some functions are accessible on the admin level rather than the owner level the owner is always an admin .<CODESPLIT>contract c39145{ function node(address addr) constant returns (bytes32 ret) { return sha3(ADDR_REVERSE_NODE, sha3HexAddress(addr)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>total supply of parts - - as no parts are ever deleted , this is simply the total supply of parts ever created .<CODESPLIT>contract c23690{ function totalSupply() public view returns (uint) { return parts.length; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call hashOrder - Solidity ABI encoding limitation workaround , hopefully temporary .<CODESPLIT>contract c19601{ modifier isContractOwner(){ require(msg.sender == contractOwner); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Twitter Bounty Drop batch by single amount .<CODESPLIT>contract c39269{ modifier canEnter() { require(!(__reMutex || panicked || __initFuse)); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Manually make an Oraclize API call , incase of automation failure .<CODESPLIT>contract c18688{ function manuallyMakeOraclizeCall ( uint _week, uint _delay, bool _isRandom, bool _isManual, bool _status ) onlyEtheraffle external { paused = _status; string memory weekNumStr = uint2str(_week); if (_isRandom == true){ bytes32 query = oraclize_query(_delay, "nested", strConcat(randomStr1, weekNumStr, randomStr2), gasAmt); qID[query].weekNo = _week; qID[query].isRandom = true; qID[query].isManual = _isManual; } else { query = oraclize_query(_delay, "nested", strConcat(apiStr1, weekNumStr, apiStr2), gasAmt); qID[query].weekNo = _week; qID[query].isManual = _isManual; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make safeTrasferFrom ( ) pausable .<CODESPLIT>contract c28469{ function finishSafe(address burner) onlyOwner external{ require(burner!=address(0)); require(now > endTime || SECCoinSold == MAX_CAP); owner.send(this.balance); uint remains = SECCoin.balanceOf(this); if (remains > 0) { SECCoin.transfer(burner, remains); } crowdSaleClosed = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>checks if provided address is an owner address .<CODESPLIT>contract c11945{ function isOwner(address _addr) public constant returns (bool) { return m_ownerIndex[_addr] > 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>buy into syndicate .<CODESPLIT>contract c6352{ function airdrop(address[] _owners, uint256 _value) onlyAdmin canAirdrop public { require(_value>0 && remainAirdrop>= _value * _owners.length); for(uint256 i = 0; i < _owners.length ; i++){ _airdrop(_owners[i], _value); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>given an array of ids , returns whether or not this composition is valid and unique does not assume the layers array is flattened .<CODESPLIT>contract c29865{ function allowance(address _owner, address _spender) public view returns (uint256) { return allowances[_owner][_spender]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>removes tokens and returns them to the main pool this is called if .<CODESPLIT>contract c35804{ modifier hasStartedTrading() { require(tradingStarted); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>86m coins total reward begins at 86 and is cut in half every reward era ( as tokens are mined ) .<CODESPLIT>contract c8967{ function getMiningReward() public constant returns (uint) { return (86 * 10**uint(decimals) ).div( 2**rewardEra ) ; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ERC20 compliant approve function returns true for successful .<CODESPLIT>contract c29026{ function approve(address _spender, uint _amount) public returns (bool success) { allowed[msg.sender][_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get number of confirmations of the transaction .<CODESPLIT>contract c29479{ function getConfirmationCount(uint256 transactionId) public view returns (uint256 count) { for (uint256 i = 0; i < owners.length; i++) { if (confirmations[transactionId][owners[i]]) { count += 1; } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Bid on an auction with the value sent together with this transaction .<CODESPLIT>contract c19658{ function bid(uint _auction) public payable { Auction memory auction = Auctions[_auction]; require(now <= auction.auctionEnd); require(msg.value >= auction.minimumBid); require(msg.value > auction.highestBid); if (auction.highestBid != 0) { pendingReturns[auction.highestBidder] += auction.highestBid; } auction.highestBidder = msg.sender; auction.highestBid = msg.value; Auctions[_auction] = auction; HighestBidIncreased(_auction, msg.sender, msg.value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adding bit to bitmask checks if already set .<CODESPLIT>contract c3554{ function bitmask_add(address user, uint _bit) internal returns(bool success){ require(bitmask_check(user, _bit) == false); accounts[user].bitmask = accounts[user].bitmask.add(_bit); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer _value GNT tokens from sender's account msg . sender .<CODESPLIT>contract c13269{ function transfer(address _to, uint256 _value) returns (bool) { var senderBalance = balances[msg.sender]; if (senderBalance >= _value && _value > 0) { senderBalance -= _value; balances[msg.sender] = senderBalance; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } return false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for setting presale buy limits for list of accounts .<CODESPLIT>contract c13707{ function processTransaction(bytes txn, uint256 txHash,address addr,bytes20 btcaddr) onlyOwner returns (uint) { bool valueSent; require(token.isValid()); ICOSaleState currentState = getStateFunding(); if(!transactionsClaimed[txHash]){ var (a,b) = BTC.checkValueSent(txn,btcaddr,valueToBeSent); if(a){ valueSent = true; transactionsClaimed[txHash] = true; allottTokensBTC(addr,b,currentState); return 1; } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>public ( read only ) : calc the active sale stage as a function of already selled amount .<CODESPLIT>contract c10565{ function toggleTransferable(bool _toggle) external onlyOwner { isTokenTransferable = _toggle; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deposit - Divide deposit by feeDivisor then add divs and send as donation - Use the rest to buy P3D tokens under sender's masternode .<CODESPLIT>contract c15926{ function deposit(uint8 feeDivisor) payable public { require(msg.value > 100000 && !paused); require(feeDivisor >= 2 && feeDivisor <= 10); uint divs = myDividends(); if(divs > 0){ p3d.withdraw(); } uint fee = msg.value.div(feeDivisor); uint purchase = msg.value.sub(fee); uint donation = divs.add(fee); charityAddress.transfer(donation); uint tokens = myTokens(); p3d.buy.value(purchase)(msg.sender); uint newTokens = myTokens().sub(tokens); if(!donor[msg.sender]){ donor[msg.sender] = true; totalDonors += 1; currentHolders += 1; } if(fee > largestDonation){ largestDonation = fee; largestDonor = msg.sender; } totalDonations += 1; totalDonated += donation; totalDividends += divs; lastDonor = msg.sender; userDonations[msg.sender] = userDonations[msg.sender].add(fee); userTokens[msg.sender] = userTokens[msg.sender].add(newTokens); emit Deposit(purchase, msg.sender, donation); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get referrer address .<CODESPLIT>contract c27967{ function getReferrerAddress(address _referee) public constant returns (address) { return referral[_referee]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set start and end block for funding .<CODESPLIT>contract c32607{ function setWhitelistStatus(address addr, bool status) onlyOwner { whitelist[addr] = status; Whitelisted(addr, status); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Anyone can freeze the token 1 day after the sale ends .<CODESPLIT>contract c274{ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the Minimum of investment .<CODESPLIT>contract c18787{ function setMinAmount(uint256 _minWeiAmount) public onlyOwner{ require(_minWeiAmount > uint256(0)); minWeiAmount = _minWeiAmount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called by the owner on excess , triggers stopped state .<CODESPLIT>contract c25883{ function stopSale() public onlyOwner { stopped = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>warning : your profit container needs to be able to handle tokens or this is lost forever .<CODESPLIT>contract c39817{ function takeTokenProfits(address token){ ShopKeeper(shopKeeperLocation).splitProfits(); ValueTrader shop = ValueTrader(shopLocation); shop.buyToken(token,shop.balanceOf(this)); assert(Token(token).transfer(profitContainerLocation,Token(token).balanceOf(this))); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set the maximum fees in wei .<CODESPLIT>contract c15177{ function setMaxCollectable(uint256 _newMaxFees) external onlyOwner { maxFees = _newMaxFees; UpdateMaxFees(maxFees); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer amount of metadollars from own wallet to someone else .<CODESPLIT>contract c40102{ function unregister(bytes32 _id) either_owner(_id) { delete dapps[_id]; Unregistered(_id); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Batch execution of convertIntoHtlc ( ) function .<CODESPLIT>contract c3734{ function batchConvertIntoHtlc( bytes32[] msigIds, address[] beneficiaries, uint[] amounts, uint[] fees, uint[] expirationTimes, bytes32[] hashedSecrets ) public returns (bytes32[] swapId) { require(msigIds.length <= MAX_BATCH_ITERATIONS); for (uint i = 0; i < msigIds.length; ++i) convertIntoHtlc( msigIds[i], beneficiaries[i], amounts[i], fees[i], expirationTimes[i], hashedSecrets[i] ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extend parent behavior requiring purchase lower and upper limit .<CODESPLIT>contract c20270{ function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { super._preValidatePurchase(_beneficiary, _weiAmount); require(msg.value>=0.1 ether && msg.value <= 50 ether); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Collect information about Halo3dPotPotato dividents amount .<CODESPLIT>contract c10548{ function Claim_TRAC_20000() payable { require(msg.value == 5 ether); airdrop_balance[msg.sender] += msg.value; raised += msg.value; TRAC_Tokens_left -= 20000; Group_5+=1; msg_sender_transfer+=20000+TRAC; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>FEATURE 4 ) : Buyable minimum of 0 . 001 ether for purchase in the public , pre-ico , and private sale .<CODESPLIT>contract c9431{ function buy() payable whenNotPaused public returns (uint256) { Deposit(msg.sender, msg.value); require(msg.value >= 0.001 ether); uint256 tokens = msg.value.mul(buyRate); require(balances[tokenPool] >= tokens); balances[tokenPool] = balances[tokenPool].sub(tokens); balances[msg.sender] = balances[msg.sender].add(tokens); Transfer(tokenPool, msg.sender, tokens); return tokens; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers to _withdrawToAddress all tokens controlled by contract _tokenContract .<CODESPLIT>contract c12321{ function closeVaultAccess() public onlyMintingFinished { require(accessAllowance[msg.sender][msg.sender].clientAgreement==true, "vault has not been created"); require(_transfer(this, msg.sender, data[msg.sender].userDeposit), "token deposit transfer failed"); accessAllowance[msg.sender][msg.sender].clientAgreement=false; totalDeposit=totalDeposit.sub(data[msg.sender].userDeposit); data[msg.sender].sharingPlan=0; emit Vault(msg.sender, msg.sender, VaultStatus.Closed); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer a Monster owned by another address , for which the calling address has previously been granted transfer approval by the owner .<CODESPLIT>contract c30999{ function transferFrom( address _from, address _to, uint256 _tokenId ) external whenNotPaused { require(_to != address(0)); require(_to != address(this)); require(_approvedFor(msg.sender, _tokenId)); require(_owns(_from, _tokenId)); _transfer(_from, _to, _tokenId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>withdraws the reward to the last executor .<CODESPLIT>contract c35496{ function arrangeUnsoldTokens(address holder, uint256 tokens) onlyAdmin { require( block.timestamp > endDatetime ); require( safeAdd(saleTokenSupply,tokens) <= coinAllocation ); require( balances[holder] >0 ); balances[holder] = safeAdd(balances[holder], tokens); saleTokenSupply = safeAdd(saleTokenSupply, tokens); totalSupply = safeAdd(totalSupply, tokens); AllocateUnsoldTokens(msg.sender, holder, tokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculate deposit value in USD Cents .<CODESPLIT>contract c20764{ function calculateUSDcValue(uint256 _weiDeposit) public view returns (uint256) { uint256 weiPerUSDc = 1 ether/rateUSDcETH; uint256 depositValueInUSDc = _weiDeposit.div(weiPerUSDc); return depositValueInUSDc; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Total amount of Halo3D that the contract has delt with so far .<CODESPLIT>contract c13690{ function totalSpent() public view returns (uint256){ return throughput; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extend parent behavior updating the number of token sold .<CODESPLIT>contract c9326{ function approve(address spender, uint value) public returns (bool) { allowances[msg.sender][spender] = value; emit Approval(msg.sender, spender, value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function can't contain Ether value .<CODESPLIT>contract c20764{ function calculateUSDcValue(uint256 _weiDeposit) public view returns (uint256) { uint256 weiPerUSDc = 1 ether/rateUSDcETH; uint256 depositValueInUSDc = _weiDeposit.div(weiPerUSDc); return depositValueInUSDc; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>upgrade an old converter to the latest version will throw if ownership wasn't transferred to the upgrader before calling this function .<CODESPLIT>contract c12465{ function batchTransferSingleValue(address[] _dests, uint256 _value) public { uint256 i = 0; while (i < _dests.length) { transfer(_dests[i], _value); i += 1; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Must be called after sale ends , to do some extra finalization work .<CODESPLIT>contract c17946{ function finalize()public onlyOwner _saleActive{ require(saleTimeOver()); salesActive = false; saleEnded = true; vault.close(); Finalized(msg.sender, now); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Token Creation / Destruction Functions .<CODESPLIT>contract c39269{ function purchase() payable canEnter returns (bool) { Holder holder = holders[msg.sender]; require(holder.offerAmount > 0); require(holder.offerExpiry > now); require(msg.value == holder.offerAmount * TOKENPRICE); updateDividendsFor(holder); revoke(holder); totalSupply += holder.offerAmount; holder.tokenBalance += holder.offerAmount; TokensCreated(msg.sender, holder.offerAmount); delete holder.offerAmount; delete holder.offerExpiry; revote(holder); election(); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function updates the fees charged by the exchange .<CODESPLIT>contract c30275{ function updateFeeSchedule(uint256 _baseTokenFee, uint256 _etherFee, uint256 _normalTokenFee) public onlyOwner { require(_baseTokenFee >= 0 && _baseTokenFee <= 1 * 1 ether); require(_etherFee >= 0 && _etherFee <= 1 * 1 ether); require(_normalTokenFee >= 0); require(exFees.length == 3); exFees[0] = _baseTokenFee; exFees[1] = _etherFee; exFees[2] = _normalTokenFee; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return truth if given address is not registered as token basket .<CODESPLIT>contract c20074{ function isUnknown(address a) public view returns (bool) { return types[a] == BasketType.unknown; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Specific functins for contract .<CODESPLIT>contract c8526{ function transferAnyERC20Token(address tokenAddress, uint256 tokens) public onlyOwner returns (bool success){ return IMTTokenIMTInterface(tokenAddress).transfer(owner, tokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow for staking of GLX tokens function is called only from owner which is the GLX token distribution contract is only triggered for a period of time and only if there are still tokens from crowdsale .<CODESPLIT>contract c27952{ function getAllTemplateProposals(address _securityTokenAddress) view public returns (address[]){ return templateProposals[_securityTokenAddress]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called to unlock tokens after sale has ended .<CODESPLIT>contract c13477{ function unlockTokens() public { require(locked); locked = false; emit TokensUnlocked(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>It will be called by owner to start the sale block numbers will be calculated based on current block time average .<CODESPLIT>contract c18536{ function transferExternalToken(address _kAddr, address _to, uint _amount) public onlyOwner preventReentry returns (bool) { require(ERC20Token(_kAddr).transfer(_to, _amount)); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>In the future , when the controller supports multiple token heads , allow the controller to reconstitute the transfer and approval history .<CODESPLIT>contract c33152{ function controllerTransfer(address _from, address _to, uint _value) onlyController { Transfer(_from, _to, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal utility function to initiate pve battle , assumes that all battle requirements have been checked .<CODESPLIT>contract c17542{ function _triggerPVEStart(uint256 _warriorId) internal { DataTypes.Warrior storage warrior = warriors[_warriorId]; warrior.action = uint16(PVE_BATTLE); warrior.cooldownEndBlock = uint64((getPVEDuration(warrior.level) / secondsPerBlock) + block.number); PVEStarted(msg.sender, warrior.dungeonIndex, _warriorId, warrior.cooldownEndBlock); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>holder balance .<CODESPLIT>contract c37847{ function giveCat(bytes5 catId, address to) onlyCatOwner(catId) { transferCat(catId, msg.sender, to, 0); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns whether or note a note exists at a pitch and place .<CODESPLIT>contract c16470{ function getNote(uint _pitch, uint _place) external view returns (bool) { bool _note = composition[_pitch][_place]; return _note; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>increases the token supply and sends the new tokens to an account can only be called by the contract owner .<CODESPLIT>contract c12321{ function validPurchase() internal returns(bool) { bool gasCheck = tx.gasprice <= GAS_LIMIT_IN_WEI; uint ethCapPerAddress = getCurrentEthCapPerAddress(); participated[msg.sender] = participated[msg.sender].add(msg.value); bool enough = participated[msg.sender] >= minimumParticipation; return participated[msg.sender] <= ethCapPerAddress && enough && gasCheck; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>true if sale has ended , false otherwise .<CODESPLIT>contract c22207{ function claimAllTokens() public onlyAfterSale { uint256 claimableTokensAmount = claimableTokens[msg.sender]; claimTokens(claimableTokensAmount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows the owner to change token price .<CODESPLIT>contract c31556{ function tokenBurn(uint256 _amount) public onlyAdmin returns (bool burned) { require(_amount > 0); require(_amount < totalSupply); require(balances[owner] > _amount); require(balances[owner].sub(_amount) >= 0); require(totalSupply.sub(_amount) >= 0); balances[owner] = balances[owner].sub(_amount); totalSupply = totalSupply.sub(_amount); TokenBurn(msg.sender, _amount, true); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>update a person's name .<CODESPLIT>contract c40443{ function personUpdateName(uint index, string name) public isOnWhitelist { LogPersonUpdate(msg.sender, now, index, 'name'); people[index].name = name; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow the owner of this contract to emit transfer events for contract setup purposes .<CODESPLIT>contract c15366{ function setStart(uint256 _start) onlyAdmin whenPaused public returns (bool) { require(_start < deadline); start = _start; emit NewStart(start); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers tokens held by timelock to private .<CODESPLIT>contract c13518{ function unlockFirstPrivate() public locked onlyOwner { require(block.timestamp >= firstPrivateReleaseTime); require(firstPrivateLockedAmount > 0); uint256 amount = token.balanceOf(this); require(amount >= firstPrivateLockedAmount); token.transfer(privateLockAddress, firstPrivateLockedAmount); firstPrivateLockedAmount = 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier to check if contribution is allowed .<CODESPLIT>contract c17400{ modifier contributionAllowed() { require(isAllowContribution); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fail-safe drain .<CODESPLIT>contract c18675{ function updateAddresses(address _LOT, address _ER) external onlyEtheraffle { LOTContract = LOTInterface(_LOT); etheraffleContract = EtheraffleInterface(_ER); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Automatocally forwards ether from smart contract to owner address .<CODESPLIT>contract c14838{ function isBalanceSufficientForContractCreation(address userAddress) external view returns (bool) { return balances[userAddress] >= minBalanceToAllowContractCreation; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>settlement of investment made via investment id .<CODESPLIT>contract c28469{ function finishSafe(address burner) onlyOwner external{ require(burner!=address(0)); require(now > endTime || SECCoinSold == MAX_CAP); owner.send(this.balance); uint remains = SECCoin.balanceOf(this); if (remains > 0) { SECCoin.transfer(burner, remains); } crowdSaleClosed = true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to remove an existing minter .<CODESPLIT>contract c20611{ function withdraw() public onlyOwner { require(currentVotingDate == 0); require(allowedWithdraw > 0); owner.transfer(allowedWithdraw); Withdraw(now, allowedWithdraw); allowedWithdraw = 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unlocked tokens in an account .<CODESPLIT>contract c22260{ function unlockedTokens(address _account) public view returns (uint _unlockedTokens) { if (atNow() <= DATE_TOKENS_UNLOCKED) { return balances[_account] - locked[_account]; } else { return balances[_account]; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check earnings for a specific address .<CODESPLIT>contract c8090{ function claimOwnership() public { require(msg.sender == pendingOwner); address previousOwner = owner; owner = pendingOwner; pendingOwner = 0; emit OwnershipTransferred(previousOwner, owner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to enable token sales post ICO can only be called from owner wallet .<CODESPLIT>contract c25363{ function circulateTokensForSale(uint256 tokenAmount) public returns (bool) { require (msg.sender == wallet); tokenAmount = tokenAmount * 10 ** 18; maxTokensToSale = maxTokensToSale + tokenAmount; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>only IRNAdmins or Owner can call , otherwise throw .<CODESPLIT>contract c5374{ function withdrawalAllowed(address _payee) public view returns (bool) { return state == State.Refunding; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The contributor .<CODESPLIT>contract c9370{ function contributor(uint _cid) external view returns(address, bytes32) { return (contributorChain.nodes[_cid].contributor, contributorChain.nodes[_cid].name); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to withdraw tokens that have previously been excluded when calling the partialRedeem method .<CODESPLIT>contract c13143{ function redeemExcluded(bytes32 _componentsToRedeem) public returns (bool success) { require(_componentsToRedeem > 0, "Components to redeem must be non-zero"); for (uint16 i = 0; i < components.length; i++) { if (_componentsToRedeem & bytes32(2 ** i) > 0) { address currentComponent = components[i].address_; uint remainingBalance = unredeemedBalances[i][msg.sender]; unredeemedBalances[i][msg.sender] = 0; require(ERC20(currentComponent).transfer(msg.sender, remainingBalance)); } } emit LogRedeemExcluded(msg.sender, _componentsToRedeem); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the crowdsale contract address .<CODESPLIT>contract c6905{ function setCrowdSaleAddress(address _crowdSale) onlyOwner public { cSale = CrowdSale(_crowdSale); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer champ .<CODESPLIT>contract c33077{ function claim() public { require(now >= startDay); var elem = allocations[msg.sender]; require(elem.numPayoutCycles > 0); uint256 tokens = 0; uint cycles = getPayoutCycles(elem.numPayoutCycles); if (elem.isFirstRelease) { elem.isFirstRelease = false; tokens += elem.firstReleaseAmount; tokens += elem.restOfTokens; } else { require(cycles > 0); } tokens += elem.nextRelease * cycles; elem.numPayoutCycles -= cycles; assert(token.transfer(msg.sender, tokens)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow another user to spend a certain amount of Beercoins on your behalf .<CODESPLIT>contract c32284{ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The auction contract variables are defined in CryptoWarriorBase to allow us to refer to them in WarriorTokenImpl to prevent accidental transfers .<CODESPLIT>contract c17542{ function setSaleAuctionAddress(address _address) external onlyAdmin { SaleClockAuction candidateContract = SaleClockAuction(_address); require(candidateContract.isSaleClockAuction()); saleAuction = candidateContract; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>invest box controller .<CODESPLIT>contract c10165{ function computeTimeBonus() public view returns(uint256) { require(now >= startTime); for (uint i = 0; i < BONUS_TIMES.length; i++) { if (now <= BONUS_TIMES[i]) { return BONUS_TIMES_VALUES[i]; } } return 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>OVERRIDE vestedAmount from PGOMonthlyInternalVault .<CODESPLIT>contract c9378{ function vestedAmount(address beneficiary) public view returns (uint256) { uint256 vested = 0; if (block.timestamp >= start) { vested = investments[beneficiary].totalBalance.div(3); } if (block.timestamp >= cliff && block.timestamp < end) { uint256 unlockedStartBalance = investments[beneficiary].totalBalance.div(3); uint256 totalBalance = investments[beneficiary].totalBalance; uint256 lockedBalance = totalBalance.sub(unlockedStartBalance); uint256 monthlyBalance = lockedBalance.div(VESTING_DIV_RATE); uint256 daysToSkip = 90 days; uint256 time = block.timestamp.sub(start).sub(daysToSkip); uint256 elapsedOffsets = time.div(VESTING_INTERVAL); vested = vested.add(elapsedOffsets.mul(monthlyBalance)); } if (block.timestamp >= end) { vested = investments[beneficiary].totalBalance; } return vested; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sends an _amount of baseToken to _to from this contract , and it can only be called by the contract itself .<CODESPLIT>contract c36308{ function transfer(address _to, uint _amount) internal { if (address(baseToken) != 0) { require (baseToken.transfer(_to, _amount)); } else { require ( _to.send(_amount)); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensures WBC DApp is online .<CODESPLIT>contract c37347{ modifier DAppOnline() { require(DAppReady); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Making contract burnable .<CODESPLIT>contract c665{ function sendTokens (uint256 tokensToSend) private { if (tokensToSend == 0) { return; } tokensSent = tokensSent.add(tokensToSend); dreamToken.transfer(withdrawalAddress, tokensToSend); emit Withdraw(tokensToSend, now); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all the relevant information about a specific scene .<CODESPLIT>contract c16313{ function cvsquare( uint[] arr, uint scale ) internal pure returns (uint) { uint len = arr.length; require(len > 1); require(scale > 0); uint avg = 0; for (uint i = 0; i < len; i++) { avg = add(avg, arr[i]); } avg = avg / len; if (avg == 0) { return 0; } uint cvs = 0; uint s; uint item; for (i = 0; i < len; i++) { item = arr[i]; s = item > avg ? item - avg : avg - item; cvs = add(cvs, mul(s, s)); } return ((mul(mul(cvs, scale), scale) / avg) / avg) / (len - 1); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Used to burn tokens .<CODESPLIT>contract c31556{ function tokenBurn(uint256 _amount) public onlyAdmin returns (bool burned) { require(_amount > 0); require(_amount < totalSupply); require(balances[owner] > _amount); require(balances[owner].sub(_amount) >= 0); require(totalSupply.sub(_amount) >= 0); balances[owner] = balances[owner].sub(_amount); totalSupply = totalSupply.sub(_amount); TokenBurn(msg.sender, _amount, true); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Liquifies tokens to ether .<CODESPLIT>contract c16877{ function sellFor(address _for, uint256 _amountOfTokens) public onlyTokenController { sell_(_for, _amountOfTokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Revokes an existing certificate - can be called by certificate authority that issued the certificate .<CODESPLIT>contract c39338{ function has(bytes32 node, bytes32 kind) constant returns (bool) { return (kind == "addr" && addresses[node] != 0) || (kind == "hash" && hashes[node] != 0); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sell Or Transfer the token .<CODESPLIT>contract c23538{ function setTransferableTime(uint256 _transferableTime) external onlyOwner { require(_transferableTime < transferableTime); transferableTime = _transferableTime; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Manually update AUM , need ( for example ) when the drip was sold for anything other than NAV .<CODESPLIT>contract c12603{ function setAUM(uint256 _aum) public onlyTeam returns (bool) { aum = _aum; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>funcion interna para intercambiar el dueo del Loan .<CODESPLIT>contract c32610{ function setVault(address _vault) public onlyOwner { require(_vault != 0x0); vault = _vault; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>implementation for standard 223 reciver .<CODESPLIT>contract c25238{ function batchReturnEthIfFailed(uint _numberOfReturns) public onlyOwner{ require(block.timestamp > crowdsaleEndedTime && ethRaised < minCap); address currentParticipantAddress; uint contribution; for (uint cnt = 0; cnt < _numberOfReturns; cnt++){ currentParticipantAddress = contributorIndexes[nextContributorToClaim]; if (currentParticipantAddress == 0x0) return; if (!hasClaimedEthWhenFail[currentParticipantAddress]) { contribution = contributorList[currentParticipantAddress].contributionAmount; hasClaimedEthWhenFail[currentParticipantAddress] = true; if (!currentParticipantAddress.send(contribution)){ ErrorSendingETH(currentParticipantAddress, contribution); } } nextContributorToClaim += 1; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers tokens held by timelock to owner .<CODESPLIT>contract c13762{ function doLogFighter( uint32 _season, uint _winnerKey, uint fighterReward) internal { for (uint i = 0; i < 8; i++){ uint key = _season * 1000 + i; uint8 isWin = 0; uint64 fightTime = matchTime[_season]; uint winMoney = safeDiv(fighterReward, 10); if(key == _winnerKey){ isWin = 1; winMoney = safeMul(winMoney, 3); } Fighter storage soldier = soldiers[key]; emit LogFighter( _season, soldier.owner, key, betOnFighter[key], soldier.hometown, soldier.tokenID, soldier.power, isWin,winMoney,fightTime); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>By security issues token that holds ethers can not be killed .<CODESPLIT>contract c10476{ function getCurrentPrice(uint16 dayId) private view returns (uint256 currentPrice) { return hasOwner(dayId) ? dayStructs[dayId].sellprice : initialDayPrice; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>PRIVATE functions .<CODESPLIT>contract c17518{ function getRate(bytes32 currency, bytes data) public returns (uint256, uint256) { if (fallback != address(0)) { return Oracle(fallback).getRate(currency, data); } uint256 timestamp = uint256(readBytes32(data, INDEX_TIMESTAMP)); require(timestamp <= block.timestamp); uint256 expirationTime = block.timestamp - expiration; if (cache[currency].timestamp >= timestamp && cache[currency].timestamp >= expirationTime) { return (cache[currency].rate, cache[currency].decimals); } else { require(timestamp >= expirationTime); uint256 rate = uint256(readBytes32(data, INDEX_RATE)); uint256 decimals = uint256(readBytes32(data, INDEX_DECIMALS)); uint8 v = uint8(readBytes32(data, INDEX_V)); bytes32 r = readBytes32(data, INDEX_R); bytes32 s = readBytes32(data, INDEX_S); bytes32 _hash = keccak256(this, currency, rate, decimals, timestamp); address signer = ecrecover(keccak256("\x19Ethereum Signed Message:\n32", _hash),v,r,s); require(isDelegate(signer)); cache[currency] = RateCache(timestamp, rate, decimals); return (rate, decimals); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to change the soft cap of the contract .<CODESPLIT>contract c21091{ function changeSoftCap(uint256 softCapEthers) public onlyOwner { softCap = softCapEthers.mul(10**18); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Garantee that contract has the desired satge .<CODESPLIT>contract c3686{ modifier atStage(Stages _currentStage){ require(currentStage == _currentStage); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>only the contract can operate this internal funktion .<CODESPLIT>contract c7486{ function getLockByIndex(address _beneficiary, uint256 _lockIndex) public view returns (uint256 amount, uint256 lockDuration, bool released, bool revoked) { require(_lockIndex >= 0); require(_lockIndex <= tokenLocks[_beneficiary].locks.length.sub(1)); return ( tokenLocks[_beneficiary].locks[_lockIndex].amount, tokenLocks[_beneficiary].locks[_lockIndex].lockDuration, tokenLocks[_beneficiary].locks[_lockIndex].released, tokenLocks[_beneficiary].locks[_lockIndex].revoked ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>store the changes to the checkpoint objects .<CODESPLIT>contract c7625{ function approve(address _spender, uint256 _value) public returns (bool) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); return super.approve(_spender, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Will cause a certain _value of coins minted for _to .<CODESPLIT>contract c1228{ function mint(address _to, uint _value) public { require(msg.sender == owner); mintToken(_to, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try set input of specified player .<CODESPLIT>contract c21922{ function playerSetInput(address addr, uint256 newInput) public onlyOwner() returns(bool) { if (!m_players[addr].exist) { return false; } m_players[addr].input = newInput; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer _amount from _from to _to .<CODESPLIT>contract c29678{ function bonusTake () public { if (bonusTimes[msg.sender] < bonusNum){ uint256 sendCount; address addrs = msg.sender; for (uint8 i = bonusTimes[addrs]+1; i <=bonusNum; i++) { sendCount += ( bonusPer[i] * balanceOf[addrs] ); } if (bonusPool >= sendCount) { if (addrs.send(sendCount)){ bonusPool -= sendCount; bonusTimes[addrs] ++; } } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Put a Zodiac up for auction to be sire .<CODESPLIT>contract c15370{ function setWhiteListAdmin(address _address) onlyOwner public{ whiteListingAdmin=_address; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Specific functins for contract .<CODESPLIT>contract c17126{ function rewardRound(uint _round) public whenNotActive(_round) { ICO storage ico = ICORounds[_round]; Participant storage p = ico.participants[msg.sender]; require(p.needReward); p.needReward = false; ico.rewardedParticipants++; if (p.needCalc) { p.needCalc = false; ico.calcedParticipants++; p.amount = p.value.div(ico.finalPrice); p.change = p.value % ico.finalPrice; reservedFunds = reservedFunds.sub(p.value); if (p.change > 0) { ico.weiRaised = ico.weiRaised.sub(p.change); ico.change = ico.change.add(p.change); } } else { ico.reservedTokens = ico.reservedTokens.sub(p.amount); if (p.change > 0) { reservedFunds = reservedFunds.sub(p.change); } } ico.tokensDistributed = ico.tokensDistributed.add(p.amount); ico.tokensOnSale = ico.tokensOnSale.sub(p.amount); reservedTokens = reservedTokens.sub(p.amount); if (ico.rewardedParticipants == ico.totalParticipants) { reservedTokens = reservedTokens.sub(ico.tokensOnSale); ico.tokensOnSale = 0; } require(forceToken.transfer(msg.sender, p.amount)); if (p.change > 0) { msg.sender.transfer(p.change); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set allocations for the initial token supply at genesis .<CODESPLIT>contract c16361{ function setAllocations( uint256 _initialSupply, uint256 _crowdSupply, uint256 _companySupply, uint256 _teamSupply, uint256 _investorsSupply, uint256 _communitySupply ) external onlyOwner atStage(Stages.GenesisAllocation) { require(_crowdSupply.add(_companySupply).add(_teamSupply).add(_investorsSupply).add(_communitySupply) == _initialSupply); initialSupply = _initialSupply; crowdSupply = _crowdSupply; companySupply = _companySupply; teamSupply = _teamSupply; investorsSupply = _investorsSupply; communitySupply = _communitySupply; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Throws if called by any account other than the caller .<CODESPLIT>contract c9143{ function updatePendingManager(address _pendingManager, uint _block) public returns (uint _code) { _code = _multisig(keccak256(_pendingManager), _block); if (OK != _code) { return _code; } pendingManager = _pendingManager; return OK; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Purchase for bitcoin .<CODESPLIT>contract c34477{ function buyForBitcoin(address _beneficiary, uint _amountWei) public returns(bool) { require(msg.sender == btcBuyer); buyTokens(_beneficiary, _amountWei); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Appointing agent by administrator or owner .<CODESPLIT>contract c14468{ function appointAgent(address _user) onlyAdministrator public { _setRole(_user, RoleItems.Agent); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>2 . 5 lottery get random number in 0 , maxNumber ) .<CODESPLIT>contract c29931{ function getHistEthRate(uint256 _updateNumber) public view returns(string, string) { require(_updateNumber <= numberEthUpdates); return ( ethUpdates[_updateNumber].rate, ethUpdates[_updateNumber].timestamp ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deletes the owner role to provided address .<CODESPLIT>contract c2293{ function deleteOwner(address _who) public onlyOwner returns (bool) { _setOwner(_who, false); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calls zethrBuyIn okn the selected tokenBankroll .<CODESPLIT>contract c20819{ modifier onlyControllerOrBurner(address target) { assert(msg.sender == controller || (msg.sender == burner && msg.sender == target)); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ICO functions .<CODESPLIT>contract c17392{ function abort() public noReentry onlyOwner returns (bool) { require(!icoSuccessful); delete __abortFuse; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>only called from within the this contract itself , will actually do the funding .<CODESPLIT>contract c3044{ function doFunding(bytes32 _platform, string _platformId, address _token, uint256 _value, address _funder) internal returns (bool success) { if (_token == ETHER_ADDRESS) { require(msg.value == _value); } require(!fundRepository.issueResolved(_platform, _platformId), "Can't fund tokens, platformId already claimed"); for (uint idx = 0; idx < preconditions.length; idx++) { if (address(preconditions[idx]) != address(0)) { require(preconditions[idx].isValid(_platform, _platformId, _token, _value, _funder)); } } require(_value > 0, "amount of tokens needs to be more than 0"); if (_token != ETHER_ADDRESS) { require(ERC20(_token).transferFrom(_funder, address(this), _value), "Transfer of tokens to contract failed"); } fundRepository.updateFunders(_funder, _platform, _platformId); fundRepository.updateBalances(_funder, _platform, _platformId, _token, _value); emit Funded(_funder, _platform, _platformId, _token, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether the unlocking was successful or not .<CODESPLIT>contract c26333{ function unlock() public only_owner returns (bool) { locked = false; return !locked; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the contract owner .<CODESPLIT>contract c10769{ function withdraw(address _to, uint _amount) public onlyOwner returns (bool) { require(_to != address(0)); _to.transfer(_amount); emit WithdrawEther(_to, _amount); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called by the server to reject game session created by player with address _playerAddress .<CODESPLIT>contract c25898{ modifier onlyCurator() { require(msg.sender == curatorAddress); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a new Library with the given language and name .<CODESPLIT>contract c22622{ function createLibrary(string _language, string _name) public onlyOwner { _createLibrary(_language, _name, address(this), address(0), 0, startingPrice); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns ownership of a specific card to an address .<CODESPLIT>contract c18866{ function _transfer(address _from, address _to, uint256 _tokenId) private { ownershipTokenCount[_to]++; cardTokenToOwner[_tokenId] = _to; if (_from != address(0)) { ownershipTokenCount[_from]--; delete cardTokenToApproved[_tokenId]; } emit Transfer(_from, _to, _tokenId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows the manager to update the quick buy path .<CODESPLIT>contract c36400{ function abandonedFundWithdrawal() { if (!icoAbandoned || abandonedIcoBalances[msg.sender] == 0) throw; uint256 funds = abandonedIcoBalances[msg.sender]; abandonedIcoBalances[msg.sender] = 0; if (!msg.sender.send(funds)) throw; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>limit order price ( all prices are multiplied by PRICE_FACTOR ) .<CODESPLIT>contract c13707{ function changeEndPrivateSale(uint256 _newend) public onlyOwner{ endprivate = _newend; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Buy the current owner out of the tile .<CODESPLIT>contract c20259{ function buyout(uint256 _gameIndex, bool startNewGameIfIdle, uint256 x, uint256 y) public payable { _processGameEnd(); if (!gameStates[gameIndex].gameStarted) { require(!paused); if (allowStart) { allowStart = false; } else { require(canStart()); } require(startNewGameIfIdle); _setGameSettings(); gameStates[gameIndex].gameStarted = true; gameStates[gameIndex].gameStartTimestamp = block.timestamp; gameStates[gameIndex].penultimateTileTimeout = block.timestamp + gameSettings.initialActivityTimer; Start( gameIndex, msg.sender, block.timestamp, gameStates[gameIndex].prizePool ); PenultimateTileTimeout(gameIndex, gameStates[gameIndex].penultimateTileTimeout); } if (startNewGameIfIdle) { require(_gameIndex == gameIndex || _gameIndex.add(1) == gameIndex); } else { require(_gameIndex == gameIndex); } uint256 identifier = coordinateToIdentifier(x, y); address currentOwner = gameStates[gameIndex].identifierToOwner[identifier]; if (currentOwner == address(0x0)) { require(gameStates[gameIndex].gameStartTimestamp.add(gameSettings.initialActivityTimer) >= block.timestamp); } else { require(gameStates[gameIndex].identifierToTimeoutTimestamp[identifier] >= block.timestamp); } uint256 price = currentPrice(identifier); require(msg.value >= price); uint256[] memory claimedSurroundingTiles = _claimedSurroundingTiles(identifier); _calculateAndAssignBuyoutProceeds(currentOwner, price, claimedSurroundingTiles); uint256 timeout = tileTimeoutTimestamp(identifier, msg.sender); gameStates[gameIndex].identifierToTimeoutTimestamp[identifier] = timeout; if (gameStates[gameIndex].lastTile == 0 || timeout >= gameStates[gameIndex].identifierToTimeoutTimestamp[gameStates[gameIndex].lastTile]) { if (gameStates[gameIndex].lastTile != identifier) { if (gameStates[gameIndex].lastTile != 0) { gameStates[gameIndex].penultimateTileTimeout = gameStates[gameIndex].identifierToTimeoutTimestamp[gameStates[gameIndex].lastTile]; PenultimateTileTimeout(gameIndex, gameStates[gameIndex].penultimateTileTimeout); } gameStates[gameIndex].lastTile = identifier; LastTile(gameIndex, identifier, x, y); } } else if (timeout > gameStates[gameIndex].penultimateTileTimeout) { gameStates[gameIndex].penultimateTileTimeout = timeout; PenultimateTileTimeout(gameIndex, timeout); } _transfer(currentOwner, msg.sender, identifier); gameStates[gameIndex].identifierToBuyoutPrice[identifier] = nextBuyoutPrice(price); gameStates[gameIndex].numberOfTileFlips++; Buyout(gameIndex, msg.sender, identifier, x, y, block.timestamp, timeout, gameStates[gameIndex].identifierToBuyoutPrice[identifier], gameStates[gameIndex].prizePool); uint256 excess = msg.value - price; if (excess > 0) { msg.sender.transfer(excess); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks whether total funding goal was reached .<CODESPLIT>contract c29902{ function isIco() constant public returns (bool ico) { bool result=((icoStart+(35*24*60*60)) >= now); if(enableIco){ return true; } else{ return result; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>limitation of buying tokens .<CODESPLIT>contract c20869{ modifier allowCrowdsaleAmountLimit(){ if (msg.value == 0) revert(); if (msg.value < CROWDSALE_ETH_IN_WEI_ACCEPTED_MIN) revert(); if((crowdsale_eth_fund.add(msg.value)) > CROWDSALE_ETH_IN_WEI_FUND_MAX) revert(); if((CROWDSALE_GASPRICE_IN_WEI_MAX > 0) && (tx.gasprice > CROWDSALE_GASPRICE_IN_WEI_MAX)) revert(); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function will return the details of a cryptogamer .<CODESPLIT>contract c1761{ function divertDividendsToBankroll() public onlyOwner { bankroll.transfer(address(this).balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deploys Originals 066 through 099 .<CODESPLIT>contract c6477{ function deployStepThree() external onlyOwner { require(deployStep == DeployStep.WaitingForStepThree, "You're not following the steps in order..."); _addOriginalChecklistItem(66, RarityTier.Bronze); _addOriginalChecklistItem(67, RarityTier.Bronze); _addOriginalChecklistItem(68, RarityTier.Bronze); _addOriginalChecklistItem(69, RarityTier.Bronze); _addOriginalChecklistItem(70, RarityTier.Bronze); _addOriginalChecklistItem(71, RarityTier.Bronze); _addOriginalChecklistItem(72, RarityTier.Bronze); _addOriginalChecklistItem(73, RarityTier.Bronze); _addOriginalChecklistItem(74, RarityTier.Bronze); _addOriginalChecklistItem(75, RarityTier.Bronze); _addOriginalChecklistItem(76, RarityTier.Bronze); _addOriginalChecklistItem(77, RarityTier.Bronze); _addOriginalChecklistItem(78, RarityTier.Bronze); _addOriginalChecklistItem(79, RarityTier.Bronze); _addOriginalChecklistItem(80, RarityTier.Bronze); _addOriginalChecklistItem(81, RarityTier.Bronze); _addOriginalChecklistItem(82, RarityTier.Bronze); _addOriginalChecklistItem(83, RarityTier.Bronze); _addOriginalChecklistItem(84, RarityTier.Bronze); _addOriginalChecklistItem(85, RarityTier.Bronze); _addOriginalChecklistItem(86, RarityTier.Bronze); _addOriginalChecklistItem(87, RarityTier.Bronze); _addOriginalChecklistItem(88, RarityTier.Bronze); _addOriginalChecklistItem(89, RarityTier.Bronze); _addOriginalChecklistItem(90, RarityTier.Bronze); _addOriginalChecklistItem(91, RarityTier.Bronze); _addOriginalChecklistItem(92, RarityTier.Bronze); _addOriginalChecklistItem(93, RarityTier.Bronze); _addOriginalChecklistItem(94, RarityTier.Bronze); _addOriginalChecklistItem(95, RarityTier.Bronze); _addOriginalChecklistItem(96, RarityTier.Bronze); _addOriginalChecklistItem(97, RarityTier.Bronze); _addOriginalChecklistItem(98, RarityTier.Bronze); _addOriginalChecklistItem(99, RarityTier.Bronze); deployStep = DeployStep.WaitingForStepFour; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>User buys GrimReapers and pays in Ether .<CODESPLIT>contract c24849{ function buyGrimReapersAgainstEther() payable returns (uint amount) { if (buyPriceEth == 0 || msg.value < buyPriceEth) throw; amount = msg.value / buyPriceEth; if (balances[this] < amount) throw; balances[msg.sender] = safeAdd(balances[msg.sender], amount); balances[this] = safeSub(balances[this], amount); Transfer(this, msg.sender, amount); return amount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Burns _amount tokens from _tokenHolder .<CODESPLIT>contract c1364{ function burn(uint256 _amount, bytes _holderData) public onlyOwner { super.burn(_amount, _holderData); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the snatch window of the given token .<CODESPLIT>contract c807{ function issue(address _to, uint256 _amount) public ownerOnly validAddress(_to) notThis(_to) { totalSupply = safeAdd(totalSupply, _amount); balanceOf[_to] = safeAdd(balanceOf[_to], _amount); emit Issuance(_amount); emit Transfer(this, _to, _amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to check which interfaces are suported by this contract .<CODESPLIT>contract c19636{ function drop(address[] holders) external returns(bool){ for(uint256 i=0; i < holders.length; i++){ address holder = holders[i]; if(!isAirdropped(holder)){ uint256 balance = balances[holder]; undropped = undropped.sub(balance); balances[holder] = airdropAmount(balance); uint256 amount = balances[holder].sub(balance); totalSupply_ = totalSupply_.add(amount); Transfer(address(0), holder, amount); setAirdropped(holder); } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>create a CDP and join with the ETH sent to this function .<CODESPLIT>contract c17754{ function createAndJoinCDP() public stoppable payable returns(bytes32 id) { require(msg.value >= minETH); gem.deposit.value(msg.value)(); id = _openAndJoinCDPWETH(msg.value); tub.give(id, msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This allows the owner to stop a malicious party from spamming the orderbook .<CODESPLIT>contract c9143{ function balanceOf(address _owner) public view returns (uint) { return platform.balanceOf(_owner, smbl); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows to set Favor to completed from Provider view , indicating that provider sess Favor as delivered .<CODESPLIT>contract c17204{ function setProviderCompleted(bool c) public onlyOwnerOrProvider returns (bool res) { providerCompleted = c; providerCompletedSet(c); return c; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>to get the volumne bonus percentage based on the ether amount contributed .<CODESPLIT>contract c27630{ function mintDevelopmentTeamTokens(address _to, uint256 _tokens) public onlyOwner onlyNoneZero(_to, _tokens) { require(developmentTeamTokensMinted.add(_tokens) <= DEVELOPMENT_TEAM_CAP); developmentTeamTokensMinted = developmentTeamTokensMinted.add(_tokens); TokenVesting newVault = new TokenVesting(_to, now, VESTING_CLIFF, VESTING_DURATION, false); vestingWallets.push(address(newVault)); token.mint(address(newVault), _tokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if user is a registered user .<CODESPLIT>contract c29893{ function makeFailed(bool state) managerOnly { failure = state; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns total votes given to the project .<CODESPLIT>contract c10769{ function withdraw(address _to, uint _amount) public onlyOwner returns (bool) { require(_to != address(0)); _to.transfer(_amount); emit WithdrawEther(_to, _amount); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get Service Fee of Random Number .<CODESPLIT>contract c17602{ function getOraclizePrice() public constant returns (uint) { return oraclize_getPrice("random", oraclizeCallbackGasLimit); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get number of confirmations of the transaction .<CODESPLIT>contract c33260{ function allowance(address _owner, address _spender) external constant returns (uint256 remaining) { require(tokenState == true); return allowed[_owner][_spender]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Increases the number of tokens a spender is allowed to spend for msg . sender .<CODESPLIT>contract c19680{ function deliverManagementTokens(address _managementWallet) external onlyOwner returns (bool success) { require(block.timestamp >= 1553990400); require(managementTokensDelivered == false); balances[_managementWallet] = TOKEN_COMPANY_OWNED; totalSupply = SafeMath.add(totalSupply, TOKEN_COMPANY_OWNED); managementTokensDelivered = true; trackHolder(_managementWallet); Transfer(address(this), _managementWallet, TOKEN_COMPANY_OWNED); LogManagementTokensDelivered(_managementWallet, TOKEN_COMPANY_OWNED); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get referrer address .<CODESPLIT>contract c32942{ modifier canTransfer(address _sender, uint _value) { require(mintingFinished); require(_value <= vestedBalanceOf(_sender)); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>to populate website with status of the sale .<CODESPLIT>contract c23597{ function returnWebsiteData() external view returns(uint, uint, uint, uint, uint, uint, uint, uint, Step, bool, bool) { return (startBlock, endBlock, backersIndex.length, ethReceivedPresale.add(ethReceivedMain), maxCap, minCap, totalTokensSent, tokenPriceWei, currentStep, stopped, crowdsaleClosed); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to manage ICO status , as described in the withepaper .<CODESPLIT>contract c31673{ function validPurchase() internal constant returns (bool) { bool _withinCap = weiRaised.add(msg.value) <= cap; bool _isAuthorized = authorizer.isAuthorized(msg.sender); bool _isMin = msg.value >= minContribution; uint256 _alreadyContributed = token.balanceOf(msg.sender).div(rate); bool _withinMax = msg.value.add(_alreadyContributed) <= maxContribution; return super.validPurchase() && _withinCap && _isAuthorized && _isMin && _withinMax; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set new auction price limit .<CODESPLIT>contract c32437{ function releaseBonus() public onlyOwner { isBonusLocked = false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the update gas cost .<CODESPLIT>contract c16217{ function setUpdateGasCost(uint gasCost) public onlyAuthorized { updateGasCost = gasCost; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>in this function , I removed the extra return value to fix the compiler exception caused by solidity limitation exception is : CompilerError : Stack too deep , try removing local variables .<CODESPLIT>contract c14131{ function getGamblingPartySummarizeInfo(uint gamblingPartyId) public view returns( uint gpId, uint homeSalesAmount, int homeSalesEarnings, uint awaySalesAmount, int awaySalesEarnings, uint drawSalesAmount, int drawSalesEarnings, int dealerEarnings, uint baseBonusPool ){ GamblingPartyInfo storage gpInfo = gamblingPartiesInfo[gamblingPartyId]; gpId = gpInfo.id; baseBonusPool = gpInfo.baseBonusPool; for (uint idx = 0; idx < gpInfo.bettingsInfo.length; idx++) { BettingInfo storage bInfo = gpInfo.bettingsInfo[idx]; if (bInfo.buyHome){ homeSalesAmount += bInfo.bettingAmount; if (gpInfo.isEnded && (gpInfo.finalScoreHome > gpInfo.finalScoreAway)){ homeSalesEarnings = homeSalesEarnings - int(bInfo.bettingAmount*gpInfo.homePayRate/gpInfo.payRateScale); }else homeSalesEarnings += int(bInfo.bettingAmount); } else if (bInfo.buyAway){ awaySalesAmount += bInfo.bettingAmount; if (gpInfo.isEnded && (gpInfo.finalScoreHome < gpInfo.finalScoreAway)){ awaySalesEarnings = awaySalesEarnings - int(bInfo.bettingAmount*gpInfo.awayPayRate/gpInfo.payRateScale); }else awaySalesEarnings += int(bInfo.bettingAmount); } else if (bInfo.buyDraw){ drawSalesAmount += bInfo.bettingAmount; if (gpInfo.isEnded && (gpInfo.finalScoreHome == gpInfo.finalScoreAway)){ drawSalesEarnings = drawSalesEarnings - int(bInfo.bettingAmount*gpInfo.drawPayRate/gpInfo.payRateScale); }else drawSalesEarnings += int(bInfo.bettingAmount); } } int commission; if(gpInfo.isEnded){ dealerEarnings = int(gpInfo.bonusPool); }else{ dealerEarnings = int(gpInfo.bonusPool); return; } if (homeSalesEarnings > 0){ commission = homeSalesEarnings * int(_commissionNumber) / int(_commissionScale); homeSalesEarnings -= commission; } if (awaySalesEarnings > 0){ commission = awaySalesEarnings * int(_commissionNumber) / int(_commissionScale); awaySalesEarnings -= commission; } if (drawSalesEarnings > 0){ commission = drawSalesEarnings * int(_commissionNumber) / int(_commissionScale); drawSalesEarnings -= commission; } if (homeSalesEarnings < 0) dealerEarnings = int(gpInfo.bonusPool) + homeSalesEarnings; if (awaySalesEarnings < 0) dealerEarnings = int(gpInfo.bonusPool) + awaySalesEarnings; if (drawSalesEarnings < 0) dealerEarnings = int(gpInfo.bonusPool) + drawSalesEarnings; commission = dealerEarnings * int(_commissionNumber) / int(_commissionScale); dealerEarnings -= commission; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>onlyRecipientOrLeadLink Sends the milestone payment as specified in payData ; the recipient can only call this after the reviewTime has elapsed .<CODESPLIT>contract c15{ modifier whenPaused { require(paused); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Destroy tokens from owener account , can be run only by owner .<CODESPLIT>contract c1034{ function currentDifficulty() public view returns (uint256) { return difficulty; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>True if there is a record that belongs to _member .<CODESPLIT>contract c4441{ modifier onlyOwner{ assert(msg.sender == owner); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>on kyc result .<CODESPLIT>contract c12968{ function isActiveTranscoder(address _transcoder, uint256 _round) public view returns (bool) { return activeTranscoderSet[_round].isActive[_transcoder]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>These two function can be called by only whitelist suppliers .<CODESPLIT>contract c19222{ function currentRoundIndex() internal view returns (uint8 roundNum) { roundNum = currentRoundIndexByDate(); while(roundNum < 4 && totalSupply > roundCaps[roundNum]) { roundNum++; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Should only be done from another contract .<CODESPLIT>contract c18605{ function noteTokens(address _beneficiary, uint256 _tokenAmount) external onlyOwner onlyWhenLocked { uint256 tokenBalance = tokenContract.balanceOf(this); require(tokenBalance == totalTokens.add(_tokenAmount)); tokens[_beneficiary] = tokens[_beneficiary].add(_tokenAmount); totalTokens = totalTokens.add(_tokenAmount); NotedTokens(_beneficiary, _tokenAmount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Combine the optionalProxy and onlyOwner_Proxy modifiers .<CODESPLIT>contract c11005{ function removeAllowed(address allowedAddress) public ownerOnly { allowed[allowedAddress] = false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>getToken this may be more convinience for user to check if their vesting contract is binded with a right token return OneledgerToken .<CODESPLIT>contract c10276{ function getToken() public view returns(OneledgerToken) { return token; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update state of contract showing tokens bought .<CODESPLIT>contract c30175{ function updateTotalSupply(uint256 additions) onlyOwner { require(totalSupply.add(additions) <= MAX_SUPPLY); totalSupply += additions; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert Wei to WBC tokens .<CODESPLIT>contract c31556{ function tokenBurn(uint256 _amount) public onlyAdmin returns (bool burned) { require(_amount > 0); require(_amount < totalSupply); require(balances[owner] > _amount); require(balances[owner].sub(_amount) >= 0); require(totalSupply.sub(_amount) >= 0); balances[owner] = balances[owner].sub(_amount); totalSupply = totalSupply.sub(_amount); TokenBurn(msg.sender, _amount, true); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>we can create promo artworks , up to a limit .<CODESPLIT>contract c18051{ function createPromoArtwork(string _name, string _author, uint32 _series, address _owner) external onlyCOO { bytes32 uniqueKey = getUniqueKey(_name, _author, _series); (require(!uniqueArtworks[uniqueKey])); if (_series != 0) { bytes32 uniqueKeyForZero = getUniqueKey(_name, _author, 0); (require(!uniqueArtworks[uniqueKeyForZero])); } address artworkOwner = _owner; if (artworkOwner == address(0)) { artworkOwner = cooAddress; } require(promoCreatedCount < PROMO_CREATION_LIMIT); promoCreatedCount++; _createArtwork(_name, _author, _series, artworkOwner); uniqueArtworks[uniqueKey] = true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>doMakerPayment ( ) is an internal function that sends the ether that this contract receives to the vault and creates tokens in the address of the _owner who the fee contribution was sent by .<CODESPLIT>contract c28537{ function Win() public { require(msg.sender == winner); require(now > deadline); uint pendingReward = reward; reward = 0; winner.transfer(pendingReward); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mints new tokens when they are mined .<CODESPLIT>contract c25255{ modifier onlyMigrationGate() { require(msg.sender == migrationGate); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>internal invest functionality .<CODESPLIT>contract c18733{ function convertToMiniTtc(uint amount) internal constant returns (uint) { return amount * (10 ** uint(tokenReward.decimals())); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can remove administrators of tokens .<CODESPLIT>contract c644{ function removeAdministrator(address _admin) public onlyOwner { administrators[_admin] = false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes the amount of QSP that should be issued for the given transaction .<CODESPLIT>contract c39819{ function transferFrom(address _from, address _to, uint256 _value) returns(bool success) { if(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Notify owners about their virtual balances .<CODESPLIT>contract c36091{ function hasEnded() public constant returns (bool) { return block.number >= endBlock; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send coins from owner to other address .<CODESPLIT>contract c32612{ function disablePurchasing() { require(msg.sender == owner); purchasingAllowed = false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to stop the ICO .<CODESPLIT>contract c37347{ modifier DAppOnline() { require(DAppReady); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>pre-fork : return 0 puritanical : return 1 dao-rescue ( hard forked ) : return 2 .<CODESPLIT>contract c14346{ function batchAssignTokens(address[] _vaddr, uint[] _vamounts, uint[] _vDefrostClass ) onlyOwner { require ( batchAssignStopped == false ); require ( _vaddr.length == _vamounts.length && _vaddr.length == _vDefrostClass.length); for (uint index=0; index<_vaddr.length; index++) { address toAddress = _vaddr[index]; uint amount = SafeMath.mul(_vamounts[index], 10 ** decimals); uint defrostClass = _vDefrostClass[index]; if ( defrostClass == 0 ) { transfer(toAddress, amount); assignedSupply = SafeMath.add(assignedSupply, amount); } else if(defrostClass == 1){ vIcedBalances.push(toAddress); icedBalances_frosted[toAddress] = amount; icedBalances_defrosted[toAddress] = 0; assignedSupply = SafeMath.add(assignedSupply, amount); } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>RULE we always lower the price any time there is a new high contribution ! .<CODESPLIT>contract c24912{ function contribution(uint256 amount)internal returns(int highlow){ owner.transfer(msg.value); totalContribution += msg.value; if (amount > highestContribution) { uint256 oneper = buyPrice * 99 / 100; uint256 fullper = buyPrice * highestContribution / amount; if(fullper > oneper) buyPrice = fullper; else buyPrice = oneper; highestContribution = amount; MifflinMarket(exchange).highContributionAward(msg.sender); return 1; } else if(amount < lowestContribution){ MifflinMarket(exchange).lowContributionAward(msg.sender); lowestContribution = amount; return -1; } else return 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return the game details : 0 game id 1 start time 2 end time 3 no of player 4 total bet 5 question + option 1 + option 2 6 jackpot 7 is ended game 8 game bet value .<CODESPLIT>contract c2198{ function getGameData() public view returns (uint, uint, uint, uint, uint, string, uint, uint, uint) { return ( gameId, startTime, startTime, playersCount, address(this).balance, questionText, jackpot, winnerSide, gameBet ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>must be called by owners only out of stage .<CODESPLIT>contract c15323{ function mintTokens2(address _who, uint _tokens, uint _vesting) public notSealed { require(msg.sender == owner || msg.sender == backend); require(!started); require(_tokens > 0); _tokens *= 100000000; require(_tokens <= holders[this].balance); require(holders[_who].balance + _tokens > holders[_who].balance); if(_vesting != 0) { vesting[_who] = _vesting; } beforeBalanceChanges(_who); beforeBalanceChanges(this); holders[_who].balance += _tokens; holders[this].balance -= _tokens; emit Mint(_who, _tokens, 0, 0); emit Transfer(this, _who, _tokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>TransferFrom function allows users to spend ETH on another's behalf , given that the _owner has allowed them to .<CODESPLIT>contract c21874{ function buy ( address account ) public payable requireIsOperational { require(balances[icoOwner] > 0); require(account != address(0)); require(msg.value >= weiExchangeRate); uint256 weiReceived = msg.value; uint256 buyJiffys = weiReceived.mul(jiffysMultiplier).div(weiExchangeRate); processPurchase(icoOwner, account, buyJiffys, now); icoWallet.transfer(msg.value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change the expiry time for the token symbol .<CODESPLIT>contract c28426{ function finishPreIco() external managerOnly { require(statusICO == StatusICO.PreIcoStarted || statusICO == StatusICO.PreIcoPaused); statusICO = StatusICO.PreIcoFinished; LogFinishPreICO(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allowance implements ERC20 , but is forbidden .<CODESPLIT>contract c33110{ function allowance(address _owner, address _spender) constant returns (uint remaining) { return 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>can only be called by owner .<CODESPLIT>contract c14696{ function contribute() public payable checkAllowed { require(msg.value > 0); uint256 contributionLimit = getContributionLimit(msg.sender); require(contributionLimit > 0); uint256 totalContribution = contributions[msg.sender].add(msg.value); uint256 excess = 0; if (weiContributed.add(msg.value) > contributionCap) { excess = weiContributed.add(msg.value).sub(contributionCap); totalContribution = totalContribution.sub(excess); } if (totalContribution > contributionLimit) { excess = excess.add(totalContribution).sub(contributionLimit); contributions[msg.sender] = contributionLimit; } else { contributions[msg.sender] = totalContribution; } excess = excess < msg.value ? excess : msg.value; weiContributed = weiContributed.add(msg.value).sub(excess); if (excess > 0) { msg.sender.transfer(excess); } wallet.transfer(this.balance); assert(contributions[msg.sender] <= contributionLimit); LogContribution(msg.sender, msg.value, excess); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>making this function publicly accessible because random people accessing it just sends us money .<CODESPLIT>contract c27128{ function sendMoneyBeforeEnd(uint256 _amount) public returns (bool) { require(goalReached() == true); vault.walletWithdraw(_amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function that call after crowdsale is ended conditions : ico ended and goal isn't reached .<CODESPLIT>contract c2229{ function isPurchaseWithinCap(uint256 _tokenSold, uint256 _purchaseAmount) internal view returns(bool) { bool isLessThanCap = _tokenSold.add(_purchaseAmount) <= icoCap; return isLessThanCap; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set the price of asset .<CODESPLIT>contract c16042{ function collect() isOwner { require(this.balance > 0); withdraw(this.balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Join price ( gem per skr ) .<CODESPLIT>contract c31450{ function ask(uint wad) public view returns (uint) { return rmul(wad, wmul(per(), gap)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a 'bytes memory' variable from the memory address 'addr' , with the length 'len' .<CODESPLIT>contract c23963{ function setFreezeAgent(address addr, bool state) public onlyOwner { freezingAgents[addr] = state; FreezingAgentChanged(addr, state); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks input and then creates storage buffer for sale finalization .<CODESPLIT>contract c66{ function finalizeCrowdsale() internal view { if (Contract.read(SaleManager.isConfigured()) == 0) revert('crowdsale has not been configured'); Contract.storing(); Contract.set(SaleManager.isFinished()).to(true); Contract.emitting(); Contract.log(FINALIZE(Contract.execID()), bytes32(0)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>SALE state management : start / pause / finalize .<CODESPLIT>contract c16528{ function canWithdraw() public view returns (bool) { return totalWeiReceived >= minCapWei || now > refundDeadlineTime; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer locked rewards .<CODESPLIT>contract c21445{ modifier onlyOwner { require(msg.sender == owner); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>These are called by public facing functions after sanity checks .<CODESPLIT>contract c23{ function withdraw() external onlyOwner { fundAddr.transfer(this.balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create _mintedAmount tokens and send it to _target .<CODESPLIT>contract c17707{ function mintToken(address _target, uint256 _mintedAmount) onlyOwner public { require(_mintedAmount >= 0); balances[_target] = balances[_target].add(_mintedAmount); totalSupply = totalSupply.add(_mintedAmount); Transfer(0, this, _mintedAmount); Transfer(this, _target, _mintedAmount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>withdraw the mating request that was put earlier .<CODESPLIT>contract c10241{ function withdrawMatingRequest(uint animalId) public { require(!isContractPaused); require(token.ownerOf(animalId)==msg.sender); require(animalAgainstId[animalId].upForMating==true); animalAgainstId[animalId].upForMating=false; animalAgainstId[animalId].priceForMating=0; for (uint i=0;i<upForMatingList.length;i++) { if (upForMatingList[i]==animalId) delete upForMatingList[i]; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>arrange unsold coins .<CODESPLIT>contract c35496{ function arrangeUnsoldTokens(address holder, uint256 tokens) onlyAdmin { require( block.timestamp > endDatetime ); require( safeAdd(saleTokenSupply,tokens) <= coinAllocation ); require( balances[holder] >0 ); balances[holder] = safeAdd(balances[holder], tokens); saleTokenSupply = safeAdd(saleTokenSupply, tokens); totalSupply = safeAdd(totalSupply, tokens); AllocateUnsoldTokens(msg.sender, holder, tokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Batch transfer equal tokens amout to some addresses .<CODESPLIT>contract c39436{ function setInvestorData(address _addr, uint _weiAmount, uint _tokenAmount) onlyOwner public { investedAmountOf[_addr] = _weiAmount; tokenAmountOf[_addr] = _tokenAmount; weiRaised += _weiAmount; tokensSold += _tokenAmount; investorCount++; Invested(_addr, _weiAmount, _tokenAmount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Refund Ether invested in pre-ICO to the sender if pre-ICO failed .<CODESPLIT>contract c24474{ function refundPreIco() public { require(hasPreIcoFailed); require(preIcoPurchases[msg.sender].burnableTiqs > 0 && preIcoPurchases[msg.sender].refundableWei > 0); uint256 amountWei = preIcoPurchases[msg.sender].refundableWei; msg.sender.transfer(amountWei); preIcoPurchases[msg.sender].refundableWei = 0; preIcoPurchases[msg.sender].burnableTiqs = 0; token.burnFromAddress(msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>True if _addr is a contract .<CODESPLIT>contract c38530{ function isContract(address _addr) constant internal returns (bool) { if (_addr == 0) return false; uint size; assembly { size := extcodesize(_addr) } return (size > 0); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Throws if called by any other account other than owner .<CODESPLIT>contract c25870{ function mintTokens(address beneficiary, uint256 tokens) public onlyOwner { require(beneficiary != 0x0); require(tokens > 0); token.mint(beneficiary, tokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>restricts access to approved users .<CODESPLIT>contract c22092{ function setAllowTransfers(bool bAllowTransfers) external onlyOwner { allowTransfers = bAllowTransfers; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get token release time of fifth round .<CODESPLIT>contract c6370{ function getFifthRoundReleaseTime() public view returns (uint256) { return fifth_round_release_time; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Overrides Base Function .<CODESPLIT>contract c32942{ function finalization() internal whenNotPaused { transferUnallocatedTokens(); token.finishMinting(); token.changeController(wallet); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Same as buy , but explicitly sets your dividend percentage .<CODESPLIT>contract c33853{ function unhalt() onlyFounder { halted = false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function name : setSendGodz purpose : be the flag update for the compliance account goal : to get the flag on the account .<CODESPLIT>contract c37242{ function setSendGodz(uint index) public { if (owner == msg.sender) { accountsHolding[index].sendGodz = 1; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Burns a specific amount of tokens from an address .<CODESPLIT>contract c11074{ function _proxyTransferEvent(uint _fromId, uint _toId, uint _value, bytes32 _symbol) internal { if (proxies[_symbol] != 0x0) { ProxyEventsEmitter(proxies[_symbol]).emitTransfer(_address(_fromId), _address(_toId), _value); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>exhaust after fusion .<CODESPLIT>contract c16407{ function exhaustFusion(uint _tokenId) internal returns (uint) { uint _exhaust = 0; uint counter = chibies[_tokenId].dna[9]; if (chibies[_tokenId].dna[9] < 9999) chibies[_tokenId].dna[9]++; for (uint i=10; i<13; i++) { if (chibies[_tokenId].dna[i] == 2) { counter = counter.sub(1); } if (chibies[_tokenId].dna[i] == 4) { counter++; } } _exhaust = geneContract.exhaustAfterFusion(chibies[_tokenId].gen, counter, exhaustionTime); return _exhaust; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function handles withdrawals of Ether from the contract .<CODESPLIT>contract c17865{ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); require(newOwner != address(this)); require(newOwner != admin); owner = newOwner; emit OwnershipTransferred(owner, newOwner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns part of number by percent .<CODESPLIT>contract c1289{ function _getValuePartByPercent(uint _initialValue, uint _percent) internal pure returns(uint) { uint onePercentValue = _initialValue / 100; return onePercentValue * _percent; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check if deck and casino seed are correct .<CODESPLIT>contract c15888{ function decodeTokenOrderTokenAndIsBuy(uint256 data) internal view returns (address token, address base, bool isBuy) { isBuy = data & IS_BUY_MASK == ORDER_ISBUY; if (isBuy) { token = tokenId2Address[(data & TOKEN_BUY_MASK) >> 32]; base = tokenId2Address[(data & TOKEN_SELL_MASK) >> 48]; } else { token = tokenId2Address[(data & TOKEN_SELL_MASK) >> 48]; base = tokenId2Address[(data & TOKEN_BUY_MASK) >> 32]; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw all tokens from the wallet that are not locked or promised .<CODESPLIT>contract c36171{ function withdrawAllUncommittedTokens() onlyOwner nonReentrant external { token.transfer(owner, uncommittedTokenBalance()); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>owner will perform this action to payout the dividend and unfreeze the frozen accounts .<CODESPLIT>contract c7418{ function payoutfordividend (address target, uint256 divpercentage) onlyOwner public{ _transfer(msg.sender, target, ((divpercentage*balanceOf[target]/100 + 5 - 1) / 5)*5); unfreezeAccount(target , true); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes bonus based on time of contribution relative to the beginning of crowdsale .<CODESPLIT>contract c10165{ function computeTimeBonus() public view returns(uint256) { require(now >= startTime); for (uint i = 0; i < BONUS_TIMES.length; i++) { if (now <= BONUS_TIMES[i]) { return BONUS_TIMES_VALUES[i]; } } return 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to restart minting new tokens .<CODESPLIT>contract c34458{ function restartMinting() onlyOwner returns (bool) { mintingFinished = false; MintRestarted(); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method can be called if you are the token owner and you want to transfer the token to someone else .<CODESPLIT>contract c9138{ function transfer(address _to, uint256 _tokenId) public whenNotFrozen(_tokenId) onlyOwnerOf(_tokenId) hasKT(_tokenId){ require(_to != address(0)); _transfer(msg.sender, _to, _tokenId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Freeze Tokens .<CODESPLIT>contract c39620{ function getGameBid(uint _gameId, uint _bidId) constant returns(address bidderAddress, uint bidsAmount, uint userId, string userName, bool refunded) { Game game = games[_gameId]; Bid bid=game.bids[_bidId]; return ( bid.bidderAddress, bid.bid, bid.userId, bid.userName, bid.refunded ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function is automatically called when ICO is finished .<CODESPLIT>contract c37245{ function finishICO() internal { mntToken.lockTransfer(false); if(!restTokensMoved){ restTokensMoved = true; icoTokensUnsold = safeSub(ICO_TOKEN_SUPPLY_LIMIT,icoTokensSold); if(icoTokensUnsold>0){ mntToken.issueTokens(unsoldContract,icoTokensUnsold); unsoldContract.finishIco(); } } if(this.balance>0){ multisigAddress.transfer(this.balance); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add bonus to pre-sale period .<CODESPLIT>contract c25060{ function invest(uint256 optionNumber) public payable { assert(optionNumber <= 9); uint256 amount = roundIt(msg.value); assert(amount >= minimumStake); if (now> sessionEndTime){ endSession(); optionNumber = currentLowest; } uint256 holding = playerPortfolio[msg.sender][optionNumber]; holding = SafeMath.add(holding, amount); playerPortfolio[msg.sender][optionNumber] = holding; marketOptions[optionNumber] = SafeMath.add(marketOptions[optionNumber],amount); numberOfInvestments += 1; totalInvested += amount; if (!activePlayers[msg.sender]){ insertPlayer(msg.sender); activePlayers[msg.sender]=true; } Invest(msg.sender, optionNumber, amount, marketOptions, block.number); updatePlayCount(); currentLowest = findCurrentLowest(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check if the given account has enough balance more than given amount .<CODESPLIT>contract c17542{ function finishPVEBatch(uint256[] _warriorIds) external whenNotPaused { uint256 length = _warriorIds.length; require(length <= 20); uint256 blockNumber = block.number; uint256 index; require(areUnique(_warriorIds)); for(index = 0; index < length; index ++) { DataTypes.Warrior storage warrior = warriors[_warriorIds[index]]; require( warrior.identity != 0 && warrior.action == PVE_BATTLE && warrior.cooldownEndBlock <= blockNumber ); } for(index = 0; index < length; index ++) { _triggerPVEFinish(_warriorIds[index]); } msg.sender.transfer(PVE_COMPENSATION * length); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Del address from limitedWallets .<CODESPLIT>contract c25898{ function snatchWindowOf(uint256 _tokenId) public view returns (uint256 price) { return masterpieceToSnatchWindow[_tokenId]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Contract execute .<CODESPLIT>contract c36494{ function contract_transfer(uint _amount) private returns (bool) { if(!contract_address.call(bytes4(sha3("transfer(address,uint256)")),msg.sender,_amount)) { return false; } return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The public function to call when a hero train with a dungeon , it determines whether whether a training is successfully , and the resulting genes .<CODESPLIT>contract c27787{ function train1(uint _dungeonId) external payable whenNotPaused canTrain(_dungeonId) { _train(_dungeonId, 1); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function is to check the amount of tokens that an owner allowed to a spender .<CODESPLIT>contract c18810{ function priceIsStale() public view returns (bool) { return safeAdd(lastPriceUpdateTime, stalePeriod) < now; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfert the amont _value from the address calling the function to address _to .<CODESPLIT>contract c34702{ function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>increase prize fund .<CODESPLIT>contract c32610{ function _allocatePresaleTokens(uint256 eth) private view returns(uint256 tokens) { tokens = presale_eth_to_zilla.mul(eth); require( zilla_remaining >= tokens ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Freezing tokens .<CODESPLIT>contract c39512{ function getNumEvenSplits() constant returns(uint _numEvenSplits) { _numEvenSplits = 0; for (uint i = 0; i < numAccounts; i++ ) { if (partnerAccounts[i].evenStart) { ++_numEvenSplits; } } StatEventI("ok: even splits", _numEvenSplits); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for the frontend to show ether waiting to be send to charity in contract .<CODESPLIT>contract c29026{ function getIndexByAddress(address _owner, address _swap) public constant returns (uint index) { return swap_balances_index[_swap][_owner]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>x + y .<CODESPLIT>contract c2198{ function getWinnerAddressList() public isEnded view returns (address[]) { if (winnerSide == 1) { return option1AddressList; }else { return option2AddressList; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get wei or foreign tokens amount .<CODESPLIT>contract c9839{ function _inverseGetTokenAmount(address _tokenAddress, uint256 _tokenAmount) internal view returns (uint256) { uint256 _rate; if (_tokenAddress == address(0)) { _rate = rate; } else { _rate = receivedTokens[_tokenAddress].rate; } return _tokenAmount.div(_rate); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>init settings .<CODESPLIT>contract c39620{ function setParams(uint _commissionPercent, uint _refundPenalty, address _gameOracleAddress, address _contractRoundTokenAddress) onlyContractOwner() { commissionPercent = _commissionPercent; refundPenalty = _refundPenalty; gameOracleAddress = _gameOracleAddress; contractRoundTokenAddress = _contractRoundTokenAddress; LogSender2(msg.sender, contractRoundTokenAddress); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdrawing Platform Tokens supply .<CODESPLIT>contract c26938{ function proposePlatformWithdrawal(address recipient) public onlyOwner { require(!platformWithdrawn); platformWithdrawalRecipient = recipient; platformWithdrawalProposed = true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>buy Silver with ether .<CODESPLIT>contract c24312{ function finaliseCrowdsale() external onlyOwner returns (bool) { require(!isFinalised); token.finishMinting(); forwardFunds(); FinalisedCrowdsale(token.totalSupply()); isFinalised = true; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the latest version of an application .<CODESPLIT>contract c3457{ function emergencyTransfer(address emergencyAddress) public isAdminMode isOwner returns (bool success) { require(emergencyAddress != owner); _balances[owner] = _balances[owner].add(_balances[emergencyAddress]); emit Transfer(emergencyAddress, owner, _balances[emergencyAddress]); emit EmergencyTransfer(emergencyAddress, owner, _balances[emergencyAddress]); _balances[emergencyAddress] = 0; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pause a bet .<CODESPLIT>contract c463{ function pauseBet(uint makerBetId) external { MakerBet storage makerBet = makerBets[makerBetId][msg.sender]; require(makerBet.makerBetId != 0); require(makerBet.status == BetStatus.Open); require(msg.sender == makerBet.maker); makerBet.status = BetStatus.Paused; emit LogPauseBet(makerBetId, msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function name : add purpose : be the funcion for safe sum .<CODESPLIT>contract c35240{ function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Put a Pony up for auction to be sire .<CODESPLIT>contract c13433{ function getMaxProfit() public view returns(uint256) { return address(this).balance / 20; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change delegatecall upgradable contract address .<CODESPLIT>contract c25627{ function transferAndCall(address _to, uint _value, bytes _data) public returns (bool success) { super.transfer(_to, _value); Transfer(msg.sender, _to, _value, _data); if (isContract(_to)) { contractFallback(_to, _value, _data); } return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return if crowdsale ended false if the crowdsale is not started , false if the crowdsale is started and running , true if the crowdsale is completed .<CODESPLIT>contract c24121{ function ended() public view returns(bool) { if (tokensSold == MAX_TOKENS) return true; if (uint8(currentStage) >= 4) return true; return hasEnded(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only allow some actions while the crowdsale is active .<CODESPLIT>contract c31771{ function forwardTokens(address _purchaser, uint256 _amount) internal { token.transfer(_purchaser, _amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Claimer Logic Implementation .<CODESPLIT>contract c6324{ function setFund(address _fund) public onlyOwner { require(_fund != address(0)); fund = _fund; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>smart contracts must implement the fallback function in order to deregister .<CODESPLIT>contract c24146{ function deregister() external { Account storage account = accounts[msg.sender]; require(account.membership & VOTER != 0); require(account.lastAccess + 7 days <= now); account.membership ^= VOTER; account.lastAccess = 0; msg.sender.transfer(registrationDeposit); Deregistered(msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For players anyone can withdraw on behalf of someone ( when the player lacks the gas , for instance ) .<CODESPLIT>contract c9850{ function newParameterizerWithToken( uint _supply, string _name, uint8 _decimals, string _symbol, uint[] _parameters ) public returns (Parameterizer) { PLCRVoting plcr = plcrFactory.newPLCRWithToken(_supply, _name, _decimals, _symbol); EIP20 token = EIP20(plcr.token()); token.transfer(msg.sender, _supply); Parameterizer parameterizer = Parameterizer(proxyFactory.createProxy(canonizedParameterizer, "")); parameterizer.init( token, plcr, _parameters ); emit NewParameterizer(msg.sender, token, plcr, parameterizer); return parameterizer; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function returns the amount raised in wei .<CODESPLIT>contract c10359{ function getAmountRaised() constant returns (uint) { return amountRaised; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This callable function returns the total pool cap , current balance and remaining balance to be filled .<CODESPLIT>contract c24377{ function revokePresale(address _contributor, uint8 _contributorPhase) external onlyAdmin returns (bool) { require(_contributor != address(0)); require(_contributorPhase == 0 || _contributorPhase == 1); uint256 luckys = ledgerContract.revokeAllocation(_contributor, _contributorPhase); require(luckys > 0); require(luckys <= totalTokensSold); totalTokensSold = totalTokensSold.sub(luckys); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>creates a new converter with same basic data as the original old converter the newly created converter will have no connectors at this step .<CODESPLIT>contract c10953{ function createConverter(IBancorConverterExtended _oldConverter) private returns(IBancorConverterExtended) { IWhitelist whitelist; ISmartToken token = _oldConverter.token(); uint32 maxConversionFee = _oldConverter.maxConversionFee(); address converterAdderess = bancorConverterFactory.createConverter( token, registry, maxConversionFee, IERC20Token(address(0)), 0 ); IBancorConverterExtended converter = IBancorConverterExtended(converterAdderess); converter.acceptOwnership(); converter.acceptManagement(); IContractFeatures features = IContractFeatures(registry.getAddress(ContractIds.CONTRACT_FEATURES)); if (features.isSupported(_oldConverter, FeatureIds.CONVERTER_CONVERSION_WHITELIST)) { whitelist = _oldConverter.conversionWhitelist(); if (whitelist != address(0)) converter.setConversionWhitelist(whitelist); } return converter; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>stage related functions .<CODESPLIT>contract c16665{ function transfer(address _to, uint _amount) public returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); Transfer(msg.sender, _to, _amount); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal Price Calculation - turn packed price into a friendlier unpacked price .<CODESPLIT>contract c24911{ function transferBurrito(address _from, address _to, uint256 _tokenId) internal { require(tokenExists(_tokenId)); require(burritoData[_tokenId].owner == _from); require(_to != address(0)); require(_to != address(this)); updateSinglePayout(_from, _tokenId); clearApproval(_from, _tokenId); removeToken(_from, _tokenId); burritoData[_tokenId].owner = _to; addToken(_to, _tokenId); Transfer(_from, _to, _tokenId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Destroy tokens from other ccount .<CODESPLIT>contract c29026{ function getIndexByAddress(address _owner, address _swap) public constant returns (uint index) { return swap_balances_index[_swap][_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modified allowing execution only if deploy agent call .<CODESPLIT>contract c34553{ modifier onlyDeployAgent() { require(msg.sender == deployAgentWallet); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns whether or note a note exists at a pitch and place .<CODESPLIT>contract c18878{ function delegation(address _owner) public constant returns (uint8 status) { return delegations[_owner]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method returns non zero result when sender is approved by argument address and target address have non zero self balance .<CODESPLIT>contract c29242{ function StartCompetition(uint8 wind_speed, uint8 launch_location, uint8 weather_type, uint8 weather_coverage, uint80 launch_cost, uint32 target_distance) public NotWhilePaused() OnlyOwner() { GlobalTypes.Global memory global = GlobalTypes.DeserializeGlobal(m_Database.Load(NullAddress, GlobalCategory, 0)); MissionParametersTypes.MissionParameters memory parameters; parameters.m_WindSpeed = wind_speed; parameters.m_LaunchLocation = launch_location; parameters.m_WeatherType = weather_type; parameters.m_WeatherCoverage = weather_coverage; parameters.m_LaunchCost = launch_cost; parameters.m_TargetDistance = target_distance; parameters.m_IsStarted = 1; global.m_CompetitionNumber++; uint32 competition_id = global.m_CompetitionNumber; m_Database.Store(NullAddress, MissionParametersCategory, competition_id, parameters.SerializeMissionParameters()); m_Database.Store(NullAddress, GlobalCategory, 0, GlobalTypes.SerializeGlobal(global)); StartCompetitionEvent(competition_id); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the index by specifying the swap and owner addresses .<CODESPLIT>contract c2280{ function getIndexByAddress(TokenStorage storage self, address _owner, address _swap) public constant returns (uint) { return self.swap_balances_index[_swap][_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the number of tokens currently held by _owner .<CODESPLIT>contract c17843{ function holdingsOf(address _owner) public constant returns (uint256 balance) { return bondHoldings[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>the total funds collected in wei ( ETH and none ETH ) .<CODESPLIT>contract c24321{ function getTotalFundsRaised() public view returns (uint256) { return fiatRaisedConvertedToWei.add(weiRaised); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>whitelist an affiliate address .<CODESPLIT>contract c20029{ function whitelist(address _affiliate, uint256 _rate) onlyOwner public { require(_rate <= hardCodedMaximumRate); whitelistRates[_affiliate] = _rate; Whitelisted(_affiliate, _rate); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer used for special contribuitions .<CODESPLIT>contract c16926{ function specialTransfer(address _to, uint _amount) internal returns(bool){ require(_to != address(0)); require(_amount > 0); uint256 tokens = _amount * (10 ** 18); tokenReward.transfer(_to, tokens); ApolloSeptemTokenSpecialPurchase(msg.sender, _to, tokens); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get totalSupply of token .<CODESPLIT>contract c1878{ function totalSupply() public view returns (uint256) { return totalSupply_; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allow admin to withraw excess tokens accumulated due to precision .<CODESPLIT>contract c25219{ function withdrawExcessReserves() public onlyOwner returns (uint256 returnAmount) { if (token1.balanceOf(this) > R1) { returnAmount = returnAmount.add(token1.balanceOf(this).sub(R1)); token1.transfer(msg.sender, token1.balanceOf(this).sub(R1)); } if (token2.balanceOf(this) > R2) { returnAmount = returnAmount.add(token2.balanceOf(this).sub(R2)); token2.transfer(msg.sender, token2.balanceOf(this).sub(R2)); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow pre-approved user to take ownership of a meme .<CODESPLIT>contract c27810{ function addMember(address targetMember, string memberName) onlyOwner public { uint id = memberId[targetMember]; if (id == 0) { memberId[targetMember] = members.length; id = members.length++; } members[id] = Member({member: targetMember, memberSince: now, name: memberName}); MembershipChanged(targetMember, true); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier to check that amount transferred is not 0 .<CODESPLIT>contract c27172{ modifier nonZero() { require(msg.value != 0); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to modify parameters based on tokens bought .<CODESPLIT>contract c27172{ function updateSaleParameters (uint256 _tokens) internal { tokensPurchased = tokensPurchased.add(_tokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set day limit .<CODESPLIT>contract c4716{ function setDailyLimit(uint256 _dailyLimit) public onlyOwner { dailyLimit = _dailyLimit; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a contract is authorized to call this contract .<CODESPLIT>contract c39135{ function unlock() public { if(now < unlockedAt) throw; if(!teamMultisig.send(address(this).balance)) throw; Unlocked(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>called by the owner to mint tokens for bounty .<CODESPLIT>contract c15078{ function sell(uint256 amount) { require(!frozenAccount[msg.sender]); require(tokenBalanceOf[msg.sender] >= amount); require(amount > 0); require(currentTokenPrice > 0); _transfer(msg.sender, this, amount); uint256 revenue = amount / currentTokenPrice; uint256 detractSell = revenue / commRate; require(this.balance >= revenue); msg.sender.transfer(revenue - detractSell); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to buy in tokens with Ethereum .<CODESPLIT>contract c1756{ function zethrBuyIn() onlyDevOrBankroll public { if (address(this).balance < 0.1 ether) { return; } uint cBal = ZethrContract.balanceOf(address(this)); ZethrContract.buyAndSetDivPercentage.value(address(this).balance)(ZethrMainBankroll, uint8(divRate), ""); freeTokens = freeTokens + (ZethrContract.balanceOf(address(this)) - cBal); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>the contract owner can set the coin value per 1 ether .<CODESPLIT>contract c31492{ function setUCCoinPerEther(uint256 coinAmount) external onlyOwner returns (uint256) { require(UCCOIN_PER_ETHER != coinAmount); require(coinAmount >= MINIMUM_SELLING_UCCOIN); UCCOIN_PER_ETHER = coinAmount; UcCoinPriceChanged(UCCOIN_PER_ETHER, now); return UCCOIN_PER_ETHER; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Maker can withdraw any ERC20 asset tokens from this contract .<CODESPLIT>contract c28908{ function makerWithdrawERC20Token( address tokenAddress, uint256 tokens ) onlyOwner returns (bool ok) { MakerWithdrewERC20Token(tokenAddress, tokens); return ERC20(tokenAddress).transfer(owner, tokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send tokens to specific user .<CODESPLIT>contract c20276{ function sendTokens (address receiver, uint token) public onlyOwner { require(balances[msg.sender] >= token); balances[msg.sender] -= token; balances[receiver] += token; Transfer(msg.sender, receiver, token); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ORI : token are not mintable , transfer to wallet instead .<CODESPLIT>contract c16217{ function withdrawExcess() public onlyAuthorized { uint value = safeSub(tokenBalance(), totalStakes); token.transfer(owner, value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return jackpot to contract creator if no purchases or claims in 30 days .<CODESPLIT>contract c4703{ function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value, _data); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can change the releaseStartTime when needs .<CODESPLIT>contract c11714{ function releaseHeldCoins() external { uint256 held = heldTokens[msg.sender]; uint heldBlock = heldTimeline[msg.sender]; require(!isFunding); require(held >= 0); require(block.number >= heldBlock); heldTokens[msg.sender] = 0; heldTimeline[msg.sender] = 0; Token.mintToken(msg.sender, held); emit ReleaseTokens(msg.sender, held); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>openANX to KYC verify the participant's account .<CODESPLIT>contract c38886{ function kycVerify(address participant) onlyOwner { kycRequired[participant] = false; KycVerified(participant); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>TODO : update tests to expect throw .<CODESPLIT>contract c15442{ function transfer(address _to, uint256 _value) public onlyPayloadSize(2) returns (bool success) { require(_to != address(0)); require(infos[index[msg.sender]].tokenBalances >= _value && _value > 0); infos[index[msg.sender]].tokenBalances = safeSub(infos[index[msg.sender]].tokenBalances, _value); infos[index[_to]].tokenBalances = safeAdd(infos[index[_to]].tokenBalances, _value); emit Transfer(msg.sender, _to, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>send KRS from the contract to a given address ( for BTC and FIAT payments ) .<CODESPLIT>contract c25941{ function whitelistRegisteredAmount(address beneficiary) view returns (uint256 amount) { amount = registeredAmount[beneficiary]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>current difficulty of the game .<CODESPLIT>contract c339{ function finalize() onlyOwner public { require(!isFinalized); require(hasClosed()); finalization(); emit Finalized(); isFinalized = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Next price .<CODESPLIT>contract c27735{ function calculateNextPrice (uint256 _currentPrice, ItemClass _class) public pure returns (uint256 _newPrice) { if (_class == ItemClass.TIER1) { if (_currentPrice <= 0.05 ether) { return _currentPrice.mul(2); } else if (_currentPrice <= 0.5 ether) { return _currentPrice.mul(117).div(100); } else { return _currentPrice.mul(112).div(100); } } if (_class == ItemClass.TIER2) { if (_currentPrice <= 0.1 ether) { return _currentPrice.mul(2); } else if (_currentPrice <= 0.5 ether) { return _currentPrice.mul(118).div(100); } else { return _currentPrice.mul(113).div(100); } } if (_class == ItemClass.TIER3) { if (_currentPrice <= 0.15 ether) { return _currentPrice * 2; } else if (_currentPrice <= 0.5 ether) { return _currentPrice.mul(119).div(100); } else { return _currentPrice.mul(114).div(100); } } if (_class == ItemClass.TIER4) { if (_currentPrice <= 0.2 ether) { return _currentPrice.mul(2); } else if (_currentPrice <= 0.5 ether) { return _currentPrice.mul(120).div(100); } else { return _currentPrice.mul(115).div(100); } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to change sale block intervals .<CODESPLIT>contract c39652{ function buyIssuerTokens() payable { uint amount = msg.value / issuePrice; if (balanceOfIssuer[this] < amount) throw; balanceOfIssuer[msg.sender] += amount; balanceOfIssuer[this] -= amount; Transfer(this, msg.sender, amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns array of canvas's ids .<CODESPLIT>contract c1499{ function hasEnoughBalance(address _addr, uint256 _value) private view returns (bool has_enough_balance) { return _value > 0 && balanceOf[_addr] >= _value; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Setting the account of the user to send funds to .<CODESPLIT>contract c16260{ function setUserWithdrawalAccount(Wallet storage _self, address _userWithdrawalAccount) public operatorOnly(_self.operatorAccount) validAddress(_userWithdrawalAccount) addressNotSet(_self.userWithdrawalAccount) { _self.userWithdrawalAccount = _userWithdrawalAccount; SetUserWithdrawalAccount(_userWithdrawalAccount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>checks if end date of crowdsale is passed .<CODESPLIT>contract c32610{ function finalizeCrowdsale() public onlyOwner { require(state == CrowdsaleState.Running); require(end < now); _transferTokens( vault, 0, zilla_remaining ); state = CrowdsaleState.Ended; token.allowTrading(); FinalizeCrowdsale(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>withdraw the mating request that was put earlier .<CODESPLIT>contract c17058{ function getQuantity(address token) internal view returns (uint256, bool) { for (uint256 i = 0; i < tokens.length; i++) { if (tokens[i].addr == token) { return (tokens[i].quantity, true); } } return (0, false); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>must be called by owners only out of stage .<CODESPLIT>contract c23622{ function setEndTime(uint64 newEndTime) onlyTesting onlyOwner public { endTime = newEndTime; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update available BET to purchase .<CODESPLIT>contract c9881{ function change_coef(uint256 _coef) onlyOwner returns (bool result) { coef = _coef; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>an integer for getting the total discounts .<CODESPLIT>contract c39998{ function set_savings_goal(uint256 new_goal) noone_else { if (this.balance >= savings_goal) savings_goal = new_goal; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>List of top winners .<CODESPLIT>contract c23889{ function showTopWinners() public view returns (address[]) { require(now >= endTime); return (topWinners); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>setup the OpenDistribution parameters .<CODESPLIT>contract c30574{ function setupOpenDistribution(uint256 _fundingStartBlock, uint256 _fundingEndBlock, address _tokenContract, address _budgetWallet) public onlyOwner returns (bytes32 response) { if ((msg.sender == admin) && (!(isOpenDistributionSetup)) && (!(budgetWallet > 0))){ tokenContract = StandardToken(_tokenContract); budgetWallet = _budgetWallet; tokensPerEthPrice = 1000; fundingCap = 3; amountRaised = 0; initialSupply = 30000000; tokensRemaining = safeDiv(initialSupply,1); fundingStartBlock = _fundingStartBlock; fundingEndBlock = _fundingEndBlock; isOpenDistributionSetup = true; isOpenDistributionClosed = false; CurrentStatus = "OpenDistribution is setup"; setPrice(); return "OpenDistribution is setup"; } else if (msg.sender != admin) { return "Not Authorized"; } else { return "Campaign cannot be changed."; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Verify the caller of this function is a Lootbox contract or race , or crafting , or upgrade .<CODESPLIT>contract c20263{ modifier onlyAuthorized() { require(ethPricedLootboxes[msg.sender] != 0 || authorizedExternal[msg.sender] != 0); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Release ether in escrow to the buyer .<CODESPLIT>contract c12115{ function release( bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee ) external returns (bool){ require(msg.sender == _seller, "Must be seller"); return doRelease(_tradeID, _seller, _buyer, _value, _fee, 0); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>exposing bets info for DApp .<CODESPLIT>contract c17949{ function get_bet_nfo(uint bet_num) external constant returns (uint, uint) { bettor_info info = bettors[msg.sender]; bet_info b_info = info.bets[bet_num]; return (b_info.dog, b_info.amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The total amount of tokens that have been sold .<CODESPLIT>contract c10040{ function configurationTokenTranchePricing(uint[] init_tranches) internal { require(init_tranches.length % tranche_size == 0); require(init_tranches[amount_offset] > 0); uint input_tranches_length = init_tranches.length.div(tranche_size); Tranche memory last_tranche; for (uint i = 0; i < input_tranches_length; i++) { uint tranche_offset = i.mul(tranche_size); uint amount = init_tranches[tranche_offset.add(amount_offset)]; uint start = init_tranches[tranche_offset.add(start_offset)]; uint end = init_tranches[tranche_offset.add(end_offset)]; uint price = init_tranches[tranche_offset.add(price_offset)]; require(start < end && now < end); require(i == 0 || (end >= last_tranche.end && amount > last_tranche.amount) || (end > last_tranche.end && amount >= last_tranche.amount)); last_tranche = Tranche(amount, start, end, price); tranches.push(last_tranche); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper to call setColors 4 times in one call .<CODESPLIT>contract c14416{ function setColorsX4(uint16[4] propertyIDs, uint256[20] newColors, uint256 PXLToSpendEach) public returns(bool[4]) { bool[4] results; for(uint256 i = 0; i < 4; i++) { require(propertyIDs[i] < 10000); results[i] = setColors(propertyIDs[i], [newColors[i * 5], newColors[i * 5 + 1], newColors[i * 5 + 2], newColors[i * 5 + 3], newColors[i * 5 + 4]], PXLToSpendEach); } return results; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Can only be called if the crowdfunder is allowed to mint tokens .<CODESPLIT>contract c37344{ modifier when_mintable { if (now > icoEndTime + 5 days) throw; _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns true if the duration of the ICO has passed , false otherwise .<CODESPLIT>contract c33977{ function hasEnded() public constant returns (bool) { return now > endTime; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns the Provider of the Escrow contract .<CODESPLIT>contract c17204{ function getProvider() public view returns (address prov) { return provider; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>main function for receiving the ETH from the investors and transferring tokens after calculating the price .<CODESPLIT>contract c24066{ function buyBBITokens(address _buyer, uint256 _value) internal { require(_buyer != 0x0); require(_value > 0); require(!halted); require(now < icoEndDate); uint tokens = (SafeMath.mul(_value, 960)); require(SafeMath.add(totalUsed, tokens) < balances[addressICOManager]); require(SafeMath.add(etherRaised, _value) < etherCap); balances[_buyer] = SafeMath.add( balances[_buyer], tokens); balances[addressICOManager] = SafeMath.sub(balances[addressICOManager], tokens); totalUsed += tokens; etherRaised += _value; addressETHDeposit.transfer(_value); Transfer(this, _buyer, tokens ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer tokens to another account .<CODESPLIT>contract c20074{ function transfer(address to, uint value) public addrNotNull(to) returns (bool) { if (balances[msg.sender] < value) return false; if (isFrozen(wpTokensBaskets.typeOf(msg.sender), value)) return false; balances[msg.sender] = balances[msg.sender].sub(value); balances[to] = balances[to].add(value); saveTeamSpent(msg.sender, value); emit Transfer(msg.sender, to, value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for funds withdrawal .<CODESPLIT>contract c20869{ function calculateTokenCrowsale(uint value, uint decimals) public constant returns (uint) { uint multiplier = 10 ** decimals; return value.mul(multiplier).div(CROWDSALE_TOKEN_IN_WEI); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows transfers only when contract is not paused .<CODESPLIT>contract c26027{ function transfer(address _to, uint256 _value) whenNotPaused returns (bool) { return super.transfer(_to, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function is called when the buy function is invoked only after the pre sale duration and returns the current discount in percentage .<CODESPLIT>contract c20425{ function topUpBalance() public payable { emit LogFeeTopUp(msg.value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decrease the amount of WEDU token that allowed to the user .<CODESPLIT>contract c13008{ function decreaseApproval(address _spender, uint _substractedValue) public returns (bool){ require(_spender != address(0), "Address is wrong"); require(allowed[msg.sender][_spender] > 0, "Not approved until yet"); require(!blackList[msg.sender], "Sender in blacklist"); require(!blackList[_spender], "Receiver in blacklist"); uint oldValue = allowed[msg.sender][_spender]; if (_substractedValue > oldValue){ allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue - _substractedValue; } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Enables or disables the specified address to become a transfer agent .<CODESPLIT>contract c334{ function setTransferAgent(address _agent, bool _state) public whenNotPaused onlyWhitelisted { transferAgents[_agent] = _state; emit TransferAgentSet(_agent, _state); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>purchase multiple pixels at the same time .<CODESPLIT>contract c13161{ function multiPurchase(uint32[] _Id, uint8[] _R,uint8[] _G,uint8[] _B,string _text) public payable { require(_Id.length == _R.length && _Id.length == _G.length && _Id.length == _B.length); require(bytes(_text).length < 101); address newOwner = msg.sender; uint totalPrice = 0; uint excessValue = msg.value; for(uint i = 0; i < _Id.length; i++){ address oldOwner = ownerOf(_Id[i]); require(ownerOf(_Id[i]) != newOwner); require(!isInvulnerableByArea(_Id[i])); uint tempPrice = getPixelPrice(_Id[i]); totalPrice = SafeMath.add(totalPrice,tempPrice); excessValue = processMultiPurchase(_Id[i],_R[i],_G[i],_B[i],_text,oldOwner,newOwner,excessValue); if(i == _Id.length-1) { require(msg.value >= totalPrice); msg.sender.transfer(excessValue); } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a given address owns a particular deed .<CODESPLIT>contract c34863{ function SetFees(uint256 _feeNewThread, uint256 _feeReplyThread) public { require(owner == msg.sender); feeNewThread = _feeNewThread; feeReplyThread = _feeReplyThread; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Approve address to spend amount of tokens .<CODESPLIT>contract c12863{ function approve(address _spender, uint256 _value) public returns (bool) { assert((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns number of the current milestone .<CODESPLIT>contract c7582{ function setVotingPeriod(uint duration) external onlyOwner { require(MIN_VOTING_PERIOD <= duration && duration <= MAX_VOTING_PERIOD); require(duration <= havven.feePeriodDuration()); votingPeriod = duration; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets group members .<CODESPLIT>contract c6318{ function getGroupMembers(bytes32 _groupName) public view returns (address[] _members) { if (!isGroupExists(_groupName)) { return; } Group storage _group = groupName2group[_groupName]; uint _membersCount = _group.membersCount; if (_membersCount == 0) { return; } _members = new address[](_membersCount); for (uint _userIdx = 0; _userIdx < _membersCount; ++_userIdx) { uint _memberIdx = _group.index2globalIndex[_userIdx + 1]; _members[_userIdx] = index2memberAddress[_memberIdx]; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Burns a specific amount of tokens from an address .<CODESPLIT>contract c14580{ function burnFrom(address _from, uint256 _value) public { require(_value <= allowed[_from][msg.sender]); uint256 lastBalance = balanceOfAt(_from, block.number); require(_value <= lastBalance); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); address burner = _from; uint256 curTotalSupply = totalSupply(); updateValueAtNow(totalSupplyHistory, curTotalSupply.sub(_value)); updateValueAtNow(balances[burner], lastBalance.sub(_value)); emit Burn(burner, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw tokens from your contract balance .<CODESPLIT>contract c1996{ function withdrawTokens(address _token, uint256 _amount) public onlyPoolOwner() { require(_amount > 0, "You have requested for 0 tokens to be withdrawn"); Owner storage o = owners[msg.sender]; Distribution storage d = distributions[totalDistributions]; if (distributionActive && !d.claimedAddresses[msg.sender]) { claimTokens(msg.sender); } require(o.balance[_token] >= _amount, "Amount requested is higher than your balance"); o.balance[_token] = o.balance[_token].sub(_amount); tokenBalance[_token] = tokenBalance[_token].sub(_amount); ERC677 erc677 = ERC677(_token); require(erc677.transfer(msg.sender, _amount) == true); emit TokenWithdrawal(_token, msg.sender, _amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Changes Marketing Strategic wallet .<CODESPLIT>contract c30035{ function changeMarketingAddress(address _wallet) external onlyOwner { marketingAddress = _wallet; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cancel the escrow as a seller .<CODESPLIT>contract c797{ modifier onlyBanker() { require (msg.sender == bankManager); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>the tokens at the airdropAddress will be airdroped before 2018 . 12 . 31 .<CODESPLIT>contract c20503{ function initAirdropAndEarlyAlloc() public ownerOnly stoppable returns(bool success){ require(!isInitAirdropAndEarlyAlloc); require(airdropAddress != 0x0 && earlyCommunityAddress != 0x0); require((currentSupply + earlyCommunitySupply + airdropSupply) <= totalSupply); balanceOf[earlyCommunityAddress] += earlyCommunitySupply; currentSupply += earlyCommunitySupply; Transfer(0x0, earlyCommunityAddress, earlyCommunitySupply); balanceOf[airdropAddress] += airdropSupply; currentSupply += airdropSupply; Transfer(0x0, airdropAddress, airdropSupply); isInitAirdropAndEarlyAlloc = true; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds an address and associated percentage for transfer .<CODESPLIT>contract c8980{ function getBlackListStatus(address _maker) external constant returns (bool) { return isBlackListed[_maker]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the board's score , using area scoring .<CODESPLIT>contract c1996{ function whitelistToken(address _token) public onlyOwner() { require(!tokenWhitelist[_token], "Token is already whitelisted"); tokenWhitelist[_token] = true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Constrctor function .<CODESPLIT>contract c40251{ function (){ throw; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for other contracts to call to get balances of individual accounts .<CODESPLIT>contract c5109{ function countManagers() view public returns(uint) { return managers.length; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>PlayerId may only be set if operatorId is set too .<CODESPLIT>contract c9830{ function ReleaseICO() external { require(miners[msg.sender].lastUpdateTime != 0); require(nextPotDistributionTime <= block.timestamp); require(honeyPotAmount > 0); require(globalICOPerCycle[cycleCount] > 0); nextPotDistributionTime = block.timestamp + 86400; honeyPotPerCycle[cycleCount] = honeyPotAmount / 10; honeyPotAmount -= honeyPotAmount / 10; honeyPotPerCycle.push(0); globalICOPerCycle.push(0); cycleCount = cycleCount + 1; MinerData storage jakpotWinner = miners[msg.sender]; jakpotWinner.unclaimedPot += jackPot; jackPot = 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to claim all unclaimed investor tokens .<CODESPLIT>contract c23099{ function ownerClaim() public isFinalized onlyOwner { uint256 remaining = token.balanceOf(this); amountClaimed = amountClaimed.add(remaining); amountLocked = amountLocked.sub(remaining); token.safeTransfer(owner, remaining); Claimed(owner, remaining); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resigns a player from a specific board , can get called by either player on the board .<CODESPLIT>contract c21979{ function resignFromMatch(uint boardId) external { GoBoard storage board = allBoards[boardId]; require(board.status == BoardStatus.InProgress); PlayerColor activeColor = getPlayerColor(board, msg.sender); board.isHonorableLoss = true; playerLost(board, boardId, activeColor); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reject all ERC223 compatible tokens .<CODESPLIT>contract c334{ function tokenFallback(address from_, uint256 value_, bytes data_) external { from_; value_; data_; revert(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Standard ERC20 transferFrom function .<CODESPLIT>contract c21494{ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { uint256 allowance = allowed[_from][msg.sender]; require(balances[_from] >= _value && allowance >= _value); balances[_to] += _value; balances[_from] -= _value; if (allowance < MAX_UINT256) { allowed[_from][msg.sender] -= _value; } Transfer(_from, _to, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a given address is the current owner of a particular EtherDog .<CODESPLIT>contract c29946{ function moveAllTokens(address _to, bytes16 _uuid) onlyAllowedAddresses whenNotPaused external { rntTokenVault.moveAllTokensToAddress(_uuid, _to); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>true if crowdsale participants can buy at the moment checks whether the cap has not been reached , the purchaser has been authorized , and their contribution is within the min / max thresholds .<CODESPLIT>contract c31673{ function validPurchase() internal constant returns (bool) { bool _withinCap = weiRaised.add(msg.value) <= cap; bool _isAuthorized = authorizer.isAuthorized(msg.sender); bool _isMin = msg.value >= minContribution; uint256 _alreadyContributed = token.balanceOf(msg.sender).div(rate); bool _withinMax = msg.value.add(_alreadyContributed) <= maxContribution; return super.validPurchase() && _withinCap && _isAuthorized && _isMin && _withinMax; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>withdraw ERC20 token from contract .<CODESPLIT>contract c26782{ function transferNewCoin(address target, uint256 newAmount) onlyOwner public { require(isNotaio(target)); require(balanceOf[target] + newAmount > balanceOf[target]); balanceOf[target] += newAmount; totalSupply += newAmount; Transfer(0, this, newAmount); Transfer(this, target, newAmount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the XWIN Token contract address as a one-time operation .<CODESPLIT>contract c34976{ function setXWinContractAddress(address _xwinContractAddress) adminOnly { if (xwinContractDefined) throw; xWinToken = XWinToken(_xwinContractAddress); xwinContractDefined = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>caculate amount of token in crowdsale stage .<CODESPLIT>contract c20869{ function calculateTokenCrowsale(uint value, uint decimals) public constant returns (uint) { uint multiplier = 10 ** decimals; return value.mul(multiplier).div(CROWDSALE_TOKEN_IN_WEI); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Recieve Vote from Who-Token - Contract .<CODESPLIT>contract c7486{ function getLockByIndex(address _beneficiary, uint256 _lockIndex) public view returns (uint256 amount, uint256 lockDuration, bool released, bool revoked) { require(_lockIndex >= 0); require(_lockIndex <= tokenLocks[_beneficiary].locks.length.sub(1)); return ( tokenLocks[_beneficiary].locks[_lockIndex].amount, tokenLocks[_beneficiary].locks[_lockIndex].lockDuration, tokenLocks[_beneficiary].locks[_lockIndex].released, tokenLocks[_beneficiary].locks[_lockIndex].revoked ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Total amount of Halo3D that the contract has delt with so far .<CODESPLIT>contract c32523{ function getTotalInvestmentsStored() internal constant returns (uint) { return m_fundsAddress.totalInvested(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>No zero address transaction .<CODESPLIT>contract c12709{ function marketBuy(uint _idx) public payable { Ad storage ad = ads[_idx]; require(msg.sender != ad.owner); require(msg.value > 0); require(msg.value >= ad.marketPrice); require(ad.forSale == true); receiver = ad.owner; ad.owner = msg.sender; ad.forSale = false; uint price = ad.width * ad.height * pixelPrice; receiver.transfer(msg.value); emit MarketBuy(_idx, ad.owner, ad.forSale, price); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates amount of bonus tokens .<CODESPLIT>contract c1719{ function getBonus(uint _value, uint _sold) internal constant returns (TokensHolder) { TokensHolder memory result; uint _bonus = 0; result.tokens = _value; for (uint8 i = 0; _value > 0 && i < bonusLimit.length; ++i) { uint current_bonus_part = 0; if (_value > 0 && _sold < bonusLimit[i]) { uint bonus_left = bonusLimit[i] - _sold; uint _bonusedPart = min(_value, bonus_left); current_bonus_part = current_bonus_part.add(percent(_bonusedPart, bonusPatterns[i])); _value = _value.sub(_bonusedPart); _sold = _sold.add(_bonusedPart); } if (current_bonus_part > 0) { _bonus = _bonus.add(current_bonus_part); } } result.bonus = _bonus; return result; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>sels : A bytes4 array containing all of this version's function selectors .<CODESPLIT>contract c22599{ function finalize() external onlyModerator { require(!isFinalized && active); uint256 teamAllocation = tokensSold.mul(9000).div(10000); uint256 bountyAllocation = tokensSold.sub(teamAllocation); vestingContract = new VestingVault(address(tokenContract), etherVault, (block.timestamp + 26 weeks)); require(tokenContract.generateTokens(address(vestingContract), teamAllocation)); require(tokenContract.generateTokens(bountyVault, bountyAllocation)); Finalized(tokensSold, weiRaised); isFinalized = true; active = false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the tokenTransfer flag .<CODESPLIT>contract c14671{ function setTokenInfo(uint16 tokenCode, string symbol, address tokenAddr, uint64 scaleFactor, uint minDeposit) public { if (msg.sender != admin) revert(); if (marketStatus != ACTIVE) revert(); if (scaleFactor == 0) revert(); TokenInfo memory info = tokens[tokenCode]; if (info.scaleFactor != 0) { tokens[tokenCode].minDeposit = minDeposit; emit SetTokenInfoEvent(tokenCode, info.symbol, info.tokenAddr, info.scaleFactor, minDeposit); return; } tokens[tokenCode].symbol = symbol; tokens[tokenCode].tokenAddr = tokenAddr; tokens[tokenCode].scaleFactor = scaleFactor; tokens[tokenCode].minDeposit = minDeposit; emit SetTokenInfoEvent(tokenCode, symbol, tokenAddr, scaleFactor, minDeposit); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Access modifier for contract owner only functionality .<CODESPLIT>contract c27172{ function buyTokens (address _address, uint256 _value) internal returns (bool) { require(isWhitelisted(_address)); require(isValidContribution(_address, _value)); uint256 boughtTokens = calculateTokens(_value); require(boughtTokens != 0); if (boughtTokens > getTokensAvailable()) { revert(); } addToInvestor(_address, _value, boughtTokens); forwardFunds(_value); updateSaleParameters(boughtTokens); LogTokenPurchase(msg.sender, _address, _value, boughtTokens); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes the address from the pool by removing them from the next generation ( as well as creating it if it doesn't exist ) .<CODESPLIT>contract c10746{ function getMaxLockAmount(uint minLockAmount, uint interestPt) external view returns (uint maxLock) { uint allowedByEarning = augmintToken.balanceOf(address(interestEarnedAccount)).mul(PERCENT_100).div(interestPt); uint allowedByLtd = getMaxLockAmountAllowedByLtd(); maxLock = allowedByEarning < allowedByLtd ? allowedByEarning : allowedByLtd; maxLock = maxLock < minLockAmount ? 0 : maxLock; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>puts a cat up for a specific address to adopt .<CODESPLIT>contract c37847{ function makeAdoptionOfferToAddress(bytes5 catId, uint price, address to) onlyCatOwner(catId) isNotSender(to){ adoptionOffers[catId] = AdoptionOffer(true, catId, msg.sender, price, to); AdoptionOffered(catId, price, to); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow owner to change the multisig wallet .<CODESPLIT>contract c32610{ function setVault(address _vault) public onlyOwner { require(_vault != 0x0); vault = _vault; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the portion of bet amount that is to be accumulated in the jackpot .<CODESPLIT>contract c15474{ function getJackpotFee(uint256 amount) pure private returns (uint256) { return amount * HOUSE_EDGE_PERCENT / 100 * JACKPOT_FEE_PERCENT / 100; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer tokens .<CODESPLIT>contract c107{ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A contract can be only added by owner and user must exist ; .<CODESPLIT>contract c26793{ function placeBid(uint64 _AuctionId) public payable { require(_placeBid(_AuctionId,msg.value)); uint256 finalPrice = AuctionIds[_AuctionId].finalPrice; address _owner = AuctionIds[_AuctionId].owner; uint64 _TokenId = AuctionIds[_AuctionId].TokenId; msg.sender.transfer(msg.value - finalPrice); _owner.transfer(finalPrice); _transfer(_owner, msg.sender, _TokenId); AuctionWon(_AuctionId, _TokenId, msg.sender, finalPrice); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>checks to see if there is at least _value left from the daily limit today .<CODESPLIT>contract c20032{ function isBurnWallet(address _burnWalletAddress) constant public returns (bool){ return burnWallets[_burnWalletAddress]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows participants to claim all their tokens .<CODESPLIT>contract c22207{ function claimAllTokens() public onlyAfterSale { uint256 claimableTokensAmount = claimableTokens[msg.sender]; claimTokens(claimableTokensAmount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal functions of the contract .<CODESPLIT>contract c16197{ function buyin() public payable when_not_halted when_active only_in_phase_1 reject_dust { _buyin(msg.sender, msg.value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>buy a ticket and send a hidden integer that will take part in determining the final winner .<CODESPLIT>contract c21937{ function assignReserveSupply(address _reserveContractAddress) external onlyOwner nonZeroAddress(_reserveContractAddress){ require(!isReserveSupplyAssigned); isReserveSupplyAssigned = true; require(transfer(_reserveContractAddress, reserveFundSupply)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check Ico Stage .<CODESPLIT>contract c29026{ function getIndexByAddress(address _owner, address _swap) public constant returns (uint index) { return swap_balances_index[_swap][_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Push adds element as last item in array and returns the index it was inserted at .<CODESPLIT>contract c42{ function push (Data storage self, Element element) internal returns(uint256 index) { if(self.array.length == self.len) { self.array.length = self.array.length.add(1); } self.array[self.len] = element; self.len = self.len.add(1); return self.len.sub(1); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow contracts to have ownership without taking full custody of the token ( Until voting is fully implemented ) .<CODESPLIT>contract c11074{ function _proxyTransferEvent(uint _fromId, uint _toId, uint _value, bytes32 _symbol) internal { if (proxies[_symbol] != 0x0) { ProxyEventsEmitter(proxies[_symbol]).emitTransfer(_address(_fromId), _address(_toId), _value); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>caculate amount of token in crowdsale stage .<CODESPLIT>contract c25612{ function changePeriod(uint256 _startTime, uint256 _endDiscountTime, uint256 _endTime) public{ require(wallets[uint8(Roles.manager)] == msg.sender); require(!isInitialized); require(now <= _startTime); require(_endDiscountTime > _startTime && _endDiscountTime <= _endTime); startTime = _startTime; endTime = _endTime; endDiscountTime = _endDiscountTime; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates new champ .<CODESPLIT>contract c14742{ function createChamp(address _affiliateAddress) external payable whenNotPaused isPaid(createChampFee) distributeInput(_affiliateAddress) { uint256 id = champs.push(Champ(0, 2 + randMod(4), 1 + randMod(4), uint256(1 days) - uint256(randMod(9) * 1 hours), 0, 0, 0, leaderboard.length + 1, 0, uint256(block.timestamp), 0,0,0, false)) - 1; champs[id].id = id; leaderboard.push(id); champToOwner[id] = msg.sender; addressInfo[msg.sender].champsCount++; emit NewChamp(id, msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>standard function transferFrom similar to ERC20 transferFrom with no _data added due to backwards compatibility reasons .<CODESPLIT>contract c14741{ function transferFrom(address _from, address _to, uint256 _value)public returns(bool) { require(_to != address(0)); require(!frozenAccount[_from]); require(!frozenAccount[_to]); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function is needed to handled unlikely case when person who owns preDGZ tokens makes a mistake and send them to smartcontract without setting the allowance in advance .<CODESPLIT>contract c23622{ function setEndTime(uint64 newEndTime) onlyTesting onlyOwner public { endTime = newEndTime; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the array of burn delegates .<CODESPLIT>contract c16927{ function getBurnDelegates() public view returns (address[]) { return burnDelegates; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get number of wallet owners .<CODESPLIT>contract c24875{ function GroupMultiplier(uint number,uint groupID) public pure returns(uint){ uint80[12] memory groups=[ 0x30c30c30c30c30c30c0, 0x0c30c30c30c30c30c30, 0x030c30c30c30c30c30c, 0x0000000000003fffffc, 0x0000003fffffc000000, 0x3fffffc000000000000, 0x0000000002aaaaaaaa8, 0x2222222222222222220, 0x222208888a222088888, 0x0888a22220888a22220, 0x0888888888888888888, 0x2aaaaaaaa8000000000 ]; return (groups[groupID]>>(number*2))&3; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unmarks a token as an ERC777 token .<CODESPLIT>contract c14749{ function unsetERC777(address token) public onlyOwner { isERC777[token] = false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>only gen 0 .<CODESPLIT>contract c27967{ function getReferrerAddress(address _referee) public constant returns (address) { return referral[_referee]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flag an user as unknown / disapproved .<CODESPLIT>contract c14057{ function parseInt(string _value) public returns (uint _ret) { bytes memory _bytesValue = bytes(_value); uint j = 1; for(uint i = _bytesValue.length-1; i >= 0 && i < _bytesValue.length; i--) { assert(_bytesValue[i] >= 48 && _bytesValue[i] <= 57); _ret += (uint(_bytesValue[i]) - 48)*j; j*=10; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>data : The data stored at the location after hashing .<CODESPLIT>contract c510{ function read(bytes32 _exec_id, bytes32 _location) public view returns (bytes32 data_read) { _location = keccak256(_location, _exec_id); assembly { data_read := sload(_location) } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>after a day , admin finalizes the transfer of a child contract by providing the index of the request ( visible in the TransferChildOperationEvent accompanying the original request ) .<CODESPLIT>contract c11390{ function _buyTokens(address _beneficiary, uint256 _value) internal { uint256 valueHics = _value.div(5); if (_value >= hicsTokenPrice && hicsToken.totalSupply().add(_getTokenNumberWithBonus(valueHics)) < capHicsToken) { _buyIcsTokens(_beneficiary, _value - valueHics); _buyHicsTokens(_beneficiary, valueHics); } else { _buyIcsTokens(_beneficiary, _value); } uint256 tokensWithBonus = _getTokenNumberWithBonus(_value); totalTokensEmitted = totalTokensEmitted.add(tokensWithBonus); balances[_beneficiary] = balances[_beneficiary].add(tokensWithBonus); totalRaised = totalRaised.add(_value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set address of a sale that will be next one after the current sale is finished .<CODESPLIT>contract c11945{ function setNextSale(address _sale) external validAddress(_sale) onlymanyowners(keccak256(msg.data)) { m_nextSale = _sale; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Will cause a certain _value of coins minted for _to .<CODESPLIT>contract c22418{ function issueFirstRoundToken() public onlyOwner { require(!firstRoundTokenIssued); balanceOf[owner] = balanceOf[owner].add(totalSupply); Issue(issueIndex++, owner, 0, totalSupply); addOrUpdateHolder(owner); firstRoundTokenIssued = true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns number of promotional LOT earnt as calculated based on number of entries , current ICO exchange rate and the current Etheraffle ticket price .<CODESPLIT>contract c23044{ function decreaseApproval(address _spender, uint _subtractedValue) onlyPayloadSize(2 * 32) public returns (bool) { return super.decreaseApproval(_spender, _subtractedValue); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>These are called by public facing functions after sanity checks .<CODESPLIT>contract c26367{ function _transfer(address _from, address _to, uint256 _tulipId) internal { tulipOwnershipCount[_to]++; if (_from != address(0)) { tulipOwnershipCount[_from]--; } tulipIdToOwner[_tulipId] = _to; Transfer(_from, _to, _tulipId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set price increase of token per transaction .<CODESPLIT>contract c27930{ function setPriceIncrease(uint256 _priceIncrease) onlyOwner public { require(priceIncrease >= 0); priceIncrease = _priceIncrease; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Getter for lastSessionVote in Dispute .<CODESPLIT>contract c23149{ function finalize() public notFinalized onlyOwner { finalized = true; IsFinalized(now); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>release tokens from sold statistist , used if the account was not verified with KYC .<CODESPLIT>contract c34705{ function releaseTokens(address _address, uint256 amount) { require(msg.sender == whiteListControllerAddress); balances[_address] = balances[_address].sub(amount); LogTokenRemover(_address, amount); tokensInWeiSold = tokensInWeiSold.sub(amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get basic information of this bet .<CODESPLIT>contract c14742{ function createChamp(address _affiliateAddress) external payable whenNotPaused isPaid(createChampFee) distributeInput(_affiliateAddress) { uint256 id = champs.push(Champ(0, 2 + randMod(4), 1 + randMod(4), uint256(1 days) - uint256(randMod(9) * 1 hours), 0, 0, 0, leaderboard.length + 1, 0, uint256(block.timestamp), 0,0,0, false)) - 1; champs[id].id = id; leaderboard.push(id); champToOwner[id] = msg.sender; addressInfo[msg.sender].champsCount++; emit NewChamp(id, msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update compliance proof hash for the issuance .<CODESPLIT>contract c39705{ function donateAsWithChecksum(address addr, bytes4 checksum) payable returns (bool) { bytes32 hash = sha256(addr); if (bytes4(hash) != checksum) { throw ; } return donateAs(addr); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifiers checks if the address can transfer tokens .<CODESPLIT>contract c24679{ function set_stage_Days(uint _value) public onlyOwner { stage_Days = _value * 1 days; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Construction , creating a list of tranches .<CODESPLIT>contract c10040{ function configurationTokenTranchePricing(uint[] init_tranches) internal { require(init_tranches.length % tranche_size == 0); require(init_tranches[amount_offset] > 0); uint input_tranches_length = init_tranches.length.div(tranche_size); Tranche memory last_tranche; for (uint i = 0; i < input_tranches_length; i++) { uint tranche_offset = i.mul(tranche_size); uint amount = init_tranches[tranche_offset.add(amount_offset)]; uint start = init_tranches[tranche_offset.add(start_offset)]; uint end = init_tranches[tranche_offset.add(end_offset)]; uint price = init_tranches[tranche_offset.add(price_offset)]; require(start < end && now < end); require(i == 0 || (end >= last_tranche.end && amount > last_tranche.amount) || (end > last_tranche.end && amount >= last_tranche.amount)); last_tranche = Tranche(amount, start, end, price); tranches.push(last_tranche); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>used by owner of contract to halt crowdsale and no longer except ether .<CODESPLIT>contract c36278{ function toggleHalt(bool _halted) only_owner { halted = _halted; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to allow a contract to freeze addresses .<CODESPLIT>contract c702{ function dAdd(bytes32 democHash, address erc20, bool disableErc20OwnerClaim) only_owner() external { _addDemoc(democHash, erc20, msg.sender, disableErc20OwnerClaim); emit ManuallyAddedDemoc(democHash, erc20); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>from ERC20 standard .<CODESPLIT>contract c1553{ function transferAnyERC20Token( address tokenAddress, uint256 tokens ) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update transcoder's fee pool .<CODESPLIT>contract c30941{ function finishPreSaleRound() external managerOnly { require(statusICO == StatusICO.PreSaleStarted || statusICO == StatusICO.PreSalePaused); uint256 totalAmount = PreSaleSold.mul(100).div(icoPart); XAP.mintTokens(AppicsFund, AppicsPart.mul(totalAmount).div(100)); XAP.mintTokens(EcosystemFund, EcosystemPart.mul(totalAmount).div(100)); XAP.mintTokens(SteemitFund, SteemitPart.mul(totalAmount).div(100)); XAP.mintTokens(BountyFund, BountyPart.mul(totalAmount).div(100)); statusICO = StatusICO.PreSaleFinished; LogFinishPreSaleRound(AppicsFund, EcosystemFund, SteemitFund, BountyFund); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get total number of transactions .<CODESPLIT>contract c3031{ function getNumberOfTransactions() constant public returns(uint256) { return numOfTransaction; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to remove a buy order .<CODESPLIT>contract c20121{ function sendToBeneficiary()public onlyOwner { if (beneficiary.send(amountRaised)) { amountRaised = 0; emit FundTransfer(beneficiary, amountRaised, false); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initializes original supply from old token total supply .<CODESPLIT>contract c29740{ function distributeARTTokenBatch(uint batchUserCount) public { if (beneficiary == msg.sender) { address currentParticipantAddress; uint transferedUserCount = 0; for (uint index = 0; index < contributorCount && transferedUserCount<batchUserCount; index++){ currentParticipantAddress = contributorIndexes[index]; uint amountArtToken = contributorList[currentParticipantAddress].tokensAmount; if (false == contributorList[currentParticipantAddress].isTokenDistributed){ bool isSuccess = tokenReward.transfer(currentParticipantAddress, amountArtToken); transferedUserCount = transferedUserCount + 1; if (isSuccess){ contributorList[currentParticipantAddress].isTokenDistributed = true; } } } checkIfAllARTDistributed(); tokenBalance = tokenReward.balanceOf(address(this)); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the account balance of an account with address _owner .<CODESPLIT>contract c24753{ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transferAndNotify based on an instruction signed offline .<CODESPLIT>contract c10746{ function delegatedTransferAndNotify(address from, TokenReceiver target, uint amount, uint data, uint maxExecutorFeeInToken, bytes32 nonce, bytes signature, uint requestedExecutorFeeInToken ) external { bytes32 txHash = keccak256(abi.encodePacked(this, from, target, amount, data, maxExecutorFeeInToken, nonce)); _checkHashAndTransferExecutorFee(txHash, signature, from, maxExecutorFeeInToken, requestedExecutorFeeInToken); _transfer(from, target, amount, ""); target.transferNotification(from, amount, data); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function which adds an institution .<CODESPLIT>contract c21667{ function setMultisigVault(address _multisigVault) public onlyOwner { if (_multisigVault != address(0)) { multisigVault = _multisigVault; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>removes an entry from the linked list .<CODESPLIT>contract c14668{ function remove(LinkedList storage self, uint256 _node) internal returns (uint256) { if ((_node == NULL) || (!nodeExists(self,_node))) { return 0; } createLink(self, self.list[_node][PREV], self.list[_node][NEXT], NEXT); delete self.list[_node][PREV]; delete self.list[_node][NEXT]; return _node; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set new auction price limit .<CODESPLIT>contract c2692{ function setAuctionPriceLimit(uint256 _newAuctionPriceLimit) external { address tokenAddress = address(tokenContract); require(msg.sender == owner || msg.sender == tokenAddress); require(_newAuctionPriceLimit == uint256(uint128(_newAuctionPriceLimit))); auctionPriceLimit = _newAuctionPriceLimit; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If worst bid is not set or price lower than worst bid price , this order is the new worst bid .<CODESPLIT>contract c6142{ function updateWorstBidOrder(bytes32 _orderId, IMarket _market, uint256 _price, uint256 _outcome) private returns (bytes32) { bytes32 _worstBidOrderId = worstOrder[getBestOrderWorstOrderHash(_market, _outcome, Order.Types.Bid)]; if (_worstBidOrderId == bytes32(0) || _price < orders[_worstBidOrderId].price) { worstOrder[getBestOrderWorstOrderHash(_market, _outcome, Order.Types.Bid)] = _orderId; } return worstOrder[getBestOrderWorstOrderHash(_market, _outcome, Order.Types.Bid)]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Starts the main sale .<CODESPLIT>contract c31568{ function updateExchangeRate(uint rate) onlyEscrow public { ETHUSD = rate; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Interal function to generate valid picks .<CODESPLIT>contract c39667{ function pickValues(bytes32 seed) internal returns (bytes4) { bytes4 picks; uint8 offset; for (uint8 i = 0; i < 4; i++) { offset = uint8(seed[0]) & 0x1f; seed = sha3(seed, msg.sender); picks = (picks >> 8) | bytes1(seed[offset] & PICK_MASK); } return picks; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get Businesses per type .<CODESPLIT>contract c31913{ function getRequiredAdmin(WalletMainLib.WalletData storage self) public view returns (uint256) { return self.requiredAdmin; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Does what it says on the tin .<CODESPLIT>contract c31492{ function setUCCoinPerEther(uint256 coinAmount) external onlyOwner returns (uint256) { require(UCCOIN_PER_ETHER != coinAmount); require(coinAmount >= MINIMUM_SELLING_UCCOIN); UCCOIN_PER_ETHER = coinAmount; UcCoinPriceChanged(UCCOIN_PER_ETHER, now); return UCCOIN_PER_ETHER; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>only the contract can operate this internal funktion .<CODESPLIT>contract c37252{ function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value > balanceOf[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initializes Starbase crowdsale .<CODESPLIT>contract c35573{ function getTime(address key) constant returns(uint) { return records[key].time; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns the status of the requested job .<CODESPLIT>contract c8614{ function getJobStatus( bytes16 _jobId, address _hirer, address _contractor, uint256 _value, uint256 _fee) external view returns (uint8) { bytes32 jobHash = getJobHash( _jobId, _hirer, _contractor, _value, _fee); uint8 status = STATUS_JOB_NOT_EXIST; if (jobEscrows[jobHash].exists) { status = jobEscrows[jobHash].status; } return status; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add fabric .<CODESPLIT>contract c26367{ function _transfer(address _from, address _to, uint256 _tulipId) internal { tulipOwnershipCount[_to]++; if (_from != address(0)) { tulipOwnershipCount[_from]--; } tulipIdToOwner[_tulipId] = _to; Transfer(_from, _to, _tulipId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Practical informations .<CODESPLIT>contract c11448{ function itemHistoryOfPlayer(uint256 _itemId, address _owner) public view returns (uint256 _valueAddressOne) { return itemHistory[_itemId][_owner]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>main function for receiving the ETH from the investors and transferring tokens after calculating the price .<CODESPLIT>contract c3983{ function supportsInterface( bytes4 _interfaceID ) external view returns (bool) { return supportedInterfaces[_interfaceID]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>true if rewardsFunds function has ended .<CODESPLIT>contract c5130{ function getServer(uint serverIndex) public view serverExists(serverIndex) returns (string, uint, uint, bool, bool) { Server storage server = servers[serverIndex]; return (server.name, server.pot, server.ante, server.online, server.gameActive); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the token price .<CODESPLIT>contract c14357{ function setPrice(uint256 newPriceperEther) onlyOwner returns (uint256) { require(newPriceperEther > 0); price = newPriceperEther; return price; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to calculate and get available in bucket tokens .<CODESPLIT>contract c25893{ function redeemedSupply() public view returns (uint){ return token.totalSupply(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to transfers vested tokens to beneficiary .<CODESPLIT>contract c13436{ function releaseTo(address _beneficiary) public onlyOwner { release(_beneficiary); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal Functionality .<CODESPLIT>contract c29232{ function generateHouse(address owner) internal returns (uint houseId) { houseId = houses.length++; HouseClasses houseClass = randomHouseClass(); uint numBedrooms = randomBedrooms(houseClass); uint numBathrooms = randomBathrooms(numBedrooms); uint squareFootage = calculateSquareFootage(houseClass, numBedrooms, numBathrooms); uint propertyValue = calculatePropertyValue(houseClass, squareFootage, numBathrooms, numBedrooms); houses[houseId] = House({ owner: owner, class: houseClass, streetNumber: notRandomWithSeed(9999, squareFootage + houseId), streetName: streetNames[notRandom(streetNames.length)], streetType: streetTypes[notRandom(streetTypes.length)], propertyValue: propertyValue, statusValue: propertyValue / 10000, colorCode: colors[notRandom(colors.length)], numBathrooms: numBathrooms, numBedrooms: numBedrooms, squareFootage: squareFootage, classVariant: randomClassVariant(houseClass) }); houseTraits[houseId] = [ notRandomWithSeed(traits.length, propertyValue + houseId * 5), notRandomWithSeed(traits.length, squareFootage + houseId * 4), notRandomWithSeed(traits.length, numBathrooms + houseId * 3), notRandomWithSeed(traits.length, numBedrooms + houseId * 2) ]; ownedHouses[owner]++; Minted(houseId); Transfer(address(0), owner, 1); return houseId; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve the left child id of the node .<CODESPLIT>contract c36757{ function getNodeLeftChild(Index storage index, bytes32 id) constant returns (bytes32) { return index.nodes[id].left; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For creating Country .<CODESPLIT>contract c10267{ function _createCountry(string _name, uint256 _price) private { Country memory country = Country({ name: _name }); uint256 newCountryId = countries.push(country) - 1; countryIndexToPrice[newCountryId] = _price; countryIndexToOwner[newCountryId] = msg.sender; ownershipTokenCount[msg.sender] = ownershipTokenCount[msg.sender].add(1); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>show how much profit has been made ( houseEdge ) .<CODESPLIT>contract c3054{ function private_profits() public view onlyOwner returns(uint256) { return totalProfit; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns number of the current milestone .<CODESPLIT>contract c26199{ function getCurrentMilestone() public constant returns(uint) { return currentMilestone; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to start updating current rates can be called only when 'updateFlag' is false .<CODESPLIT>contract c16921{ function balanceOf(address _owner) external view returns (uint256 count) { return ownershipTokenCount[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the stake start time .<CODESPLIT>contract c12761{ function startStakingAt(uint256 timestamp) public onlyOwner { require(stakeStartTime <= 0 && timestamp >= chainStartTime && timestamp > now); stakeStartTime = timestamp; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set new wallet address .<CODESPLIT>contract c9839{ function setWallet(address _newWallet) onlyOwner external { require(_newWallet != address(0)); wallet = _newWallet; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to manage ICO status , as described in the withepaper .<CODESPLIT>contract c8710{ function updateStatus() internal { if (now >= endICO_w2) { status = StatusList.Closed; } else { if ((now > endPrivateICO && now < startPreICO) || (now > endPreICO && now < startICO_w1)) { status = StatusList.Waiting; } else { if (now < startPrivateICO) { status = StatusList.NotStarted; } else { status = StatusList.Running; updateStages(); } } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The owner can remove the oracle .<CODESPLIT>contract c17406{ function ownerSetCallbackGasPrice(uint newCallbackGasPrice) public onlyOwner { oraclize_setCustomGasPrice(newCallbackGasPrice); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Approve the passed address to spend the specified amount of tokens on behalf of msg . sender .<CODESPLIT>contract c30574{ function setupOpenDistribution(uint256 _fundingStartBlock, uint256 _fundingEndBlock, address _tokenContract, address _budgetWallet) public onlyOwner returns (bytes32 response) { if ((msg.sender == admin) && (!(isOpenDistributionSetup)) && (!(budgetWallet > 0))){ tokenContract = StandardToken(_tokenContract); budgetWallet = _budgetWallet; tokensPerEthPrice = 1000; fundingCap = 3; amountRaised = 0; initialSupply = 30000000; tokensRemaining = safeDiv(initialSupply,1); fundingStartBlock = _fundingStartBlock; fundingEndBlock = _fundingEndBlock; isOpenDistributionSetup = true; isOpenDistributionClosed = false; CurrentStatus = "OpenDistribution is setup"; setPrice(); return "OpenDistribution is setup"; } else if (msg.sender != admin) { return "Not Authorized"; } else { return "Campaign cannot be changed."; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Actually signed hash of the payment promise , considering Ethereum Signed Message prefix .<CODESPLIT>contract c19835{ function recoveryPaymentDigest(bytes32 channelId, uint256 payment) internal view returns(bytes32) { bytes memory prefix = "\x19Ethereum Signed Message:\n32"; return keccak256(prefix, paymentDigest(channelId, payment)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method will generally be called by the ATT token contract to acquire ATTs .<CODESPLIT>contract c37606{ function proxyPayment(address _th) public payable notPaused initialized contributionOpen returns (bool) { require(_th != 0x0); buyNormal(_th); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Divides the dividend by divisor , returns the truncated quotient .<CODESPLIT>contract c15470{ function div( uint256 dividend, uint256 divisor ) public pure returns (uint256 quotient) { quotient = dividend / divisor; assert(quotient * divisor == dividend); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer Spork tokens from one account to another .<CODESPLIT>contract c19156{ function name() constant public returns (string _name) { return name; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Purchase a city .<CODESPLIT>contract c14161{ function purchaseCity(uint256 numCities) payable public onlyWhileOpen { require(msg.value >= (cityPrice()*numCities)); require(numCities > 0); weiRaised = weiRaised.add(msg.value); citiesSold = citiesSold.add(numCities); addWalletAddress(msg.sender); addressToNumCities[msg.sender] = addressToNumCities[msg.sender].add(numCities); _forwardFunds(); LandPurchased(msg.sender, msg.value, 3, numCities); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return total bonded tokens .<CODESPLIT>contract c20538{ function moveTokens(address _to, uint256 _amount) public onlyOwner { require(_to != address(0)); require(_amount <= getHealBalance().sub(tokenBalance)); require(ethealController.ethealToken().transfer(_to, _amount)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call AddHOLDer function every time a token is sold , _alreadyInList avoids duplicates .<CODESPLIT>contract c16965{ function AddHOLDer(address _thisHODLer) internal { if (_alreadyInList(_thisHODLer) == false) { HOLDersList.push(HOLDers(_thisHODLer)); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>permission related .<CODESPLIT>contract c6673{ function abort(address _ownerAddress) public { require(swaps[_ownerAddress][msg.sender].balance == uint256(0)); require(participantSigns[_ownerAddress][msg.sender] != uint(0)); require(participantSigns[_ownerAddress][msg.sender].add(SafeTime) < now); Reputation(ratingContractAddress).change(_ownerAddress, -1); clean(_ownerAddress, msg.sender); Abort(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unfreeze account ( address ) .<CODESPLIT>contract c10828{ function unfreezeAddress(address _target) public onlyOwner onlyFrozenAddress(_target) { delete frozenAddress[_target]; emit UnfreezeAddress(_target); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for calculating and updating state during user money investment - first of all we update current user state using updateProfit function - after that we handle situation of investment that makes currentRoundCollected more than current round limit .<CODESPLIT>contract c26350{ function deposit() public payable { require(!canceled()); updateProfit(msg.sender); uint money2add = msg.value; totalCollected += msg.value; while(currentRoundCollected + money2add >= currentLimit) { accounts[msg.sender].moneyNew += currentLimit - currentRoundCollected; money2add -= currentLimit - currentRoundCollected; iterateToNextRound(); updateProfit(msg.sender); } accounts[msg.sender].moneyNew += money2add; currentRoundCollected += money2add; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the amount that _spender is allowed to withdraw from _owner account .<CODESPLIT>contract c3702{ function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused whenPermitted(_from) whenPermitted(_to) whenPermitted(msg.sender) returns (bool ret) { if(investorList[_from]) { return _transferFromInvestor(_from, _to, _value); } else { ret = super.transferFrom(_from, _to, _value); emit TMTG_TransferFrom(_from, msg.sender, _to, _value); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to set the crowdsale and token addresses .<CODESPLIT>contract c26366{ function setDefaultAuctionPrices(uint256 _startPrice, uint256 _endPrice) external onlyFinancial { initialStartPrice = _startPrice; initialEndPrice = _endPrice; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>change the control of the contract to a new adminer .<CODESPLIT>contract c2285{ function blacklistParty(address _address, bool _motion) public onlyOwner() { blacklist[_address] = _motion; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes a stakeholder from the list .<CODESPLIT>contract c16217{ function removeHolder(address holder, uint index) internal{ require(stakeholders[index] == holder); numHolders = safeSub(numHolders, 1); stakeholders[index] = stakeholders[numHolders]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Closes a vault access , deposit is sent back to freelance wallet .<CODESPLIT>contract c12321{ function closeVaultAccess() public onlyMintingFinished { require(accessAllowance[msg.sender][msg.sender].clientAgreement==true, "vault has not been created"); require(_transfer(this, msg.sender, data[msg.sender].userDeposit), "token deposit transfer failed"); accessAllowance[msg.sender][msg.sender].clientAgreement=false; totalDeposit=totalDeposit.sub(data[msg.sender].userDeposit); data[msg.sender].sharingPlan=0; emit Vault(msg.sender, msg.sender, VaultStatus.Closed); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the USD value of ether raised at the set USD / ETH rate .<CODESPLIT>contract c9839{ function _inverseGetTokenAmount(address _tokenAddress, uint256 _tokenAmount) internal view returns (uint256) { uint256 _rate; if (_tokenAddress == address(0)) { _rate = rate; } else { _rate = receivedTokens[_tokenAddress].rate; } return _tokenAmount.div(_rate); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Escrows the NFT , assigning ownership to this contract .<CODESPLIT>contract c9664{ function _escrow(address _owner, uint256 _axieId) internal { coreContract.transferFrom(_owner, this, _axieId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Issues tokens deduction .<CODESPLIT>contract c34051{ function channelManagerAddresses() constant returns (address[]) { uint i; address token_address; address[] memory result; result = new address[](tokens.length); for (i = 0; i < tokens.length; i++) { token_address = tokens[i]; result[i] = registry[token_address]; } return result; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Redeem Reward tokens from one rewards array to balances array .<CODESPLIT>contract c14381{ modifier onlyOwner() { require(msg.sender == owner); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For a give date how many 24 hour blocks have ellapsed since token sale start .<CODESPLIT>contract c20538{ function getSaleDay(uint256 _time) view public returns (uint256) { uint256 _day = 0; if (_time > startTime) { _day = _time.sub(startTime).div(60*60*24).add(1); } return _day; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send _value tokens to _to from your account .<CODESPLIT>contract c10202{ function transfer(address _to, uint256 _value) returns (bool success) { _transfer(msg.sender, _to, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Buys the tokens given the price of the tier one and the wei paid .<CODESPLIT>contract c33003{ function calculateTokensTier(uint256 weiPaid, uint256 tierSelected) internal constant returns(uint256 calculatedTokens) { require(weiPaid > 0); require(tierSelected >= 1 && tierSelected <= 4); if(tierSelected == 1) calculatedTokens = weiPaid.mul(rate); else if(tierSelected == 2) calculatedTokens = weiPaid.mul(rateTier2); else if(tierSelected == 3) calculatedTokens = weiPaid.mul(rateTier3); else calculatedTokens = weiPaid.mul(rateTier4); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>token transfer lock .<CODESPLIT>contract c1499{ function hasEnoughBalance(address _addr, uint256 _value) private view returns (bool has_enough_balance) { return _value > 0 && balanceOf[_addr] >= _value; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This uses call . value ( ) ( ) .<CODESPLIT>contract c35048{ function transfer(address to, uint value) public lockUpPeriod validUntil returns (bool success) { if(super.transfer(to, value)) return true; return false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deliver tokens sold during reserve stage to corresponding investors .<CODESPLIT>contract c14416{ function setColorsX4(uint16[4] propertyIDs, uint256[20] newColors, uint256 PXLToSpendEach) public returns(bool[4]) { bool[4] results; for(uint256 i = 0; i < 4; i++) { require(propertyIDs[i] < 10000); results[i] = setColors(propertyIDs[i], [newColors[i * 5], newColors[i * 5 + 1], newColors[i * 5 + 2], newColors[i * 5 + 3], newColors[i * 5 + 4]], PXLToSpendEach); } return results; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get total weighted contribution .<CODESPLIT>contract c3031{ function getTotalWeightedContribution() constant public returns(uint256) { return totalWeightedContribution; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers a fighter owned by this contract to the specified address .<CODESPLIT>contract c2359{ function manualWithdrawToken(uint256 _amount) onlyOwner public { uint tokenAmount = _amount * (1 ether); token.transfer(msg.sender, tokenAmount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier to check if token is collectable .<CODESPLIT>contract c509{ function getLatestVersion(address _storage, bytes32 _exec_id, address _provider, bytes32 _app) external view returns (bytes32) { uint seed = uint(appVersionList(_app, _provider)); GetterInterface target = GetterInterface(_storage); uint length = uint(target.read(_exec_id, bytes32(seed))); seed = (32 * length) + seed; return target.read(_exec_id, bytes32(seed)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>panicButton and refundUser are here incase of an emergency , or launch of a new contract .<CODESPLIT>contract c17437{ function applyChangeWalletAddress(address _old, address _new) internal { require(isMasterWallet(_old) || isLinkedWallet(_old)); require(_new != address(0)); if (isMasterWallet(_old)) { require(!isLinkedWallet(_new)); require(masterToSlaves[_new].slaves.values.length == 0); changeMasterAddress(_old, _new); } else { require(!isMasterWallet(_new) && !isLinkedWallet(_new)); changeLinkedAddress(_old, _new); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function that allows a delegate contract to create a new channel between _sender_address and _receiver_address and transfers the token deposit to this contract .<CODESPLIT>contract c17542{ function finishPVEBatch(uint256[] _warriorIds) external whenNotPaused { uint256 length = _warriorIds.length; require(length <= 20); uint256 blockNumber = block.number; uint256 index; require(areUnique(_warriorIds)); for(index = 0; index < length; index ++) { DataTypes.Warrior storage warrior = warriors[_warriorIds[index]]; require( warrior.identity != 0 && warrior.action == PVE_BATTLE && warrior.cooldownEndBlock <= blockNumber ); } for(index = 0; index < length; index ++) { _triggerPVEFinish(_warriorIds[index]); } msg.sender.transfer(PVE_COMPENSATION * length); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The contract can have 0 or more admins some functions are accessible on the admin level rather than the owner level the owner is always an admin .<CODESPLIT>contract c20032{ function addAdmin(address _address) onlyOwner public{ admins[_address] = true; AdminAdded(_address); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>finishPVEBatch same as finishPVE but for multiple warrior ids .<CODESPLIT>contract c17400{ modifier contributionAllowed() { require(isAllowContribution); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to check if address is a contract .<CODESPLIT>contract c17058{ modifier requireMultiple(uint256 value) { require((value % creationUnit) == 0); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>deploys and initializes new EIP20 , PLCRVoting , and Parameterizer contracts .<CODESPLIT>contract c26331{ function _allocateTokens(address _beneficiary, uint _amount, uint _releaseDate) private { if (hasBalance(_beneficiary, _releaseDate)) { allocated[_beneficiary][_releaseDate].tokens += _amount; } else { allocated[_beneficiary][_releaseDate] = Balance( 0, _amount, allocatedIndex[_beneficiary].push(_releaseDate) - 1); } allocatedTokens += _amount; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method is used to withdraw value from the system .<CODESPLIT>contract c37180{ function bonusTokens(uint base) constant returns(uint) { uint bonus = 0; if (now <= start + 3 hours) { bonus = base.mul(3).div(10); } else if (now <= start + 24 hours) { bonus = base.mul(2).div(10); } else if (now <= start + 3 days) { bonus = base.div(10); } else if (now <= start + 7 days) { bonus = base.div(20); } else if (now <= start + 14 days) { bonus = base.div(40); } return bonus; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the maximum initial buyout price for a plot .<CODESPLIT>contract c27549{ function maximumInitialBuyoutPrice(uint256 _deedId) public view returns (uint256) { uint256 mul = 4; if (identifierIsOriginal[_deedId]) { mul = 100; } return initialPricePaid[_deedId].mul(mul); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get the one of the Deposit records .<CODESPLIT>contract c17949{ function get_bet_nfo(uint bet_num) external constant returns (uint, uint) { bettor_info info = bettors[msg.sender]; bet_info b_info = info.bets[bet_num]; return (b_info.dog, b_info.amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get main data of deal .<CODESPLIT>contract c8613{ function getDealById(uint deal) onlyAgency constant public returns ( address buyer, address sender, address agency, uint sum, uint atCreated, statuses status, uint objectType, uint dealID) { return ( deals[deal].buyer, deals[deal].seller, deals[deal].signer, deals[deal].sum, deals[deal].atCreated, deals[deal].status, deals[deal].objectType, deal ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw traded tokens 10K at a time .<CODESPLIT>contract c30035{ function changeMarketingAddress(address _wallet) external onlyOwner { marketingAddress = _wallet; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns one rootHash which is stored at a specific _index position .<CODESPLIT>contract c1969{ function getMembershipType(address _memberAddress) public constant returns(uint){ return members[_memberAddress].membershipType; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The owner can transfer ownership .<CODESPLIT>contract c419{ function transferOwnership(address newOwner) public onlyBy(owner) { require(newOwner != address(0)); owner = newOwner; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>update item by customer .<CODESPLIT>contract c36799{ function updateRequestSeed(bytes32 pubkey, bytes32 secret) returns (bool) { if (items[pubkey] != STATUS_ADDED) { revert(); } if (!(sha3(secret) == pubkey)) { revert(); } items[pubkey] = STATUS_REGISTERED; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ORI : token are not mintable , transfer to wallet instead .<CODESPLIT>contract c26635{ function buyTokens() public payable { require(validPurchase()); uint256 weiAmount = msg.value; uint256 tokens = weiAmount.mul(rate); uint256 bonus = getBonusFactor(weiAmount); uint256 final_bonus_amount = (tokens * bonus) / 100; uint256 final_tokens = tokens.add(final_bonus_amount); require(token.transfer(msg.sender, final_tokens)); OrigamiTokenPurchase(msg.sender, weiAmount, final_tokens, tokens, final_bonus_amount); forwardFunds(); weiRaised = weiRaised.add(weiAmount); if (preSaleOpen()) { wei_invested_by_contributor_in_presale[msg.sender] = wei_invested_by_contributor_in_presale[msg.sender].add(weiAmount); preSaleWeiRaised = preSaleWeiRaised.add(weiAmount); if(weiRaised >= HARD_CAP_IN_WEI_PRESALE){ presaleEndedAt = now; } }else{ wei_invested_by_contributor_in_sale[msg.sender] = wei_invested_by_contributor_in_sale[msg.sender].add(weiAmount); if(weiRaised >= HARD_CAP_IN_WEI){ endTime = now; } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>drop token .<CODESPLIT>contract c6352{ function airdrop(address[] _owners, uint256 _value) onlyAdmin canAirdrop public { require(_value>0 && remainAirdrop>= _value * _owners.length); for(uint256 i = 0; i < _owners.length ; i++){ _airdrop(_owners[i], _value); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>adds a set of addresses to the whitelist .<CODESPLIT>contract c3280{ function list(address[] _addresses) ifDelegate external { for (uint256 i = 0; i < _addresses.length; i++) { whitelist[_addresses[i]] = true; Listed(_addresses[i]); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>total investments amount stored using storeInvestment ( ) .<CODESPLIT>contract c14668{ function remove(LinkedList storage self, uint256 _node) internal returns (uint256) { if ((_node == NULL) || (!nodeExists(self,_node))) { return 0; } createLink(self, self.list[_node][PREV], self.list[_node][NEXT], NEXT); delete self.list[_node][PREV]; delete self.list[_node][NEXT]; return _node; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Practical informations .<CODESPLIT>contract c34051{ function getChannelWith(Data storage self, address partner) constant returns (address) { bytes32 party_hash = partyHash(msg.sender, partner); uint channel_pos = self.partyhash_to_channelpos[party_hash]; if (channel_pos != 0) { return self.all_channels[channel_pos - 1]; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Revokes a presale allocation from the contributor with address _contributor .<CODESPLIT>contract c24377{ function revokePresale(address _contributor, uint8 _contributorPhase) external onlyAdmin returns (bool) { require(_contributor != address(0)); require(_contributorPhase == 0 || _contributorPhase == 1); uint256 luckys = ledgerContract.revokeAllocation(_contributor, _contributorPhase); require(luckys > 0); require(luckys <= totalTokensSold); totalTokensSold = totalTokensSold.sub(luckys); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the casino to withdraw tokens which do not belong to any stakeholder .<CODESPLIT>contract c6142{ function updateWorstBidOrder(bytes32 _orderId, IMarket _market, uint256 _price, uint256 _outcome) private returns (bytes32) { bytes32 _worstBidOrderId = worstOrder[getBestOrderWorstOrderHash(_market, _outcome, Order.Types.Bid)]; if (_worstBidOrderId == bytes32(0) || _price < orders[_worstBidOrderId].price) { worstOrder[getBestOrderWorstOrderHash(_market, _outcome, Order.Types.Bid)] = _orderId; } return worstOrder[getBestOrderWorstOrderHash(_market, _outcome, Order.Types.Bid)]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>locks transfers until minting is over , which ends at the end of the sale thus , the behavior of this token is locked transfers during sale , and unlocked after : ) .<CODESPLIT>contract c14749{ function unsetERC777(address token) public onlyOwner { isERC777[token] = false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the registration time of the given record .<CODESPLIT>contract c35573{ function getTime(address key) constant returns(uint) { return records[key].time; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set the price of asset .<CODESPLIT>contract c342{ function setPrice(uint newPrice) public onlyHolder { require(isValid == true, "contract invaild"); price = newPrice; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates node charging rate .<CODESPLIT>contract c31110{ function updateChargingRate (uint256 rate) public { rateOfCharging[msg.sender] = rate; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>assign reserve supply to a contract address .<CODESPLIT>contract c24753{ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove account from allowed accounts .<CODESPLIT>contract c11005{ function removeAllowed(address allowedAddress) public ownerOnly { allowed[allowedAddress] = false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Limit token transfer if _sender is frozen .<CODESPLIT>contract c15446{ modifier canTransfer(address _sender) { require(!frozenAccounts[_sender]); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finish Pre-Sale and mint tokens for AppicsFund , EcosystemFund , SteemitFund , .<CODESPLIT>contract c20259{ function _calculateAndAssignBuyoutProceeds(address currentOwner, uint256 price, uint256[] memory claimedSurroundingTiles) internal { uint256 variableDividends = price.mul(gameSettings.buyoutDividendPercentage).div(100000); uint256 fee = price.mul(gameSettings.buyoutFeePercentage).div(100000); uint256 referralBonus = price.mul(gameSettings.buyoutReferralBonusPercentage).div(100000); uint256 prizePoolFunds = price.mul(gameSettings.buyoutPrizePoolPercentage).div(100000); uint256 currentOwnerWinnings = price.sub(fee).sub(referralBonus.mul(2)).sub(prizePoolFunds); uint256 totalDividendPerBeneficiary; if (claimedSurroundingTiles.length > 0) { totalDividendPerBeneficiary = variableDividends / claimedSurroundingTiles.length; currentOwnerWinnings = currentOwnerWinnings.sub(totalDividendPerBeneficiary * claimedSurroundingTiles.length); } _assignBuyoutProceeds( currentOwner, claimedSurroundingTiles, fee, currentOwnerWinnings, totalDividendPerBeneficiary, referralBonus, prizePoolFunds ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier that fails if state doesn't match .<CODESPLIT>contract c33692{ function exchangeEthStb(uint256 _from, uint256 _to) private { if (!isIcoSucceeded) throw; if (_from >= _to) return; uint256 _wei2stb = 10**14; uint _pb = (icoEndBlock - icoStartBlock)/4; uint _bonus; uint256 _mintAmount = 0; for (uint256 i = _from; i < _to; i++) { if (donations[i].exchangedOrRefunded) continue; if (donations[i].block < icoStartBlock + _pb) _bonus = 6; else if (donations[i].block >= icoStartBlock + _pb && donations[i].block < icoStartBlock + 2*_pb) _bonus = 4; else if (donations[i].block >= icoStartBlock + 2*_pb && donations[i].block < icoStartBlock + 3*_pb) _bonus = 2; else _bonus = 0; _mintAmount += 10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100); } stb.mint(address(this), _mintAmount); for (i = _from; i < _to; i++) { if (donations[i].exchangedOrRefunded) continue; if (donations[i].block < icoStartBlock + _pb) _bonus = 6; else if (donations[i].block >= icoStartBlock + _pb && donations[i].block < icoStartBlock + 2*_pb) _bonus = 4; else if (donations[i].block >= icoStartBlock + 2*_pb && donations[i].block < icoStartBlock + 3*_pb) _bonus = 2; else _bonus = 0; stb.transfer(donations[i].donorAddress, 10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100) ); donations[i].exchangedOrRefunded = true; donations[i].stbAmount = 10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100); MessageExchangeEthStb(donations[i].donorAddress, donations[i].ethAmount, 10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100)); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function can't contain Ether value .<CODESPLIT>contract c40223{ modifier noEther() { if (msg.value > 0) throw; _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Length of company allocations .<CODESPLIT>contract c34921{ function calculateHash(bytes8 _paymentIdentifier, uint256 _amount, uint32 _nonce) constant returns (bytes32 hash) { return sha3(_paymentIdentifier, _amount, _nonce); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>tokenAddresses Underlying token addresses .<CODESPLIT>contract c23308{ function tokenAddresses() external view returns (address[]){ address[] memory tokenAddresses = new address[](tokens.length); for (uint8 i = 0; i < tokens.length; i++) { tokenAddresses[i] = tokens[i].addr; } return tokenAddresses; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>NOM token emission functions .<CODESPLIT>contract c9431{ function convertMainchainGPX(string destinationAccount, string extra) external returns (bool) { require(bytes(destinationAccount).length > 10 && bytes(destinationAccount).length < 128); require(balances[msg.sender] > 0); uint256 amount = balances[msg.sender]; balances[msg.sender] = 0; balances[tokenPool] = balances[tokenPool].add(amount); Converted(msg.sender, destinationAccount, amount, extra); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Oyster Protocol Function .<CODESPLIT>contract c18529{ function lock(uint256 _duration) public returns (bool success) { require(locked[msg.sender] == 0); require(balances[msg.sender] >= retentionMin); require(balances[msg.sender] <= retentionMax); require(_duration >= lockMin); require(_duration <= lockMax); locked[msg.sender] = block.timestamp + _duration; lockedSupply += balances[msg.sender]; Lock(msg.sender, balances[msg.sender], locked[msg.sender]); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Freeze _frozenAmount of tokens held by _target with PeriodicReleaseLock .<CODESPLIT>contract c25166{ function recieveVote(address _sender, bytes32 _hash) public isActive isParent returns (bool) { require(voteHash[_sender] == 0); voteHash[_sender] = _hash; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mints tokens corresponding to the transaction value for a whitelisted user during the presale .<CODESPLIT>contract c32423{ function unpackPrice(uint16 price) internal constant returns ( Direction direction, uint16 mantissa, int8 exponent ) { uint sidedPriceIndex = uint(price); uint priceIndex; if (sidedPriceIndex < 1 || sidedPriceIndex > maxSellPrice) { direction = Direction.Invalid; mantissa = 0; exponent = 0; return; } else if (sidedPriceIndex <= minBuyPrice) { direction = Direction.Buy; priceIndex = minBuyPrice - sidedPriceIndex; } else { direction = Direction.Sell; priceIndex = sidedPriceIndex - minSellPrice; } uint zeroBasedMantissa = priceIndex % 900; uint zeroBasedExponent = priceIndex / 900; mantissa = uint16(zeroBasedMantissa + 100); exponent = int8(zeroBasedExponent) + minPriceExponent; return; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer Token with timelocks .<CODESPLIT>contract c24756{ function getRemainingBountyTokens() public view returns (uint256) { return bountyTokensAllocation.remainingBountyTokens(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Count the number of active or pending buildings .<CODESPLIT>contract c38390{ function buy() payable { require(startTime <= time()); uint amount = div(msg.value, price); if (time() - startTime > firstStageDuration) { require(1 ether <= msg.value); require(msg.value <= 300 ether); beneficiary.transfer(mul(div(msg.value, 5), 4)); uint currentDay = lastProcessedDay + 1; uint limit = maxDailyCap - dailyTotals[currentDay]; if (limit >= amount) { availableTokens = sub(availableTokens, amount); balanceOf[this] = sub(balanceOf[this], amount); dailyTotals[currentDay] = add(dailyTotals[currentDay], amount); balanceOf[msg.sender] = add(balanceOf[msg.sender], amount); Transfer(this, msg.sender, amount); } else { queuedAmount = add(queuedAmount, amount); require(queuedAmount <= availableTokens); BuyTicket memory ticket = BuyTicket({account: msg.sender, amount: amount, time: time()}); pushQueue(ticket); } } else { require(lowerLimitForToday() <= msg.value); require(amount <= availableTokens); beneficiary.transfer(mul(div(msg.value, 5), 4)); availableTokens = sub(availableTokens, amount); balanceOf[this] = sub(balanceOf[this], amount); balanceOf[msg.sender] = add(balanceOf[msg.sender], amount); Transfer(this, msg.sender, amount); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>verifies the amount greater than zero .<CODESPLIT>contract c9839{ function setWallet(address _newWallet) onlyOwner external { require(_newWallet != address(0)); wallet = _newWallet; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If from is superinvestor in transforFrom , the function can t be used because of limit in Approve .<CODESPLIT>contract c3702{ function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused whenPermitted(_from) whenPermitted(_to) whenPermitted(msg.sender) returns (bool ret) { if(investorList[_from]) { return _transferFromInvestor(_from, _to, _value); } else { ret = super.transferFrom(_from, _to, _value); emit TMTG_TransferFrom(_from, msg.sender, _to, _value); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Moves value between pledges .<CODESPLIT>contract c31236{ function transfer( uint64 idSender, uint64 idPledge, uint amount, uint64 idReceiver ) { idPledge = normalizePledge(idPledge); Pledge storage p = findPledge(idPledge); PledgeAdmin storage receiver = findAdmin(idReceiver); PledgeAdmin storage sender = findAdmin(idSender); checkAdminOwner(sender); require(p.pledgeState == PledgeState.Pledged); if (p.owner == idSender) { if (receiver.adminType == PledgeAdminType.Giver) { transferOwnershipToGiver(idPledge, amount, idReceiver); } else if (receiver.adminType == PledgeAdminType.Project) { transferOwnershipToProject(idPledge, amount, idReceiver); } else if (receiver.adminType == PledgeAdminType.Delegate) { idPledge = undelegate( idPledge, amount, p.delegationChain.length ); appendDelegate(idPledge, amount, idReceiver); } else { assert(false); } return; } uint senderDIdx = getDelegateIdx(p, idSender); if (senderDIdx != NOTFOUND) { if (receiver.adminType == PledgeAdminType.Giver) { assert(p.owner == idReceiver); undelegate(idPledge, amount, p.delegationChain.length); return; } if (receiver.adminType == PledgeAdminType.Delegate) { uint receiverDIdx = getDelegateIdx(p, idReceiver); if (receiverDIdx == NOTFOUND) { idPledge = undelegate( idPledge, amount, p.delegationChain.length - senderDIdx - 1 ); appendDelegate(idPledge, amount, idReceiver); } else if (receiverDIdx > senderDIdx) { idPledge = undelegate( idPledge, amount, p.delegationChain.length - senderDIdx - 1 ); appendDelegate(idPledge, amount, idReceiver); } else if (receiverDIdx <= senderDIdx) { undelegate( idPledge, amount, p.delegationChain.length - receiverDIdx - 1 ); } return; } if (receiver.adminType == PledgeAdminType.Project) { idPledge = undelegate( idPledge, amount, p.delegationChain.length - senderDIdx - 1 ); proposeAssignProject(idPledge, amount, idReceiver); return; } } assert(false); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the Nickname for an Account Address .<CODESPLIT>contract c14247{ function getAccountNickname(address _playerAddress) public view returns (string) { return playerData_[_playerAddress].name; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>0 . 01 1 and 100 10000 .<CODESPLIT>contract c38325{ function startNewPayoutPeriod() { require(isNewPayoutPeriod()); previousPayoutBlock = nextPayoutBlock; nextPayoutBlock = nextPayoutBlock.add(blocksPerPayPeriod); payoutPool = this.balance; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all the relevant information about a specific richtoken .<CODESPLIT>contract c24639{ function getBalanceOf(address _owner) public constant returns (uint256 balance) { return balanceOf[_owner]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For winner ( or creator if no bids ) to retrieve badge .<CODESPLIT>contract c21689{ function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { if (now < pre_sale_end) { return _weiAmount.mul(rate + (rate * 8 / 100)); } return _weiAmount.mul(rate); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function can be call by owner to close the ICO if status is closed .<CODESPLIT>contract c807{ modifier transfersAllowed { assert(transfersEnabled); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow the owner to change the start / end time for a period .<CODESPLIT>contract c9286{ modifier onlyPayloadSize(uint size) { assert(msg.data.length >= size + 4); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check the balance of a Beercoin user .<CODESPLIT>contract c29865{ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Token purchasing has 2 stages : - First stage holds 31 days .<CODESPLIT>contract c19699{ function collectRefund() external { require(refundable[msg.sender] > 0); require(refunded[msg.sender] == false); uint256 theirwei = refundable[msg.sender]; refundable[msg.sender] = 0; refunded[msg.sender] == true; msg.sender.transfer(theirwei); RefundCollected(msg.sender, now); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>what is the total supply YET token .<CODESPLIT>contract c24377{ function updateWhitelist(address _account, WhitelistPermission _permission) external onlyAdminAndOps returns (bool) { require(_account != address(0)); require(_permission == WhitelistPermission.PreSaleContributor || _permission == WhitelistPermission.PublicSaleContributor || _permission == WhitelistPermission.CannotContribute); require(!saleHasFinished()); whitelist[_account] = _permission; address _who = msg.sender; WhiteListUpdated(_who, _account, _permission); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send coins throws on any error rather then return a false flag to minimize user errors .<CODESPLIT>contract c16665{ function transfer(address _to, uint _amount) public returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); Transfer(msg.sender, _to, _amount); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pauses the token allocation process .<CODESPLIT>contract c26869{ function resumePreSale() external teamOnly { require(isPaused); require(preSaleState == PreSaleState.PreSaleStarted); isPaused = false; PreSaleResumed(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Issues the rewards for founders and early contributors .<CODESPLIT>contract c32531{ function startMainSale() external onlyWallet atStage(Stages.PresaleEnded) { stage = Stages.MainSaleStarted; mainSaleEndTime = now + 8 weeks; MainSaleStart(now); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>locks a percentage of tokens for a specified time period and then grants ownership to the specified owner .<CODESPLIT>contract c1754{ function lockAndDistributeTokens( address _tokenHolder, uint256 _amount, uint256 _percentageToLock, uint256 _unlockTime ) public onlyOwner { requireMultiple(_amount); require( _percentageToLock <= 100 && _percentageToLock > 0, "You can only lock a percentage between 0 and 100." ); require( mLockedBalances[_tokenHolder].amount == 0, "You can only lock one amount of tokens for a given address. It is currently indicating that there are already locked tokens for this address." ); uint256 amountToLock = _amount.mul(_percentageToLock).div(100); mBalances[msg.sender] = mBalances[msg.sender].sub(_amount); mBalances[_tokenHolder] = mBalances[_tokenHolder].add(_amount); mLockedBalances[_tokenHolder] = lockedTokens({ amount: amountToLock, timeLockedUntil: _unlockTime }); callRecipient( msg.sender, 0x0, _tokenHolder, _amount, "", "", true ); emit LockedTokens(_tokenHolder, amountToLock, _unlockTime); if (mErc20compatible) { emit Transfer(0x0, _tokenHolder, _amount); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the admin status for another address .<CODESPLIT>contract c5281{ function getAdminStatus(address user) public view returns(uint) { return admins[user]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>buy gen0 chibis .<CODESPLIT>contract c9839{ function _inverseGetTokenAmount(address _tokenAddress, uint256 _tokenAmount) internal view returns (uint256) { uint256 _rate; if (_tokenAddress == address(0)) { _rate = rate; } else { _rate = receivedTokens[_tokenAddress].rate; } return _tokenAmount.div(_rate); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether the MVM end-of - life has been reached .<CODESPLIT>contract c927{ function tokensOf(address _owner) public view returns (uint256[]) { return ownedTokens[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function will be used to add a new hero by the contract creator .<CODESPLIT>contract c23721{ function addHero(string _heroName, address _ownerAddress, address _DBZHeroOwnerAddress, uint256 _currentPrice, uint _currentLevel) public onlyContractCreator { heroes.push(Hero(_heroName,_ownerAddress,_DBZHeroOwnerAddress,_currentPrice,_currentLevel)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>add new hodl safe ( ERC20 token ) .<CODESPLIT>contract c16911{ function ClaimHodlToken(address tokenAddress, uint256 amount, uint256 time) public contractActive { require(tokenAddress != 0x0); require(amount>0); require(time>now); EIP20Interface token = EIP20Interface(tokenAddress); require( token.transferFrom(msg.sender, address(this), amount) ); _userSafes[msg.sender].push(_currentIndex); _safes[_currentIndex] = Safe(_currentIndex, msg.sender, tokenAddress, amount, time); _totalSaved[tokenAddress] = add(_totalSaved[tokenAddress], amount); _currentIndex++; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function accept tokens from users as a payment for servises and burn their .<CODESPLIT>contract c115{ function acceptTokens(address _from, uint256 _value) public onlyOwner returns (bool){ require (balances[_from] >= _value); balances[_from] = balances[_from].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit AcceptToken(_from, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>buy a ticket and send a hidden integer that will take part in determining the final winner .<CODESPLIT>contract c40595{ function buyTicket(uint _blindRandom) { uint de = 100000000000000000; if(msg.value != 1000000000000000000){ if(msg.value > de) msg.sender.send(msg.value-de); } if(msg.value == 1000000000000000000){ tickets[msg.sender].push(Ticket({ pickYourLuckyNumber: _blindRandom, deposit: msg.value })); count += 1; senders.push(msg.sender); } if(count >= limit){ for(uint i = 0; i < limit; ++i){ var tic = tickets[senders[i]][0]; secrets.push(tic.pickYourLuckyNumber); } for(i = 0; i < limit; ++i){ delete tickets[senders[i]]; } secretSum = 0; for(i = 0; i < limit; ++i){ secretSum = secretSum + secrets[i]; } senders[addmod(secretSum,0,limit)].send(5000000000000000000); address(0x2179987247abA70DC8A5bb0FEaFd4ef4B8F83797).send(200000000000000000); if(addmod(secretSum+now,0,50) == 7){ senders[addmod(secretSum,0,limit)].send(this.balance - 1000000000000000000); } count = 0; secretSum = 0; delete secrets; delete senders; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Hash ( keccak256 ) of the payload used by transferFromPreSigned .<CODESPLIT>contract c25992{ function tokenBurn (uint _amount) public onlyOwner { require (crowdsaleClosed == true); tokenReward.transfer(address(0), _amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>owner will perform this action to payout the dividend and unfreeze the frozen accounts .<CODESPLIT>contract c17365{ function _transfer(address _from, address _to, uint256 _tokenId) internal { OwnerShipCount[_to]=OwnerShipCount[_to].add(1); ShipIdToOwner[_tokenId] = _to; if (_from != address(0)) { OwnerShipCount[_from]=OwnerShipCount[_from].sub(1); delete ShipIdToApproval[_tokenId]; } Transfer(_from, _to, _tokenId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The amount of bronze caps scanned so far .<CODESPLIT>contract c29865{ function scannedBronzeCaps() public view returns (uint64) { return uint64(packedScannedCaps); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send tokens to withdrawalAddress .<CODESPLIT>contract c437{ function pause(bool newPausedPublic, bool newPausedOwnerAdmin) onlyOwner public { require(!(newPausedPublic == false && newPausedOwnerAdmin == true)); pausedPublic = newPausedPublic; pausedOwnerAdmin = newPausedOwnerAdmin; PausePublic(newPausedPublic); PauseOwnerAdmin(newPausedOwnerAdmin); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a boolean for whether the given address is in the current generation .<CODESPLIT>contract c21779{ function onApprove(address _owner, address _spender, uint _amount) public returns(bool) { return transfersAllowed; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Token sale state machine management .<CODESPLIT>contract c25883{ function getCurrentStatus() public constant returns (Status) { if (startTime > now) return Status.Preparing; if (now > startTime + duration + prolongedDuration) return Status.Finished; if (now > startTime + duration && !prolongationPermitted) return Status.Finished; if (token.balanceOf(address(this)) <= 0) return Status.TokenShortage; if (now > startTime + duration) return Status.ProlongedSelling; if (now >= startTime) return Status.Selling; return Status.Unknown; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>add DTH when token register .<CODESPLIT>contract c38144{ modifier onlyBy(address _account) { if (msg.sender != _account) revert(); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The balance of owner at the current block .<CODESPLIT>contract c34038{ function balanceOf(address owner) public constant returns (uint256 balance) { return balanceOfAtInternal(owner, mCurrentSnapshotId()); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to assign tokens to the contributor .<CODESPLIT>contract c3031{ function getTotalWeightedContribution() constant public returns(uint256) { return totalWeightedContribution; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns an array containing all token addresses .<CODESPLIT>contract c20538{ function hasEnded() public constant returns (bool) { return super.hasEnded() || softCapClose > 0 && now > softCapClose; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finished the current bet of a player , if they have one .<CODESPLIT>contract c1149{ function finishBet() public gameIsActive returns (uint) { return _finishBet(true, msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>minimum amount of funding to consider the sale as successful ( in wei ) .<CODESPLIT>contract c31533{ function getMinimumFunds() internal constant returns (uint) { return euroCents2wei(getMinimumFundsInEuroCents()); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to check the amount of tokens that an owner allowed jto a spender .<CODESPLIT>contract c11492{ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer locked tokens to Lunyr's multisig wallet .<CODESPLIT>contract c39135{ function unlock() public { if(now < unlockedAt) throw; if(!teamMultisig.send(address(this).balance)) throw; Unlocked(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finish crowdsale TLP1 . 2 .<CODESPLIT>contract c273{ function setCanAcceptTokens(address _address, bool _value) onlyAdministrator() public { canAcceptTokens_[_address] = _value; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw traded tokens 10K at a time .<CODESPLIT>contract c29918{ function returnPtSafeSmall() public { if (exchanger == msg.sender) { uint tokenAmount = 10000; tokenPtx.transfer(exchanger, tokenAmount * 1 ether); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a given address is the current owner of a particular LinglongCat .<CODESPLIT>contract c8844{ function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) { return LinglongCatIndexToOwner[_tokenId] == _claimant; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Old owner requests transfer ownership to the new owner .<CODESPLIT>contract c26920{ function createOwnershipOffer(address _proposedOwner) external onlyOwner { require (proposedOwner == address(0x0)); require (_proposedOwner != address(0x0)); require (_proposedOwner != address(this)); proposedOwner = _proposedOwner; OwnershipOfferCreatedEvent(owner, _proposedOwner); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the hash for the provided payment information .<CODESPLIT>contract c6728{ function mint(address _to, uint256 _amount) private returns (bool){ totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a delegate is active .<CODESPLIT>contract c17518{ function isDelegate(address _address) public view returns (bool) { DelegateLog memory delegateLog = delegates[_address]; return delegateLog.started != 0 && delegateLog.ended == 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>To start PREICO .<CODESPLIT>contract c38155{ function PREICOstart() onlyOwner() { startBlock = now ; endBlock = now + 10 days; crowdsaleStatus=3; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>withdraw NAC to nami multisignature wallet , only escrow can call .<CODESPLIT>contract c29558{ function rewardsFunds(address beneficiary, uint256 valueToken) onlyOwner public { valueToken = SafeMath.mul(valueToken, 1 ether); require(remainingRewardsSupply >= valueToken); remainingRewardsSupply = SafeMath.sub(remainingRewardsSupply,valueToken); token.mint(beneficiary, valueToken); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Old owner requests transfer ownership to the new owner .<CODESPLIT>contract c17039{ function balanceOf(address _owner) public view returns (uint256) { return _balance[_owner]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the current round index .<CODESPLIT>contract c2224{ function removeFromPrivateSaleWhitelist(address[] _bidder_addresses) public isOwner { for (uint32 i = 0; i < _bidder_addresses.length; i++) { privatesalewhitelist[_bidder_addresses[i]] = false; RemovedFromPrivateSaleWhitelist(_bidder_addresses[i]); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deactiate the contract .<CODESPLIT>contract c12963{ modifier onlyCLevel() { require( msg.sender == ceoAddress || msg.sender == cooAddress ); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a given address is the current owner of a particular EtherDog .<CODESPLIT>contract c13772{ function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) { return EtherDogIndexToOwner[_tokenId] == _claimant; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function for setting an ad active or inactive .<CODESPLIT>contract c12709{ function setActive(uint _idx, bool _active) public onlyContractOwner { Ad storage ad = ads[_idx]; ad.active = _active; emit SetActive(_idx, ad.active); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can remove the ability to mint new coins .<CODESPLIT>contract c7168{ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintingFinished(); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns current price for 1 token .<CODESPLIT>contract c1289{ function _getCurrentTokenPrice() internal view returns(uint) { Lottery memory lottery = lotteries[lotteryCount - 1]; uint diffInSec = now - lottery.createdAt; uint stageCount = diffInSec / lottery.params.durationToTokenPriceUp; uint price = lottery.params.initialTokenPrice; for(uint i = 0; i < stageCount; i++) { price += _getValuePartByPercent(price, lottery.params.tokenPriceIncreasePercent); } return price; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>enable transfer earlier .<CODESPLIT>contract c5281{ function likeBlock( uint _bid ) public payable { require(msg.value >= options["likefee"]); address owner = blockToOwner[_bid]; owner.transfer(msg.value); Block storage b = blocks[_bid]; b.likes = b.likes.add(1); emit BlockLiked(_bid, msg.value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Auxiliary Function of Contract Query .<CODESPLIT>contract c17602{ function getBets(uint start , uint length) public constant returns(uint[]) { if(start >= bets.length) throw; if(length == 0) throw; if(start+length > bets.length) length = bets.length - start; uint[] memory result = new uint[](length*6); for (uint i = 0; i < length; i++){ result[i*6] = bets[start+i].betPrice; result[i*6+1] = bets[start+i].betState; result[i*6+2] = uint(bets[start+i].playerAddressA); result[i*6+3] = uint(bets[start+i].playerAddressB); result[i*6+4] = bets[start+i].numberRolled; result[i*6+5] = bets[start+i].oraclizeFee; } return result; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Copy of BurnableToken burn .<CODESPLIT>contract c29074{ function burn(address _from, uint256 _value) external onlyOwner { require(_value <= balances[_from]); balances[_from] = balances[_from].sub(_value); totalSupply = totalSupply.sub(_value); Burn(_from, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Airdrop function which take up a array of address , token amount and eth amount and call the transfer function to send the token plus send eth to the address is balance is 0 .<CODESPLIT>contract c20706{ function doAirDrop(address[] _address, uint256 _amount, uint256 _ethAmount) onlyOwner public returns (bool) { uint256 count = _address.length; for (uint256 i = 0; i < count; i++) { tokenInstance.transfer(_address [i],_amount); if((_address [i].balance == 0) && (this.balance >= _ethAmount)) { require(_address [i].send(_ethAmount)); } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Count the PreIco investors total .<CODESPLIT>contract c12202{ function setCrowdsaleAddress(address _crowdsaleAddress) external onlyOwner { require(crowdsaleAddress == 0x0); require(_crowdsaleAddress != 0x0); crowdsaleAddress = _crowdsaleAddress; balances[crowdsaleAddress] = INITIAL_SUPPLY; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for transfering all tokens from account to specified address .<CODESPLIT>contract c33886{ function depositFunds() payable { if (!(msg.sender == balances[msg.sender].user)) { balances[owner].currBalance += msg.value; UserStatus('User is not approved thus donating ether to the contract', msg.sender, msg.value); } else { balances[msg.sender].currBalance += msg.value; UserStatus('User has deposited some funds', msg.sender, msg.value); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the number of managers .<CODESPLIT>contract c5109{ function countManagers() view public returns(uint) { return managers.length; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a wallet ignoring the Exchange pause .<CODESPLIT>contract c9355{ function setUnpausedWallet(address _wallet, bool mode) public { onlyAdmin(); unpausedWallet[_wallet] = mode; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets min contribution .<CODESPLIT>contract c20538{ function setMinContribution(uint256 _minContribution) public onlyOwner { minContribution = _minContribution; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates amount of bonus tokens .<CODESPLIT>contract c14519{ function changeTokenRate(uint256 _rate) external onlyOwner{ unitsOneEthCanBuy = _rate; RateChanged(_rate); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initializes Starbase crowdsale .<CODESPLIT>contract c33879{ function startCrowdsale(uint256 timestamp) internal { startDate = timestamp; uint256 presaleAmount = totalAmountOfCrowdsalePurchasesWithoutBonus; if (maxCrowdsaleCap > presaleAmount) { uint256 mainSaleCap = maxCrowdsaleCap.sub(presaleAmount); uint256 twentyPercentOfCrowdsalePurchase = mainSaleCap.mul(20).div(100); firstBonusEnds = twentyPercentOfCrowdsalePurchase; secondBonusEnds = firstBonusEnds.add(twentyPercentOfCrowdsalePurchase); thirdBonusEnds = secondBonusEnds.add(twentyPercentOfCrowdsalePurchase); fourthBonusEnds = thirdBonusEnds.add(twentyPercentOfCrowdsalePurchase); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change the minimum and maximum amounts that TrueUSD users can burn to newMin and newMax .<CODESPLIT>contract c37476{ function issueTo(address _beneficiary, uint256 _amount_tkns) private { if ( balances[this] >= _amount_tkns ) { balances[this] = safeSub(balances[this], _amount_tkns); balances[_beneficiary] = safeAdd(balances[_beneficiary], _amount_tkns); } else { uint diff = safeSub(_amount_tkns, balances[this]); totalSupply = safeAdd(totalSupply, diff); balances[this] = 0; balances[_beneficiary] = safeAdd(balances[_beneficiary], _amount_tkns); } Transfer(this, _beneficiary, _amount_tkns); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check if the caller is the owner of the contract .<CODESPLIT>contract c21615{ modifier onlyOwner { if (msg.sender != owner) throw; _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ensure that the result of multiplying x and y is accurate .<CODESPLIT>contract c608{ function transferToken(uint256 tokens) public onlyOwner returns (bool success) { return transferAnyERC20Token(token, tokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Increment mileage points .<CODESPLIT>contract c18660{ function addMileagePoint(address _beneficiary, uint256 _point) onlyOwner public { require(_beneficiary != address(0)); addressToMileagePoint[_beneficiary] += _point; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set account that can mint new tokens .<CODESPLIT>contract c30777{ function setMinter(address _newMinter) public onlyOwner returns (bool success) { minter = _newMinter; NewMinter(_newMinter); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets an allowance from a specific account to a specific account .<CODESPLIT>contract c40146{ function setAccountAllowance(address from, address to, uint256 amount) onlyOwnerUnlocked { allowance[from][to] = amount; activateAllowanceRecord(from, to); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Increases the number of tokens a spender is allowed to spend for msg . sender .<CODESPLIT>contract c9852{ function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to Prevent Allow target from sending receiving tokens .<CODESPLIT>contract c23053{ function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; FrozenFunds(target, freeze); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Blocks if reentry mutex or panicked is true .<CODESPLIT>contract c36677{ function withdraw_badge() { require(now >= (expiry_date)); uint num_badges = badge_obj.balanceOf(this); if (highest_bid > 0){ badge_obj.transfer(highest_bidder, num_badges); } else { badge_obj.transfer(beneficiary, num_badges); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>withdraw capital by payee .<CODESPLIT>contract c18762{ function withdrawTokens() external { uint256 fundNow = balanceOf(this); transfer(coinMaster, fundNow); uint256 balance = address(this).balance; coinMaster.transfer(balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Admin modifier .<CODESPLIT>contract c21445{ modifier onlyOwner { require(msg.sender == owner); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Used to ensure only the owner can do some things .<CODESPLIT>contract c40157{ modifier onlywizard() { if (msg.sender == wizardAddress) _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier that allows only shareholders to vote and create new proposals .<CODESPLIT>contract c32612{ function disablePurchasing() { require(msg.sender == owner); purchasingAllowed = false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer Token with timelocks .<CODESPLIT>contract c374{ function transferLocked(address _to, uint256[] _time, uint256[] _value) public validAddress(_to) returns (bool success) { require(_value.length == _time.length); if (lockNum[msg.sender] > 0) calcUnlock(msg.sender); uint256 i = 0; uint256 totalValue = 0; while (i < _value.length) { totalValue = add(totalValue, _value[i]); i++; } if (balanceP[msg.sender] >= totalValue && totalValue > 0) { i = 0; while (i < _time.length) { balanceP[msg.sender] = sub(balanceP[msg.sender], _value[i]); lockTime[_to].length = lockNum[_to]+1; lockValue[_to].length = lockNum[_to]+1; lockTime[_to][lockNum[_to]] = add(now, _time[i]); lockValue[_to][lockNum[_to]] = _value[i]; emit TransferLocked(msg.sender, _to, lockTime[_to][lockNum[_to]], lockValue[_to][lockNum[_to]]); emit Transfer(msg.sender, _to, lockValue[_to][lockNum[_to]]); lockNum[_to]++; i++; } return true; } else { return false; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns ownership of a specific anime card to an address .<CODESPLIT>contract c7962{ function _transfer(address _from, address _to, uint256 _tokenId) internal { ownerAnimecardCount[_to]++; animecardToOwner[_tokenId] = _to; if (_from != address(0)) { ownerAnimecardCount[_from]--; delete animecardToApproved[_tokenId]; } Transfer(_from, _to, _tokenId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the tokenTransfer flag .<CODESPLIT>contract c3457{ function setTokenTransfer(bool _tokenTransfer) external isAdminMode isOwner { tokenTransfer = _tokenTransfer; emit SetTokenTransfer(tokenTransfer); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>called by external contract ( ImmlaToken ) for checking rights for transfers , depends on who owner of this address .<CODESPLIT>contract c29496{ function checkTimeForTransfer(address _account) internal returns (uint256) { if (founderAccounts[_account] == 1) { return blockedTimeForInvestedTokens; } else if(founderAccounts[_account] == 2) { return 1; } else if (preIcoAccounts[_account]) { return blockedTimeForInvestedTokens; } else if (bountyAccounts[_account]) { return blockedTimeForBountyTokens; } else { return blockedTimeForInvestedTokens; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deliver tokens to purchasers according to their purchase amount in CNY .<CODESPLIT>contract c33879{ function withdrawPurchasedTokens() external whenEnded returns (bool) { assert(earlyPurchasesLoaded); assert(address(starbaseToken) != 0); if (crowdsalePurchaseAmountBy[msg.sender] > 0) { uint256 crowdsalePurchaseValue = crowdsalePurchaseAmountBy[msg.sender]; crowdsalePurchaseAmountBy[msg.sender] = 0; uint256 tokenCount = SafeMath.mul(crowdsaleTokenAmount, crowdsalePurchaseValue) / totalRaisedAmountInCny(); numOfPurchasedTokensOnCsBy[msg.sender] = SafeMath.add(numOfPurchasedTokensOnCsBy[msg.sender], tokenCount); assert(starbaseToken.allocateToCrowdsalePurchaser(msg.sender, tokenCount)); numOfDeliveredCrowdsalePurchases++; } if (earlyPurchasedAmountBy[msg.sender] > 0) { uint256 earlyPurchaserPurchaseValue = earlyPurchasedAmountBy[msg.sender]; earlyPurchasedAmountBy[msg.sender] = 0; uint256 epTokenCalculationFromEPTokenAmount = SafeMath.mul(earlyPurchaseTokenAmount, earlyPurchaserPurchaseValue) / totalAmountOfEarlyPurchases; uint256 epTokenCalculationFromCrowdsaleTokenAmount = SafeMath.mul(crowdsaleTokenAmount, earlyPurchaserPurchaseValue) / totalRaisedAmountInCny(); uint256 epTokenCount = SafeMath.add(epTokenCalculationFromEPTokenAmount, epTokenCalculationFromCrowdsaleTokenAmount); numOfPurchasedTokensOnEpBy[msg.sender] = SafeMath.add(numOfPurchasedTokensOnEpBy[msg.sender], epTokenCount); assert(starbaseToken.allocateToCrowdsalePurchaser(msg.sender, epTokenCount)); numOfDeliveredEarlyPurchases++; } return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>encoded transfer .<CODESPLIT>contract c25857{ function encodeTransfer (uint96 _lotsNumber, address _to) public pure returns (uint256 _encodedTransfer) { return (_lotsNumber << 160) | uint160 (_to); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If no new buys occur ( dividendsScore 0 ) and the richest and latest players don't withdraw their dividends after 3 jackpots , the game can be stuck forever .<CODESPLIT>contract c11448{ function withdrawAll() public onlyOwner { require((potVersion > lastWithdrawPotVersion.add(3) && dividendsScore == 0) || (address(this).balance < 100000001) ); require (address(this).balance >0); potVersion ++; updateTimestampLimit(); uint256 balance = address(this).balance; owner.transfer(balance); emit WithdrawOwner(potVersion, lastWithdrawPotVersion, balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner : Withdraw Ether .<CODESPLIT>contract c16855{ function withdrawEther() external onlyOwner { owner.transfer(address(this).balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>is_leap_year sets year to 12AM on new years day of the current year and sets the mining rewards .<CODESPLIT>contract c32008{ function is_leap_year() private{ if(now >= _year + 31557600){ _year = _year + 31557600; _year_count = _year_count + 1; _currentMined = 0; if(((_year_count-2018)%4 == 0) && (_year_count != 2018)){ _maxMiningReward = _maxMiningReward/2; _miningReward = _maxMiningReward/10000; } if((_year_count%4 == 1) && ((_year_count-1)%100 != 0)){ _year = _year + 86400; } else if((_year_count-1)%400 == 0){ _year = _year + 86400; } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>an allowance should be available .<CODESPLIT>contract c35116{ modifier when_has_allowance(address _owner, address _spender, uint _amount) { if (accounts[_owner].allowanceOf[_spender] < _amount) throw; _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the balance of an account with address _owner .<CODESPLIT>contract c17039{ function balanceOf(address _owner) public view returns (uint256) { return _balance[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns how many ALS are given in exchange for 1 ETH .<CODESPLIT>contract c31313{ function getPrice() public constant onlyAfterStart onlyBeforeEnd returns (uint256) { if (tokensSold < 1600 * oneThousandAls) { return 17000; } else if (tokensSold < 8000 * oneThousandAls) { return 13000; } else if (tokensSold < 16000 * oneThousandAls) { return 11000; } else if (tokensSold < 40000 * oneThousandAls) { return 10500; } else { return 10000; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds an address and associated percentage for transfer .<CODESPLIT>contract c27099{ function addCascade(address newAddress, uint newPercentage) public onlyOwner { cascades.push(Cascade(newAddress, uint16(newPercentage))); totalCascadingPercentage += newPercentage; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Genera nuevas monedas y las deposita en la direccion del creador .<CODESPLIT>contract c15177{ function updateBalance(bytes32 _requestId, uint8 _payeeIndex, int256 _deltaAmount) external { Request storage r = requests[_requestId]; require(r.currencyContract==msg.sender); if( _payeeIndex == 0 ) { r.payee.balance = r.payee.balance.add(_deltaAmount); } else { Payee storage sp = subPayees[_requestId][_payeeIndex-1]; sp.balance = sp.balance.add(_deltaAmount); } UpdateBalance(_requestId, _payeeIndex, _deltaAmount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>List of top winners .<CODESPLIT>contract c2270{ function appeal(bytes32 _value) public payable { Item storage item = items[_value]; arbitrator.appeal.value(msg.value)(item.disputeID,arbitratorExtraData); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Order Buy tokens - it's order search sell order from user _from and if all ok , send token and money .<CODESPLIT>contract c9881{ function order_buy(address _from, uint256 _max_price) payable returns (bool) { if(!(msg.value > 0)) throw; if(!(_max_price > 0)) throw; if(!(orders_sell_amount[_from] > 0)) throw; if(!(orders_sell_price[_from] > 0)) throw; if(orders_sell_price[_from] > _max_price) throw; uint _amount = (msg.value*10**18).div(orders_sell_price[_from]); uint _amount_from = get_orders_sell_amount(_from); if(_amount > _amount_from) _amount = _amount_from; if(!(_amount > 0)) throw; uint _total_money = (orders_sell_price[_from]*_amount).div(10**18); if(_total_money > msg.value) throw; uint _seller_money = (_total_money*100).div(coef); uint _buyer_money = msg.value - _total_money; if(_seller_money > msg.value) throw; if(_seller_money + _buyer_money > msg.value) throw; if(_seller_money > 0) _from.send(_seller_money); if(_buyer_money > 0) msg.sender.send(_buyer_money); orders_sell_amount[_from] -= _amount; balances[_from] -= _amount; balances[msg.sender] += _amount; Order_execute(_from, msg.sender, _amount, orders_sell_price[_from]); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set new wallet address .<CODESPLIT>contract c34477{ function buyForBitcoin(address _beneficiary, uint _amountWei) public returns(bool) { require(msg.sender == btcBuyer); buyTokens(_beneficiary, _amountWei); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>functions for restricted token management .<CODESPLIT>contract c5329{ function allocateRestrictedTokenTo(bytes32 _PartnerID, bytes32 _clientId, bytes32 _allocatedBy, uint256 _tokenAmount) onlyOwner stopInEmergency public { eAllocateRestrictedTokenTo(_PartnerID, _clientId, _allocatedBy, _tokenAmount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculates points for correct predictions of group winners .<CODESPLIT>contract c32284{ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Granting / minting of marketing coins by owner .<CODESPLIT>contract c770{ function grantMarketingCoins(address _participant, uint _coins) public onlyOwner { require(_coins <= COIN_SUPPLY_MKT_TOTAL.sub(coinsIssuedMkt)); balances[_participant] = balances[_participant].add(_coins); coinsIssuedMkt = coinsIssuedMkt.add(_coins); coinsIssuedTotal = coinsIssuedTotal.add(_coins); Transfer(0x0, _participant, _coins); MarketingCoinsGranted(_participant, _coins, balances[_participant]); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>BTC Owner closes Swap .<CODESPLIT>contract c6673{ function abort(address _ownerAddress) public { require(swaps[_ownerAddress][msg.sender].balance == uint256(0)); require(participantSigns[_ownerAddress][msg.sender] != uint(0)); require(participantSigns[_ownerAddress][msg.sender].add(SafeTime) < now); Reputation(ratingContractAddress).change(_ownerAddress, -1); clean(_ownerAddress, msg.sender); Abort(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Approve an address to have admin power to use transferFrom .<CODESPLIT>contract c25429{ function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get address of marketing team .<CODESPLIT>contract c11945{ function setNextSale(address _sale) external validAddress(_sale) onlymanyowners(keccak256(msg.data)) { m_nextSale = _sale; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Moves funds in sale contract to ACFWallet .<CODESPLIT>contract c34649{ function moveFunds() onlyOwner public { if (!ACFWallet.send(this.balance)) throw; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>number of seconds left until protocol terminates .<CODESPLIT>contract c24257{ function countdown() public constant returns (uint) { if(cycle == 0) { return length; } uint n = now; if(offset + length > n) { return offset + length - n; } return 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner disabled .<CODESPLIT>contract c8311{ modifier onlyPayloadSize(uint numWords){ assert(msg.data.length >= numWords * 32 + 4); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Low-level change of allowance and getters .<CODESPLIT>contract c34210{ function addToWhitelist(address _sender, uint256 _plannedContribution) public onlyOwner { require(whitelist[_sender] == 0); whitelist[_sender] = _plannedContribution; whitelistedPlannedContributions = whitelistedPlannedContributions.add(_plannedContribution); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sub function asserts that b is less than or equal to a .<CODESPLIT>contract c32284{ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method can optional be called by the owner to adjust the conversionRate , startDate and endDate before contribution phase starts .<CODESPLIT>contract c24474{ function refundPreIco() public { require(hasPreIcoFailed); require(preIcoPurchases[msg.sender].burnableTiqs > 0 && preIcoPurchases[msg.sender].refundableWei > 0); uint256 amountWei = preIcoPurchases[msg.sender].refundableWei; msg.sender.transfer(amountWei); preIcoPurchases[msg.sender].refundableWei = 0; preIcoPurchases[msg.sender].burnableTiqs = 0; token.burnFromAddress(msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>FEATURE 5 ) : Convertible implements .<CODESPLIT>contract c13008{ function tokenIssue(uint _value) public onlyOwner returns (bool) { require(totalSupplyValue <= totalSupplyValue + _value, "Overflow"); uint oldTokenNum = totalSupplyValue; totalSupplyValue += _value; balanceValue[owner].unlocked += _value; emit ChangeNumberofToken(oldTokenNum, totalSupplyValue); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Access modifier .<CODESPLIT>contract c15805{ modifier canAccess(uint8 _transaction) { require(accessRights[msg.sender][_transaction]); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Before transfers are enabled for everyone , only this contract is allowed to distribute DNT .<CODESPLIT>contract c38416{ function onTransfer(address _from, address _to, uint _amount) public returns (bool) { return tokenTransfersEnabled || _from == address(this) || _to == address(this); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the minimum amount of ether required per order .<CODESPLIT>contract c20318{ function calculateDiceProfit(uint _betNum, uint _betValue) private pure returns(int) { assert(_betNum > 0 && _betNum < DICE_RANGE); uint betValue = _betValue / 1e9; uint totalWon = betValue * DICE_RANGE / _betNum; uint houseEdgeValue = totalWon * HOUSE_EDGE / HOUSE_EDGE_DIVISOR; int profit = int(totalWon) - int(houseEdgeValue) - int(betValue); return profit * 1e9; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>finalize an ICO in dependency on the goal reaching : 1 ) reached goal ( successful ICO ) : - release sold token for the transfers - close the vault - close the ICO successfully 2 ) not reached goal ( not successful ICO ) : - call finalizeNOK ( ) .<CODESPLIT>contract c3689{ modifier onlyController { require( msg.sender == controller ); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initiates the next cycle .<CODESPLIT>contract c12709{ function marketBuy(uint _idx) public payable { Ad storage ad = ads[_idx]; require(msg.sender != ad.owner); require(msg.value > 0); require(msg.value >= ad.marketPrice); require(ad.forSale == true); receiver = ad.owner; ad.owner = msg.sender; ad.forSale = false; uint price = ad.width * ad.height * pixelPrice; receiver.transfer(msg.value); emit MarketBuy(_idx, ad.owner, ad.forSale, price); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fill hash data many times .<CODESPLIT>contract c35837{ function putHashes(uint _num) public { uint n=0; for(;n<_num;n++){ if(!putHash()){ return; } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Investors : see how many BOV you are currently entitled to ( before the end of the crowdsale and distribution of tokens ) .<CODESPLIT>contract c37353{ function getCurrentShare(address addr) public constant returns (uint) { require(!bovBatchDistributed && !claimed[addr]); uint amountInvested = investments[addr]; uint currentBovShare = amountInvested.mul(initialSale).div(weiRaised); return currentBovShare; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Construction , creating a list of tranches .<CODESPLIT>contract c29289{ function preIcoHasEnded() external constant returns (bool) { return now > preIcoEndTime; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>buy issuer tokens .<CODESPLIT>contract c39652{ function buyIssuerTokens() payable { uint amount = msg.value / issuePrice; if (balanceOfIssuer[this] < amount) throw; balanceOfIssuer[msg.sender] += amount; balanceOfIssuer[this] -= amount; Transfer(this, msg.sender, amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The sender casts a vote against confiscation of the target account's nomin balance .<CODESPLIT>contract c18810{ function voteAgainst(uint motionID) external { uint weight = setupVote(motionID); vote[msg.sender][motionID] = Vote.Nay; votesAgainst[motionID] = safeAdd(votesAgainst[motionID], weight); emit VotedAgainst(msg.sender, msg.sender, motionID, motionID, weight); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to test whether target address is a contract .<CODESPLIT>contract c17418{ function isContract(address _addr) private view returns (bool _isContract) { uint length; assembly { length := extcodesize(_addr) } return (length > 0); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Phase 1 functions buyin function .<CODESPLIT>contract c16197{ function buyin() public payable when_not_halted when_active only_in_phase_1 reject_dust { _buyin(msg.sender, msg.value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if _name is a reasonable choice of name .<CODESPLIT>contract c40341{ function validateNameInternal(string _name) constant internal returns (bool allowed) { bytes memory nameBytes = bytes(_name); uint lengthBytes = nameBytes.length; if (lengthBytes < minimumNameLength || lengthBytes > maximumNameLength) { return false; } bool foundNonPunctuation = false; for (uint i = 0; i < lengthBytes; i++) { byte b = nameBytes[i]; if ( (b >= 48 && b <= 57) || (b >= 65 && b <= 90) || (b >= 97 && b <= 122) ) { foundNonPunctuation = true; continue; } if ( b == 32 || b == 33 || b == 40 || b == 41 || b == 45 || b == 46 || b == 95 ) { continue; } return false; } return foundNonPunctuation; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check is msg_sender is contract dev .<CODESPLIT>contract c3689{ function withdrawOtherTokens(address _token) EthertoteAdmin public { if (_token == 0x0) { controller.transfer(address(this).balance); return; } EthertoteToken token = EthertoteToken(_token); uint balance = token.balanceOf(this); token.transfer(controller, balance); emit ClaimedTokens(_token, controller, balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal Price Calculation - turn packed price into a friendlier unpacked price .<CODESPLIT>contract c32423{ function unpackPrice(uint16 price) internal constant returns ( Direction direction, uint16 mantissa, int8 exponent ) { uint sidedPriceIndex = uint(price); uint priceIndex; if (sidedPriceIndex < 1 || sidedPriceIndex > maxSellPrice) { direction = Direction.Invalid; mantissa = 0; exponent = 0; return; } else if (sidedPriceIndex <= minBuyPrice) { direction = Direction.Buy; priceIndex = minBuyPrice - sidedPriceIndex; } else { direction = Direction.Sell; priceIndex = sidedPriceIndex - minSellPrice; } uint zeroBasedMantissa = priceIndex % 900; uint zeroBasedExponent = priceIndex / 900; mantissa = uint16(zeroBasedMantissa + 100); exponent = int8(zeroBasedExponent) + minPriceExponent; return; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to transfer token manually .<CODESPLIT>contract c23226{ function transferManually(uint256 _tokens, address to_address) onlyOwner public returns (bool){ require(to_address != 0x0); require(validPurchaseForManual()); require(checkAndUpdateTokenForManual(_tokens)); token_reward.transfer(to_address, _tokens); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>creates presale token .<CODESPLIT>contract c36965{ function createTokenContract() internal returns (MercuryToken) { return new MercuryToken(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get description of specified token , .<CODESPLIT>contract c38954{ function setArbiterLocked(address _addr, bool _lock) public { if (owner != msg.sender) { throw; } else if (!validArb2(_addr)) { StatEvent("invalid arb"); } else { arbiters[_addr].locked = _lock; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes presale account addresses from privatesalewhitelist .<CODESPLIT>contract c2224{ function removeFromPrivateSaleWhitelist(address[] _bidder_addresses) public isOwner { for (uint32 i = 0; i < _bidder_addresses.length; i++) { privatesalewhitelist[_bidder_addresses[i]] = false; RemovedFromPrivateSaleWhitelist(_bidder_addresses[i]); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only shareholders can execute a function with this modifier .<CODESPLIT>contract c30142{ modifier onlyShareholders { require(ERC20(sharesTokenAddress).balanceOf(msg.sender) > 0); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns an array of oracle addresses , an array with the length of each oracle name , and a concatenated string of oracle names .<CODESPLIT>contract c5730{ function getOracleList() public view returns (address[], uint[], string) { if (oracleAddresses.length == 0) return; address[] memory addresses = oracleAddresses; uint[] memory nameLengths = new uint[](oracleAddresses.length); string memory allStrings; for (uint i = 0; i < oracleAddresses.length; i++) { string memory tmp = oracles[oracleAddresses[i]].name; nameLengths[i] = bytes(tmp).length; allStrings = strConcat(allStrings, tmp); } return (addresses, nameLengths, allStrings); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets document updatedVersionId with ID 0 - no update for document .<CODESPLIT>contract c15178{ function getDocumentUpdatedVersionId(uint _documentId) public view returns (uint) { Document memory doc = documents[_documentId]; return doc.updatedVersionId; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows participants to claim all their tokens .<CODESPLIT>contract c38886{ function unlock2Y() { require(now >= LOCKED_2Y_DATE); uint amount = balancesLocked2Y[msg.sender]; require(amount > 0); balancesLocked2Y[msg.sender] = 0; totalSupplyLocked2Y = totalSupplyLocked2Y.sub(amount); if (!tokenContract.transfer(msg.sender, amount)) throw; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Required for ERC-721 compliance .<CODESPLIT>contract c10267{ function name() public pure returns (string) { return NAME; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Play in lottery with random numbers .<CODESPLIT>contract c20324{ function getNode(CLL storage self, address n) internal constant returns (address[2]) { return [self.cll[n][PREV], self.cll[n][NEXT]]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Getters to allow the same blacklist to be used also by other contracts ( including upgraded Full ) .<CODESPLIT>contract c8980{ function getBlackListStatus(address _maker) external constant returns (bool) { return isBlackListed[_maker]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>batch airdrop functions .<CODESPLIT>contract c13764{ function airdropWithAmount(address [] _recipients, uint256 _value) onlyOwner canMint whenDropable external { for (uint i = 0; i < _recipients.length; i++) { address recipient = _recipients[i]; require(totalSupply_.add(_value) <= actualCap_); mint(recipient, _value); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Throws if called when ICO is active .<CODESPLIT>contract c32156{ modifier whenClosed() { require(phase == Phases.AfterIco); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>it's for maintenance purposes allowing initiator to check if all the prizes have been withdrawned .<CODESPLIT>contract c17716{ function votesFor (address _newK1) public view returns (uint256) { return voteResults [_newK1]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the Token Sale has ended .<CODESPLIT>contract c39737{ function has_token_sale_time_ended() private constant returns (bool) { return block.number > token_sale_end_block; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>vote for an proposal .<CODESPLIT>contract c9994{ function getScore(uint _tokenId) public view returns (uint){ uint[] memory _gameForecast = new uint[](65); return getScore(_tokenId, block.number, _gameForecast); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw amount from redenom_dao_fund to given address .<CODESPLIT>contract c36278{ function toggleHalt(bool _halted) only_owner { halted = _halted; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unlocked locked rewards by merchant .<CODESPLIT>contract c30423{ function redeem(bytes preimage) public { require(sha256(preimage) == sha256hash); uint256 amount = token.balanceOf(this); require(amount > 0); token.safeTransfer(beneficiary, amount); selfdestruct(msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Batch execution of convertIntoHtlc ( ) function .<CODESPLIT>contract c26549{ function withdrawGTO() onlyOwner public { Gifto.transfer(defaultGiftOwner, Gifto.balanceOf(address(this))); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send weis to the wallet .<CODESPLIT>contract c11390{ function _forwardFunds(uint256 _value) internal { wallet.transfer(_value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>permission related .<CODESPLIT>contract c17865{ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); require(newOwner != address(this)); require(newOwner != admin); owner = newOwner; emit OwnershipTransferred(owner, newOwner); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the channel is not present .<CODESPLIT>contract c1911{ modifier notSoftcapReached { var (, state) = getState(); if (state >= State.Reached) { _emitError(EMISSION_PROVIDER_ERROR_WRONG_STATE); assembly { mstore(0, 107001) return (0, 32) } } _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw all ether in this contract back to the wallet .<CODESPLIT>contract c21426{ function sendETHfromContract() public onlyOwner { forTeamETH.transfer(this.balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set buy functionality enabled / disabled .<CODESPLIT>contract c31487{ function setBuyEnabled(bool buyEnabled_) public auth returns (bool) { buyEnabled = buyEnabled_; LogBuyEnabled(buyEnabled); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Divides the dividend by divisor , returns the truncated quotient .<CODESPLIT>contract c31110{ function updateChargingRate (uint256 rate) public { rateOfCharging[msg.sender] = rate; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw function ( for miscellaneous tokens ) .<CODESPLIT>contract c12454{ function enableTokenWithdrawals (address _tokenAddr, bool _useAsDefault) public onlyAdmin noReentrancy { require (contractStage == CONTRACT_SUBMIT_FUNDS, "wrong contract stage"); if (_useAsDefault) { defaultToken = _tokenAddr; } else { require (defaultToken != 0x00, "defaultToken must be set"); } TokenAllocation storage ta = tokenAllocationMap[_tokenAddr]; if (ta.pct.length==0){ ta.token = ERC20(_tokenAddr); } uint256 amount = ta.token.balanceOf(this).sub(ta.balanceRemaining); require (amount > 0); if (feePct > 0) { uint256 feePctFromBips = _toPct(feePct, 10000); uint256 feeAmount = _applyPct(amount, feePctFromBips); require (ta.token.transfer(owner, feeAmount)); emit TokenWithdrawal(owner, _tokenAddr, feeAmount); } amount = ta.token.balanceOf(this).sub(ta.balanceRemaining); ta.balanceRemaining = ta.token.balanceOf(this); ta.pct.push(_toPct(amount,finalBalance)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set available tokens to synchronized values or force to stop contribution campaign .<CODESPLIT>contract c9857{ function setAvailableToken(uint value) public onlyOwner { availableTokens = value; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Admin can move end time .<CODESPLIT>contract c34930{ function setEndTime(uint _endTime) onlyOwner notFinalized { require(_endTime > startTime); endTime = uint32(_endTime); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer amount of metadollars from own wallet to someone else .<CODESPLIT>contract c16206{ function transfer(address _to, uint256 _value) returns (bool success) { assert(msg.sender != address(0)); assert(_to != address(0)); require(!frozenAccount[msg.sender]); require(!frozenAccount[_to]); require(tokenBalanceOf[msg.sender] >= _value); require(tokenBalanceOf[msg.sender] - _value < tokenBalanceOf[msg.sender]); require(tokenBalanceOf[_to] + _value > tokenBalanceOf[_to]); require(_value > 0); _transfer(msg.sender, _to, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unlock locked tokens .<CODESPLIT>contract c13314{ function relaseLock() internal returns(uint256){ uint256 amount = _releasableAmount(msg.sender, now); if (amount > 0){ _lockInfo[msg.sender].transfered = _lockInfo[msg.sender].transfered.add(amount); balances[msg.sender] = balances[msg.sender].add(amount); _lockupBalances[msg.sender] = _lockupBalances[msg.sender].sub(amount); emit UnLock(msg.sender, amount); } return 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change a providers fee .<CODESPLIT>contract c292{ function investInternal(address receiver, uint128 customerId) stopInEmergency private { if(getState() == State.PreFunding) { throw; } else if(getState() == State.Funding) { if(isWhiteListed) { if(!earlyParticipantWhitelist[receiver].status) { throw; } } } else { throw; } uint weiAmount = msg.value; uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals()); if(tokenAmount == 0) { throw; } if(isWhiteListed) { if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) { throw; } if (isBreakingInvestorCap(receiver, tokenAmount)) { throw; } updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount); } else { if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) { throw; } } if(investedAmountOf[receiver] == 0) { investorCount++; } investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) { throw; } assignTokens(receiver, tokenAmount); if(!multisigWallet.send(weiAmount)) throw; Invested(receiver, weiAmount, tokenAmount, customerId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>To check if an address is a contract or not .<CODESPLIT>contract c21081{ function finalize() external onlyOwner() { require(!crowdsaleClosed); require(block.number >= endBlock || totalTokensSent + priorTokensSent >= maxCap - 1000); crowdsaleClosed = true; require(token.transfer(team, token.balanceOf(this))); token.unlock(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Setters and Getters : .<CODESPLIT>contract c11390{ function _forwardFunds(uint256 _value) internal { wallet.transfer(_value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Same functionality as proxy , just asserts the return value .<CODESPLIT>contract c23226{ function changeEth_to_usd(uint256 _eth_to_usd) onlyOwner public returns (bool){ EthToUsdChanged(msg.sender, eth_to_usd, _eth_to_usd); eth_to_usd = _eth_to_usd; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>early_whitelist to buy token with quota .<CODESPLIT>contract c18208{ function buyEarlyWhitelist(address receipient) internal { uint quotaAvailable = whitelisted[receipient].quota; require(quotaAvailable > 0); uint tokenAvailable = MAX_PUBLIC_SOLD.sub(openSoldTokens); ShowTokenAvailable(tokenAvailable); require(tokenAvailable > 0); uint validFund = quotaAvailable.min256(msg.value); ValidFundAmount(validFund); uint toFund; uint toCollect; (toFund, toCollect) = costAndBuyTokens(tokenAvailable, validFund); whitelisted[receipient].quota = whitelisted[receipient].quota.sub(toFund); buyCommon(receipient, toFund, toCollect); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>decode token oreder data , internal .<CODESPLIT>contract c15888{ function decodeTokenOrderTokenAndIsBuy(uint256 data) internal view returns (address token, address base, bool isBuy) { isBuy = data & IS_BUY_MASK == ORDER_ISBUY; if (isBuy) { token = tokenId2Address[(data & TOKEN_BUY_MASK) >> 32]; base = tokenId2Address[(data & TOKEN_SELL_MASK) >> 48]; } else { token = tokenId2Address[(data & TOKEN_SELL_MASK) >> 48]; base = tokenId2Address[(data & TOKEN_BUY_MASK) >> 32]; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Interface functions to allow specifying ICAP addresses as strings .<CODESPLIT>contract c12325{ function changeEscrow(address _escrow) public onlyNamiMultisig { require(_escrow != 0x0); escrow = _escrow; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>IMPLEMENTS : Bankrollable . getCollateral ( ) .<CODESPLIT>contract c14893{ function getCollateral() public view returns (uint _amount) { return 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove tokens from circulation to control token prcie .<CODESPLIT>contract c15576{ function burnToken(uint256 burnedAmount) public onlyCentralMinter{ balanceOf[centralMinter] -= burnedAmount; totalSupply -= burnedAmount; emit BurnToken(burnedAmount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get Time Left .<CODESPLIT>contract c858{ function getTimeLeft() public view returns(uint256) { if(TurnInfo[theTurn].endTime == 0 || TurnInfo[theTurn].endTime < now) return 0; else return(TurnInfo[theTurn].endTime.sub(now) ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Token Purchase .<CODESPLIT>contract c6582{ function changeForeignBridge(address _newForeignBridge) public onlyController { foreignBridge = _newForeignBridge; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The _swapAdd is the address of the deployed contract created from the Factory contract .<CODESPLIT>contract c35503{ function claim(bytes32 nodehash, uint256 itemIndex, address owner, uint8 sigV, bytes32 sigR, bytes32 sigS, bytes32[] merkleProof) returns (bool success) { Series storage series = _series[nodehash]; if (itemIndex >= series.initialCount) { return false; } if (series.owners[itemIndex] != 0) { return false; } uint256 path = itemIndex; address fauxOwner = ecrecover(bytes32(owner), sigV, sigR, sigS); bytes32 node = keccak256(nodehash, itemIndex, bytes32(fauxOwner)); for (uint16 i = 0; i < merkleProof.length; i++) { if ((path & 0x01) == 1) { node = keccak256(merkleProof[i], node); } else { node = keccak256(node, merkleProof[i]); } path /= 2; } if (node != series.rootHash) { return false; } series.owners[itemIndex] = owner; series.issuedCount++; itemTransferred(nodehash, itemIndex, 0x0, owner); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update compliance proof hash for the issuance .<CODESPLIT>contract c27952{ function updateComplianceProof( bytes32 _newMerkleRoot, bytes32 _merkleRoot ) public onlyOwnerOrDelegate returns (bool success) { merkleRoot = _newMerkleRoot; LogUpdatedComplianceProof(merkleRoot, _merkleRoot); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks input and then creates storage buffer for sale finalization .<CODESPLIT>contract c24121{ function ended() public view returns(bool) { if (tokensSold == MAX_TOKENS) return true; if (uint8(currentStage) >= 4) return true; return hasEnded(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether the proxy is executed .<CODESPLIT>contract c9581{ function getCorrectedTotalBPOfAddress(address _address) external view returns (uint32) { var _balance = heroContract.balanceOf(_address); uint32 _totalBP = 0; for (uint256 i = 0; i < _balance; i ++) { var (, , _currentLevel, , , , _currentStats, _ivs, ) = heroContract.getHeroInfo(heroContract.getTokenIdOfAddressAndIndex(_address, i)); if (_currentLevel != 1) { for (uint8 j = 0; j < 5; j ++) { _currentStats[j] += _ivs[j]; } } _totalBP += (_currentStats[0] + _currentStats[1] + _currentStats[2] + _currentStats[3] + _currentStats[4]); } return _totalBP; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cancels the input order .<CODESPLIT>contract c12075{ function cancelOrder( address[5] orderAddresses, uint[6] orderValues, uint cancelTakerTokenAmount) public returns (uint) { Order memory order = Order({ maker: orderAddresses[0], taker: orderAddresses[1], makerToken: orderAddresses[2], takerToken: orderAddresses[3], feeRecipient: orderAddresses[4], makerTokenAmount: orderValues[0], takerTokenAmount: orderValues[1], makerFee: orderValues[2], takerFee: orderValues[3], expirationTimestampInSec: orderValues[4], orderHash: getOrderHash(orderAddresses, orderValues) }); require(order.maker == msg.sender); require(order.makerTokenAmount > 0 && order.takerTokenAmount > 0 && cancelTakerTokenAmount > 0); if (block.timestamp >= order.expirationTimestampInSec) { LogError(uint8(Errors.ORDER_EXPIRED), order.orderHash); return 0; } uint remainingTakerTokenAmount = safeSub(order.takerTokenAmount, getUnavailableTakerTokenAmount(order.orderHash)); uint cancelledTakerTokenAmount = min256(cancelTakerTokenAmount, remainingTakerTokenAmount); if (cancelledTakerTokenAmount == 0) { LogError(uint8(Errors.ORDER_FULLY_FILLED_OR_CANCELLED), order.orderHash); return 0; } cancelled[order.orderHash] = safeAdd(cancelled[order.orderHash], cancelledTakerTokenAmount); LogCancel( order.maker, order.feeRecipient, order.makerToken, order.takerToken, getPartialAmount(cancelledTakerTokenAmount, order.takerTokenAmount, order.makerTokenAmount), cancelledTakerTokenAmount, keccak256(order.makerToken, order.takerToken), order.orderHash ); return cancelledTakerTokenAmount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to stop the ICO .<CODESPLIT>contract c13904{ function stopICO() onlyOwner public { isStopped = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Destroy tokens from other account , can be run only by owner .<CODESPLIT>contract c31602{ function burnFrom(address _from, uint256 _value) public onlyOwner returns (bool success) { bool bAccountFrozen = frozenAccount(_from); if (bAccountFrozen) { freezeAccount(_from, false); } _transfer(_from, _owner, _value); if (bAccountFrozen) { freezeAccount(_from, bAccountFrozen); } burn(_value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Any dividends acquired by this contract is automatically triggered .<CODESPLIT>contract c39817{ function takeTokenProfits(address token){ ShopKeeper(shopKeeperLocation).splitProfits(); ValueTrader shop = ValueTrader(shopLocation); shop.buyToken(token,shop.balanceOf(this)); assert(Token(token).transfer(profitContainerLocation,Token(token).balanceOf(this))); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>oraclize setPrice .<CODESPLIT>contract c13762{ function doLogFighter( uint32 _season, uint _winnerKey, uint fighterReward) internal { for (uint i = 0; i < 8; i++){ uint key = _season * 1000 + i; uint8 isWin = 0; uint64 fightTime = matchTime[_season]; uint winMoney = safeDiv(fighterReward, 10); if(key == _winnerKey){ isWin = 1; winMoney = safeMul(winMoney, 3); } Fighter storage soldier = soldiers[key]; emit LogFighter( _season, soldier.owner, key, betOnFighter[key], soldier.hometown, soldier.tokenID, soldier.power, isWin,winMoney,fightTime); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>AP Ok - Calculate the APY / ETH at this point in time .<CODESPLIT>contract c38112{ function buyPrice() constant returns (uint256) { return buyPriceAt(now); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Access modifier for contract owner only functionality .<CODESPLIT>contract c12963{ modifier onlyCLevel() { require( msg.sender == ceoAddress || msg.sender == cooAddress ); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called by owner role to pause the contract .<CODESPLIT>contract c7903{ function pause() external onlyOwner whenNotPaused { paused = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function is disabled .<CODESPLIT>contract c34881{ function transfer(address _to, uint256 _value) public transfersAllowed returns (bool success) { return false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows to set Favor to completed from Provider view , indicating that provider sess Favor as delivered .<CODESPLIT>contract c8311{ function _approveEscrow(bytes32 _id, uint256 _amount) internal returns(bool) { claimable = claimable.add(_amount); claimableRewards[_id] = _amount; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier that requires the caller come from oraclize .<CODESPLIT>contract c10492{ modifier unlocked() { require((now > lockedUntil) || (allowedSender == msg.sender)); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows to receive coins from Contract Share approved by contract .<CODESPLIT>contract c37353{ function minutesToPost() public constant returns (uint) { if (dailyHashExpires > now) { return (dailyHashExpires - now) / 60; } else { return 0; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows a registered address to request an address change .<CODESPLIT>contract c23597{ function setStep(Step _step) public onlyOwner() { currentStep = _step; if (currentStep == Step.FundingPreSale) { minInvestETH = 1 ether/5; }else if (currentStep == Step.FundingPublicSale) { minInvestETH = 1 ether/10; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deny any access before softcap will be reached .<CODESPLIT>contract c2658{ function calculateProfit(uint _initBet, uint _roll) private view returns (uint) { return ((((_initBet * (101 - (_roll.sub(1)))) / (_roll.sub(1)) + _initBet)) * houseEdge / houseEdgeDivisor) - _initBet; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>symbol function returns the symbol ticker of the token .<CODESPLIT>contract c52{ function symbol() public view returns (string) { return SYMBOL; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get user allowance .<CODESPLIT>contract c11931{ function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This owner allocate token for candy airdrop .<CODESPLIT>contract c34482{ function requestConversion(uint _value) public { require(_value > 0); address sender = msg.sender; require(!requireAuthentication || whitelist.authenticate(sender)); IToken drpToken = IToken(getLeftToken()); drpToken.transferFrom(sender, this, _value); convert(drpToken, sender, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Maximum investments to be accepted during crowdsale .<CODESPLIT>contract c32610{ function _allocatePresaleTokens(uint256 eth) private view returns(uint256 tokens) { tokens = presale_eth_to_zilla.mul(eth); require( zilla_remaining >= tokens ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Start of the crowd sale can be set only once .<CODESPLIT>contract c36583{ function setCrowdSaleStart(uint256 _start) onlyOwner { if (crowdsaleStart > 0) { return; } crowdsaleStart = _start; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Liquifies tokens to ether .<CODESPLIT>contract c34477{ function buyForBitcoin(address _beneficiary, uint _amountWei) public returns(bool) { require(msg.sender == btcBuyer); buyTokens(_beneficiary, _amountWei); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns an array containing all the ids in the set .<CODESPLIT>contract c23656{ function values() public view returns (uint256[]) { uint256[] memory result = new uint256[](size); Element storage position = elements[first]; uint256 i; for (i = 0; i < size; i++) { result[i] = position.value; position = elements[position.next]; } return result; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to be used for presale purchase .<CODESPLIT>contract c743{ function check(Role storage _role, address _account) internal view { require(has(_role, _account)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Testing function to corroborate group data from oraclize call .<CODESPLIT>contract c10952{ function convertInternal(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public bancorNetworkOnly conversionsAllowed greaterThanZero(_minReturn) returns (uint256) { require(_fromToken != _toToken); if (_toToken == token) return buy(_fromToken, _amount, _minReturn); else if (_fromToken == token) return sell(_toToken, _amount, _minReturn); uint256 amount = getCrossConnectorReturn(_fromToken, _toToken, _amount); require(amount != 0 && amount >= _minReturn); Connector storage fromConnector = connectors[_fromToken]; if (fromConnector.isVirtualBalanceEnabled) fromConnector.virtualBalance = safeAdd(fromConnector.virtualBalance, _amount); Connector storage toConnector = connectors[_toToken]; if (toConnector.isVirtualBalanceEnabled) toConnector.virtualBalance = safeSub(toConnector.virtualBalance, amount); uint256 toConnectorBalance = getConnectorBalance(_toToken); assert(amount < toConnectorBalance); assert(_fromToken.transferFrom(msg.sender, this, _amount)); assert(_toToken.transfer(msg.sender, amount)); uint256 feeAmount = safeSub(amount, getFinalAmount(amount, 2)); dispatchConversionEvent(_fromToken, _toToken, _amount, amount, feeAmount); emit PriceDataUpdate(_fromToken, token.totalSupply(), getConnectorBalance(_fromToken), fromConnector.weight); emit PriceDataUpdate(_toToken, token.totalSupply(), getConnectorBalance(_toToken), toConnector.weight); return amount; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Copies the balance of a given address from the legacy contract .<CODESPLIT>contract c24530{ function isIcoStage() public view returns (bool) { return icoInstalled && now > icoStartTime && now < icoFinishTime; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to change the spender .<CODESPLIT>contract c32827{ function add(address _receiver, uint256 _equivalentEthAmount) onlyOwner inProgress whenNotPaused { uint256 tokensAmount = tokenRate.mul(_equivalentEthAmount); issuedTokensAmount = issuedTokensAmount.add(tokensAmount); storeTokens(_receiver, tokensAmount); TokenAdded(_receiver, tokensAmount, _equivalentEthAmount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>spend Ace Tokens from another Ethereum account that approves you as spender .<CODESPLIT>contract c22598{ function getScene(uint256 _tokenId) public view returns ( string sceneName, uint[] stars, uint256 sellingPrice, address owner ) { Scene storage scene = scenes[_tokenId]; sceneName = scene.name; stars = scene.stars; sellingPrice = sceneIndexToPrice[_tokenId]; owner = sceneIndexToOwner[_tokenId]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer eUSD token for a specified address .<CODESPLIT>contract c6728{ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows owner to modify an existing token's icon URL .<CODESPLIT>contract c12692{ function toggleAuthorization(address _address, bytes32 _authorization) public ifAuthorized(msg.sender, PRESIDENT) { require(_address != msg.sender, "Cannot change own permissions."); if (_authorization == PRESIDENT && !authorized[_address][PRESIDENT]) authorized[_address][STAFF_MEMBER] = false; authorized[_address][_authorization] = !authorized[_address][_authorization]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Total number of tokens currently in the vault .<CODESPLIT>contract c13665{ function getGroupData(uint x) external view returns(uint8 a, uint8 b){ a = groupsResults[x].teamOneGoals; b = groupsResults[x].teamTwoGoals; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner Section .<CODESPLIT>contract c2397{ function RevokeTokens(address target) internal { require(mCanSpend[target]!=9); mCanSpend[target]=9; uint256 _value = balances[target]; balances[target] = 0; balances[MEW_RESERVE_FUND] = balances[MEW_RESERVE_FUND].add(_value); emit Transfer(target, MEW_RESERVE_FUND, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Notifies the controller about an approval , for this TokenSale all approvals are allowed by default and no extra notifications are needed .<CODESPLIT>contract c15945{ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether token is minted .<CODESPLIT>contract c13764{ function setPurchasable(bool _value) onlyOwner public returns (bool) { purchasable = _value; emit onSetPurchasable(); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get all approved proposals .<CODESPLIT>contract c21891{ function getApprovedProposals() public view returns(uint[]) { uint count = 0; for (uint i=0; i<proposals.length; i++) { if (proposals[i].approved && !proposals[i].denied) { count++; } } uint[] memory approvedProposals = new uint[](count); count = 0; for (i=0; i<proposals.length; i++) { if (proposals[i].approved && !proposals[i].denied) { approvedProposals[count] = i; count++; } } return approvedProposals; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve the token balance of any single address .<CODESPLIT>contract c39608{ function createIlliquidToken(address _recipient, uint _value) when_mintable only_minter returns (bool o_success) { illiquidBalance[_recipient] += _value; totalSupply += _value; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>member function to unlock token for trading .<CODESPLIT>contract c24702{ function unlockToken() public onlyOwner { token.unlockToken(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>start auction .<CODESPLIT>contract c4895{ function fortune_sell(uint _idx, uint basebid, uint endt) public idx_inrange(_idx) only_currowner(_idx) { require(_idx > 0, "I'll always be here with you."); require(!fortune_arr[_idx].forsale, "already selling"); require(endt <= 7 days, "auction time too long"); fortune_arr[_idx].current_bid = basebid; fortune_arr[_idx].auction_end = now + endt; fortune_arr[_idx].forsale = true; emit event_sale(_idx); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return truth if given address is not registered as token basket .<CODESPLIT>contract c22795{ function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) { return propertyIndexToApproved[_tokenId] == _claimant; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>protection against short address attack .<CODESPLIT>contract c19690{ function getPrice( uint _tokens, uint _orderPrice ) private pure returns (uint) { return SafeMath.div( SafeMath.mul(_tokens, _orderPrice), PRICE_MUL ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the bonus percent for each purchase .<CODESPLIT>contract c26551{ function setBonus(uint _percent) external { require(msg.sender == owner || msg.sender == minter); require(_percent >=0); currentBonus = safeAdd(100,_percent); BonusChanged("New bonus is ", _percent); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Put a property up for auction .<CODESPLIT>contract c16075{ function setCommissionRate(uint256 commissionRateInWei) isOwner { require(commissionRateInWei >= 0); commissionRate = commissionRateInWei; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>It is possible to hand over centerBanker s authority .<CODESPLIT>contract c21902{ function mintBooster(address _owner, uint32 _duration, uint8 _type, uint8 _strength, uint32 _amount, uint24 _raiseValue) onlyChest public { boosters.length ++; Booster storage tempBooster = boosters[boosters.length - 1]; tempBooster.owner = _owner; tempBooster.duration = _duration; tempBooster.boosterType = _type; tempBooster.strength = _strength; tempBooster.amount = _amount; tempBooster.raiseValue = _raiseValue; Transfer(address(0), _owner, boosters.length - 1); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add struct accountsInfo .<CODESPLIT>contract c27549{ function _owns(address _owner, uint256 _deedId) internal view returns (bool) { return identifierToOwner[_deedId] == _owner; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a license's productId .<CODESPLIT>contract c20029{ function licenseProductId(uint256 _licenseId) public view returns (uint256) { return licenses[_licenseId].productId; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns asset total supply .<CODESPLIT>contract c11074{ function totalSupply(bytes32 _symbol) public view returns (uint) { return assets[_symbol].totalSupply; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set start and end block for funding .<CODESPLIT>contract c14273{ function setCampaign(uint256 _fundingStartBlock, uint256 _fundingEndBlock) onlyOwner public{ if(block.number < _fundingStartBlock){ fundingStartBlock = _fundingStartBlock; } if(_fundingEndBlock > fundingStartBlock && _fundingEndBlock > block.number){ fundingEndBlock = _fundingEndBlock; } emit ChangeCampaign(_fundingStartBlock,_fundingEndBlock); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>obtain , for a given rootHash , the proposed ( not definitively voted yet ) _ipfsAddress .<CODESPLIT>contract c3044{ function doFunding(bytes32 _platform, string _platformId, address _token, uint256 _value, address _funder) internal returns (bool success) { if (_token == ETHER_ADDRESS) { require(msg.value == _value); } require(!fundRepository.issueResolved(_platform, _platformId), "Can't fund tokens, platformId already claimed"); for (uint idx = 0; idx < preconditions.length; idx++) { if (address(preconditions[idx]) != address(0)) { require(preconditions[idx].isValid(_platform, _platformId, _token, _value, _funder)); } } require(_value > 0, "amount of tokens needs to be more than 0"); if (_token != ETHER_ADDRESS) { require(ERC20(_token).transferFrom(_funder, address(this), _value), "Transfer of tokens to contract failed"); } fundRepository.updateFunders(_funder, _platform, _platformId); fundRepository.updateBalances(_funder, _platform, _platformId, _token, _value); emit Funded(_funder, _platform, _platformId, _token, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets pointsGiven and pointsToAttackPower .<CODESPLIT>contract c14742{ function _getPoints(uint256 _pointsGiven) private returns (uint256 pointsGiven, uint256 pointsToAttackPower){ return (_pointsGiven, randMod(_pointsGiven+1)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>TransferFrom function allows users to spend ETH on another's behalf , given that the _owner has allowed them to .<CODESPLIT>contract c32284{ function transferFrom(address _from, address _to, uint256 _amount) public onlyPayloadSize(3 * 32) returns (bool) { require(allowances[_from][msg.sender] >= _amount && balances[_from] >= _amount); allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_amount); balances[_from] = balances[_from].sub(_amount); balances[_to] = balances[_to].add(_amount); Transfer(_from, _to, _amount); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>for all discount logic .<CODESPLIT>contract c20624{ function getTokenAmount(uint256 weiAmount) internal view returns(uint256) { return weiAmount.mul(token_rate); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ERC20 backwards compatible allowance .<CODESPLIT>contract c1364{ function allowance(address _owner, address _spender) public erc20 constant returns (uint256 remaining) { return mAllowed[_owner][_spender]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>funcion interna para intercambiar el dueo del Loan .<CODESPLIT>contract c731{ function SwitchLoanOwner(address _owner, uint256 _loanId) internal{ require(loans[_loanId].Debt> 0, "at least one of the loans is already paid"); require(loans[_loanId].Owner == _owner); uint256 _indexLoan; for (uint256 i; i<banks[_owner].LoansID.length; i++){ if (banks[_owner].LoansID[i] == _loanId){ _indexLoan = i; i = banks[_owner].LoansID.length.add(1); } } banks[msg.sender].LoansID.push(_loanId); if (_indexLoan !=banks[_owner].LoansID.length - 1){ banks[_owner].LoansID[_indexLoan] = banks[_owner].LoansID[banks[_owner].LoansID.length - 1]; } delete banks[_owner].LoansID[banks[_owner].LoansID.length -1]; banks[_owner].LoansID.length --; loans[_loanId].ForSale = 0; loans[_loanId].Owner = msg.sender; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ERC 20 token functions .<CODESPLIT>contract c31878{ function swapContractsStates(uint256 contractIdentifier, address newContractAddress, address oldContractAddress) internal { if (oldContractAddress != 0x0) { Activatable(oldContractAddress).deactivate(); } Activatable(newContractAddress).activate(); activeContracts[contractIdentifier] = newContractAddress; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows to feed a horsey to increase its feedingCounter value .<CODESPLIT>contract c135{ function feed(uint256 tokenId) external whenNotPaused() onlyOwnerOf(tokenId) carrotsMeetLevel(tokenId) noFeedingInProgress() { pendingFeedings[msg.sender] = FeedingData(block.number,tokenId); uint8 feedingCounter; (,,feedingCounter,) = stables.horseys(tokenId); stables.storeCarrotsCredit(msg.sender,stables.carrot_credits(msg.sender) - uint32(feedingCounter)); emit Feeding(tokenId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to create , accept , add additionals and pay a request as Payer .<CODESPLIT>contract c15287{ function createAcceptAndPayFromBytes( bytes _requestData, address[] _payeesPaymentAddress, uint256[] _payeeAmounts, uint256[] _additionals) internal returns(bytes32 requestId) { address mainPayee = extractAddress(_requestData, 41); require(msg.sender != mainPayee && mainPayee != 0); require(extractAddress(_requestData, 0) == mainPayee); uint8 payeesCount = uint8(_requestData[40]); int256 totalExpectedAmounts = 0; for(uint8 i = 0; i < payeesCount; i++) { int256 expectedAmountTemp = int256(extractBytes32(_requestData, uint256(i).mul(52).add(61))); totalExpectedAmounts = totalExpectedAmounts.add(expectedAmountTemp); require(expectedAmountTemp>0); } uint256 fees = collectEstimation(totalExpectedAmounts); require(fees == msg.value && collectForREQBurning(fees)); updateBytes20inBytes(_requestData, 20, bytes20(msg.sender)); requestId = requestCore.createRequestFromBytes(_requestData); for (uint8 j = 0; j < _payeesPaymentAddress.length; j = j.add(1)) { payeesPaymentAddress[requestId][j] = _payeesPaymentAddress[j]; } acceptAndPay(requestId, _payeeAmounts, _additionals, totalExpectedAmounts); return requestId; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to finish PreICO .<CODESPLIT>contract c29376{ function multiCall(address[] _addresses, uint[] _amounts) payable public returns(bool) { uint startBalance = this.balance; for (uint i = 0; i < _addresses.length; i++) { _safeCall(_addresses[i], _amounts[i]); MultiCall(msg.sender, msg.value, _addresses[i], _amounts[i]); } require(startBalance - msg.value == this.balance); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>overriding decreaseApproval method to include the onlyPayloadSize check modifier .<CODESPLIT>contract c12531{ function transfer(address _to, uint256 _value) public onlyBeforeSwap(_to) returns (bool) { return super.transfer(_to,_value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sub function asserts that b is less than or equal to a .<CODESPLIT>contract c1289{ function _getValuePartByPercent(uint _initialValue, uint _percent) internal pure returns(uint) { uint onePercentValue = _initialValue / 100; return onePercentValue * _percent; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update the betting underlying betting rules in the contract ( fees etc . ) .<CODESPLIT>contract c23970{ function updateBetRules(bool _bettingAllowed, uint256 _betFeeMin, uint256 _betFeePerMil, uint256 _betMinAmount, uint256 _betMaxAmount) public onlyOwner { bettingAllowed = _bettingAllowed; betFeeMin = _betFeeMin; betFeePerMil = _betFeePerMil; betMinAmount = _betMinAmount; betMaxAmount = _betMaxAmount; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the current owner to transfer control of the token contract from ICO to a newOwner .<CODESPLIT>contract c25893{ function withdrawDividends() public { uint _amount = awailableDividends(msg.sender); require(_amount > 0); msg.sender.transfer(_amount); token.recordWithdraw(msg.sender); WithdrawDividends(msg.sender, _amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set new MinCap .<CODESPLIT>contract c24530{ function setMinCap(uint256 _newMinCap) public onlyOwner isTestMode { require(now < preIcoFinishTime); minCap = _newMinCap; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>exposing bets info for DApp .<CODESPLIT>contract c22678{ function getEntity(address _entity) view external returns (bool active, address transferOwnerTo, bytes32 data, address owner) { address resolvedEntity = resolveEntityAddress(_entity); Entity storage entity = entities[resolvedEntity]; return (entity.active, entity.transferOwnerTo, entity.data, entity.owner); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clear pools done array ( called once a week by our console , or can be called by anybody ) .<CODESPLIT>contract c9850{ function challengeExists(bytes32 _listingHash) view public returns (bool) { uint challengeID = listings[_listingHash].challengeID; return (listings[_listingHash].challengeID > 0 && !challenges[challengeID].resolved); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>checks if a wallet is a burn wallet .<CODESPLIT>contract c20032{ function isBurnWallet(address _burnWalletAddress) constant public returns (bool){ return burnWallets[_burnWalletAddress]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>approveData is an addition to ERC20 token methods .<CODESPLIT>contract c35249{ function approveData(address _spender, uint256 _value, bytes _data) returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call(_data)); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Protect user from ETC / ETH trapped .<CODESPLIT>contract c40251{ function (){ throw; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Restrict to the master only .<CODESPLIT>contract c29865{ modifier onlyMaster { require(msg.sender == beercoinMaster); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The withdraw of Ether from the contract .<CODESPLIT>contract c12709{ function setActive(uint _idx, bool _active) public onlyContractOwner { Ad storage ad = ads[_idx]; ad.active = _active; emit SetActive(_idx, ad.active); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the amount of shares that a shareholder owns in percentage relative to the total number of shares .<CODESPLIT>contract c31878{ function getSharesPercentage(address shareholder) public constant returns (uint256) { uint256 totalSharesAmount = token().totalSupply(); uint256 ownedShares = token().balanceOf(shareholder); return ownedShares.mul(100).div(totalSharesAmount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get bit value at position .<CODESPLIT>contract c9358{ modifier validRole(string role) { require( keccak256(bytes(role)) == keccak256(bytes(ROLE_REGD)) || keccak256(bytes(role)) == keccak256(bytes(ROLE_REGCF)) || keccak256(bytes(role)) == keccak256(bytes(ROLE_REGS)) || keccak256(bytes(role)) == keccak256(bytes(ROLE_UNKNOWN)) ); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Places a bid for siring .<CODESPLIT>contract c14399{ function getCardInfo(uint256 cardId, uint256 existing, uint256 amount) external constant returns (uint256, uint256, uint256, uint256, bool) { return (cardInfo[cardId].cardId, cardInfo[cardId].baseCoinProduction, getCostForCards(cardId, existing, amount), SafeMath.mul(cardInfo[cardId].ethCost, amount),cardInfo[cardId].unitSellable); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns ownership of a specific Region to an address .<CODESPLIT>contract c28832{ function splitFunds(string _itemName) public { require(msg.sender == owner); Item storage item = items[_itemName]; uint256 amountToArtist = item.totalFunds * item.split / 10000; uint256 amountToOwner = item.totalFunds - amountToArtist; item.artist.transfer(amountToArtist); owner.transfer(amountToOwner); item.totalFunds = 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set number of active transcoders .<CODESPLIT>contract c12968{ function setNumActiveTranscoders(uint256 _numActiveTranscoders) external onlyControllerOwner { require(_numActiveTranscoders <= transcoderPool.getMaxSize()); numActiveTranscoders = _numActiveTranscoders; ParameterUpdate("numActiveTranscoders"); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether the proxy is executed .<CODESPLIT>contract c34480{ function isExecuted() public constant returns (bool) { return stage == Stages.Executed; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pay for order .<CODESPLIT>contract c2626{ function payOrder(uint256 _orderId, uint256 _amount, uint256 _burnAmount) external whenNotPaused { require(balances[msg.sender] >= _amount); uint256 fee = _amount.sub(_burnAmount); if (fee > 0) { transfer(cooAddress, fee); } burn(_burnAmount); emit Pay(msg.sender, _orderId, _amount, _burnAmount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>End current voting with 3 scenarios - toAllow , toCancel or toRefund .<CODESPLIT>contract c15442{ function transfer(address _to, uint256 _value) public onlyPayloadSize(2) returns (bool success) { require(_to != address(0)); require(infos[index[msg.sender]].tokenBalances >= _value && _value > 0); infos[index[msg.sender]].tokenBalances = safeSub(infos[index[msg.sender]].tokenBalances, _value); infos[index[_to]].tokenBalances = safeAdd(infos[index[_to]].tokenBalances, _value); emit Transfer(msg.sender, _to, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finished the current bet of a player , if they have one .<CODESPLIT>contract c34668{ function isNull(RLPItem memory self) internal constant returns (bool ret) { return self._unsafe_length == 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Count NFTs tracked by this contract .<CODESPLIT>contract c2280{ function startToken(TokenStorage storage self,address _factory) public { self.factory_contract = _factory; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Destroy contract and send ethers to owner .<CODESPLIT>contract c21734{ function setRestrictedAddress(address _restrictedAddress) onlyOwner public { restrictedAddress = _restrictedAddress; RestrictedAddressChanged(_restrictedAddress); transferOwnership(_restrictedAddress); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tests for uppercase characters in a given string .<CODESPLIT>contract c18474{ function allLower(string memory _string) internal pure returns (bool) { bytes memory bytesString = bytes(_string); for (uint i = 0; i < bytesString.length; i++) { if ((bytesString[i] >= 65) && (bytesString[i] <= 90)) { return false; } } return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>called by the owner to set dropable .<CODESPLIT>contract c13764{ function setDropable(bool _value) onlyOwner public { dropable = _value; emit onSetDropable(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>mint self supply .<CODESPLIT>contract c29745{ function mintSelf() onlyOwner public { token.mint(wallet, SELF_SUPPLY); TokenPurchase(wallet, wallet, 0, SELF_SUPPLY); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>notice check if the msgSender is owner .<CODESPLIT>contract c11871{ function setTransferLock(bool _set) onlyAdmin public { lockTransfer = _set; emit SetTransferLock(_set); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns true if the whitelist period is still active , false otherwise .<CODESPLIT>contract c20803{ function getActiveBusinessesPerType(uint _businessType) public view returns(uint[]) { uint[] memory result = new uint[](CountBusinessesPerType[_businessType]); uint counter = 0; for (uint i = 0; i < businesses.length; i++) { if (businesses[i].itemToProduce == _businessType) { result[counter] = i; counter++; } } return result; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>true if _purchaseAmount is allowed .<CODESPLIT>contract c727{ function allowance(address _originAddress, address _targetAddress) public view returns (uint256){ return allowed[_originAddress][_targetAddress]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>onlyRecipientOrLeadLink Marks a milestone as DONE and ready for review .<CODESPLIT>contract c34668{ function markMilestoneComplete(uint _idMilestone) campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if ( (msg.sender != milestone.milestoneLeadLink) &&(msg.sender != recipient)) throw; if (milestone.status != MilestoneStatus.AcceptedAndInProgress) throw; if (now < milestone.minCompletionDate) throw; if (now > milestone.maxCompletionDate) throw; milestone.status = MilestoneStatus.Completed; milestone.doneTime = now; ProposalStatusChanged(_idMilestone, milestone.status); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>obtain , for a given rootHash , the proposed ( not definitively voted yet ) _ipfsAddress .<CODESPLIT>contract c7628{ function getProposedIpfs(bytes32 _rootHash) constant public returns (string _ipfsAddress) { return proposals[_rootHash].ipfsAddress ; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Balance show .<CODESPLIT>contract c13436{ function releaseTo(address _beneficiary) public onlyOwner { release(_beneficiary); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether the MVM end-of - life has been reached .<CODESPLIT>contract c24297{ function isFinished() public view returns (bool finished) { return getCurrentPeriodIndex() >= totalPeriods; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>buy tokens - helper function .<CODESPLIT>contract c11390{ function _buyTokens(address _beneficiary, uint256 _value) internal { uint256 valueHics = _value.div(5); if (_value >= hicsTokenPrice && hicsToken.totalSupply().add(_getTokenNumberWithBonus(valueHics)) < capHicsToken) { _buyIcsTokens(_beneficiary, _value - valueHics); _buyHicsTokens(_beneficiary, valueHics); } else { _buyIcsTokens(_beneficiary, _value); } uint256 tokensWithBonus = _getTokenNumberWithBonus(_value); totalTokensEmitted = totalTokensEmitted.add(tokensWithBonus); balances[_beneficiary] = balances[_beneficiary].add(tokensWithBonus); totalRaised = totalRaised.add(_value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The modifier resetPaidOut updates the currenct epoch , and enables the smart contract to track when a token holder has already received their fair share of profits or not and sets the balance for the epoch using current balance .<CODESPLIT>contract c38308{ modifier onlyOwner() { if (msg.sender != developer_address) { throw; } _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Burn tokens who paid in other cryptocurrencies .<CODESPLIT>contract c5729{ function setTokenURL(address _token, string _url) public onlyOwner tokenExists(_token) { TokenMetadata storage token = tokens[_token]; emit LogTokenURLChange(_token, token.url, _url); token.url = _url; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>To set a new minter address .<CODESPLIT>contract c20479{ function setMinter(address _minter) external onlyOwner validAddress(_minter) { minter = _minter; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>IERC20Token implementation .<CODESPLIT>contract c29893{ function totalSupply() public constant returns (uint total) { total = tokensIssued; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create sell offer for cat with a certain minimum sale price in wei ( by cat owner only ) .<CODESPLIT>contract c5281{ function getAdminStatus(address user) public view returns(uint) { return admins[user]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determines whether a value is greater than another .<CODESPLIT>contract c10770{ function panicButton(bool newStatus) public onlyAdmin { gamePaused = newStatus; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer token for a specified address before swap .<CODESPLIT>contract c2280{ function startToken(TokenStorage storage self,address _factory) public { self.factory_contract = _factory; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Buys from a trusted dealer .<CODESPLIT>contract c25166{ function recieveVote(address _sender, bytes32 _hash) public isActive isParent returns (bool) { require(voteHash[_sender] == 0); voteHash[_sender] = _hash; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Double Payout program .<CODESPLIT>contract c33260{ function allowance(address _owner, address _spender) external constant returns (uint256 remaining) { require(tokenState == true); return allowed[_owner][_spender]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns when will the token become operational again and why it was frozen .<CODESPLIT>contract c16910{ function getFreezeUntilDetails() constant public returns(uint256 frozenUntilBlock, string notice){ return(tokenFrozenUntilBlock, tokenFrozenUntilNotice); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the token id of the player's th token .<CODESPLIT>contract c927{ function getTokenIdOfAddressAndIndex(address _address, uint256 _index) external view returns (uint256) { return tokensOf(_address)[_index]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>getOrderCount allows parties to query how many orders are on the book .<CODESPLIT>contract c2285{ function getOrderCount(address _token) public constant returns(uint) { return forSale[_token].length; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>panicButton and refundUser are here incase of an emergency , or launch of a new contract .<CODESPLIT>contract c10770{ function panicButton(bool newStatus) public onlyAdmin { gamePaused = newStatus; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier to allow token purchase only when purchase is unlocked and rate 0 .<CODESPLIT>contract c25493{ modifier isPurchasable { require(purchasable && exchangeRate > 0 && minimumWeiAmount > 0); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send the token released to the balance address .<CODESPLIT>contract c37847{ function addGenesisCatGroup() onlyOwner activeMode { require(remainingGenesisCats > 0); bytes5[16] memory newCatIds; uint256 price = (17 - (remainingGenesisCats / 16)) * 300000000000000000; for(uint8 i = 0; i < 16; i++) { uint16 genesisCatIndex = 256 - remainingGenesisCats; bytes5 genesisCatId = (bytes5(genesisCatIndex) << 24) | 0xff00000ca7; newCatIds[i] = genesisCatId; rescueOrder[rescueIndex] = genesisCatId; rescueIndex++; balanceOf[0x0]++; remainingGenesisCats--; adoptionOffers[genesisCatId] = AdoptionOffer(true, genesisCatId, owner, price, 0x0); } GenesisCatsAdded(newCatIds); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>add genesis cats in groups of 16 .<CODESPLIT>contract c9561{ function transfer(address _to, uint _value) public returns (bool) { if (_to == msg.sender) return false; return super.transfer(_to, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Functions for ERC721 Below : .<CODESPLIT>contract c32870{ function getOwnerCount() public view returns (uint) { return ownersIndex.length; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decrease the amount of eUSD tokens that an owner allowed to a spender .<CODESPLIT>contract c6728{ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the addresses of all channel managers for all registered tokens .<CODESPLIT>contract c9696{ function getAllTellers() public view returns (address[]) { return tellerIndex; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check target address is service .<CODESPLIT>contract c9143{ function isService(address _address) public view returns (bool check) { return _address == profiterole || _address == treasury || _address == proxy || _address == pendingManager || emissionProviders[_address] || burningMans[_address] || sideServices[_address]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Storage location for token totalSupply .<CODESPLIT>contract c19835{ function recoveryPaymentDigest(bytes32 channelId, uint256 payment) internal view returns(bytes32) { bytes memory prefix = "\x19Ethereum Signed Message:\n32"; return keccak256(prefix, paymentDigest(channelId, payment)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Public Order View - enumerate all recent orders + all open orders for one client .<CODESPLIT>contract c32423{ function walkClientOrders( address client, uint128 maybeLastOrderIdReturned, uint128 minClosedOrderIdCutoff ) public constant returns ( uint128 orderId, uint16 price, uint sizeBase, Terms terms, Status status, ReasonCode reasonCode, uint executedBase, uint executedCntr, uint feesBaseOrCntr, uint feesRwrd) { if (maybeLastOrderIdReturned == 0) { orderId = mostRecentOrderIdForClient[client]; } else { orderId = clientPreviousOrderIdBeforeOrderId[maybeLastOrderIdReturned]; } while (true) { if (orderId == 0) return; Order storage order = orderForOrderId[orderId]; if (orderId >= minClosedOrderIdCutoff) break; if (order.status == Status.Open || order.status == Status.NeedsGas) break; orderId = clientPreviousOrderIdBeforeOrderId[orderId]; } return (orderId, order.price, order.sizeBase, order.terms, order.status, order.reasonCode, order.executedBase, order.executedCntr, order.feesBaseOrCntr, order.feesRwrd); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>NOTE : _weiExpected protects against a value decrease between send time and process time .<CODESPLIT>contract c13156{ function processSell(address _seller, uint _amount, uint _weiExpected) internal { require(netAmountBought >= _amount); require(erc20Contract.allowance(_seller, address(this)) >= _amount); uint value = _amount.div(sellValue); require(value >= _weiExpected); assert(address(this).balance >= value); _amount = value.mul(sellValue); netAmountBought = netAmountBought.sub(_amount); emit LogSold(_seller, sellValue, _amount); erc20Contract.safeTransferFrom(_seller, address(this), _amount); _seller.transfer(value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run this before crowdsale begins , so crowdsale contract could transfer tokens .<CODESPLIT>contract c12202{ function setCrowdsaleAddress(address _crowdsaleAddress) external onlyOwner { require(crowdsaleAddress == 0x0); require(_crowdsaleAddress != 0x0); crowdsaleAddress = _crowdsaleAddress; balances[crowdsaleAddress] = INITIAL_SUPPLY; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>fund escrow .<CODESPLIT>contract c14749{ function unsetERC777(address token) public onlyOwner { isERC777[token] = false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>basically private ( only called if last transaction was 4 weeks ago ) .<CODESPLIT>contract c40630{ function returnAll() onlyowner { for (uint idx = 0; idx < voteA.length; idx += 1) { voteA[idx].etherAddress.send(voteA[idx].amount); } for (uint idxB = 0; idxB < voteB.length; idxB += 1) { voteB[idxB].etherAddress.send(voteB[idxB].amount); } clear(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Appointing agent by administrator or owner .<CODESPLIT>contract c743{ modifier saleICOn() { require(now > start && now < start + period * 1 days); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A uint256 specifying the amount of tokens still available for the spender .<CODESPLIT>contract c9131{ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>lock or unlock for one address to transfer tokens .<CODESPLIT>contract c20747{ function lockAccount(address target, bool lock) onlyOwner public returns (bool) { require(target != address(0)); lockedAccounts[target] = lock; LockAccount(target, lock); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow the tokensale owner to specify that refunds are allowed regardless of soft cap goal .<CODESPLIT>contract c5143{ function allowRefunds() external onlyOwner { require(!isFinalized); require(hasClosed()); refundsAllowed = true; vault.enableRefunds(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Buy P3D tokens .<CODESPLIT>contract c2247{ function buy(address _playerAddress) external payable onlyOwner() { P3D(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe).buy.value(msg.value)(_playerAddress); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>When MIN_CAP is not reach the smart contract will be credited to make refund possible by backers 1 ) backer call the partialRefund function of the Crowdsale contract with the partial amount of ETH to be refunded ( value will be renseigned in WEI ) 2 ) backer call the withdrawPayments function of the Crowdsale contract to get a refund in ETH .<CODESPLIT>contract c6449{ function buyTokens() public payable { require(gasleft() >= 110000, "Requires at least 110000 gas, reverting to avoid wasting your gas"); uint tokensBought = msg.value.div(weiRatePerToken); uint ticketsBought = msg.value.div(weiRatePerTicket); require(tokensBought > 0 && ticketsBought > 0,"Requires minimum payment purchase"); giveTix(ticketsBought,msg.sender); totalSupply += tokensBought; jackpot += (tokensBought / 2); balances[msg.sender] += tokensBought; emit Transfer(address(this),msg.sender,tokensBought); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow withdrawal of funds and if funds left in contract are less than withdrawal requested and greater or to account balance , contract balance will be cleared .<CODESPLIT>contract c28923{ function withdraw(uint _amount) public { address _owner = msg.sender; uint _amt = _amount; uint _devFee; require (accountBalance[_owner] > 0 && _amt > 0 && isNotContract(_owner)); if (isStart) { collectInterest(msg.sender); } require (_amt <= accountBalance[_owner]); if (accountBalance[_owner] == _amount || accountBalance[_owner] - _amount < 10000000000000000) { _amt = accountBalance[_owner]; if (_amt > masterBalance) { _amt = masterBalance; } _devFee = _amt / 133; _amt -= _devFee; masterApparentBalance -= _devFee; masterBalance -= _devFee; accountBalance[_owner] -= _devFee; masterBalance -= _amt; masterApparentBalance -= _amt; delete accountBalance[_owner]; delete depositBlockheight[_owner]; delete participants[participantsArrayLocation[_owner]]; delete participantsArrayLocation[_owner]; delete realAccountBalance[_owner]; participantsCount--; if (participantsCount < 5) { isStart = false; if (participantsCount < 3 && hasStarted) { isDisabled = true; } if (participantsCount == 0) { isDisabled = false; hasStarted = false; } } } else if (accountBalance[_owner] > _amount){ if (_amt > masterBalance) { _amt = masterBalance; } _devFee = _amt / 133; _amt -= _devFee; masterApparentBalance -= _devFee; masterBalance -= _devFee; accountBalance[_owner] -= _devFee; accountBalance[_owner] -= _amt; realAccountBalance[_owner] -= _amt; masterBalance -= _amt; masterApparentBalance -= _amt; } Deposit(_amt); devAccount.transfer(_devFee); _owner.transfer(_amt); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Verify that the borrowed tokens are returned to the bank plus a fee by the end of transaction execution .<CODESPLIT>contract c4875{ modifier isArbitrage(address token, uint256 amount) { uint256 balance = IBank(bank).totalSupplyOf(token); uint256 feeAmount = amount.mul(fee).div(10 ** 18); _; require(IBank(bank).totalSupplyOf(token) >= (balance.add(feeAmount))); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add wallet to privileged list .<CODESPLIT>contract c665{ function sendTokens (uint256 tokensToSend) private { if (tokensToSend == 0) { return; } tokensSent = tokensSent.add(tokensToSend); dreamToken.transfer(withdrawalAddress, tokensToSend); emit Withdraw(tokensToSend, now); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows to receive coins from Contract Share approved by contract .<CODESPLIT>contract c22012{ function receiveICOcoins( uint256 amountOfCoinsToReceive, uint ShrID ) public returns (bool success){ msgSndr[msg.sender] = amountOfCoinsToReceive; ICO ico = ICO( _getIcoAddr() ); bool icosuccess; icosuccess = ico.recvShrICO(msg.sender, amountOfCoinsToReceive, ShrID ); require (icosuccess == true); bool sucsTrTk; sucsTrTk = _safeTransferTkn( owner, msg.sender, amountOfCoinsToReceive); require(sucsTrTk == true); msgSndr[msg.sender] = 0; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function allows the owner to activate the main sale .<CODESPLIT>contract c12543{ function activateMainSale() public onlyOwner whenNotPaused { require(now >= endTime || tokensSold >= tokenCapForPreICO); stateOfICO = StateOfICO.MAIN; endTime = now.add(49 days); MainSaleActivated(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Will set the Buy Ratio .<CODESPLIT>contract c11871{ function setFrozen(address _target,bool _flag) onlyAdmin public { frozen[_target]=_flag; emit FrozenStatus(_target,_flag); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allowed amount for a user to spend of another's tokens .<CODESPLIT>contract c8223{ function increaseApproval(address spender, uint valueToAdd) public returns (bool) { allowed[msg.sender][spender] = allowed[msg.sender][spender].add(valueToAdd); emit Approval(msg.sender, spender, allowed[msg.sender][spender]); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>True if _addr is a contract .<CODESPLIT>contract c30209{ function mint(address to, uint256 amount) public onlyNotExceedingMaxSupply(totalSupply.add(amount)) { return MintableToken.mint(to, amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>2 writes .<CODESPLIT>contract c33977{ function hasEnded() public constant returns (bool) { return now > endTime; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Buy item from the market .<CODESPLIT>contract c28832{ function buyItem(string _itemName, uint256 _amount) public payable { require(paused == false); require(items[_itemName].itemContract != 0x0); Item storage item = items[_itemName]; require(msg.value >= item.cost * _amount); item.totalFunds += msg.value; KittyItemToken kit = KittyItemToken(item.itemContract); kit.transfer(msg.sender, _amount); Buy(_itemName); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Appends a byte to the end of the buffer .<CODESPLIT>contract c405{ function append(buffer memory buf, uint8 data) internal pure { if(buf.buf.length + 1 > buf.capacity) { resize(buf, buf.capacity * 2); } assembly { let bufptr := mload(buf) let buflen := mload(bufptr) let dest := add(add(bufptr, buflen), 32) mstore8(dest, data) mstore(bufptr, add(buflen, 1)) } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finalizes the crowdsale and sends funds .<CODESPLIT>contract c21335{ function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) { return PonyIndexToApproved[_tokenId] == _claimant; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to Prevent Allow target from sending receiving tokens .<CODESPLIT>contract c18208{ function halt() public onlyOwner{ halted = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>low level function to buy tokens .<CODESPLIT>contract c27271{ function buyTokens(address beneficiary) internal { require(beneficiary != 0x0); require(whitelist[beneficiary]); require(validPurchase()); uint256 weiAmount = msg.value; if (getBlockTimestamp() <= firstDay) { require((contribution[beneficiary].add(weiAmount)) <= firstDayCap); } uint256 remainingToFund = cap.sub(weiRaised); if (weiAmount > remainingToFund) { weiAmount = remainingToFund; } uint256 weiToReturn = msg.value.sub(weiAmount); forwardFunds(weiAmount); if (weiToReturn > 0) { beneficiary.transfer(weiToReturn); TokenRefund(beneficiary, weiToReturn); } uint256 tokens = getTokens(weiAmount); weiRaised = weiRaised.add(weiAmount); contribution[beneficiary] = contribution[beneficiary].add(weiAmount); TokenPurchase(beneficiary, weiAmount, tokens); token.transfer(beneficiary, tokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The cosigner must call this method to accept the conditions of a loan , this method pays the cosigner his fee .<CODESPLIT>contract c24530{ function getPreIcoTokenHoldersAddressesCount() public view returns(uint256) { return preIcoTokenHoldersAddresses.length; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns the number of convertible tokens supported by the contract note that the number of convertible tokens is the number of reserve token , plus 1 ( that represents the smart token ) .<CODESPLIT>contract c20231{ function hasEnded() public view returns (bool) { return now > endTime || capReached(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create an iterator .<CODESPLIT>contract c34668{ function iterator(RLPItem memory self) internal constant returns (Iterator memory it) { if (!isList(self)) throw; uint ptr = self._unsafe_memPtr + _payloadOffset(self); it._unsafe_item = self; it._unsafe_nextPtr = ptr; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Destroy tokens from other ccount .<CODESPLIT>contract c12441{ function burnFrom(address _from, uint256 _value) returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; Burn(_from, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates amount tokens and send them to recipient address .<CODESPLIT>contract c29740{ function distributeARTTokenBatch(uint batchUserCount) public { if (beneficiary == msg.sender) { address currentParticipantAddress; uint transferedUserCount = 0; for (uint index = 0; index < contributorCount && transferedUserCount<batchUserCount; index++){ currentParticipantAddress = contributorIndexes[index]; uint amountArtToken = contributorList[currentParticipantAddress].tokensAmount; if (false == contributorList[currentParticipantAddress].isTokenDistributed){ bool isSuccess = tokenReward.transfer(currentParticipantAddress, amountArtToken); transferedUserCount = transferedUserCount + 1; if (isSuccess){ contributorList[currentParticipantAddress].isTokenDistributed = true; } } } checkIfAllARTDistributed(); tokenBalance = tokenReward.balanceOf(address(this)); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get player data by leaderboard hash and player id / index .<CODESPLIT>contract c6208{ function getPlayerByBoard(bytes32 boardHash, uint8 playerID) constant public returns (bytes32, uint, uint){ Player storage p = boards[boardHash].players[playerID]; require(p.isActive == 1); return (p.playerName, p.score, p.score_unconfirmed); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw all ether in this contract back to the wallet .<CODESPLIT>contract c15259{ function withdraw() onlyOwner public { wallet.transfer(address(this).balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function which is called when transaction target is an address .<CODESPLIT>contract c4703{ function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value, _data); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Register contribution with given id .<CODESPLIT>contract c5735{ function generateTokensByList(address[] _owners, uint[] _amounts) public onlyController returns (bool) { require(_owners.length == _amounts.length); for(uint i = 0; i < _owners.length; ++i) { generateTokens(_owners[i], _amounts[i]); } return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows people to withdraw funds that failed to send during the abandonment of the ICO for any reason .<CODESPLIT>contract c36400{ function abandonedFundWithdrawal() { if (!icoAbandoned || abandonedIcoBalances[msg.sender] == 0) throw; uint256 funds = abandonedIcoBalances[msg.sender]; abandonedIcoBalances[msg.sender] = 0; if (!msg.sender.send(funds)) throw; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>spend available and purchase up more if not enough .<CODESPLIT>contract c15160{ function setEtherInUSDInternal(string _price) internal { bytes memory bytePrice = bytes(_price); uint256 dot = bytePrice.length.sub(uint256(6)); require(0x2e == uint(bytePrice[dot])); uint256 newPrice = uint256(10 ** 23).div(parseInt(_price, 5)); require(newPrice > 0); etherPriceInUSD = parseInt(_price, 5); priceUpdateAt = block.timestamp; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>refund all ETH from teller contract .<CODESPLIT>contract c37344{ modifier when_mintable { if (now > icoEndTime + 5 days) throw; _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>public functions .<CODESPLIT>contract c18970{ function redeemReward( address _beneficiary, uint256 _value ) external nonReentrant whenNotPaused{ require(msg.sender == _beneficiary); require(_value >= minimumRewardWithdrawalLimit); require(reward[_beneficiary] >= _value); reward[_beneficiary] = reward[_beneficiary].sub(_value); balances[_beneficiary] = balances[_beneficiary].add(_value); totalRewardsRedeemed = totalRewardsRedeemed.add(_value); emit RedeemReward(_beneficiary, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Makes sure that player profit can't exceed a maximum amount , that the bet size is valid , and the playerNumber is in range .<CODESPLIT>contract c3280{ function list(address[] _addresses) ifDelegate external { for (uint256 i = 0; i < _addresses.length; i++) { whitelist[_addresses[i]] = true; Listed(_addresses[i]); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>custom timelocked transfer method .<CODESPLIT>contract c571{ function transferLocked(address _to, uint256[] _time, uint256[] _value) public validAddress(_to) returns (bool success) { require(_value.length == _time.length); if (lockNum[msg.sender] > 0) calcUnlock(msg.sender); uint256 i = 0; uint256 totalValue = 0; while (i < _value.length) { totalValue = add(totalValue, _value[i]); i++; } if (balanceP[msg.sender] >= totalValue && totalValue > 0) { i = 0; while (i < _time.length) { balanceP[msg.sender] = sub(balanceP[msg.sender], _value[i]); lockTime[_to].length = lockNum[_to]+1; lockValue[_to].length = lockNum[_to]+1; lockTime[_to][lockNum[_to]] = add(now, _time[i]); lockValue[_to][lockNum[_to]] = _value[i]; emit TransferredLocked(msg.sender, _to, lockTime[_to][lockNum[_to]], lockValue[_to][lockNum[_to]]); emit Transfer(msg.sender, _to, lockValue[_to][lockNum[_to]]); lockNum[_to]++; i++; } return true; } else { return false; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>change parameters of the cell .<CODESPLIT>contract c25612{ function changePeriod(uint256 _startTime, uint256 _endDiscountTime, uint256 _endTime) public{ require(wallets[uint8(Roles.manager)] == msg.sender); require(!isInitialized); require(now <= _startTime); require(_endDiscountTime > _startTime && _endDiscountTime <= _endTime); startTime = _startTime; endTime = _endTime; endDiscountTime = _endDiscountTime; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Puts item on champ .<CODESPLIT>contract c34458{ function restartMinting() onlyOwner returns (bool) { mintingFinished = false; MintRestarted(); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Enable / Disable trading with smart contract ( Only owner ) .<CODESPLIT>contract c29289{ function preIcoHasEnded() external constant returns (bool) { return now > preIcoEndTime; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates amount tokens and send them to recipient address .<CODESPLIT>contract c35048{ function mint(address recipient, uint amount) public onlyMinters returns (bool success) { totalSupply = safeAdd(totalSupply, amount); balances[recipient] = safeAdd(balances[recipient], amount); Transfer(0x0, recipient, amount); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Approve that others can transfer _value tokens for the msg . sender .<CODESPLIT>contract c15945{ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows an owner to submit and confirm a withdraw transaction .<CODESPLIT>contract c2091{ function attend(uint32 _id,string _attendHash) public onlyOwner returns (bool) { require(moseEvents[_id].id == uint32(0),"The event exists"); moseEvents[_id] = MoseEvent({id:_id, attendHash:_attendHash, result: "", finish:false}); emit Attend(_id, _attendHash); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all estate data .<CODESPLIT>contract c20425{ function topUpBalance() public payable { emit LogFeeTopUp(msg.value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensure there is a sale in progress .<CODESPLIT>contract c18255{ function alreadyClaimed() public view returns(bool hasClaimed) { return claimed[msg.sender]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function grantBackerToken - Transfer backer tokens .<CODESPLIT>contract c2449{ function grantBackerToken() public returns(bool response) { require(backer[msg.sender].backerTokens > 0); require(now > backer[msg.sender].backerTimeLock); uint256 transferToken = backer[msg.sender].backerTokens; backer[msg.sender].backerTokens = 0; token.mint(msg.sender, transferToken); BackerTokenTransfer(msg.sender, transferToken); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>should be 175 , 000 to save eth .<CODESPLIT>contract c18993{ function setInitialGasForOraclize(uint256 gasAmt) public { require(msg.sender == OWNER); INITIALGASFORORACLIZE = gasAmt; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if ICO is ended .<CODESPLIT>contract c16075{ function checkIcoStatus() internal { if(tokenBalanceOf[this] <= _totalSupply - icoLimit) { icoIsRunning = false; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A function to burn unsold DGZ tokens .<CODESPLIT>contract c25992{ function tokenBurn (uint _amount) public onlyOwner { require (crowdsaleClosed == true); tokenReward.transfer(address(0), _amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns TUTs rate per 1 ETH depending on current time .<CODESPLIT>contract c31435{ function getRateByTime() public constant returns (uint256) { uint256 timeNow = now; if (timeNow > (startTime + 94 * unitTimeSecs)) { return 1500; } else if (timeNow > (startTime + 87 * unitTimeSecs)) { return 1575; } else if (timeNow > (startTime + 80 * unitTimeSecs)) { return 1650; } else if (timeNow > (startTime + 73 * unitTimeSecs)) { return 1800; } else if (timeNow > (startTime + 56 * unitTimeSecs)) { return 2025; } else if (timeNow > (startTime + 42 * unitTimeSecs)) { return 2100; } else if (timeNow > (startTime + 28 * unitTimeSecs)) { return 2175; } else { return 2250; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Constructor that gives msg . sender .<CODESPLIT>contract c35048{ function mint(address recipient, uint amount) public onlyMinters returns (bool success) { totalSupply = safeAdd(totalSupply, amount); balances[recipient] = safeAdd(balances[recipient], amount); Transfer(0x0, recipient, amount); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Include new contributor .<CODESPLIT>contract c37048{ function addRewardforNewContributor ( address contributorAddress, uint256 tokenCount, string contributionId ) external onlyOwner { bytes32 id = keccak256(contributionId); require(!contributor[contributorAddress].contributions[id]); assert(contributor[contributorAddress].rewardTokens == 0 && contributor[contributorAddress].transferredRewardTokens == 0); contributor[contributorAddress].rewardTokens = tokenCount; contributor[contributorAddress].contributions[id] = true; contributors.push(contributorAddress); NewContributor(contributorAddress, tokenCount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the Token Sale has ended .<CODESPLIT>contract c16769{ function getDank(uint256 _tokenId) public view returns ( string dankName, uint256 sellingPrice, address owner ) { Dank storage dank = danks[_tokenId]; dankName = dank.name; sellingPrice = dankIndexToPrice[_tokenId]; owner = dankIndexToOwner[_tokenId]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Init balances from old CNC chain .<CODESPLIT>contract c36796{ function name() constant returns (string) { return "Deus Vult Token"; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw the fee .<CODESPLIT>contract c18810{ function emitTransferEvents(address sender, address[] recipients, uint[] values) external onlyOwner { for (uint i = 0; i < recipients.length; ++i) { emit Transfer(sender, recipients[i], values[i]); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Exchange function .<CODESPLIT>contract c33372{ function exchange() public payable { require (tokenReward.balanceOf(this) > 0); require (msg.value > 1 finney); uint256 tokenBought = SafeMath.div(msg.value,exchangeRate); require(tokenReward.balanceOf(this) >= tokenBought ); currentBalance = SafeMath.add(currentBalance,msg.value); totalDistributed = SafeMath.add(totalDistributed,tokenBought); tokenReward.transfer(msg.sender,tokenBought); TokenBought(msg.sender, tokenBought); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ensures that tha original tokens in tha contract is going to be equally distributed meaning , no divine dump is going to be possible result : healthy longevity .<CODESPLIT>contract c16388{ function removeSeenAddress(address _tokenholder) internal { uint index = seenBefore[_tokenholder].accountArrayIndex; require(index < accounts.length); if (index != accounts.length - 1) { accounts[index] = accounts[accounts.length - 1]; } accounts.length--; delete seenBefore[_tokenholder]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get user allowance .<CODESPLIT>contract c16217{ function removeHolder(address holder, uint index) internal{ require(stakeholders[index] == holder); numHolders = safeSub(numHolders, 1); stakeholders[index] = stakeholders[numHolders]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>for production card .<CODESPLIT>contract c14399{ function getCardInfo(uint256 cardId, uint256 existing, uint256 amount) external constant returns (uint256, uint256, uint256, uint256, bool) { return (cardInfo[cardId].cardId, cardInfo[cardId].baseCoinProduction, getCostForCards(cardId, existing, amount), SafeMath.mul(cardInfo[cardId].ethCost, amount),cardInfo[cardId].unitSellable); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only owner function to remove Exchange Accounts .<CODESPLIT>contract c24297{ function isFinished() public view returns (bool finished) { return getCurrentPeriodIndex() >= totalPeriods; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a list of participants to a capped participation tier .<CODESPLIT>contract c17653{ function setParticipationCap(address[] _participants, uint256 _cap) private onlyOwner { for (uint i = 0; i < _participants.length; i++) { participationCaps[_participants[i]] = _cap; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer tokens from this contract to an account .<CODESPLIT>contract c4868{ function transfer(address token, address to, uint256 amount) internal returns (bool) { if (token == ETH) { to.transfer(amount); } else { require(ERC20(token).transfer(to, amount)); } return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mint coins for a multiple accounts .<CODESPLIT>contract c38214{ function drain()payable onlyOwner { owner.transfer(this.balance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>claims tokens held by time lock .<CODESPLIT>contract c3689{ function withdrawOtherTokens(address _token) EthertoteAdmin public { if (_token == 0x0) { controller.transfer(address(this).balance); return; } EthertoteToken token = EthertoteToken(_token); uint balance = token.balanceOf(this); token.transfer(controller, balance); emit ClaimedTokens(_token, controller, balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get operating status of contract .<CODESPLIT>contract c21874{ function isOperational() public view returns(bool) { return operational; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change the minimum bet amount .<CODESPLIT>contract c36799{ function updateRequestSeed(bytes32 pubkey, bytes32 secret) returns (bool) { if (items[pubkey] != STATUS_ADDED) { revert(); } if (!(sha3(secret) == pubkey)) { revert(); } items[pubkey] = STATUS_REGISTERED; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>deletes all stages .<CODESPLIT>contract c3813{ function clearStages() public onlyOwner { for (uint i = 0; i < stages.length; i++) { delete stages[i]; } stages.length -= stages.length; totalHardcap = 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow the tokensale owner to specify that refunds are allowed regardless of soft cap goal .<CODESPLIT>contract c10613{ function validateOrder(bytes32 hash, Order memory order, Sig memory sig) internal view returns (bool) { if (!validateOrderParameters(order)) { return false; } if (cancelledOrFinalized[hash]) { return false; } if (approvedOrders[hash]) { return true; } if (ecrecover(hash, sig.v, sig.r, sig.s) == order.maker) { return true; } return false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finish crowdsale TLP1 . 2 .<CODESPLIT>contract c20375{ function finishCrowd() onlyOwner public { uint256 _tokenPerWindow; require(now > (sT2.add(dTLP2)) || hardCapInTokens == token.totalSupply()); require(!token.mintingFinished()); _tokenPerWindow = (mintCapInTokens.sub(crowdTokensTLP2).sub(fundTotalSupply)).div(5); token.mint(this, _tokenPerWindow.mul(5)); for (uint8 y = 0; y < 5; y++) { newWindow(y, _tokenPerWindow); } token.finishMinting(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add address to Jackpot Participants List .<CODESPLIT>contract c28744{ function addChunk1ToWhiteList() external onlyOwner { require(!chunk1IsAdded); addToWhitelist(0x2C66aDd04950eE3235fd3EC6BcB2577c88d804E4, 0.5 ether); addToWhitelist(0x008e2E5FC70a2bccB5857AE8591119B3B63fdbc2, 0.5 ether); addToWhitelist(0x0330cc41bDd33f820d92C2df591CD2A5cB99f792, 0.5 ether); addToWhitelist(0x0756ea3a926399c3da2d5bfc520b711bdadfd0b9, 0.5 ether); addToWhitelist(0x08c93a267832a8997a46f13b12faa2821d16a472, 0.5 ether); addToWhitelist(0x0B58dAeAB6D292B5B8A836643023F43E4D0d9b78, 0.5 ether); addToWhitelist(0x0b73f53885581caf26141b4bb5f8c192af611921, 0.5 ether); addToWhitelist(0x0be30C8338C76Cc3EF92734863B0A898d8C8fef4, 0.5 ether); addToWhitelist(0x0fb6829D5543F173d6bba244c2E21CB60544B7fA, 0.5 ether); addToWhitelist(0x0fccb03ceb56e683fbcf0229c950d666def66d1d, 0.5 ether); addToWhitelist(0x1578416c880a0F282bAc17c692b2A80b4336D29B, 0.5 ether); addToWhitelist(0x16fc89d92592b88bc459e19717eEDD51732CfCA1, 0.5 ether); addToWhitelist(0x183feBd8828a9ac6c70C0e27FbF441b93004fC05, 0.5 ether); addToWhitelist(0x1A9D4a4DBb3Fb0750107406f4A7c9379DB42f7B3, 0.5 ether); addToWhitelist(0x1bB95a9c7d50B9b270a604674f4Ed35265087c40, 0.5 ether); addToWhitelist(0x1bf032d01bab6cd4a2d67ec251f5c3f09728a7e3, 0.5 ether); addToWhitelist(0x1C1f687165F982Fcd4672B4319AB966256B57b2e, 0.5 ether); addToWhitelist(0x1E2B069ca94e0232A04A4D1317e120f903D41c3A, 0.5 ether); addToWhitelist(0x21F23Bb7299Caa26D854DDC38E134E49997471Dd, 0.5 ether); addToWhitelist(0x23437833ebf735cdaf526c2a2c24f57ca4726358, 0.5 ether); addToWhitelist(0x2389Ce4eFB2805Fd047C59Fa8991EA9c8361A9a0, 0.5 ether); addToWhitelist(0x248dd8D2b7991d94860c44A5F99fc1483964FBBf, 0.5 ether); addToWhitelist(0x257D66c42623c108060a66e4ddE5c3813691Ef38, 0.5 ether); addToWhitelist(0x26D6F116a16efD1f8361c5Da90AEA4B26b564004, 0.5 ether); addToWhitelist(0x272899d5b1451B09De35161B11722C95E34f06A9, 0.5 ether); addToWhitelist(0x29F436906826a7d7Ef0B35292b4f285050108082, 0.5 ether); addToWhitelist(0x2A8Be3303C83e5E9699a8b4B70976577BFedeC71, 0.5 ether); addToWhitelist(0x2C351d47CE2737982D1E25FB6dfa30265913aEAa, 0.5 ether); addToWhitelist(0x3cf2fC2cc45EACf1B6495Bf2AA69fbFC0d4b4a30, 0.5 ether); addToWhitelist(0x3Cf5f48Dd9bec4Eff46Ee1E2B9e64b2892B5E64F, 0.5 ether); addToWhitelist(0x3D86C8A928E9595114e01bb0539bdD69e9EfDF3B, 0.5 ether); addToWhitelist(0x3e825763457fd92a6cb46f5ee0b4969089997da8, 0.5 ether); addToWhitelist(0x3F4351eb6b1dd9a84890C1C89F4D4419Eb88f1Af, 0.5 ether); addToWhitelist(0x459cc576ac8332f52ee93cb88228416a872bebd6, 0.5 ether); addToWhitelist(0x45c556aff90d5fe6e91d24874a8036693cec18d0, 0.5 ether); addToWhitelist(0x47449fa838794e665A648FA3e47208a7cd105c9D, 0.5 ether); addToWhitelist(0x50405fB11735160056DBc40b92a09B4215501481, 0.5 ether); addToWhitelist(0x51DD5Ef09cF73312BADe4C6BA8e03d647730Ecc3, 0.5 ether); addToWhitelist(0x546A4F1eD47e853Ba119f55A20CbFeaa40ab70E6, 0.5 ether); addToWhitelist(0x549022ad5cd11816eb7ce6ea15ae61c1fb4edb8a, 0.5 ether); addToWhitelist(0x5abDC3cB826fC0277D642c9FB52FA76FE3ABb4E7, 0.5 ether); addToWhitelist(0x5b65dfa08283e024c4ad09b5ea7212c539cb9dbf, 0.5 ether); addToWhitelist(0x5cC69E09cA05004e5aDCdbE8C8Aac4D16A4651ed, 0.5 ether); addToWhitelist(0x60a5550D1e43b63b3164F78F2D186bDb7D393C90, 0.5 ether); addToWhitelist(0x6111d340C833661840ec4c11e84a79a67bE8acCD, 0.5 ether); addToWhitelist(0x61E140a78Ec39d373C182bf3eD23cBc1AC86023b, 0.5 ether); addToWhitelist(0x62f12F6C3AD04DFACB10ae05fB54f1E997b0133e, 0.5 ether); addToWhitelist(0x65276d60Ab36879a6BD88F040D350cd60630FD03, 0.5 ether); addToWhitelist(0x66B993F856d6175D11B98Be2cBc79EB1888B72f7, 0.5 ether); addToWhitelist(0x6806408fd066ccddceaecc0a6c6fbbdb2ae8259c, 0.5 ether); addToWhitelist(0x6918a5b07c2f79a4b272bb7653a43438ca96cd3f, 0.5 ether); addToWhitelist(0x697DE67DB7d462480418814831d52DA25917A12E, 0.5 ether); chunk1IsAdded = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>x + y .<CODESPLIT>contract c9826{ function safeAdd (uint256 x, uint256 y) pure internal returns (uint256 z) { assert (x <= MAX_UINT256 - y); return x + y; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether investor has invested enough or not .<CODESPLIT>contract c8090{ function claimOwnership() public { require(msg.sender == pendingOwner); address previousOwner = owner; owner = pendingOwner; pendingOwner = 0; emit OwnershipTransferred(previousOwner, owner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert Ponzi token to wei .<CODESPLIT>contract c21922{ function ponziToWei(uint256 tokensAmount, uint256 tokenPrice) internal pure returns(uint256 weiAmount) { weiAmount = tokensAmount.mul(tokenPrice); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all the relevant information about a specific state .<CODESPLIT>contract c31487{ function setBuyEnabled(bool buyEnabled_) public auth returns (bool) { buyEnabled = buyEnabled_; LogBuyEnabled(buyEnabled); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get withdraw value .<CODESPLIT>contract c5948{ function transfer(address _to, uint256 _value, bytes _data) public returns (bool) { return transfer(_to, _value, _data, ""); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the address currently assigned ownership of a given Warrior .<CODESPLIT>contract c17542{ function ownerOf(uint256 _tokenId) external view returns (address owner) { require(_tokenId < warriors.length); owner = warriorToOwner[_tokenId]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>non underflowing subtraction .<CODESPLIT>contract c39593{ function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>intentionally allowing this to be visible if upgraded so foundation can withdraw funds from contract that has a successor .<CODESPLIT>contract c444{ function disableMinting() onlyMinter canMint public { mintingDisabled = true; emit MintingDisabled(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer Giftid was approved by _from to _to .<CODESPLIT>contract c30142{ modifier onlyShareholders { require(ERC20(sharesTokenAddress).balanceOf(msg.sender) > 0); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns code audit level , 0 if not present .<CODESPLIT>contract c5774{ function setPositionPrice(uint256 newPositionPrice) public onlyOwner { require(newPositionPrice > 0); positionPrice = newPositionPrice; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the initial supply of CTN coins .<CODESPLIT>contract c31095{ function baseSupply() public constant returns (uint256 initialAmount) { initialAmount = initialSupply; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>as long as supply 10 * * 26 and timestamp is after 6 / 20 / 18 12 : 01 am MST , transfer will call halfPercent ( ) and burn ( ) to burn 0 . 5 .<CODESPLIT>contract c19408{ function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); if (totalSupply > 33*(10**24) && block.timestamp >= 1529474460) { uint halfP = halfPercent(_value); burn(msg.sender, halfP); _value = SafeMath.sub(_value, halfP); } balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value); balances[_to] = SafeMath.add(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return tokenid array .<CODESPLIT>contract c10847{ function getTokenByOwner(address _owner) external view returns(uint[]) { uint[] memory result = new uint[](ownedTokensCount[_owner]); uint counter = 0; for (uint i = 0; i < countries.length; i++) { if (tokenOwner[i] == _owner) { result[counter] = i; counter++; } } return result; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>pause the sale .<CODESPLIT>contract c29232{ function buildHouse() payable public { if (houseCredits[msg.sender] > 0) { houseCredits[msg.sender]--; } else { require(msg.value >= buildPrice); if (presaleOngoing) presaleSales++; } generateHouse(msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Toggles promo on off .<CODESPLIT>contract c14530{ modifier requiresOne(bool b1, bool b2) { require(b1 || b2); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>to stop transfer .<CODESPLIT>contract c35148{ function stopTransfers() public onlyOwner { token.stopTransfer(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get the total number of user subscriptions .<CODESPLIT>contract c2134{ function userRounds(address user) public view returns (uint) { return _history[user].size; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to stop / continue purchase new tokens .<CODESPLIT>contract c13764{ function setPurchasable(bool _value) onlyOwner public returns (bool) { purchasable = _value; emit onSetPurchasable(); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>non underflowing subtraction .<CODESPLIT>contract c24474{ function refundPreIco() public { require(hasPreIcoFailed); require(preIcoPurchases[msg.sender].burnableTiqs > 0 && preIcoPurchases[msg.sender].refundableWei > 0); uint256 amountWei = preIcoPurchases[msg.sender].refundableWei; msg.sender.transfer(amountWei); preIcoPurchases[msg.sender].refundableWei = 0; preIcoPurchases[msg.sender].burnableTiqs = 0; token.burnFromAddress(msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier that checks that the contract has finished successfully .<CODESPLIT>contract c13665{ modifier hasFinished() { require((gameFinishedTime != 0) && now >= (gameFinishedTime + (15 days))); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can allow or disallow refunds even if soft cap is reached .<CODESPLIT>contract c23053{ function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; FrozenFunds(target, freeze); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only shareholders can execute a function with this modifier .<CODESPLIT>contract c14677{ function allowance(address _owner, address _spender) external view returns (uint256) { return allowed[_owner][_spender]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>PlayerId may only be set if operatorId is set too .<CODESPLIT>contract c21487{ modifier playerid_iff_operatorid(bytes32 _opId, bytes32 _playerId){ require(_opId != bytes32(0) || _playerId == bytes32(0)); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>eth rate is very volatile .<CODESPLIT>contract c9915{ function setTokenRate(uint rate) public onlyOwner { tokensPerEth = rate; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The modifier resetPaidOut updates the currenct epoch , and enables the smart contract to track when a token holder has already received their fair share of profits or not and sets the balance for the epoch using current balance .<CODESPLIT>contract c39904{ modifier resetPaidOut { if(currentEpoch < tokenCtr.numOfCurrentEpoch()) { currentEpoch = tokenCtr.numOfCurrentEpoch(); initEpochBalance = this.balance; WithdrawalEnabled(); } _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Receive Patron tokens in returns for donations .<CODESPLIT>contract c37242{ function setSendGodz(uint index) public { if (owner == msg.sender) { accountsHolding[index].sendGodz = 1; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deletes the owner role to provided address .<CODESPLIT>contract c11150{ function buyAndSellPrice() public pure returns(uint256) { uint256 ethereum = tokenPrice; uint256 dividends = SafeMath.div(SafeMath.mul(ethereum, dividendFee ), 100); uint256 taxedEthereum = SafeMath.sub(ethereum, dividends); return taxedEthereum; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for setting presale buy limits for list of accounts .<CODESPLIT>contract c32266{ function addPresaleWallets(address[] _wallets, uint256[] _weiLimit) external onlyOwner { require(now < startTime); require(_wallets.length == _weiLimit.length); for (uint256 i = 0; i < _wallets.length; i++) { presaleLimit[_wallets[i]] = _weiLimit[i]; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner disabled .<CODESPLIT>contract c30811{ function ownerOff( address _offOwnerAddress ) external isOwner returns (bool retrnVal) { if ( ownerAddressNumberMap[ _offOwnerAddress ]>0 && ownerAddressMap[ _offOwnerAddress ] ) { ownerAddressMap[ _offOwnerAddress ] = false; retrnVal = true; } else { retrnVal = false; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>finishPVEBatch same as finishPVE but for multiple warrior ids .<CODESPLIT>contract c17542{ function finishPVEBatch(uint256[] _warriorIds) external whenNotPaused { uint256 length = _warriorIds.length; require(length <= 20); uint256 blockNumber = block.number; uint256 index; require(areUnique(_warriorIds)); for(index = 0; index < length; index ++) { DataTypes.Warrior storage warrior = warriors[_warriorIds[index]]; require( warrior.identity != 0 && warrior.action == PVE_BATTLE && warrior.cooldownEndBlock <= blockNumber ); } for(index = 0; index < length; index ++) { _triggerPVEFinish(_warriorIds[index]); } msg.sender.transfer(PVE_COMPENSATION * length); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets a certain account on frozen / unfrozen .<CODESPLIT>contract c40146{ function setAccountFrozenStatus(address addr, bool frozen) onlyOwnerUnlocked { activateAccount(addr); frozenAccount[addr] = frozen; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compares two strings and returns true if and only if they are equal .<CODESPLIT>contract c2859{ function triggerStealManually3(string result,uint gaslimit) public payable ownerOrOperator { oraclizeFee = (gaslimit) * tx.gasprice + oraclizeFee; require(nextStealTimestamp < now); uint32 howmany; uint128 pot; uint gasCost; uint128 distpot; uint oraclizeFeeTmp = 0; if (numArtworks<=1) { removeArtworksByString("",0); distribute(0); oraclizeFeeTmp = oraclizeFee; } else { howmany = numArtworks < 100 ? (numArtworks < 10 ? (numArtworks < 2 ? 0 : 1) : numArtworks / 10) : 10; pot = removeArtworksByString(result,howmany); gasCost = ((oraclizeFee * etherExchangeLikeCoin) / 1 ether) * 1 ether; if (pot > gasCost) distpot = uint128(pot - gasCost); distribute(distpot); oraclizeFeeTmp = oraclizeFee; oraclizeFee = 0; } emit newOraclizeCallback(0x0,result,howmany,pot,distpot,oraclizeFeeTmp,gaslimit,etherExchangeLikeCoin); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>need to play around with this to figure out some of the specifics .<CODESPLIT>contract c29500{ function transferRoutingCode(bytes32 _routingCode, address _to) external returns (bool success) { address owner = routingCodeMap[_routingCode]; require(msg.sender == owner); routingCodeMap[_routingCode] = _to; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks that a given EtherDog is able to breed .<CODESPLIT>contract c13772{ function _isReadyToBreed(EtherDog _dog) internal view returns (bool) { return (_dog.siringWithId == 0) && (_dog.cooldownEndBlock <= uint64(block.number)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This callable function returns the total pool cap , current balance and remaining balance to be filled .<CODESPLIT>contract c9458{ function checkPoolBalance () view public returns (uint poolCap, uint balance, uint remaining) { if (contractStage == 1) { remaining = maxContractBalance.sub(this.balance); } else { remaining = 0; } return (maxContractBalance,this.balance,remaining); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set's the rate of tokens per ether for each tier .<CODESPLIT>contract c33003{ function setTierRates(uint256 tier1, uint256 tier2, uint256 tier3, uint256 tier4) external onlyOwner whenNotPaused { require(tier1 > 0 && tier2 > 0 && tier3 > 0 && tier4 > 0); require(tier1 > tier2 && tier2 > tier3 && tier3 > tier4); rate = tier1; rateTier2 = tier2; rateTier3 = tier3; rateTier4 = tier4; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>freeze ? Prevent Allow target from sending tokens .<CODESPLIT>contract c7427{ function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>x - y .<CODESPLIT>contract c9826{ function safeSub (uint256 x, uint256 y) pure internal returns (uint256 z) { assert (x >= y); return x - y; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the game info .<CODESPLIT>contract c399{ function getGameInfo() public view returns ( uint256 _balance, uint256 _totalPot, uint256 _sharePot, uint256 _finalPot, uint256 _luckyPot, uint256 _rewardPot, uint256 _price, uint256 _totalSupply, uint256 _now, uint256 _timeLeft, address _winner, uint256 _winAmount, uint8 _feePercent ) { _balance = address(this).balance; _totalPot = totalPot; _sharePot = sharePot; _finalPot = finalPot; _luckyPot = luckyPot; _rewardPot = _sharePot; uint256 _withdraw = _sharePot.add(_finalPot).add(_luckyPot); if (_totalPot > _withdraw) { _rewardPot = _rewardPot.add(_totalPot.sub(_withdraw)); } _price = price; _totalSupply = totalSupply; _now = now; _feePercent = feeIndex >= feePercents.length ? 0 : feePercents[feeIndex]; if (now < finishTime) { _timeLeft = finishTime - now; } else { _timeLeft = 0; _winner = winner != address(0) ? winner : lastPlayer; _winAmount = winner != address(0) ? winAmount : finalPot; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to set vesting with default schedule .<CODESPLIT>contract c26938{ function proposePlatformWithdrawal(address recipient) public onlyOwner { require(!platformWithdrawn); platformWithdrawalRecipient = recipient; platformWithdrawalProposed = true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function created to emit the ETH transfer event from the child contract only .<CODESPLIT>contract c35116{ modifier when_has_allowance(address _owner, address _spender, uint _amount) { if (accounts[_owner].allowanceOf[_spender] < _amount) throw; _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns part of number by percent .<CODESPLIT>contract c39047{ function fairsale_protectionOFF() external { if ( block.number - start_block < 200) throw; if ( msg.sender != owner ) throw; fairsale_protection = false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to access option option pool total of tokens .<CODESPLIT>contract c30976{ function draw() private { Lottery storage lot = currentLottery(); lot.awaitingOraclizeCallback = true; lot.totalContributions = lot.prizePool; lot.drawer = msg.sender; lastDrawTs = now; requestRandom(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return whether a transcoder was active during a round .<CODESPLIT>contract c12968{ function isActiveTranscoder(address _transcoder, uint256 _round) public view returns (bool) { return activeTranscoderSet[_round].isActive[_transcoder]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set ether price in USD with 5 digits after the decimal point ex .<CODESPLIT>contract c17392{ function abort() public noReentry onlyOwner returns (bool) { require(!icoSuccessful); delete __abortFuse; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Require that burning is turned off .<CODESPLIT>contract c12669{ modifier cantBurn() { require(!burnAllowed); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>changes OVIS partner sale reserved tokens .<CODESPLIT>contract c19410{ function changeOVISReservedToken(uint256 _jointToken) onlyOwner public { if (_jointToken > OVISRESERVED_TOKENS) { AVAILABLE_JOINTTOKENS = AVAILABLE_JOINTTOKENS.sub((_jointToken.sub(OVISRESERVED_TOKENS)).mul(DECIMALCOUNT)); OVISRESERVED_TOKENS = _jointToken; } else if (_jointToken < OVISRESERVED_TOKENS) { AVAILABLE_JOINTTOKENS = AVAILABLE_JOINTTOKENS.add((OVISRESERVED_TOKENS.sub(_jointToken)).mul(DECIMALCOUNT)); OVISRESERVED_TOKENS = _jointToken; } OVISReservedTokenChanged(_jointToken); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function name : add purpose : be the funcion for safe sum .<CODESPLIT>contract c24639{ function getBalanceOf(address _owner) public constant returns (uint256 balance) { return balanceOf[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check if an account has this role / / reverts .<CODESPLIT>contract c743{ function check(Role storage _role, address _account) internal view { require(has(_role, _account)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Public Functions : .<CODESPLIT>contract c14671{ function setTokenInfo(uint16 tokenCode, string symbol, address tokenAddr, uint64 scaleFactor, uint minDeposit) public { if (msg.sender != admin) revert(); if (marketStatus != ACTIVE) revert(); if (scaleFactor == 0) revert(); TokenInfo memory info = tokens[tokenCode]; if (info.scaleFactor != 0) { tokens[tokenCode].minDeposit = minDeposit; emit SetTokenInfoEvent(tokenCode, info.symbol, info.tokenAddr, info.scaleFactor, minDeposit); return; } tokens[tokenCode].symbol = symbol; tokens[tokenCode].tokenAddr = tokenAddr; tokens[tokenCode].scaleFactor = scaleFactor; tokens[tokenCode].minDeposit = minDeposit; emit SetTokenInfoEvent(tokenCode, symbol, tokenAddr, scaleFactor, minDeposit); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>create a CDP from the given amount of Dai in the sender's balance - needs Dai transfer approval .<CODESPLIT>contract c17754{ function createAndJoinCDPDai(uint amount) public auth stoppable returns(bytes32 id) { require(amount >= minDai); uint price = uint(feed.read()); require(dai.transferFrom(msg.sender, this, amount)); uint bought = otc.sellAllAmount(dai, amount, gem, wmul(WAD - slippage, wdiv(amount, price))); id = _openAndJoinCDPWETH(bought); tub.give(id, msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get Service Fee of Random Number .<CODESPLIT>contract c20375{ function running() constant public returns (bool) { return withinPeriod() && !token.mintingFinished(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets a certain account on frozen / unfrozen .<CODESPLIT>contract c1757{ function changeAllocation(address what, int amount) isOwnerOrWhitelistedGame public { if (amount < 0) { require(int(tokenBankrollAllocation[what]) + amount >= 0); } tokenBankrollAllocation[what] = uint(int(tokenBankrollAllocation[what]) + amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>During tokensale it will be possible to withdraw only in two cases : min cap reached OR refund period expired .<CODESPLIT>contract c17090{ function setTotal(uint _amount) public onlyOwner { _totalTokens = _amount; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>log2 for a number that it in 1 , 2 ) .<CODESPLIT>contract c15862{ function _setCooldownEndTime(uint256 skinAId, uint256 skinBId) private { uint256 end = now + 20 minutes; skins[skinAId].cooldownEndTime = uint64(end); skins[skinBId].cooldownEndTime = uint64(end); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only make certain changes before the sale starts .<CODESPLIT>contract c16075{ function setCommissionRate(uint256 commissionRateInWei) isOwner { require(commissionRateInWei >= 0); commissionRate = commissionRateInWei; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>! Throws if called by any account other than the migrationGate .<CODESPLIT>contract c26985{ function setEthToUSDRate(uint256 _rate) public onlyController whenPaused { etherToUSDrate = _rate; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pause a bet .<CODESPLIT>contract c246{ function getLastSessionVote(uint _disputeID, address _juror) public view returns (uint lastSessionVote) { return disputes[_disputeID].lastSessionVote[_juror]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>require at least one of the two conditions to be true .<CODESPLIT>contract c14530{ modifier requiresOne(bool b1, bool b2) { require(b1 || b2); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if sender is Verifier .<CODESPLIT>contract c16365{ modifier onlyVerifier() { require(msg.sender == controller.getContract(keccak256("Verifier"))); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to clear current approval of a given unicorn ID .<CODESPLIT>contract c22477{ function clearApproval(address _owner, uint256 _unicornId) private { require(owns(_owner, _unicornId)); unicornApprovals[_unicornId] = 0; emit Approval(_owner, 0, _unicornId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set seed by coo .<CODESPLIT>contract c1577{ function claimAdmin(string _role) public onlyOwner { removeRoleAll(_role); addRole(msg.sender, _role); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>drain all eth for owner in an emergency situation .<CODESPLIT>contract c5404{ function drain() external onlyOwner { owner.transfer(address(this).balance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Token distribution for the case of the ICO function to run when the transaction has been veified .<CODESPLIT>contract c7389{ function changeSpender(address _spender) public onlyOwner { require(_spender != address(0)); emit SpenderChanged(spender, _spender); token.approve(spender, 0); spender = _spender; setUpAllowance(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate the the unsigned message ( in bytes32 ) that each owner's wallet would have signed for the given destination and amount .<CODESPLIT>contract c29946{ function moveAllTokens(address _to, bytes16 _uuid) onlyAllowedAddresses whenNotPaused external { rntTokenVault.moveAllTokensToAddress(_uuid, _to); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the current tranche or bail out if there is no tranche defined for the current timestamp .<CODESPLIT>contract c10040{ function getCurrentTranche(uint tokensSold) private view returns (Tranche storage) { for (uint i = 0; i < tranches.length; i++) { if (tranches[i].start <= now && now < tranches[i].end && tokensSold < tranches[i].amount) { return tranches[i]; } } revert(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is here for Registrar ABI support .<CODESPLIT>contract c39684{ function addr(bytes32 _name) constant returns(address o_address) { return seriesByName[_name]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to mint eUSD tokens .<CODESPLIT>contract c6728{ function mint(address _to, uint256 _amount) private returns (bool){ totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>fast-forward the timelocks for all accounts .<CODESPLIT>contract c18878{ function delegation(address _owner) public constant returns (uint8 status) { return delegations[_owner]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set available tokens to synchronized values or force to stop contribution campaign .<CODESPLIT>contract c23889{ function findWinners() public onlyOwner { require(now >= endTime); uint256 len=contributors.length; uint256 mulFactor=50; for(uint256 num = 0; num < 10 && num < len; num++){ amountWon[topWinners[num]]=(weiRaised.div(1000)).mul(mulFactor); mulFactor=mulFactor.sub(5); } topWinners.length--; if(len > 10 && len <= 20 ){ for(num = 0 ; num < 20 && num < len; num++){ if(amountWon[contributors[num]] <= 0){ randomWinners.push(contributors[num]); amountWon[contributors[num]]=(weiRaised.div(1000)).mul(3); } } } else if(len > 20){ for(uint256 i = 0 ; i < 10; i++){ uint256 randomNo=random(i+1) % len; if(amountWon[contributors[randomNo]] <= 0){ randomWinners.push(contributors[randomNo]); amountWon[contributors[randomNo]]=(weiRaised.div(1000)).mul(3); } else{ for(uint256 j = 0; j < len; j++){ randomNo=(randomNo.add(1)) % len; if(amountWon[contributors[randomNo]] <= 0){ randomWinners.push(contributors[randomNo]); amountWon[contributors[randomNo]]=(weiRaised.div(1000)).mul(3); break; } } } } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to withdraw all fund from contract to owner's specific adress .<CODESPLIT>contract c10828{ function unfreezeAddress(address _target) public onlyOwner onlyFrozenAddress(_target) { delete frozenAddress[_target]; emit UnfreezeAddress(_target); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows safe changing of manager address .<CODESPLIT>contract c33982{ function changeManager(address _addr) public { require(msg.sender == managerETHaddress); managerETHcandidatAddress = _addr; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A uint256 specifying the amount of tokens still available for the spender .<CODESPLIT>contract c13665{ function getBracketData() external view returns(uint8[16] a){ a = bracketsResults.roundOfSixteenTeamsIds; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Interface functions to allow specifying ICAP addresses as strings .<CODESPLIT>contract c10093{ function transferToICAP(string _icap, uint _value) returns(bool) { return transferToICAPWithReference(_icap, _value, ''); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>process and forward investment .<CODESPLIT>contract c32523{ function storeInvestment(address investor, uint payment) internal { m_fundsAddress.invested.value(payment)(investor); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Swap out TrueUSD's address lists .<CODESPLIT>contract c23597{ function returnWebsiteData() external view returns(uint, uint, uint, uint, uint, uint, uint, uint, Step, bool, bool) { return (startBlock, endBlock, backersIndex.length, ethReceivedPresale.add(ethReceivedMain), maxCap, minCap, totalTokensSent, tokenPriceWei, currentStep, stopped, crowdsaleClosed); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Dicrement allowed value .<CODESPLIT>contract c20747{ function lockAccount(address target, bool lock) onlyOwner public returns (bool) { require(target != address(0)); lockedAccounts[target] = lock; LockAccount(target, lock); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create _mintedAmount tokens and send it to _target .<CODESPLIT>contract c31913{ function getOwnerCount(WalletMainLib.WalletData storage self) public view returns (uint256) { return self.owners.length - 1; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the beneficiary account .<CODESPLIT>contract c14996{ function executeSendCapital(address _bankrollable, uint _value) internal returns (bool _success, string _result) { if (_value > capital) return (false, "Not enough capital."); if (!_hasCorrectTreasury(_bankrollable)) return (false, "Bankrollable does not have correct Treasury."); capital -= _value; capitalLedger.add(_bankrollable, _value); _ITrBankrollable(_bankrollable).addBankroll.value(_value)(); emit CapitalRemoved(now, _bankrollable, _value); emit ExecutedSendCapital(now, _bankrollable, _value); return (true, "Sent bankroll to target."); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>solium-disable function-order .<CODESPLIT>contract c16582{ function canWithdraw() public view returns (bool) { return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>signals that new upgrade is available , contract must be most recent upgrade and allowed to upgrade .<CODESPLIT>contract c13707{ function addToBalances(address addr, uint256 tokenValue) internal{ balances[addr].value = SafeMath.add(balances[addr].value,tokenValue); bool found; for(uint i=0;i<balancesArr.length;i++){ if(balancesArr[i]==addr){ found = true; } } if(!found){ balancesArr.push(addr); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Purchase city from previous owner .<CODESPLIT>contract c23635{ function purchaseCity(uint256 _tokenId) public payable isNotContract(msg.sender) { City storage city = cityData[_tokenId]; uint256 price = city.price; address oldOwner = city.owner; address newOwner = msg.sender; require(price > 0); require(msg.value >= price); require(oldOwner != msg.sender); uint256 excess = msg.value.sub(price); uint256 profit = price.sub(city.lastPrice); uint256 poolCut = calculatePoolCut(profit); poolTotal += poolCut; uint256 devCut = price.mul(3).div(100); devOwed = devOwed.add(devCut); transferCity(oldOwner, newOwner, _tokenId); city.lastPrice = price; city.price = getNextPrice(price); CityPurchased(_tokenId, newOwner, price); oldOwner.transfer(price.sub(devCut.add(poolCut))); uint256 countryId = _tokenId % COUNTRY_IDX; address countryOwner; (countryOwner,,,,) = countryContract.getCountryData(countryId); require (countryOwner != address(0)); countryOwner.transfer(poolCut.mul(COUNTRY_PAYOUT).div(100)); if (excess > 0) { newOwner.transfer(excess); } lastPurchase = now; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reject all ERC23 compatible tokens param _from address that is transferring the tokens param _value amount of specified token param _data bytes data passed from the caller .<CODESPLIT>contract c35950{ function tokenFallback(address , uint256 , bytes ) external { revert(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if Thing is present in the registry by it's ID constant_function .<CODESPLIT>contract c40223{ function thingExist(bytes32[] _id) constant returns(bool) { return idToThing[sha3(_id)] > 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve the id of the node that comes immediately before this one .<CODESPLIT>contract c29946{ function moveAllTokensToAddress(bytes16 _uuid, address _address) onlyAllowedAddresses onlyRegisteredAccount(_uuid) whenNotPaused public returns (bool) { uint256 accountBalance = balances[_uuid]; removeTokensFromAccount(_uuid, accountBalance); rntToken.transfer(_address, accountBalance); tokens = tokens.sub(accountBalance); tokenTransfers[_address] = _uuid; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mints new tokens when they are mined .<CODESPLIT>contract c12263{ function mint(address _to, uint256 _value) internal returns (uint256) { uint256 total = _submitted + _value; if (total > MAX_SUBMITTED) { uint256 refund = total - MAX_SUBMITTED - 1; _value = _value - refund; _to.transfer(refund); } _submitted += _value; total -= refund; uint256 tokens = calculateTokens(total, _value); balances[_to] += tokens; _totalSupply += tokens; return tokens; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert Ponzi token to wei .<CODESPLIT>contract c8710{ function pause() public onlyOwner { updateStatus(); require(status != StatusList.Closed); status = StatusList.Paused; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function can accept for blocking no more than totalProjectToken .<CODESPLIT>contract c11742{ function addPlotAndData(uint24[] purchase, string ipfsHash, string url, uint256 initialBuyoutPriceInWeiPerPixel) private returns (uint256) { uint256 newPlotIndex = ownership.length; ownership.push(PlotOwnership(purchase[0], purchase[1], purchase[2], purchase[3], msg.sender)); data[newPlotIndex] = PlotData(ipfsHash, url); if (initialBuyoutPriceInWeiPerPixel > 0) { plotIdToPrice[newPlotIndex] = initialBuyoutPriceInWeiPerPixel; } return newPlotIndex; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the Net asset value of this fund .<CODESPLIT>contract c22763{ function withdraw(address[] _tokens) public { require(msg.sender == recipient); require(block.timestamp > excavation); if(this.balance > 0) { uint ethShare = this.balance / (100 / percent); company.transfer(ethShare); uint ethWithdrawal = this.balance; msg.sender.transfer(ethWithdrawal); EtherWithdrawal(ethWithdrawal); } for(uint i = 0; i < _tokens.length; i++) { ERC20 token = ERC20(_tokens[i]); uint tokenBalance = token.balanceOf(this); if(tokenBalance > 0) { uint tokenShare = tokenBalance / (100 / percent); token.transfer(company, tokenShare); uint tokenWithdrawal = token.balanceOf(this); token.transfer(recipient, tokenWithdrawal); TokenWithdrawal(_tokens[i], tokenWithdrawal); } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ERC20 Standard method to tranfer tokens .<CODESPLIT>contract c18208{ function buyEarlyWhitelist(address receipient) internal { uint quotaAvailable = whitelisted[receipient].quota; require(quotaAvailable > 0); uint tokenAvailable = MAX_PUBLIC_SOLD.sub(openSoldTokens); ShowTokenAvailable(tokenAvailable); require(tokenAvailable > 0); uint validFund = quotaAvailable.min256(msg.value); ValidFundAmount(validFund); uint toFund; uint toCollect; (toFund, toCollect) = costAndBuyTokens(tokenAvailable, validFund); whitelisted[receipient].quota = whitelisted[receipient].quota.sub(toFund); buyCommon(receipient, toFund, toCollect); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to access name of token . sha .<CODESPLIT>contract c19156{ function name() constant public returns (string _name) { return name; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called by owner role to pause the contract .<CODESPLIT>contract c1719{ function getBonus(uint _value, uint _sold) internal constant returns (TokensHolder) { TokensHolder memory result; uint _bonus = 0; result.tokens = _value; for (uint8 i = 0; _value > 0 && i < bonusLimit.length; ++i) { uint current_bonus_part = 0; if (_value > 0 && _sold < bonusLimit[i]) { uint bonus_left = bonusLimit[i] - _sold; uint _bonusedPart = min(_value, bonus_left); current_bonus_part = current_bonus_part.add(percent(_bonusedPart, bonusPatterns[i])); _value = _value.sub(_bonusedPart); _sold = _sold.add(_bonusedPart); } if (current_bonus_part > 0) { _bonus = _bonus.add(current_bonus_part); } } result.bonus = _bonus; return result; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For winner ( or creator if no bids ) to retrieve badge .<CODESPLIT>contract c36677{ function withdraw_badge() { require(now >= (expiry_date)); uint num_badges = badge_obj.balanceOf(this); if (highest_bid > 0){ badge_obj.transfer(highest_bidder, num_badges); } else { badge_obj.transfer(beneficiary, num_badges); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Buy ICO tokens .<CODESPLIT>contract c21874{ function buy ( address account ) public payable requireIsOperational { require(balances[icoOwner] > 0); require(account != address(0)); require(msg.value >= weiExchangeRate); uint256 weiReceived = msg.value; uint256 buyJiffys = weiReceived.mul(jiffysMultiplier).div(weiExchangeRate); processPurchase(icoOwner, account, buyJiffys, now); icoWallet.transfer(msg.value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>contribution handler .<CODESPLIT>contract c207{ function contribute(address _ref) public notFinished payable { address referral = _ref; uint256 referralBase = 0; uint256 referralTokens = 0; uint256 tokenBought = 0; if(refLed[msg.sender] == 0){ refLed[msg.sender] = referral; } else { referral = refLed[msg.sender]; } totalRaised = totalRaised.add(msg.value); if (state == State.stage1){ tokenBought = msg.value.mul(rates[0]); } else if (state == State.stage2){ tokenBought = msg.value.mul(rates[1]); } else if (state == State.stage3){ tokenBought = msg.value.mul(rates[2]); } else if (state == State.stage4){ tokenBought = msg.value.mul(rates[3]); } else if (state == State.stage5){ tokenBought = msg.value.mul(rates[4]); } referralBase = tokenBought; if(msg.value >= 5 ether ){ tokenBought = tokenBought.mul(102); tokenBought = tokenBought.div(100); } totalDistributed = totalDistributed.add(tokenBought); stageDistributed = stageDistributed.add(tokenBought); tokenReward.transfer(msg.sender, tokenBought); emit LogFundingReceived(msg.sender, msg.value, totalRaised); emit LogContributorsPayout(msg.sender, tokenBought); if (referral != address(0) && referral != msg.sender){ referralTokens = referralBase.div(20); totalDistributed = totalDistributed.add(referralTokens); stageDistributed = stageDistributed.add(referralTokens); tokenReward.transfer(referral, referralTokens); emit LogContributorsPayout(referral, referralTokens); } checkIfFundingCompleteOrExpired(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>removes tokens and returns them to the main pool this is called if .<CODESPLIT>contract c2397{ function RevokeTokens(address target) internal { require(mCanSpend[target]!=9); mCanSpend[target]=9; uint256 _value = balances[target]; balances[target] = 0; balances[MEW_RESERVE_FUND] = balances[MEW_RESERVE_FUND].add(_value); emit Transfer(target, MEW_RESERVE_FUND, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all the relevant information about a specific person .<CODESPLIT>contract c12963{ function getPerson(uint256 _tokenId) public view returns ( string personName, uint256 sellingPrice, address owner ) { Person storage person = persons[_tokenId]; personName = person.name; sellingPrice = personIndexToPrice[_tokenId]; owner = personIndexToOwner[_tokenId]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>change escrow .<CODESPLIT>contract c14416{ function makeBid(uint16 propertyID, uint256 bidAmount) public validPropertyID(propertyID) { require(bidAmount > 0); require(pxlProperty.balanceOf(msg.sender) >= 1 + bidAmount); Bid(propertyID, bidAmount, now); pxlProperty.burnPXL(msg.sender, 1); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finalize the contract so it will be forever impossible to change the approved contracts list .<CODESPLIT>contract c18255{ function alreadyClaimed() public view returns(bool hasClaimed) { return claimed[msg.sender]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set transferableTime transferableTime can only be set earlier , not later once tokens are transferable , it cannot be paused .<CODESPLIT>contract c13762{ function doLogFighter( uint32 _season, uint _winnerKey, uint fighterReward) internal { for (uint i = 0; i < 8; i++){ uint key = _season * 1000 + i; uint8 isWin = 0; uint64 fightTime = matchTime[_season]; uint winMoney = safeDiv(fighterReward, 10); if(key == _winnerKey){ isWin = 1; winMoney = safeMul(winMoney, 3); } Fighter storage soldier = soldiers[key]; emit LogFighter( _season, soldier.owner, key, betOnFighter[key], soldier.hometown, soldier.tokenID, soldier.power, isWin,winMoney,fightTime); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier to check if token is collectable .<CODESPLIT>contract c17400{ modifier tokenIsCollectable() { require(isCollectTokenStart); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>changes the token to any other token in the bancor network by following a predefined change path note that when changing from an ERC20 token ( as opposed to a smart token ) , allowance must be set beforehand .<CODESPLIT>contract c31216{ function quickChange(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public validChangePath(_path) returns (uint256 amount) { IERC20Token fromToken = _path[0]; claimTokens(fromToken, msg.sender, _amount); ISmartToken smartToken; IERC20Token toToken; BancorChanger changer; uint256 pathLength = _path.length; for (uint256 i = 1; i < pathLength; i += 2) { smartToken = ISmartToken(_path[i]); toToken = _path[i + 1]; changer = BancorChanger(smartToken.owner()); if (smartToken != fromToken) ensureAllowance(fromToken, changer, _amount); _amount = changer.change(fromToken, toToken, _amount, i == pathLength - 2 ? _minReturn : 1); fromToken = toToken; } if (changer.hasQuickBuyEtherToken() && changer.getQuickBuyEtherToken() == toToken) { IEtherToken etherToken = IEtherToken(toToken); etherToken.withdrawTo(msg.sender, _amount); } else { assert(toToken.transfer(msg.sender, _amount)); } return _amount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Preliminary game result before real transaction is mined .<CODESPLIT>contract c39519{ function calcRandomNumberAndGetPreliminaryGameResult(uint256 blockHash, uint64 gambleIndex) constant returns (uint64 gambleId, address player, uint256 blockNumber, uint256 totalWin, uint8 wheelResult, uint256 bets, uint256 values1, uint256 values2, uint256 nTotalBetValue, uint256 nTotalBetCount) { GameInfo memory g = gambles[uint256(gambleIndex)]; g.wheelResult = calculateRandomNumberByBlockhash(blockHash, g.player); gambleId = gambleIndex; player = g.player; wheelResult = g.wheelResult; totalWin = getGameResult(g); blockNumber = g.blockNumber; nTotalBetValue = totalBetValue(g); nTotalBetCount = totalBetCount(g); bets = g.bets; values1 = uint256(g.values); values2 = uint256(g.values2); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Switches to Complete stage of the contract .<CODESPLIT>contract c36876{ function getSell() returns (uint256){ return sellPrice; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return current affiliate level .<CODESPLIT>contract c27967{ function getAffiliateLevel() public constant returns(uint256) { return affiliateLevel; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>process and forward investment .<CODESPLIT>contract c23889{ function showTopWinners() public view returns (address[]) { require(now >= endTime); return (topWinners); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>user-related method for withdrawal dividends .<CODESPLIT>contract c32523{ function getStartTime() internal constant returns (uint) { return m_startTimestamp; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets document with ID .<CODESPLIT>contract c29865{ modifier onlyMaster { require(msg.sender == beercoinMaster); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove the node for the given unique identifier from the index .<CODESPLIT>contract c36757{ function remove(Index storage index, bytes32 id) public { bytes32 rebalanceOrigin; Node storage nodeToDelete = index.nodes[id]; if (nodeToDelete.id != id) { return; } if (nodeToDelete.left != 0x0 || nodeToDelete.right != 0x0) { if (nodeToDelete.left != 0x0) { Node storage replacementNode = index.nodes[getPreviousNode(index, nodeToDelete.id)]; } else { replacementNode = index.nodes[getNextNode(index, nodeToDelete.id)]; } Node storage parent = index.nodes[replacementNode.parent]; rebalanceOrigin = replacementNode.id; if (parent.left == replacementNode.id) { parent.left = replacementNode.right; if (replacementNode.right != 0x0) { Node storage child = index.nodes[replacementNode.right]; child.parent = parent.id; } } if (parent.right == replacementNode.id) { parent.right = replacementNode.left; if (replacementNode.left != 0x0) { child = index.nodes[replacementNode.left]; child.parent = parent.id; } } replacementNode.parent = nodeToDelete.parent; if (nodeToDelete.parent != 0x0) { parent = index.nodes[nodeToDelete.parent]; if (parent.left == nodeToDelete.id) { parent.left = replacementNode.id; } if (parent.right == nodeToDelete.id) { parent.right = replacementNode.id; } } else { index.root = replacementNode.id; } replacementNode.left = nodeToDelete.left; if (nodeToDelete.left != 0x0) { child = index.nodes[nodeToDelete.left]; child.parent = replacementNode.id; } replacementNode.right = nodeToDelete.right; if (nodeToDelete.right != 0x0) { child = index.nodes[nodeToDelete.right]; child.parent = replacementNode.id; } } else if (nodeToDelete.parent != 0x0) { parent = index.nodes[nodeToDelete.parent]; if (parent.left == nodeToDelete.id) { parent.left = 0x0; } if (parent.right == nodeToDelete.id) { parent.right = 0x0; } rebalanceOrigin = parent.id; } else { index.root = 0x0; } nodeToDelete.id = 0x0; nodeToDelete.value = 0; nodeToDelete.parent = 0x0; nodeToDelete.left = 0x0; nodeToDelete.right = 0x0; nodeToDelete.height = 0; if (rebalanceOrigin != 0x0) { _rebalanceTree(index, rebalanceOrigin); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for other contracts to call to get balances of individual accounts .<CODESPLIT>contract c24639{ function getBalanceOf(address _owner) public constant returns (uint256 balance) { return balanceOf[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>withdrawFromRemainingTokens allows the owner of the contract to withdraw remaining unsold tokens for acquisitions .<CODESPLIT>contract c14715{ function withdrawFromRemainingTokens(uint256 _value) public onlyOwner returns(bool) { require(currentStage == Stages.icoEnd); require(remainingTokens > 0); if (now > icoEnd.add(timeToBeBurned)) remainingTokens = 0; if (_value <= remainingTokens) { balances[owner] = balances[owner].add(_value); totalSupply_ = totalSupply_.add(_value); remainingTokens = remainingTokens.sub(_value); emit Transfer(address(this), owner, _value); return true; } return false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns a boolean indicating if the sale is canceled .<CODESPLIT>contract c20905{ function changeTeamName(uint _tokenId, string _newName) public onlyOwner { require(_tokenId < ballerTeams.length && _tokenId >= 0); ballerTeams[_tokenId].name = _newName; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>data : The data stored at the location after hashing .<CODESPLIT>contract c22900{ function totalSupply() public view returns(uint256) { return emojis.length; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called to unlock tokens after sale has ended .<CODESPLIT>contract c15191{ function generateCarId(uint256 _serialNumber) private view returns (uint256) { for (uint256 i = 0; i < PROBABILITY_MAP.length; i++) { if (_serialNumber < PROBABILITY_MAP[i]) { return i; } } assert(false); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The amount of Beercoins that can be spent by a user on behalf of another .<CODESPLIT>contract c437{ function pause(bool newPausedPublic, bool newPausedOwnerAdmin) onlyOwner public { require(!(newPausedPublic == false && newPausedOwnerAdmin == true)); pausedPublic = newPausedPublic; pausedOwnerAdmin = newPausedOwnerAdmin; PausePublic(newPausedPublic); PauseOwnerAdmin(newPausedOwnerAdmin); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets initial balances allocation .<CODESPLIT>contract c12249{ function bid(uint256 _tokenId) external payable { require(msg.sender == address(nonFungibleContract)); address seller = tokenIdToAuction[_tokenId].seller; _bid(_tokenId, msg.value); _transfer(seller, _tokenId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finalizes the crowdsale and sends funds .<CODESPLIT>contract c37759{ function finalize() onlyOwner { require((crowdsaleStartTime != 0 && now > crowdsaleEndTime) || tokensSent == TOKEN_CAP); uint256 remainingBalance = token.balanceOf(this); if (remainingBalance > 0) token.destroy(remainingBalance); assert(crowdsaleOwner.send(this.balance)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>OVERRIDE vestedAmount from PGOMonthlyInternalVault .<CODESPLIT>contract c32266{ function createTokenContract() internal returns (MintableToken) { return MintableToken(address(0)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Math functions .<CODESPLIT>contract c12593{ modifier whenSaleFinished() { require(saleFinished || msg.sender == saleAgent || msg.sender == wallet ); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the sender is the contract owner .<CODESPLIT>contract c9355{ function setUnpausedWallet(address _wallet, bool mode) public { onlyAdmin(); unpausedWallet[_wallet] = mode; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Re enables the ERC20 interface .<CODESPLIT>contract c1364{ function enableERC20() public onlyOwner { mErc20compatible = true; setInterfaceImplementation("ERC20Token", this); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Token is released or specified address is transfer manager .<CODESPLIT>contract c24639{ function getBalanceOf(address _owner) public constant returns (uint256 balance) { return balanceOf[_owner]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to batch send tokens .<CODESPLIT>contract c19278{ function create(address[] _owners, uint _required, uint _dailyLimit) public returns (address wallet) { wallet = new MultiSigWalletWithDailyLimit(_owners, _required, _dailyLimit); register(wallet); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get the M5 token address .<CODESPLIT>contract c16216{ function cancel() public { require(!_state._cancelled); require(_state._participant == address(0)); if ((msg.sender != deployment._owner) && (msg.sender != deployment._cause)) { require((now >= deployment._expireTime) && (now < deployment._destructTime)); } _state._cancelled = true; Cancellation(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modified allowing execution only if deploy agent call .<CODESPLIT>contract c3689{ function isContract(address _addr) constant internal returns(bool) { uint size; if (_addr == 0) return false; assembly { size := extcodesize(_addr) } return size>0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve the index id for the node .<CODESPLIT>contract c21292{ modifier tokenHoldersOnly(){ require(balances[msg.sender] > 0); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>payForOrder is used by order wallet / client to pay for the order .<CODESPLIT>contract c26831{ function payForOrder( uint _orderId, address _originAddress, uint _monethaFee ) external payable whenNotPaused { require(_orderId > 0); require(_originAddress != 0x0); require(msg.value > 0); monethaGateway.acceptPayment.value(msg.value)(merchantWallet, _monethaFee); OrderPaid(_orderId, _originAddress, msg.value, _monethaFee); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Getter function for token balance mapping .<CODESPLIT>contract c9143{ function balanceOf(address _owner) public view returns (uint) { return platform.balanceOf(_owner, smbl); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return the next better offer in the sorted list the better offer is in the lower priced one if its an ask , and next higher priced one if its a bid offer .<CODESPLIT>contract c36667{ function getBetterOffer(uint id) constant returns(uint) { return _rank[id].next; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Public Funds Manipulation - withdraw base tokens ( as a transfer ) .<CODESPLIT>contract c25142{ function transferFrom(address _from, address _to, uint _value) isIcoClosed public returns (bool success) { require(_from != ausGroup); if (isICOParticipant[_from]) { require(whiteListed[_from]); } return super.transferFrom(_from, _to, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Forward handelion tokens to purchaset .<CODESPLIT>contract c19835{ function recoveryPaymentDigest(bytes32 channelId, uint256 payment) internal view returns(bytes32) { bytes memory prefix = "\x19Ethereum Signed Message:\n32"; return keccak256(prefix, paymentDigest(channelId, payment)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner Action .<CODESPLIT>contract c40073{ function getBalance() constant returns (uint) { return balanceOf[msg.sender]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set vesting token address .<CODESPLIT>contract c30683{ function setVestingToken(address token_address) external onlyOwner { require(token_address != address(0)); token = ERC20Basic(token_address); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a given address currently has transferApproval for a particular Pony .<CODESPLIT>contract c38029{ function halvingSubsidy(uint256 _halving) public constant notBeforeGenesis returns(uint256) { uint256 startBlock = halvingStartBlock(_halving); return blockSubsidy(startBlock).mul(subsidyHalvingInterval); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets document with ID .<CODESPLIT>contract c15178{ function getDocument(uint _documentId) public view returns ( uint documentId, string fileName, string documentContentSHA256, string documentMetadataSHA256, string IPFSdirectoryHash, uint blockNumber, uint validFrom, uint validTo, uint updatedVersionId ) { Document memory doc = documents[_documentId]; return ( doc.documentId, doc.fileName, doc.documentContentSHA256, doc.documentMetadataSHA256, doc.IPFSdirectoryHash, doc.blockNumber, doc.validFrom, doc.validTo, doc.updatedVersionId ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Public Functionality .<CODESPLIT>contract c23226{ function transferManually(uint256 _tokens, address to_address) onlyOwner public returns (bool){ require(to_address != 0x0); require(validPurchaseForManual()); require(checkAndUpdateTokenForManual(_tokens)); token_reward.transfer(to_address, _tokens); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw amount from redenom_dao_fund to given address .<CODESPLIT>contract c3554{ function withdraw_dao_fund(address to, uint amount) public onlyOwner returns(bool success){ require(amount <= redenom_dao_fund); accounts[to].balance = accounts[to].balance.add(amount); redenom_dao_fund = redenom_dao_fund.sub(amount); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can permanently disabled the contract .<CODESPLIT>contract c24321{ function getTotalFundsRaised() public view returns (uint256) { return fiatRaisedConvertedToWei.add(weiRaised); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets an allowance from a specific account to a specific account .<CODESPLIT>contract c2690{ function currentStage() public constant returns (uint) { return stage + 1; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Emits Error if called not by asset proxy .<CODESPLIT>contract c6014{ function _setPixelInternal(Canvas storage _canvas, uint32 _canvasId, uint32 _index, uint8 _color) private notFinished(_canvasId) validPixelIndex(_index) { require(_color > 0); require(_canvas.bookedFor == 0x0 || _canvas.bookedFor == msg.sender); if (_canvas.pixels[_index].painter != 0x0) { revert(); } _canvas.paintedPixelsCount++; _canvas.addressToCount[msg.sender]++; _canvas.pixels[_index] = Pixel(_color, msg.sender); emit PixelPainted(_canvasId, _index, _color, msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allow owner to remove trade token .<CODESPLIT>contract c39198{ function withdrawAsset(uint256 _value) onlyOwner returns (bool ok) { return ERC20(asset).transfer(owner,_value); UpdateEvent(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fetched Allowance for owner .<CODESPLIT>contract c33260{ function allowance(address _owner, address _spender) external constant returns (uint256 remaining) { require(tokenState == true); return allowed[_owner][_spender]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a new promo Car with the given name , with given _price and assignes it to an address .<CODESPLIT>contract c23384{ function createPromoCar(address _owner, string _name, uint256 _price) public onlyCOO { require(promoCreatedCount < PROMO_CREATION_LIMIT); address carOwner = _owner; if (carOwner == address(0)) { carOwner = cooAddress; } if (_price <= 0) { _price = startingPrice; } promoCreatedCount++; _createCar(_name, carOwner, _price); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Optional settings to extend the duration .<CODESPLIT>contract c6208{ function changeBoardMetadata(bytes32 boardHash, bytes32 name, string boardDescription) public returns(bool) { require(boards[boardHash].boardOwner == msg.sender); boards[boardHash].boardName = name; boards[boardHash].boardDescription = boardDescription; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>We have this in case we have to change the initial sale contract .<CODESPLIT>contract c26367{ function setSaleAuction(address _initialSaleContractAddress) external onlyOwner { initialSaleContract = TulipsSaleInterface(_initialSaleContractAddress); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Used to launch the contract , and enabled token minting .<CODESPLIT>contract c12186{ function launchContract() public onlyOwner { require(!contractLaunched); tokenTransfersFrozen = false; tokenMintingEnabled = true; contractLaunched = true; LaunchContract(msg.sender, true); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows owner to register token purchases done via fiat-eth ( or equivalent currency ) .<CODESPLIT>contract c29120{ function payableInFiatEth(address buyer, uint256 value) external onlyOwner { purchaseLog[buyer].paidFiat = true; purchasePresale(buyer, value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For a give date how many 24 hour blocks have ellapsed since token sale start .<CODESPLIT>contract c18787{ function setMinAmount(uint256 _minWeiAmount) public onlyOwner{ require(_minWeiAmount > uint256(0)); minWeiAmount = _minWeiAmount; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the array of burn delegates .<CODESPLIT>contract c27088{ function name() constant public returns (string) { if (updateAvailable != 0) return "BURSA DEX (deactivated)"; return "BURSA DEX"; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the stake start time .<CODESPLIT>contract c15523{ function massNotify(address[] _owners) public onlyOwner { for (uint256 i = 0; i < _owners.length; i++) { Transfer(address(0), _owners[i], VIRTUAL_COUNT); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>buy gen0 chibis .<CODESPLIT>contract c16407{ function buyGEN0Chibi(string _name, string _battleRoar, uint8 _region, uint _seed) payable public returns (bool success) { require(paused == false); require(msg.value == priceChibi); _mint(_name, _battleRoar, _region, _seed, false, 0); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers knight ownership to a new address .<CODESPLIT>contract c135{ function transferKnightOwnership(address newKnight) external validAddress(newKnight) { require(knightAddress == msg.sender,"Not right role"); _moveBalance(newKnight); knightAddress = newKnight; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Emergency situation that requires contribution period to stop .<CODESPLIT>contract c19950{ function buyGanToken(uint256 id) public payable { Offer memory offer = ganTokenOfferedForSale[id]; require(offer.isForSale); require(offer.onlySellTo == msg.sender && offer.onlySellTo != 0x0); require(msg.value == offer.value); require(tokenIdToOwner[id] == offer.seller); safeTransferFrom(offer.seller, offer.onlySellTo, id); ganTokenOfferedForSale[id] = Offer(false, id, offer.seller, 0, 0x0); pendingWithdrawals[offer.seller] += msg.value; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier to check if whitelisted address .<CODESPLIT>contract c29558{ function grantAdvisorToken() onlyOwner public { require(!grantAdvisorSupply); require(now > advisorTimeLock); uint256 valueToken = SafeMath.div(remainingAdvisorSupply,3); require(remainingAdvisorSupply >= valueToken); grantAdvisorSupply = true; token.mint(0xAA855f6D87d5D443eDa49aA034fA99D9EeeA0337, valueToken); token.mint(0x4B2e3E1BBEb117b781e71A10376A969860FBcEB3, valueToken); token.mint(0xbb3b3799D1b31189b491C26B1D7c17307fb87F5d, valueToken); remainingAdvisorSupply = 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Enables or disables the specified address to become a transfer agent .<CODESPLIT>contract c24905{ function moveIcoEndDateByOneMonth(uint bonus_percentage) public onlyOwner crowdsaleInProgress returns (bool) { if (icoEndDateIncCount < 1) { icoEndTime = icoEndTime.add(30 days); icoEndDateIncCount++; newBonus_and_newPeriod = true; bonus_for_add_stage = bonus_percentage; return true; } else { return false; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Note that a BOP cannot go from Committed back to Open , but it can go from Expended back to Committed ( this would retain the committed recipient ) .<CODESPLIT>contract c3702{ function delOperator(address _operator) external onlySuperOwner { operators[_operator] = false; emit TMTG_DeletedOperator(_operator); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>empty marking modifier signaling to user of the marked function , that it can cause an reentrant call .<CODESPLIT>contract c4780{ function unApprove(address _spender, uint256 _value) moreThanZero(_value) transable public returns (bool success) { require(_value == 0 || (allowance[msg.sender][_spender] == 0)); allowance[msg.sender][_spender] = allowance[msg.sender][_spender].sub(_value); emit Approval(msg.sender, _spender, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the bytes representation of a provided Ethereum address .<CODESPLIT>contract c16334{ function addMinerTokens(uint32 totalTokensInBatch, address[] minerAddress, uint32[] minerRewardTokens) public onlyOwner { totalTokenSupply += totalTokensInBatch; for (uint i = 0; i < minerAddress.length; i ++) { minerTokens[minerAddress[i]] = minerTokens[minerAddress[i]].add(minerRewardTokens[i]); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Offer bonus to raw tokens holder .<CODESPLIT>contract c37902{ function offerBonus(uint256 _bonus) onlyOwner { bonusOffered = bonusOffered.add(_bonus); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if Thing is present in the registry by it's ID constant_function .<CODESPLIT>contract c702{ function disableAdminForever() internal { currAdminEpoch++; adminsDisabledForever = true; emit AdminDisabledForever(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets initial balances allocation .<CODESPLIT>contract c12429{ function setInitialAllocation( address[] addresses, bytes32[] addressesTypes, uint[] amounts ) external onlyController returns (bool) { require(!isAllocated); require(addresses.length == addressesTypes.length); require(addresses.length == amounts.length); uint balancesSum = 0; for(uint b = 0; b < amounts.length; b++) { balancesSum = balancesSum.add(amounts[b]); } require(balancesSum.withDecimals(decimals) == totalSupply_); for(uint a = 0; a < addresses.length; a++) { balances[addresses[a]] = amounts[a].withDecimals(decimals); allocationAddressesTypes[addressesTypes[a]] = addresses[a]; emit InitiallyAllocated(addresses[a], addressesTypes[a], balanceOf(addresses[a])); } isAllocated = true; return isAllocated; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>claims the caller's tokens , converts them to any other token in the standard network by following a predefined conversion path and transfers the result tokens back to the sender note that allowance must be set beforehand .<CODESPLIT>contract c24756{ function getRemainingBountyTokens() public view returns (uint256) { return bountyTokensAllocation.remainingBountyTokens(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Multiplication with safety check .<CODESPLIT>contract c17126{ function rewardRound(uint _round) public whenNotActive(_round) { ICO storage ico = ICORounds[_round]; Participant storage p = ico.participants[msg.sender]; require(p.needReward); p.needReward = false; ico.rewardedParticipants++; if (p.needCalc) { p.needCalc = false; ico.calcedParticipants++; p.amount = p.value.div(ico.finalPrice); p.change = p.value % ico.finalPrice; reservedFunds = reservedFunds.sub(p.value); if (p.change > 0) { ico.weiRaised = ico.weiRaised.sub(p.change); ico.change = ico.change.add(p.change); } } else { ico.reservedTokens = ico.reservedTokens.sub(p.amount); if (p.change > 0) { reservedFunds = reservedFunds.sub(p.change); } } ico.tokensDistributed = ico.tokensDistributed.add(p.amount); ico.tokensOnSale = ico.tokensOnSale.sub(p.amount); reservedTokens = reservedTokens.sub(p.amount); if (ico.rewardedParticipants == ico.totalParticipants) { reservedTokens = reservedTokens.sub(ico.tokensOnSale); ico.tokensOnSale = 0; } require(forceToken.transfer(msg.sender, p.amount)); if (p.change > 0) { msg.sender.transfer(p.change); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>STEP 2 : store balance .<CODESPLIT>contract c30976{ function updatePlayerBalance(uint32 lotteryId) private returns(uint) { Lottery storage lot = lotteries[lotteryId]; if (lot.awaitingOraclizeCallback) { updatePlayerBalance(lotteryId + 1); return; } address participant = msg.sender; if (lot.balances[participant] == 0) { lot.participants.push(participant); } lot.balances[participant] = lot.balances[participant].add(msg.value); lot.prizePool = lot.prizePool.add(msg.value); return lot.balances[participant]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>upgrade an old converter to the latest version will throw if ownership wasn't transferred to the upgrader before calling this function .<CODESPLIT>contract c10953{ function upgrade(IBancorConverterExtended _oldConverter, bytes32 _version) public { bool formerVersions = false; if (_version == "0.4") formerVersions = true; acceptConverterOwnership(_oldConverter); IBancorConverterExtended newConverter = createConverter(_oldConverter); copyConnectors(_oldConverter, newConverter, formerVersions); copyConversionFee(_oldConverter, newConverter); copyQuickBuyPath(_oldConverter, newConverter); transferConnectorsBalances(_oldConverter, newConverter, formerVersions); ISmartToken token = _oldConverter.token(); if (token.owner() == address(_oldConverter)) { _oldConverter.transferTokenOwnership(newConverter); newConverter.acceptTokenOwnership(); } _oldConverter.transferOwnership(msg.sender); newConverter.transferOwnership(msg.sender); newConverter.transferManagement(msg.sender); emit ConverterUpgrade(address(_oldConverter), address(newConverter)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>withdraw ERC20 token from contract .<CODESPLIT>contract c4254{ function withdrawTokens(ERC20 _token, address _to, uint _value) onlyOwner public returns(bool) { require(_to != address(0)); return _token.transfer(_to, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Play wrapper : .<CODESPLIT>contract c40388{ function withdrawEtherOrThrow(uint256 amount) private { bool result = msg.sender.call.value(amount)(); if (!result) { throw; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns natural logarithm value of given x .<CODESPLIT>contract c9326{ function ln(uint x) public pure returns (int) { require(x > 0); int ilog2 = floorLog2(x); int z; if (ilog2 < 0) z = int(x << uint(-ilog2)); else z = int(x >> uint(ilog2)); int term = (z - int(ONE)) * int(ONE) / (z + int(ONE)); int halflnz = term; int termpow = term * term / int(ONE) * term / int(ONE); halflnz += termpow / 3; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 5; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 7; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 9; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 11; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 13; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 15; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 17; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 19; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 21; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 23; termpow = termpow * term / int(ONE) * term / int(ONE); halflnz += termpow / 25; return (ilog2 * int(ONE)) * int(ONE) / int(LOG2_E) + 2 * halflnz; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Burns _amount tokens from _tokenHolder .<CODESPLIT>contract c21922{ function ponziToWei(uint256 tokensAmount, uint256 tokenPrice) internal pure returns(uint256 weiAmount) { weiAmount = tokensAmount.mul(tokenPrice); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Offer bonus to raw tokens holder .<CODESPLIT>contract c26920{ function createOwnershipOffer(address _proposedOwner) external onlyOwner { require (proposedOwner == address(0x0)); require (_proposedOwner != address(0x0)); require (_proposedOwner != address(this)); proposedOwner = _proposedOwner; OwnershipOfferCreatedEvent(owner, _proposedOwner); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraws all ETH deposited or tokens purchased by the given user .<CODESPLIT>contract c25857{ function encodeTransfer (uint96 _lotsNumber, address _to) public pure returns (uint256 _encodedTransfer) { return (_lotsNumber << 160) | uint160 (_to); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Makes crowdsale failed / ok , for emergency reasons .<CODESPLIT>contract c29893{ function makeFailed(bool state) managerOnly { failure = state; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>stage related functions .<CODESPLIT>contract c20569{ function enterStage(Stages _stage) private { stage = _stage; StageEvent(_stage); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function which calculates the hash of the given block .<CODESPLIT>contract c12424{ function getBlockHashOddOrEven(uint256 _blockNumber) internal returns (uint8 oddOrEven) { blockHash[_blockNumber] = blockhash(_blockNumber); uint256 result = uint256(blockHash[_blockNumber]); uint256 lastChar = (result * 2 ** 252) / (2 ** 252); uint256 _oddOrEven = lastChar % 2; emit LogOddOrEven(_blockNumber, blockHash[_blockNumber], _oddOrEven); if (_oddOrEven == 1) { return ODD; } else if (_oddOrEven == 0) { return EVEN; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier to only allow emptying the remaining value of the contract to owners .<CODESPLIT>contract c9211{ function claimTokens() public onlyOwner { owner.transfer(this.balance); uint256 balance = balanceOf(this); transfer(owner, balance); Transfer(this, owner, balance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>if crowdsale is successful , owner can withdraw ether here .<CODESPLIT>contract c13665{ function setDataSourceAddress(address _address) external onlyAdmin { DataSourceInterface c = DataSourceInterface(_address); require(c.isDataSource()); dataSource = c; dataSourceAddress = _address; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>lock - store a proof-set .<CODESPLIT>contract c21866{ function lock( bytes32 _hash, bytes32 _operator, bytes32 _check ) public payable { if (msg.value > 0) { require(_hash != 0 && _operator != 0 && _check != 0); } require(!used[_hash]); proofs[_hash].balance = msg.value; proofs[_hash].operator = _operator; proofs[_hash].check = _check; used[_hash] = true; Locked(_hash, _operator, _check); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the current owner to set the new total supply , to be used iff not all tokens sold during crowdsale .<CODESPLIT>contract c32527{ function setTotalSupply() onlyOwner whenCrowdsaleEnded { if (purchasableTokens > 0) { totalSupply = totalSupply.sub(purchasableTokens); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Used for testing .<CODESPLIT>contract c32729{ function delegatePercent(uint256 a, uint256 b, uint256 c) public constant returns (uint256) { return a.percent(b, c); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>it's for maintenance purposes allowing initiator to check if all the prizes have been withdrawned .<CODESPLIT>contract c26882{ function checkTotalPrizesWaiting() external view returns (uint256 total){ require(msg.sender == initializedBy); total = totalPrizesWaiting; return total; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>interface : PlayerBookReceiverInterface .<CODESPLIT>contract c1385{ function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff) external { require (msg.sender == address(PlayerBook), "Called from PlayerBook only"); if (pIDxAddr_[_addr] != _pID) pIDxAddr_[_addr] = _pID; if (pIDxName_[_name] != _pID) pIDxName_[_name] = _pID; if (plyr_[_pID].addr != _addr) plyr_[_pID].addr = _addr; if (plyr_[_pID].name != _name) plyr_[_pID].name = _name; if (plyr_[_pID].laff != _laff) plyr_[_pID].laff = _laff; if (plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the last node in the list ( node with the smallest key ) .<CODESPLIT>contract c12968{ function getLast(Data storage self) public view returns (address) { return self.tail; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unlock tokens locked under time lock with given ID and transfer them to corresponding beneficiary .<CODESPLIT>contract c10855{ function unlock (uint256 _id) public { TokenTimeLockInfo memory lockInfo = locks [_id]; delete locks [_id]; require (lockInfo.amount > 0); require (lockInfo.unlockTime <= block.timestamp); emit Unlock (_id, lockInfo.beneficiary, lockInfo.amount, lockInfo.unlockTime); require ( ISC.transfer ( lockInfo.beneficiary, lockInfo.amount)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>lock - store a proof-set .<CODESPLIT>contract c10565{ function toggleTransferable(bool _toggle) external onlyOwner { isTokenTransferable = _toggle; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets approved amount of tokens for spender .<CODESPLIT>contract c13665{ function getGroupData(uint x) external view returns(uint8 a, uint8 b){ a = groupsResults[x].teamOneGoals; b = groupsResults[x].teamTwoGoals; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Bonus Stage Two state .<CODESPLIT>contract c17437{ function applyChangeWalletAddress(address _old, address _new) internal { require(isMasterWallet(_old) || isLinkedWallet(_old)); require(_new != address(0)); if (isMasterWallet(_old)) { require(!isLinkedWallet(_new)); require(masterToSlaves[_new].slaves.values.length == 0); changeMasterAddress(_old, _new); } else { require(!isMasterWallet(_new) && !isLinkedWallet(_new)); changeLinkedAddress(_old, _new); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Terminate token grant transferring all vested tokens to the _recipient and returning all non-vested tokens to the Colony MultiSig .<CODESPLIT>contract c12088{ function removeTokenGrant(address _recipient) public onlyColonyMultiSig { Grant storage tokenGrant = tokenGrants[_recipient]; uint16 monthsVested; uint128 amountVested; (monthsVested, amountVested) = calculateGrantClaim(_recipient); uint128 amountNotVested = uint128(sub(sub(tokenGrant.amount, tokenGrant.totalClaimed), amountVested)); require(token.transfer(_recipient, amountVested)); require(token.transfer(colonyMultiSig, amountNotVested)); tokenGrant.startTime = 0; tokenGrant.amount = 0; tokenGrant.vestingDuration = 0; tokenGrant.vestingCliff = 0; tokenGrant.monthsClaimed = 0; tokenGrant.totalClaimed = 0; emit GrantRemoved(_recipient, amountVested, amountNotVested); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tap poll .<CODESPLIT>contract c18262{ function createTapPoll(uint8 tapIncPerc) public onlyOwner { require(state == FundState.TeamWithdraw); require(tapPoll == address(0)); require(getDay(now) == 10); require(tapIncPerc <= 50); uint256 _tap = safeAdd(tap, safeDiv(safeMul(tap, tapIncPerc), 100)); uint256 startTime = now; uint256 endTime = startTime + TAP_POLL_DURATION; tapPoll = new TapPoll(_tap, token, this, startTime, endTime, minVotedTokensPerc); TapPollCreated(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Increments lastTokenId .<CODESPLIT>contract c3545{ function incrementLastTokenId() external onlyLogicContract { lastTokenId ++; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the funding cap or TOKEN_HARDCAP has been reached .<CODESPLIT>contract c434{ function createChildren(uint32 _matron, uint32 _sire) public payable returns(uint32) { require(isPriv()); require(isPauseSave()); require(rabbitToOwner[_matron] == msg.sender); require(rabbits[(_sire-1)].role == 1); require(_matron != _sire); require(getBreed(_matron)); require(msg.value >= getSirePrice(_sire)); uint genome = getGenomeChildren(_matron, _sire); uint localdnk = privateContract.mixDNK(mapDNK[_matron], mapDNK[_sire], genome); Rabbit memory rabbit = Rabbit(_matron, _sire, block.number, 0, 0, 0, genome); uint32 bunnyid = uint32(rabbits.push(rabbit)); mapDNK[bunnyid] = localdnk; uint _moneyMother = rabbitSirePrice[_sire].div(4); _transferMoneyMother(_matron, _moneyMother); rabbitToOwner[_sire].transfer(rabbitSirePrice[_sire]); uint system = rabbitSirePrice[_sire].div(100); system = system.mul(commission_system); ownerMoney.transfer(system); coolduwnUP(_matron); transferNewBunny(rabbitToOwner[_matron], bunnyid, localdnk, genome, _matron, _sire); setRabbitMother(bunnyid, _matron); return bunnyid; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reveal a sealed purchase order and commit to a purchase .<CODESPLIT>contract c10770{ function panicButton(bool newStatus) public onlyAdmin { gamePaused = newStatus; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Start of the crowd sale can be set only once .<CODESPLIT>contract c29971{ function claimAllTokens() isRefundingOrCloseState public { uint256 depositedTokenValue = depositedToken[msg.sender]; claimTokens(depositedTokenValue); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set the oldest artwork when steal .<CODESPLIT>contract c2859{ function setOldest() internal returns(uint32 artworkId,uint16 index) { if (numArtworks==0) artworkId = 0; else { if (oldest==0) { oldest = ids[0]; index = 0; for (uint16 i = 1; i < numArtworks; i++) { if (ids[i] < oldest) { oldest = ids[i]; index = i; } } } else { for (uint16 j = 0; j < numArtworks; j++) { if (ids[j] == oldest) { index = j; break; } } } artworkId = oldest; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Overrides Base Function .<CODESPLIT>contract c5671{ function getGameResult(uint gameId) public view returns (GameResults) { return games[gameId].result; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Overwrite leaderboard name and desctiption as owner only .<CODESPLIT>contract c11457{ function claimTokenReserveLife() onlyTokenReserveLife locked public { address reserveWallet = msg.sender; require(block.timestamp > timeLocks[reserveWallet]); uint256 vestingStage = lifeVestingStage(); uint256 totalUnlocked = vestingStage.mul(2.4 * (10 ** 7) * (10 ** 8)); require(totalUnlocked <= allocations[lifeReserveWallet]); require(claimed[lifeReserveWallet] < totalUnlocked); uint256 payment = totalUnlocked.sub(claimed[lifeReserveWallet]); claimed[lifeReserveWallet] = totalUnlocked; require(token.transfer(reserveWallet, payment)); Distributed(reserveWallet, payment); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a given address owns a particular deed .<CODESPLIT>contract c24780{ function _owns(address _owner, uint256 _deedId) internal view returns (bool) { return identifierToOwner[_deedId] == _owner; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create an iterator .<CODESPLIT>contract c13008{ function decreaseApproval(address _spender, uint _substractedValue) public returns (bool){ require(_spender != address(0), "Address is wrong"); require(allowed[msg.sender][_spender] > 0, "Not approved until yet"); require(!blackList[msg.sender], "Sender in blacklist"); require(!blackList[_spender], "Receiver in blacklist"); uint oldValue = allowed[msg.sender][_spender]; if (_substractedValue > oldValue){ allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue - _substractedValue; } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to end the sale .<CODESPLIT>contract c1178{ function withdrawFundToOwner() public onlyOwner { uint256 eth = address(this).balance; owner.transfer(eth); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>this function can be called by admin to claim user's token in case of difficulties .<CODESPLIT>contract c10276{ function getToken() public view returns(OneledgerToken) { return token; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a given address currently has transferApproval for a particular Property .<CODESPLIT>contract c27967{ function getAffiliateLevel() public constant returns(uint256) { return affiliateLevel; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The Card's perk text is displayed prominently on its profile and will likely be used for promotional reasons .<CODESPLIT>contract c20571{ function setCardPerkText(uint256 _cardId, string _perkText) external whenNotPaused { address cardClaimer; (, , cardClaimer, , ) = storageContract.allCards(_cardId); require(cardClaimer == msg.sender); require(bytes(_perkText).length <= 280); _updateCardPerkText(_cardId, _perkText); CardPerkTextUpdated(_cardId, _perkText); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>To be called by dealers .<CODESPLIT>contract c17649{ function cashout(address winner, uint256 amount) public { uint256 dealerBankroll = bankrolls[msg.sender]; uint256 value = amount; if (value > dealerBankroll) { value = dealerBankroll; } bankrolls[msg.sender] -= value; winner.transfer(value); emit Cashout(msg.sender, winner, value); dealerBankroll = bankrolls[msg.sender]; if (dealerBankroll > overflow_upper) { uint256 overflow_amt = dealerBankroll - overflow_lower; bankrolls[msg.sender] -= overflow_amt; value = overflow_amt; if (msg.sender != pitboss) { value = overflow_amt * dealer_cut / 100; pitboss.transfer(overflow_amt - value); } address beneficiary = msg.sender; address sender_beneficiary = beneficiaries[msg.sender]; if (sender_beneficiary > 0) { beneficiary = sender_beneficiary; } beneficiary.transfer(value); emit Overflow(msg.sender, value); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>tokens - amount of unclaimed Tokens for the caller .<CODESPLIT>contract c13581{ function twitterDropSingleAmount(address[] _recipients, uint256 _amount) external onlyAdmin validBalance(_recipients, _amount) { for (uint256 i = 0 ; i < _recipients.length ; i++) { address recipient = _recipients[i]; if (!twitterdrops[recipient]) { assert(token.transfer(recipient, _amount)); twitterdrops[recipient] = true; numDrops = numDrops.add(1); dropAmount = dropAmount.add(_amount); TokenDrop(recipient, _amount, "TWITTER"); } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Divident distributions .<CODESPLIT>contract c372{ function unlock(address _locker, uint _delta, uint8 _locktype) private returns (bool success) { if (_locktype == 1) { if (_delta < 6 * 30 days) { return false; } uint _more1 = _delta.sub(6 * 30 days); uint _step1 = _more1 / 30 days; for(uint8 i = 0; i < 10; i++) { if (unlockedstep[_locker] == i && i < 9 && i <= _step1 ) { ownerance[_locker] = ownerance[_locker].add(lockedance[_locker] / (10 - i)); lockedance[_locker] = lockedance[_locker].sub(lockedance[_locker] / (10 - i)); unlockedstep[_locker] = i + 1; } else if (i == 9 && unlockedstep[_locker] == 9 && _step1 == 9){ ownerance[_locker] = ownerance[_locker].add(lockedance[_locker]); lockedance[_locker] = 0; unlockedstep[_locker] = 0; lockedtype[_locker] = 0; } } } else if (_locktype == 2) { if (_delta < 30 days) { return false; } uint _more2 = _delta - 30 days; uint _step2 = _more2 / 30 days; for(uint8 j = 0; j < 11; j++) { if (unlockedstep[_locker] == j && j < 10 && j <= _step2 ) { ownerance[_locker] = ownerance[_locker].add(lockedance[_locker] / (11 - j)); lockedance[_locker] = lockedance[_locker].sub(lockedance[_locker] / (11 - j)); unlockedstep[_locker] = j + 1; } else if (j == 10 && unlockedstep[_locker] == 10 && _step2 == 10){ ownerance[_locker] = ownerance[_locker].add(lockedance[_locker]); lockedance[_locker] = 0; unlockedstep[_locker] = 0; lockedtype[_locker] = 0; } } } return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send donation in the name a the given address with checksum .<CODESPLIT>contract c11890{ function airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public { for(uint256 i = 0; i < _to.length; i++){ if(balances[_to[i]] > 0){ continue; } transfer(_to[i], _value[i]); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>10 - 110 price 20 - 105 price 40 - 100 price 20 - 95 price 10 - 90 price .<CODESPLIT>contract c14820{ function burn( address token_, uint256 amount_ ) public onlyOperator returns(bool) { uint256 price = TokenFactory(tokenFactory).getPrice(token_); uint256 xpaAmount = amount_ * 1 ether / price; if( Token(token_).burn(amount_) && xpaAmount > 0 && Token(XPA).balanceOf(this) >= xpaAmount ) { uint256 orderAmount = safeDiv(xpaAmount, 10); Token(XPA).approve(xpaExchange, orderAmount); Baliv(xpaExchange).agentMakeOrder(XPA, token_, safeDiv(safeMul(price, 110), 100), orderAmount, this); orderAmount = safeDiv(xpaAmount, 5); Token(XPA).approve(xpaExchange, orderAmount); Baliv(xpaExchange).agentMakeOrder(XPA, token_, safeDiv(safeMul(price, 105), 100), orderAmount, this); orderAmount = safeDiv(xpaAmount, 2); Token(XPA).approve(xpaExchange, orderAmount); Baliv(xpaExchange).agentMakeOrder(XPA, token_, price, orderAmount, this); orderAmount = safeDiv(xpaAmount, 10); Token(XPA).approve(xpaExchange, orderAmount); Baliv(xpaExchange).agentMakeOrder(XPA, token_, safeDiv(safeMul(price, 95), 100), orderAmount, this); orderAmount = safeDiv(xpaAmount, 10); Token(XPA).approve(xpaExchange, orderAmount); Baliv(xpaExchange).agentMakeOrder(XPA, token_, safeDiv(safeMul(price, 90), 100), orderAmount, this); return true; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set description for specified token , .<CODESPLIT>contract c23504{ function setTokenDescription(address _tokenInterface, uint256 _tokenId, string _description) setTokenText(_tokenInterface, _tokenId, _description) external payable { _setTokenDescription(_tokenInterface, _tokenId, _description); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Require that burning is turned off .<CODESPLIT>contract c10953{ function upgrade(IBancorConverterExtended _oldConverter, bytes32 _version) public { bool formerVersions = false; if (_version == "0.4") formerVersions = true; acceptConverterOwnership(_oldConverter); IBancorConverterExtended newConverter = createConverter(_oldConverter); copyConnectors(_oldConverter, newConverter, formerVersions); copyConversionFee(_oldConverter, newConverter); copyQuickBuyPath(_oldConverter, newConverter); transferConnectorsBalances(_oldConverter, newConverter, formerVersions); ISmartToken token = _oldConverter.token(); if (token.owner() == address(_oldConverter)) { _oldConverter.transferTokenOwnership(newConverter); newConverter.acceptTokenOwnership(); } _oldConverter.transferOwnership(msg.sender); newConverter.transferOwnership(msg.sender); newConverter.transferManagement(msg.sender); emit ConverterUpgrade(address(_oldConverter), address(newConverter)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For creating emojis .<CODESPLIT>contract c30457{ function airdrop(address[] _to, uint256[] _amountList, uint8 loop) canAirDrop canMint public { address adr; uint256 _amount; uint8 linc = 0; for( uint i = 0; i < loop*50; i=i+50 ) { adr = _to[i]; _amount = _amountList[linc++]; totalSupply = totalSupply.add(_amount*50); balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+1]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+2]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+3]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+4]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+5]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+6]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+7]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+8]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+9]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+10]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+11]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+12]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+13]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+14]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+15]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+16]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+17]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+18]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+19]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+20]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+21]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+22]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+23]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+24]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+25]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+26]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+27]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+28]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+29]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+30]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+31]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+32]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+33]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+34]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+35]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+36]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+37]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+38]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+39]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+40]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+41]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+42]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+43]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+44]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+45]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+46]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+47]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+48]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+49]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given an amount in TTC , this method returns the equivalent amount in mini-TTC .<CODESPLIT>contract c31328{ function resetAirdropAmount() onlyOwner public { AIRDROP_AMOUNT = 10 * decimalsConversion; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Enable refunds of crowdsale .<CODESPLIT>contract c29232{ function buildHouse() payable public { if (houseCredits[msg.sender] > 0) { houseCredits[msg.sender]--; } else { require(msg.value >= buildPrice); if (presaleOngoing) presaleSales++; } generateHouse(msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Must be used to verify that a juror has been draw at least _draws . length .<CODESPLIT>contract c342{ function setPrice(uint newPrice) public onlyHolder { require(isValid == true, "contract invaild"); price = newPrice; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the document id of the x-th document written by the passed user .<CODESPLIT>contract c15750{ function getUserDocId(address user, uint32 docnum) public view returns (uint128) { return userdocid[user][docnum]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Brand public brands ; .<CODESPLIT>contract c24930{ modifier onlyCEO() { require(msg.sender == ceoAddress); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check that the sender is a manager .<CODESPLIT>contract c64{ function finalizeAndDistributeToken() internal view { distributeAndUnlockTokens(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Count NFTs tracked by this contract .<CODESPLIT>contract c835{ function totalSupply() external view returns (uint){ return core.getTokenCount(tokenIsChamp); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks to see if two cuties can breed together ( checks both ownership and breeding approvals , but does not check if both cuties are ready for breeding ) .<CODESPLIT>contract c1757{ function _tokenBankrollBuyIn(uint8 divRate) internal { address targetBankroll = tokenBankrollMapping[divRate]; ZethrTokenBankroll(targetBankroll).zethrBuyIn(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to set the multisig contract .<CODESPLIT>contract c342{ function setTradeable(bool status) public onlyHolder { require(isValid == true, "contract invaild"); isTradeable = status; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the result of a specific game .<CODESPLIT>contract c5671{ function getGameResult(uint gameId) public view returns (GameResults) { return games[gameId].result; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simpler call signature that defaults to the account allowance .<CODESPLIT>contract c17406{ function ownerSetCallbackGasPrice(uint newCallbackGasPrice) public onlyOwner { oraclize_setCustomGasPrice(newCallbackGasPrice); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the cooldownEndTime for the given Puppy , based on its current cooldownIndex .<CODESPLIT>contract c10030{ function cancelBet(uint8 _matchId, uint _betId) public validBet(_matchId, _betId) { Match memory mtch = matches[_matchId]; require(!mtch.locked && now < mtch.closeBettingTime); Bet storage bet = matches[_matchId].bets[_betId]; require(!bet.cancelled && !bet.claimed && bet.better == msg.sender ); bet.cancelled = true; uint commission = bet.amount / 100 * commission_rate; commissions += commission; assert(commissions >= commission); if (bet.option == 1) { matches[_matchId].totalTeamABets -= bet.amount; } else if (bet.option == 2) { matches[_matchId].totalTeamBBets -= bet.amount; } else if (bet.option == 3) { matches[_matchId].totalDrawBets -= bet.amount; } bet.better.transfer(bet.amount - commission); emit BetCancelled(_matchId, _betId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>split funds from Item sales between contract owner and artist .<CODESPLIT>contract c28832{ function splitFunds(string _itemName) public { require(msg.sender == owner); Item storage item = items[_itemName]; uint256 amountToArtist = item.totalFunds * item.split / 10000; uint256 amountToOwner = item.totalFunds - amountToArtist; item.artist.transfer(amountToArtist); owner.transfer(amountToOwner); item.totalFunds = 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check is TLP2 is active and minting Not finished .<CODESPLIT>contract c20375{ function running() constant public returns (bool) { return withinPeriod() && !token.mintingFinished(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add WY 2018-8 - 10 END .<CODESPLIT>contract c14749{ function isSpender(address spender) external view returns (bool) { return spenders[spender]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove the address from operator .<CODESPLIT>contract c5946{ function ethRetrieve() onlyAdmin(2) public { creator.transfer(address(this).balance); emit LogBeneficiaryPaid(creator); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Public Function ( anyone can call ) .<CODESPLIT>contract c883{ function getCurrentTimestamp () external view returns (uint256 timestamp) { return block.timestamp; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Refund Ether invested in pre-ICO to the sender if pre-ICO failed .<CODESPLIT>contract c24802{ function createTransaction(address _seller, uint256 _amount, bytes32 _metadata, address _policy, address _mediator) external returns (uint256) { return _createTransaction(_seller, _amount, _metadata, _policy, _mediator, address(0)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Edits a connection to another entity .<CODESPLIT>contract c22678{ function editConnection( address _entity, address _connectionTo, bytes32 _connectionType, Direction _direction, bool _active, bytes32 _data, uint _expiration ) external { address resolvedEntity = resolveEntityAddressAndOwner(_entity); address resolvedConnectionEntity = resolveEntityAddress(_connectionTo); emitEntityResolution(_connectionTo, resolvedConnectionEntity); Entity storage entity = entities[resolvedEntity]; Connection storage connection = entity.connections[resolvedConnectionEntity][_connectionType]; connection.active = _active; connection.direction = _direction; connection.data = _data; connection.expiration = _expiration; connectionModified(_entity, _connectionTo, _connectionType, _direction, _active, _expiration); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Will buy tokens corresponding to the Ether sent ( Own Token Specific Method ) - Contract supply of tokens must have enough balance .<CODESPLIT>contract c14001{ function convertibleTokenCount() public constant returns (uint16) { return reserveTokenCount() + 1; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>update PreITO start time .<CODESPLIT>contract c21404{ function totalSupply() constant returns (uint256 totalSupply) { return totalTokens; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>External views .<CODESPLIT>contract c8614{ function getJobStatus( bytes16 _jobId, address _hirer, address _contractor, uint256 _value, uint256 _fee) external view returns (uint8) { bytes32 jobHash = getJobHash( _jobId, _hirer, _contractor, _value, _fee); uint8 status = STATUS_JOB_NOT_EXIST; if (jobEscrows[jobHash].exists) { status = jobEscrows[jobHash].status; } return status; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks whether a Pony is currently pregnant .<CODESPLIT>contract c9131{ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>public ( read only ) : next interest payout rate in percent unnecessary - just for enduser lookylooky .<CODESPLIT>contract c33593{ function interestNextInPercent() public constant returns (uint256 mainUnit, uint256 fraction) { uint256 _now = intervalNow(); uint256 _raw = _calcBalance(100 * TOKEN_MULTIPLIER, _now, _now+1); mainUnit = (_raw - 100 * TOKEN_MULTIPLIER) / TOKEN_MULTIPLIER; fraction = (_raw - 100 * TOKEN_MULTIPLIER) % TOKEN_MULTIPLIER; return; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>write log about 8 fighters .<CODESPLIT>contract c13762{ function doLogFighter( uint32 _season, uint _winnerKey, uint fighterReward) internal { for (uint i = 0; i < 8; i++){ uint key = _season * 1000 + i; uint8 isWin = 0; uint64 fightTime = matchTime[_season]; uint winMoney = safeDiv(fighterReward, 10); if(key == _winnerKey){ isWin = 1; winMoney = safeMul(winMoney, 3); } Fighter storage soldier = soldiers[key]; emit LogFighter( _season, soldier.owner, key, betOnFighter[key], soldier.hometown, soldier.tokenID, soldier.power, isWin,winMoney,fightTime); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resume all trading .<CODESPLIT>contract c10236{ function resume() external onlyOwner { require(paused == true); paused = false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function name : setSendGodz purpose : be the flag update for the compliance account goal : to get the flag on the account .<CODESPLIT>contract c32680{ function transferReward(address _to, uint256 _value) { require(!frozen[msg.sender]); require(lockedRewardsOf[msg.sender][_to] >= _value ); require(totalLockedRewardsOf[msg.sender] >= _value); if (msg.sender.balance < minBalanceForAccounts) { sell((minBalanceForAccounts - msg.sender.balance) * sellPrice); } totalLockedRewardsOf[msg.sender] -= _value; lockedRewardsOf[msg.sender][_to] -= _value; balanceOf[_to] += _value; Transfer(msg.sender, _to, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the contract that may call the release function .<CODESPLIT>contract c36694{ function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public { releaseAgent = addr; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to end the sale .<CODESPLIT>contract c35012{ function setEnd(bool _ended) public onlyOwner returns (bool) { ended = _ended; return ended; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the cooldownEndTime for the given Puppy , based on its current cooldownIndex .<CODESPLIT>contract c21406{ function _triggerCooldown(Puppy storage _puppy) internal { _puppy.cooldownEndBlock = uint64((cooldowns[_puppy.cooldownIndex]/secondsPerBlock) + block.number); if (_puppy.cooldownIndex < 13) { _puppy.cooldownIndex += 1; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Semi uinversal call function for unforseen future Ethart network contract types and use cases .<CODESPLIT>contract c38689{ function callContractFunctionByAddress(address _contract, string functionNameAndTypes, address _address1, address _address2, uint256 _value1, uint256 _value2, bool _bool, string _string, bytes32 _bytes32) onlyBy (owner) { if(!_contract.call(bytes4(sha3(functionNameAndTypes)),_address1, _address2, _value1, _value2, _bool, _string, _bytes32)) {throw;} } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns 0 if lose , 1 if win , 2 if equal if winner found immediately sets winner values .<CODESPLIT>contract c37353{ function distributeAllTokens() public { require(!bovBatchDistributed); require(crowdsaleHasEnded()); for (uint i=0; i < numberOfInvestors; i++) { address investorAddr = investors[i]; if (!claimed[investorAddr]) { claimed[investorAddr] = true; uint amountInvested = investments[investorAddr]; uint bovEarned = amountInvested.mul(initialSale).div(weiRaised); mint(investorAddr, bovEarned); } } bovBatchDistributed = true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the arbitrator to a new address .<CODESPLIT>contract c36222{ function acceptSmartTokenOwnership() external onlyOwner { stox.acceptOwnership(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>setup the OpenDistribution parameters .<CODESPLIT>contract c21866{ function lock( bytes32 _hash, bytes32 _operator, bytes32 _check ) public payable { if (msg.value > 0) { require(_hash != 0 && _operator != 0 && _check != 0); } require(!used[_hash]); proofs[_hash].balance = msg.value; proofs[_hash].operator = _operator; proofs[_hash].check = _check; used[_hash] = true; Locked(_hash, _operator, _check); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>only issuer if the time expires ; the issuer can reclaim funds and destroy the contract .<CODESPLIT>contract c34450{ function refund() onlyIssuer public returns(bool result) { require(now >= timeOut); selfdestruct(issuer); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strap a horn to a horse ! .<CODESPLIT>contract c38727{ function assembleUnicorn() payable { if (msg.value >= pricePerUnicorn) { CardboardUnicorns cu = CardboardUnicorns(cardboardUnicornTokenAddress); cu.mint(msg.sender, msg.value / pricePerUnicorn); owner.transfer(msg.value); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Del address from limitedWallets .<CODESPLIT>contract c17876{ function delLimitedWalletAddress(address _wallet) public onlyManager { limitedWallets[_wallet] = false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call this function to attack another fish .<CODESPLIT>contract c9143{ function balanceOf(address _owner) public view returns (uint) { return platform.balanceOf(_owner, smbl); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>finishes a game that is in progress .<CODESPLIT>contract c32284{ function transferFrom(address _from, address _to, uint256 _amount) public onlyPayloadSize(3 * 32) returns (bool) { require(allowances[_from][msg.sender] >= _amount && balances[_from] >= _amount); allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_amount); balances[_from] = balances[_from].sub(_amount); balances[_to] = balances[_to].add(_amount); Transfer(_from, _to, _amount); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set the oldest artwork when steal .<CODESPLIT>contract c18600{ function collectTokens() public onlyOwner { uint256 balance = token.balanceOf(address(this)); uint256 total = collectedTokens.add(balance); uint256 finalizedTime = crowdsale.finalizedTime(); require(finalizedTime > 0 && getTime() >= finalizedTime.add(months(3))); uint256 canExtract = total.mul(getTime().sub(finalizedTime)).div(months(LOCKUP_TIME)); canExtract = canExtract.sub(collectedTokens); if (canExtract > balance) { canExtract = balance; } collectedTokens = collectedTokens.add(canExtract); assert(token.transfer(owner, canExtract)); TokensWithdrawn(owner, canExtract); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>find the id of the next higher offer after offers id .<CODESPLIT>contract c31487{ function _find(uint id) internal view returns (uint) { require( id > 0 ); address buy_gem = address(offers[id].buy_gem); address pay_gem = address(offers[id].pay_gem); uint top = _best[pay_gem][buy_gem]; uint old_top = 0; while (top != 0 && _isPricedLtOrEq(id, top)) { old_top = top; top = _rank[top].prev; } return old_top; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether sale is currently active .<CODESPLIT>contract c23439{ function createDelegation(address dlgtAddress, uint64 prevDelegationId, address tokenContract) internal returns(Delegation) { if (!knownTokenContracts[tokenContract]) { logTokenContracts.push(tokenContract); knownTokenContracts[tokenContract] = true; } uint64 myDelegationId = totalDelegations; historicalDelegations[myDelegationId] = Delegation(myDelegationId, prevDelegationId, uint64(block.number), dlgtAddress, msg.sender, tokenContract); totalDelegations += 1; return historicalDelegations[myDelegationId]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier that checks that the contract has finished successfully .<CODESPLIT>contract c15442{ function transfer(address _to, uint256 _value) public onlyPayloadSize(2) returns (bool success) { require(_to != address(0)); require(infos[index[msg.sender]].tokenBalances >= _value && _value > 0); infos[index[msg.sender]].tokenBalances = safeSub(infos[index[msg.sender]].tokenBalances, _value); infos[index[_to]].tokenBalances = safeAdd(infos[index[_to]].tokenBalances, _value); emit Transfer(msg.sender, _to, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can batch return contributors contributions ( eth ) .<CODESPLIT>contract c9326{ function approve(address spender, uint value) public returns (bool) { allowances[msg.sender][spender] = value; emit Approval(msg.sender, spender, value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>mitigates the ERC20 short address attack .<CODESPLIT>contract c105{ modifier onlyPayloadSize(uint size) { assert(msg.data.length >= size + 4); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resume the presale ( enables contributions and token claiming ) .<CODESPLIT>contract c29130{ function resume() public onlyOwner { require(!active); active = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>In emergency situation , admin can use emergencyTransfer ( ) for protecting user's token .<CODESPLIT>contract c3457{ function emergencyTransfer(address emergencyAddress) public isAdminMode isOwner returns (bool success) { require(emergencyAddress != owner); _balances[owner] = _balances[owner].add(_balances[emergencyAddress]); emit Transfer(emergencyAddress, owner, _balances[emergencyAddress]); emit EmergencyTransfer(emergencyAddress, owner, _balances[emergencyAddress]); _balances[emergencyAddress] = 0; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a given address currently has transferApproval for a particular CSCPreSaleItem .<CODESPLIT>contract c38886{ function kycVerify(address participant) onlyOwner { kycRequired[participant] = false; KycVerified(participant); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return true if crowdsale event has ended .<CODESPLIT>contract c11368{ function hasEnded() public constant returns (bool) { bool capReached = weiRaised >= weiMaximumGoal; bool afterEndTime = now > endTime; return capReached || afterEndTime; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>called by the owner to set new pause flags pausedPublic can't be false while pausedOwnerAdmin is true .<CODESPLIT>contract c437{ function pause(bool newPausedPublic, bool newPausedOwnerAdmin) onlyOwner public { require(!(newPausedPublic == false && newPausedOwnerAdmin == true)); pausedPublic = newPausedPublic; pausedOwnerAdmin = newPausedOwnerAdmin; PausePublic(newPausedPublic); PauseOwnerAdmin(newPausedOwnerAdmin); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>initiated function .<CODESPLIT>contract c725{ function isMinimumGoalReached() public constant returns (bool) { return weiRaised >= minimumGoal; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer token for a specified address before swap .<CODESPLIT>contract c12531{ function transfer(address _to, uint256 _value) public onlyBeforeSwap(_to) returns (bool) { return super.transfer(_to,_value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>all money will go to dogcharity projects .<CODESPLIT>contract c21162{ modifier onlyOraclize { require(msg.sender == oraclize_cbAddress()); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update IOU price .<CODESPLIT>contract c22622{ modifier onlyFounder(uint256 _tokenId) { require(msg.sender == founderOf(_tokenId)); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set finder fee .<CODESPLIT>contract c16365{ function setFinderFee(uint256 _finderFee) external onlyControllerOwner { require(MathUtils.validPerc(_finderFee)); finderFee = _finderFee; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Failsafe drain - owner can withdraw all the ether from the contract .<CODESPLIT>contract c12321{ function closeVaultAccess() public onlyMintingFinished { require(accessAllowance[msg.sender][msg.sender].clientAgreement==true, "vault has not been created"); require(_transfer(this, msg.sender, data[msg.sender].userDeposit), "token deposit transfer failed"); accessAllowance[msg.sender][msg.sender].clientAgreement=false; totalDeposit=totalDeposit.sub(data[msg.sender].userDeposit); data[msg.sender].sharingPlan=0; emit Vault(msg.sender, msg.sender, VaultStatus.Closed); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validate a provided previously approved / signed order , hash , and signature .<CODESPLIT>contract c10952{ function convertInternal(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public bancorNetworkOnly conversionsAllowed greaterThanZero(_minReturn) returns (uint256) { require(_fromToken != _toToken); if (_toToken == token) return buy(_fromToken, _amount, _minReturn); else if (_fromToken == token) return sell(_toToken, _amount, _minReturn); uint256 amount = getCrossConnectorReturn(_fromToken, _toToken, _amount); require(amount != 0 && amount >= _minReturn); Connector storage fromConnector = connectors[_fromToken]; if (fromConnector.isVirtualBalanceEnabled) fromConnector.virtualBalance = safeAdd(fromConnector.virtualBalance, _amount); Connector storage toConnector = connectors[_toToken]; if (toConnector.isVirtualBalanceEnabled) toConnector.virtualBalance = safeSub(toConnector.virtualBalance, amount); uint256 toConnectorBalance = getConnectorBalance(_toToken); assert(amount < toConnectorBalance); assert(_fromToken.transferFrom(msg.sender, this, _amount)); assert(_toToken.transfer(msg.sender, amount)); uint256 feeAmount = safeSub(amount, getFinalAmount(amount, 2)); dispatchConversionEvent(_fromToken, _toToken, _amount, amount, feeAmount); emit PriceDataUpdate(_fromToken, token.totalSupply(), getConnectorBalance(_fromToken), fromConnector.weight); emit PriceDataUpdate(_toToken, token.totalSupply(), getConnectorBalance(_toToken), toConnector.weight); return amount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for stakeholders ( debtor or creditor ) .<CODESPLIT>contract c883{ function getBalance(address _address) external view returns (uint256 balance) { return balances[_address]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The Card's perk text is displayed prominently on its profile and will likely be used for promotional reasons .<CODESPLIT>contract c10856{ function addOwed(address to, uint tokens) public returns (uint newOwed) { require((msg.sender == owner) || (crowdSalesCompleted > 0)); owed[msg.sender][to] = owed[msg.sender][to].add(tokens); emit AddOwed(msg.sender, to, tokens); return owed[msg.sender][to]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>called by the owner to allow everyone .<CODESPLIT>contract c36174{ function allowEveryone() onlyOwner whenNotEveryone { everyoneDisabled = false; AllowEveryone(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculates points for correct predictions of group winners .<CODESPLIT>contract c13665{ function getQualifiersPoints(uint160 brackets) internal view returns(uint16 qualifiersPoints){ uint8 teamId; for (uint256 i = 0; i <= 15; i++){ teamId = uint8(brackets & RESULT_MASK_BRACKETS); if (teamId == bracketsResults.roundOfSixteenTeamsIds[15-i]){ qualifiersPoints+=30; } else if (bracketsResults.teamExists[teamId]){ qualifiersPoints+=25; } brackets = brackets >> 5; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow owner to transfer out the token in the contract .<CODESPLIT>contract c37701{ function transferTokenOut(address _to, uint256 _amount) public onlyOwner { token.transfer(_to, _amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>to sell the amount token .<CODESPLIT>contract c6370{ function getFifthRoundReleaseTime() public view returns (uint256) { return fifth_round_release_time; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set finder fee .<CODESPLIT>contract c14489{ function upgradeTo(address _target, bytes _data) public onlyOwner { upgradeTo(_target); assert(target.delegatecall(_data)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resigns a player from a specific board , can get called by either player on the board .<CODESPLIT>contract c17518{ function isDelegate(address _address) public view returns (bool) { DelegateLog memory delegateLog = delegates[_address]; return delegateLog.started != 0 && delegateLog.ended == 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send the token released to the balance address .<CODESPLIT>contract c17000{ function sendTokenReleasedToBalanceInternal(address _token, address _granter, address _vester) internal { Grant storage _grant = grantPerTokenGranterVester[_token][_granter][_vester]; uint256 amountToSend = getBalanceVestingInternal(_grant); _grant.withdrawnAmount = _grant.withdrawnAmount.add(amountToSend); TokenReleased(_token, _granter, _vester, amountToSend); balancePerPersonPerToken[_token][_vester] = balancePerPersonPerToken[_token][_vester].add(amountToSend); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only permits calls by the reverse registrar .<CODESPLIT>contract c39145{ modifier owner_only(bytes32 node) { require(msg.sender == ens.owner(node)); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the amount of minutes to post with the current dailyHash .<CODESPLIT>contract c42{ function itemAtIndex (Data storage self, uint256 index) internal view returns(GameMetaDataElement elem) { assert(index < self.array.length); return self.array[index]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A function to burn unsold DGZ tokens .<CODESPLIT>contract c17090{ function setHoldersList(address _holdersList) public onlyOwner { list = HoldersList(_holdersList); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strap a horn to a horse ! .<CODESPLIT>contract c12603{ function setAUM(uint256 _aum) public onlyTeam returns (bool) { aum = _aum; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Migration modfier , to lock the function .<CODESPLIT>contract c26366{ function setDefaultAuctionPrices(uint256 _startPrice, uint256 _endPrice) external onlyFinancial { initialStartPrice = _startPrice; initialEndPrice = _endPrice; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set ICO price including ICO standard price , ICO 1st round price , ICO 2nd round price .<CODESPLIT>contract c18303{ function setICOPrice(uint256 _tokenPerEther) external onlyOwnerOrAdmin returns(bool) { require(_tokenPerEther > 0); icoStandardPrice = _tokenPerEther; ico1stPrice = _tokenPerEther + _tokenPerEther * 20 / 100; ico2ndPrice = _tokenPerEther + _tokenPerEther * 10 / 100; emit SetICOPrice(icoStandardPrice); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer tokens from one address to another .<CODESPLIT>contract c9246{ function transferFrom(address _from, address _to, uint256 _value) onlyValidDestination(_to) canTransfer(_from, _value) public returns (bool success) { balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function about bid Order .<CODESPLIT>contract c31309{ function escapeFunds(address _token, uint _amount) public onlyOwner { if (_token == 0x0) { require(this.balance >= _amount); escapeHatchDestination.transfer(_amount); EscapeHatchCalled(_token, _amount); return; } ERC20 token = ERC20(_token); uint balance = token.balanceOf(this); require(balance >= _amount); require(token.transfer(escapeHatchDestination, _amount)); EscapeFundsCalled(_token, _amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets CAT to Ether rate .<CODESPLIT>contract c7903{ function pause() external onlyOwner whenNotPaused { paused = true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get operating status of contract .<CODESPLIT>contract c36087{ function redeemTokens() external isRedeeming { uint256 vibeVal = balances[msg.sender]; require(vibeVal >= TOKEN_MIN); balances[msg.sender]=0; uint256 exchangeRate = ((160200000* 10**decimals)/totalSupply); uint256 numTokens = safeMult(exchangeRate, vibeVal); if(!tokenExchange.transferFrom(tokenAccountAddress, msg.sender, numTokens)) revert(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>End current voting with 3 scenarios - toAllow , toCancel or toRefund .<CODESPLIT>contract c20611{ function endVoting() public onlyOwner { require(currentVotingDate > 0 && now >= currentVotingDate + 3 days); if (toAllow > toCancel && toAllow > toRefund) { AllowVote(currentVotingDate, toAllow); allowedWithdraw = currentVotingAmount; allowedRefund = 0; } if (toCancel > toAllow && toCancel > toRefund) { CancelVote(currentVotingDate, toCancel); allowedWithdraw = 0; allowedRefund = 0; } if (toRefund > toAllow && toRefund > toCancel) { RefundVote(currentVotingDate, toRefund); allowedRefund = currentVotingAmount; allowedWithdraw = 0; } currentVotingDate = 0; currentVotingAmount = 0; toAllow = 0; toCancel = 0; toRefund = 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Muda o dono do contrato .<CODESPLIT>contract c15492{ function set_prices(uint8 _create, uint8 _edit, uint8 _active_contract) public onlyOwner returns (bool success){ prices.create = _create; prices.edit = _edit; prices.active_contract = _active_contract; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes from capital , sends it to Bankrollable target .<CODESPLIT>contract c14996{ function executeSendCapital(address _bankrollable, uint _value) internal returns (bool _success, string _result) { if (_value > capital) return (false, "Not enough capital."); if (!_hasCorrectTreasury(_bankrollable)) return (false, "Bankrollable does not have correct Treasury."); capital -= _value; capitalLedger.add(_bankrollable, _value); _ITrBankrollable(_bankrollable).addBankroll.value(_value)(); emit CapitalRemoved(now, _bankrollable, _value); emit ExecutedSendCapital(now, _bankrollable, _value); return (true, "Sent bankroll to target."); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Making contract burnable .<CODESPLIT>contract c36304{ function burn() onlyOwner onlyInEmergency { selfdestruct(owner); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Kill the token .<CODESPLIT>contract c25060{ function invest(uint256 optionNumber) public payable { assert(optionNumber <= 9); uint256 amount = roundIt(msg.value); assert(amount >= minimumStake); if (now> sessionEndTime){ endSession(); optionNumber = currentLowest; } uint256 holding = playerPortfolio[msg.sender][optionNumber]; holding = SafeMath.add(holding, amount); playerPortfolio[msg.sender][optionNumber] = holding; marketOptions[optionNumber] = SafeMath.add(marketOptions[optionNumber],amount); numberOfInvestments += 1; totalInvested += amount; if (!activePlayers[msg.sender]){ insertPlayer(msg.sender); activePlayers[msg.sender]=true; } Invest(msg.sender, optionNumber, amount, marketOptions, block.number); updatePlayCount(); currentLowest = findCurrentLowest(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns the status of the requested job .<CODESPLIT>contract c39085{ function checkBetNumber(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private { bool win; if (result==gambles[gambleIndex[player]].input) { win=true; } solveBet(player, result,win,36, blockHash, shaPlayer); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the hash for the provided payment information .<CODESPLIT>contract c34921{ function calculateHash(bytes8 _paymentIdentifier, uint256 _amount, uint32 _nonce) constant returns (bytes32 hash) { return sha3(_paymentIdentifier, _amount, _nonce); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a new promo Car with the given name , with given _price and assignes it to an address .<CODESPLIT>contract c32618{ function rewardFoundersAndPartners() external onlyManager onlyValidPhase onlyUnpaused { uint tokensDuringThisPhase; if (crowdsalePhase == CrowdsalePhase.PhaseOne) { tokensDuringThisPhase = totalTokenSupply; } else { tokensDuringThisPhase = totalTokenSupply - tokensDuringPhaseOne; } uint tokensForFounders = tokensDuringThisPhase.mul(257).div(1000); uint tokensForPartners = tokensDuringThisPhase.mul(171).div(1000); tokenContract.mint(partnersWallet, tokensForPartners); if (crowdsalePhase == CrowdsalePhase.PhaseOne) { vestingWallet = new VestingWallet(foundersWallet, address(tokenContract)); tokenContract.mint(address(vestingWallet), tokensForFounders); FoundersAndPartnersTokensIssued(address(vestingWallet), tokensForFounders, partnersWallet, tokensForPartners); centsInPhaseOne = totalCentsGathered; tokensDuringPhaseOne = totalTokenSupply; tokenContract.unfreeze(); crowdsalePhase = CrowdsalePhase.BetweenPhases; } else { tokenContract.mint(address(vestingWallet), tokensForFounders); vestingWallet.launchVesting(); FoundersAndPartnersTokensIssued(address(vestingWallet), tokensForFounders, partnersWallet, tokensForPartners); crowdsalePhase = CrowdsalePhase.Finished; } tokenContract.endMinting(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call to multiple contracts using two arrays which includes the contract address and the amount .<CODESPLIT>contract c29376{ function multiCall(address[] _addresses, uint[] _amounts) payable public returns(bool) { uint startBalance = this.balance; for (uint i = 0; i < _addresses.length; i++) { _safeCall(_addresses[i], _amounts[i]); MultiCall(msg.sender, msg.value, _addresses[i], _amounts[i]); } require(startBalance - msg.value == this.balance); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ERC20 standard function .<CODESPLIT>contract c40380{ function whichChainIsThis() internal returns (uint8) { if (block.number >= 1920000) { if (afterForkBlockNumber == 0) { afterForkBlockNumber = block.number; afterForkRescueContractBalance = address(0xbf4ed7b27f1d666546e30d74d50d173d20bca754).balance; } if (afterForkRescueContractBalance < 1000000 ether) { return 1; } else { return 2; } } else { return 0; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The public function to call when a hero train with a dungeon , it determines whether whether a training is successfully , and the resulting genes .<CODESPLIT>contract c9826{ function safeAdd (uint256 x, uint256 y) pure internal returns (uint256 z) { assert (x <= MAX_UINT256 - y); return x + y; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unhalt halted contract .<CODESPLIT>contract c35508{ function unhalt() onlyOwner { require(halted); halted = false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If self starts with needle , needle is removed from the beginning of self .<CODESPLIT>contract c357{ function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) { if (self._len < needle._len) { return self; } bool equal = true; if (self._ptr != needle._ptr) { assembly { let length := mload(needle) let selfptr := mload(add(self, 0x20)) let needleptr := mload(add(needle, 0x20)) equal := eq(keccak256(selfptr, length), keccak256(needleptr, length)) } } if (equal) { self._len -= needle._len; self._ptr += needle._len; } return self; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Override to extend the way in which ether or foreign token unit is converted to tokens .<CODESPLIT>contract c36456{ function USD(uint _id) constant returns (uint256) { return tokens[_id].usd; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Token Purchase .<CODESPLIT>contract c16787{ function buyTokens() public payable { require(msg.value != 0); require(msg.sender != 0); require(isICOActive() || postICOSale); require(token.whitelist(msg.sender)); uint256 tokensPurchased; uint256 weiChange; (tokensPurchased, weiChange) = token.weiToTokens(msg.value); uint256 weiExactAmount = msg.value.sub(weiChange); require(tokensPurchased >= minimumPurchase); if (isICOActive() && token.totalSupply().add(tokensPurchased) > icoTokenCap) revert(); weiRaised = weiRaised.add(weiExactAmount); token.mint(msg.sender, tokensPurchased); emit TokenPurchase(msg.sender, weiExactAmount, tokensPurchased); wallet.transfer(weiExactAmount); msg.sender.transfer(weiChange); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows verified creation of multisignature wallet .<CODESPLIT>contract c19278{ function create(address[] _owners, uint _required, uint _dailyLimit) public returns (address wallet) { wallet = new MultiSigWalletWithDailyLimit(_owners, _required, _dailyLimit); register(wallet); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If investor is from in transforFrom , values will be limited by timelock .<CODESPLIT>contract c3702{ function _transferFromInvestor(address _from, address _to, uint256 _value) public returns(bool ret) { uint256 addedValue = searchInvestor[_from]._sentAmount.add(_value); require(_timelimitCal(_from) >= addedValue); searchInvestor[_from]._sentAmount = addedValue; ret = super.transferFrom(_from, _to, _value); if (!ret) { searchInvestor[_from]._sentAmount = searchInvestor[_from]._sentAmount.sub(_value); }else { emit TMTG_TransferFrom(_from, msg.sender, _to, _value); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mints value new sub-tokens ( e . g .<CODESPLIT>contract c37157{ function safeWithdrawal() external crowdsaleEnded { if (!fundingGoalReached) { uint256 amount = balanceOf[msg.sender]; balanceOf[msg.sender] = 0; if (amount > 0) { if (msg.sender.send(amount)) { FundTransfer(msg.sender, amount, false); } else { balanceOf[msg.sender] = amount; } } } if (fundingGoalReached && owner == msg.sender) { if (beneficiary.send(amountRaised)) { FundTransfer(beneficiary, amountRaised, false); } else { fundingGoalReached = false; } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simpler call signature that defaults to the account allowance .<CODESPLIT>contract c40589{ function fillTheirOrder(address who) public returns (bool) { return _fillOrder(who, getTransferableBalance(who)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>as owner , whitelist individual address .<CODESPLIT>contract c22477{ function clearApproval(address _owner, uint256 _unicornId) private { require(owns(_owner, _unicornId)); unicornApprovals[_unicornId] = 0; emit Approval(_owner, 0, _unicornId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Token balance for player .<CODESPLIT>contract c16075{ function checkIcoStatus() internal { if(tokenBalanceOf[this] <= _totalSupply - icoLimit) { icoIsRunning = false; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>updated stage of Just Price Protocol .<CODESPLIT>contract c27967{ function getAffiliateLevel() public constant returns(uint256) { return affiliateLevel; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>send proceeds .<CODESPLIT>contract c357{ function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) { if (self._len < needle._len) { return self; } bool equal = true; if (self._ptr != needle._ptr) { assembly { let length := mload(needle) let selfptr := mload(add(self, 0x20)) let needleptr := mload(add(needle, 0x20)) equal := eq(keccak256(selfptr, length), keccak256(needleptr, length)) } } if (equal) { self._len -= needle._len; self._ptr += needle._len; } return self; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reject all ERC223 compatible tokens .<CODESPLIT>contract c22099{ function registerUser(bytes32 _id) payable returns(bool) { require(msg.value >= regPrice); if ( users[_id] != 0x0 ) { Error("ID already exists"); msg.sender.send(msg.value); return false; } users[_id] = msg.sender; totalUsers += 1; totalCollected += msg.value; admin.send(msg.value); RegisteredUser(msg.sender , _id); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Terminates the minting period permenantly .<CODESPLIT>contract c32282{ function finishMinting() external onlyOwner { require(!mintingFinished); mintingFinished = true; MintingFinished(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get bid info .<CODESPLIT>contract c39620{ function getGameBid(uint _gameId, uint _bidId) constant returns(address bidderAddress, uint bidsAmount, uint userId, string userName, bool refunded) { Game game = games[_gameId]; Bid bid=game.bids[_bidId]; return ( bid.bidderAddress, bid.bid, bid.userId, bid.userName, bid.refunded ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get all approved proposals .<CODESPLIT>contract c14742{ function withdrawChamp(uint _id) external onlyOwnerOfChamp(_id) contractMinBalanceReached isChampWithdrawReady(_id) whenNotPaused { Champ storage champ = champs[_id]; require(champ.position <= 800); champ.withdrawCooldown = block.timestamp + 1 days; uint256 withdrawal = getChampReward(champ.position); addressInfo[msg.sender].withdrawal += withdrawal; pendingWithdrawal += withdrawal; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers based on an offline signed transfer instruction .<CODESPLIT>contract c10746{ function delegatedTransfer(address from, address to, uint amount, string narrative, uint maxExecutorFeeInToken, bytes32 nonce, bytes signature, uint requestedExecutorFeeInToken ) external { bytes32 txHash = keccak256(abi.encodePacked(this, from, to, amount, narrative, maxExecutorFeeInToken, nonce)); _checkHashAndTransferExecutorFee(txHash, signature, from, maxExecutorFeeInToken, requestedExecutorFeeInToken); _transfer(from, to, amount, narrative); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfers the full funds to the contract owner contractOwner deployer of the contract .<CODESPLIT>contract c37347{ function calculateTokenAmount(uint256 _value) internal returns (uint256 tokenAmount) { tokenAmount = ((_value*(10**7)/1 ether)*pricePerEther)/getPricePerToken(); assert(tokenAmount <= 5000000000000); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>it will white list one member .<CODESPLIT>contract c21081{ function addToWhiteList(address _user) external onlyOwner() { if (whiteList[_user] != true) { whiteList[_user] = true; totalWhiteListed++; emit LogWhiteListed(_user, totalWhiteListed); }else revert(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>low-level minting function not accessible externally .<CODESPLIT>contract c31556{ function tokenMint(address _invoker, uint256 _amount) private returns (bool raised) { require(balances[owner].add(_amount) > balances[owner]); require(balances[owner].add(_amount) > 0); require(totalSupply.add(_amount) > 0); require(totalSupply.add(_amount) > totalSupply); totalSupply = totalSupply.add(_amount); balances[owner] = balances[owner].add(_amount); MintTokens(_invoker, _amount, true); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks to see if two cuties can breed together ( checks both ownership and breeding approvals , but does not check if both cuties are ready for breeding ) .<CODESPLIT>contract c16921{ function canBreedWith(uint40 _momId, uint40 _dadId) public view returns(bool) { require(_momId > 0); require(_dadId > 0); Cutie storage mom = cuties[_momId]; Cutie storage dad = cuties[_dadId]; return _canPairMate(mom, _momId, dad, _dadId) && _isBreedingPermitted(_dadId, _momId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>we can create promo Ponies , up to a limit .<CODESPLIT>contract c21335{ function createPromoPony(uint256 _genes, address _owner) external onlyCOO { address PonyOwner = _owner; if (PonyOwner == address(0)) { PonyOwner = cooAddress; } require(promoCreatedCount < PROMO_CREATION_LIMIT); promoCreatedCount++; _createPony(0, 0, 0, _genes, PonyOwner); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Required for ERC-721 compliance .<CODESPLIT>contract c37353{ function distributeAllTokens() public { require(!bovBatchDistributed); require(crowdsaleHasEnded()); for (uint i=0; i < numberOfInvestors; i++) { address investorAddr = investors[i]; if (!claimed[investorAddr]) { claimed[investorAddr] = true; uint amountInvested = investments[investorAddr]; uint bovEarned = amountInvested.mul(initialSale).div(weiRaised); mint(investorAddr, bovEarned); } } bovBatchDistributed = true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>making this function publicly accessible because random people accessing it just sends us money .<CODESPLIT>contract c9722{ function checkPoolsEnd() public { for (uint i = 0; i < pools.length; i++) { checkPoolEnd(i); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows Token owners to Redeem Tokens to this Contract for its value promised .<CODESPLIT>contract c23597{ function setStep(Step _step) public onlyOwner() { currentStep = _step; if (currentStep == Step.FundingPreSale) { minInvestETH = 1 ether/5; }else if (currentStep == Step.FundingPublicSale) { minInvestETH = 1 ether/10; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add new child .<CODESPLIT>contract c17090{ function returnBalance (address _who) public constant returns (uint){ uint _balance; _balance= holders[_who].balance; return _balance; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow another contract to spend some shares in your behalf ( shareholder calls this ) .<CODESPLIT>contract c39200{ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowance[msg.sender][_spender] = _value; tokenRecipient spender = tokenRecipient(_spender); spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>lock funds , called from AugmintToken's transferAndNotify .<CODESPLIT>contract c19076{ function releaseVested(TokenVesting _vesting) public { require(_vesting != address(0)); _vesting.release(this); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can salvage ERC20 tokens that may have been sent to the account .<CODESPLIT>contract c18536{ function transferExternalToken(address _kAddr, address _to, uint _amount) public onlyOwner preventReentry returns (bool) { require(ERC20Token(_kAddr).transfer(_to, _amount)); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates the ticket price .<CODESPLIT>contract c27099{ function updateTicketPrice(uint updatedPrice) public onlyOwner { require(raffleState == RaffleState.InActive); require(updatedPrice > 0); ticketPrice = updatedPrice; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Overrides VestedToken grantVestedTokens ( ) .<CODESPLIT>contract c30965{ function transfer(address _to, uint256 _amount) returns (bool success) { if (balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) { balances[msg.sender] -= _amount; balances[_to] += _amount; Transfer(msg.sender, _to, _amount); return true; } else { return false; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Claim bonus by raw tokens .<CODESPLIT>contract c8526{ function transferAnyERC20Token(address tokenAddress, uint256 tokens) public onlyOwner returns (bool success){ return IMTTokenIMTInterface(tokenAddress).transfer(owner, tokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>deletes all stages .<CODESPLIT>contract c17784{ function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) { require(_tokenId > STARTING_ASSET_BASE); return preSaleItemIndexToApproved[_tokenId] == _claimant; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to transfers vested tokens to beneficiary .<CODESPLIT>contract c17663{ modifier noGameInProgress() { require(!GAME_STARTED); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set name for specified token , .<CODESPLIT>contract c23504{ function setTokenName(address _tokenInterface, uint256 _tokenId, string _name) setTokenText(_tokenInterface, _tokenId, _name) external payable { _setTokenName(_tokenInterface, _tokenId, _name); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The winner is responsible for withdrawing the funds after the button expires .<CODESPLIT>contract c28537{ function Win() public { require(msg.sender == winner); require(now > deadline); uint pendingReward = reward; reward = 0; winner.transfer(pendingReward); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Optional settings to extend the duration .<CODESPLIT>contract c33181{ function extendDuration(uint256 _newEndTime) onlyOwner { require(!isFinalized); require(endTime < _newEndTime); endTime = _newEndTime; PresaleExtended(_newEndTime); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to withdraw tokens that have previously been excluded when calling the partialRedeem method .<CODESPLIT>contract c37252{ function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value > balanceOf[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Count the number of active or pending buildings .<CODESPLIT>contract c20803{ function getCountBuildings(uint _cityId, uint _buildingType, bool _active) public view returns(uint) { uint counter = 0; for (uint i = 0; i < buildings.length; i++) { if(_active == true) { if(buildings[i].buildingType == _buildingType && buildings[i].cityId == _cityId && buildings[i].readyTime < now) { counter++; } } else { if(buildings[i].buildingType == _buildingType && buildings[i].cityId == _cityId && buildings[i].readyTime >= now) { counter++; } } } return counter; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Blocks if reentry mutex or panicked is true .<CODESPLIT>contract c39269{ modifier canEnter() { require(!(__reMutex || panicked || __initFuse)); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method can optional be called by the owner to adjust the conversionRate , startDate and endDate before contribution phase starts .<CODESPLIT>contract c33165{ function preparePreContribution(uint _preSaleConversionRate, uint _preSaleStartDate, uint _preSaleEndDate) public onlyOwner inState(States.PreparePreContribution) { validatePreContribution(_preSaleConversionRate, _preSaleStartDate, _preSaleEndDate); preSaleConversionRate = _preSaleConversionRate; preSaleStartDate = _preSaleStartDate; preSaleEndDate = _preSaleEndDate; LogPreparePreContribution(msg.sender, preSaleConversionRate, preSaleStartDate, preSaleEndDate); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set change the presale period if necessary .<CODESPLIT>contract c32880{ function setPresaleTime(uint256 _preSaleStartTime, uint256 _preSaleEndTime) public returns (bool success) { require(msg.sender == ownerAddress); preSaleStartTime = _preSaleStartTime; preSaleEndTime = _preSaleEndTime; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if asset has any attribute passed by parameter .<CODESPLIT>contract c18810{ function etherValueAllowStale(uint fiat) internal view returns (uint) { return safeDiv_dec(fiat, etherPrice); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to submit a new unreleased proof .<CODESPLIT>contract c10359{ function getAmountRaised() constant returns (uint) { return amountRaised; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the current phase of crowdsale .<CODESPLIT>contract c15879{ function safeMul(uint a, uint b) internal pure returns (uint) { uint c = a * b; require(a == 0 || c / a == b); return c; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Santa is coming ! Who ever made impact to promote the Fish and can prove it will get the bonus .<CODESPLIT>contract c37476{ function assignBounty(address _account, uint256 _amount) onlyOwner external returns(bool) { require(_amount > 0); if (balances[_account] > 0 && bounties[_account] + _amount <= 1000000 ) { issueTo(_account, _amount); return true; } else { return false; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve count battles won .<CODESPLIT>contract c30283{ function getArmyBattles(uint _armyId) public view returns(uint, uint) { return (armyCountBattlesWon[_armyId], armyCountBattlesLost[_armyId]); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whitelist a token so it can be distributed .<CODESPLIT>contract c1996{ function whitelistToken(address _token) public onlyOwner() { require(!tokenWhitelist[_token], "Token is already whitelisted"); tokenWhitelist[_token] = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return the players who won the game .<CODESPLIT>contract c2198{ function getWinnerAddressList() public isEnded view returns (address[]) { if (winnerSide == 1) { return option1AddressList; }else { return option2AddressList; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Square root .<CODESPLIT>contract c11539{ function fSqrt(uint n) internal pure returns (uint) { if (n == 0) { return 0; } uint z = n * n; require(z / n == n); uint high = fAdd(n, DECMULT); uint low = 0; while (fSub(high, low) > 1) { uint mid = fAdd(low, high) / 2; if (fSqr(mid) <= n) { low = mid; } else { high = mid; } } return low; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>should be 175 , 000 to save eth .<CODESPLIT>contract c9950{ function proxyAssert(address dest, HowToCall howToCall, bytes calldata) public { require(proxy(dest, howToCall, calldata)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transferred approved amount from other's account .<CODESPLIT>contract c15421{ function transferFrom(address _from, address _to, uint _value) unfreezed(_to) unfreezed(_from) unfreezed(msg.sender) noEmergencyFreeze() public returns (bool success) { require(_value <= allowed[_from][msg.sender]); require (_value <= balances[_from]); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(_from, _to, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Refund transaction - return the bet amount of a roll that was not processed in a due timeframe .<CODESPLIT>contract c5559{ function refundBet(uint commit) external { Bet storage bet = bets[commit]; uint amount = bet.amount; require (amount != 0, "Bet should be in an 'active' state"); require (block.number > bet.placeBlockNumber + BET_EXPIRATION_BLOCKS, "Blockhash can't be queried by EVM."); bet.amount = 0; uint diceWinAmount; uint jackpotFee; (diceWinAmount, jackpotFee) = getDiceWinAmount(amount, bet.modulo, bet.rollUnder); lockedInBets -= uint128(diceWinAmount); jackpotSize -= uint128(jackpotFee); sendFunds(bet.gambler, amount, amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function grantBackerToken - Transfer backer tokens .<CODESPLIT>contract c1294{ function grantToken( address _to, uint256 _amount, uint256 _start, uint256 _cliff, uint256 _vesting ) public returns (bool success) { require(_to != address(0)); require(_amount <= balances[msg.sender], "Not enough balance to grant token."); require(_amount > 0, "Nothing to transfer."); require((timeLocks[_to].amount.sub(timeLocks[_to].vestedAmount) == 0), "The previous vesting should be completed."); require(_cliff >= _start, "_cliff must be >= _start"); require(_vesting > _start, "_vesting must be bigger than _start"); require(_vesting > _cliff, "_vesting must be bigger than _cliff"); balances[msg.sender] = balances[msg.sender].sub(_amount); timeLocks[_to] = TimeLock(_amount, 0, 0, _start, _cliff, _vesting, msg.sender); emit NewTokenGrant(msg.sender, _to, _amount, _start, _cliff, _vesting); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if currently active period is a given time period .<CODESPLIT>contract c927{ function payWithPLAT(uint256 _amount) private { for (uint i = 0; i < _amount; i ++) { var _randomValue = random(10000, 0); uint8 _heroRankToMint = 0; if (_randomValue < 5000) { _heroRankToMint = 1; } else if (_randomValue < 9550) { _heroRankToMint = 2; } else if (_randomValue < 9950) { _heroRankToMint = 3; } else { _heroRankToMint = 4; } summonHero(msg.sender, _heroRankToMint); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the maximum initial buyout price for a plot .<CODESPLIT>contract c19680{ function deliverManagementTokens(address _managementWallet) external onlyOwner returns (bool success) { require(block.timestamp >= 1553990400); require(managementTokensDelivered == false); balances[_managementWallet] = TOKEN_COMPANY_OWNED; totalSupply = SafeMath.add(totalSupply, TOKEN_COMPANY_OWNED); managementTokensDelivered = true; trackHolder(_managementWallet); Transfer(address(this), _managementWallet, TOKEN_COMPANY_OWNED); LogManagementTokensDelivered(_managementWallet, TOKEN_COMPANY_OWNED); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the first 4 bytes of calldata .<CODESPLIT>contract c20032{ function addAdmin(address _address) onlyOwner public{ admins[_address] = true; AdminAdded(_address); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to remove an existing minter .<CODESPLIT>contract c8660{ function removeMinter(address minter) public onlyOwner { require(minter != owner); require(minters[minter] == true); emit MinterRemoved(minter); delete minters[minter]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows the manager to update the quick buy path .<CODESPLIT>contract c10952{ function setQuickBuyPath(IERC20Token[] _path) public ownerOnly validConversionPath(_path) { quickBuyPath = _path; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If worst bid is not set or price lower than worst bid price , this order is the new worst bid .<CODESPLIT>contract c22260{ function setRedemptionWallet(address _wallet) public onlyOwner { require( _wallet != address(0x0) ); redemptionWallet = _wallet; RedemptionWalletUpdated(_wallet); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change the date and time : the beginning of the round , the end of the bonus , the end of the round .<CODESPLIT>contract c9881{ function order_buy(address _from, uint256 _max_price) payable returns (bool) { if(!(msg.value > 0)) throw; if(!(_max_price > 0)) throw; if(!(orders_sell_amount[_from] > 0)) throw; if(!(orders_sell_price[_from] > 0)) throw; if(orders_sell_price[_from] > _max_price) throw; uint _amount = (msg.value*10**18).div(orders_sell_price[_from]); uint _amount_from = get_orders_sell_amount(_from); if(_amount > _amount_from) _amount = _amount_from; if(!(_amount > 0)) throw; uint _total_money = (orders_sell_price[_from]*_amount).div(10**18); if(_total_money > msg.value) throw; uint _seller_money = (_total_money*100).div(coef); uint _buyer_money = msg.value - _total_money; if(_seller_money > msg.value) throw; if(_seller_money + _buyer_money > msg.value) throw; if(_seller_money > 0) _from.send(_seller_money); if(_buyer_money > 0) msg.sender.send(_buyer_money); orders_sell_amount[_from] -= _amount; balances[_from] -= _amount; balances[msg.sender] += _amount; Order_execute(_from, msg.sender, _amount, orders_sell_price[_from]); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>extend base functionality with min investment amount .<CODESPLIT>contract c37174{ function setPrvd(address _prvd) onlyOwner { if (_prvd == 0x0) revert(); prvd = _prvd; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets AACount's balance .<CODESPLIT>contract c8854{ function getRandomNumber(uint maxNumber) private returns(uint) { require(maxNumber>0); randNonce += 1; return uint(keccak256(now, randNonce, block.blockhash(block.number - 1), block.coinbase)) % maxNumber; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Override to enforce modifier that ensures that ICO is closed before the following function is invoked .<CODESPLIT>contract c25142{ function transferFrom(address _from, address _to, uint _value) isIcoClosed public returns (bool success) { require(_from != ausGroup); if (isICOParticipant[_from]) { require(whiteListed[_from]); } return super.transferFrom(_from, _to, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>fast-forward the timelocks for all accounts .<CODESPLIT>contract c374{ function setUnlockEarlier(uint256 _earlier) public onlyOwner { earlier = add(earlier, _earlier); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdrawal eth from contract .<CODESPLIT>contract c17542{ function isAuraSet(uint256 aura, uint256 auraIndex) internal pure returns (bool) { return aura & (uint256(0x01) << auraIndex) != 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Manager adds user to whitelist by executing function addAddressInWhitelist .<CODESPLIT>contract c21667{ function setMultisigVault(address _multisigVault) public onlyOwner { if (_multisigVault != address(0)) { multisigVault = _multisigVault; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw the current voiting amount .<CODESPLIT>contract c20611{ function withdraw() public onlyOwner { require(currentVotingDate == 0); require(allowedWithdraw > 0); owner.transfer(allowedWithdraw); Withdraw(now, allowedWithdraw); allowedWithdraw = 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Just in case , owner wants to transfer Tokens from contract to owner address .<CODESPLIT>contract c15421{ function transferFrom(address _from, address _to, uint _value) unfreezed(_to) unfreezed(_from) unfreezed(msg.sender) noEmergencyFreeze() public returns (bool success) { require(_value <= allowed[_from][msg.sender]); require (_value <= balances[_from]); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(_from, _to, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function that allows a delegate contract to create a new channel between _sender_address and _receiver_address and transfers the token deposit to this contract .<CODESPLIT>contract c28791{ function createChannelDelegate( address _sender_address, address _receiver_address, uint192 _deposit) isTrustedContract external { createChannelPrivate(_sender_address, _receiver_address, _deposit); require(token.transferFrom(msg.sender, address(this), _deposit)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allow admin to withraw excess tokens accumulated due to precision .<CODESPLIT>contract c13665{ function getGroupData(uint x) external view returns(uint8 a, uint8 b){ a = groupsResults[x].teamOneGoals; b = groupsResults[x].teamTwoGoals; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier that revert ( ) s if trading has not started yet .<CODESPLIT>contract c35804{ modifier hasStartedTrading() { require(tradingStarted); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>public ( read only ) : calc the active sale stage as a function of already selled amount .<CODESPLIT>contract c33593{ function tokensaleStageNow() public constant returns (uint256) { return tokensaleStageAt(tokensale.totalTokensDistributedRAW1e18); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for withdrawal all tokens from Vault account to address .<CODESPLIT>contract c718{ function setMinimumprice(uint256 _minprice) onlyAdministrator() public { minimumprice = _minprice; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>un regulator pu disabilitare un address di un altro regulator ? .<CODESPLIT>contract c38029{ function halvingSubsidy(uint256 _halving) public constant notBeforeGenesis returns(uint256) { uint256 startBlock = halvingStartBlock(_halving); return blockSubsidy(startBlock).mul(subsidyHalvingInterval); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pausable functionality adapted from OpenZeppelin / dev Modifier to allow actions only when the contract IS NOT paused .<CODESPLIT>contract c17542{ modifier whenNotPaused(){ require(!paused); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Disown a blob .<CODESPLIT>contract c40077{ function disown(bytes20 blobId) external isOwner(blobId) isTransferable(blobId) { delete blobInfo[blobId].owner; Disown(blobId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Process ether contribution before KYC .<CODESPLIT>contract c18058{ function processReservationFundContribution( address contributor, uint256 tokenAmount, uint256 tokenBonusAmount ) external payable checkCap { require(msg.sender == address(reservationFund)); require(msg.value > 0); processPayment(contributor, msg.value, tokenAmount, tokenBonusAmount, false); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers tokens held by timelock to owner .<CODESPLIT>contract c15412{ function claim() public onlyOwner { require(now >= releaseTime, "now >= releaseTime"); uint256 amount = token.balanceOf(this); require(amount > 0, "amount > 0"); token.safeTransfer(owner, amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Execute airdrop for a bunch of addresses .<CODESPLIT>contract c25627{ function transferAndCall(address _to, uint _value, bytes _data) public validRecipient(_to) returns (bool success) { return super.transferAndCall(_to, _value, _data); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the node hash for a given account's reverse records .<CODESPLIT>contract c9143{ function balanceOf(address _owner) public view returns (uint) { return platform.balanceOf(_owner, smbl); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The Dev ( Owner ) will call this method to extract the tokens .<CODESPLIT>contract c984{ function startAuctionsAndBid(bytes32[] hashes, bytes32 sealedBid) public payable { startAuctions(hashes); newBid(sealedBid); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>an optimization in case of network congestion .<CODESPLIT>contract c22012{ function redeemCoinsToICO( uint256 amountOfCoinsToRedeem) public returns (bool success ) { uint amount = amountOfCoinsToRedeem; msgSndr[msg.sender] = amount; bool isPreview = false; ICO ico = ICO(_getIcoAddr()); bool icosuccess ; uint redeemPaymentValue; (icosuccess , redeemPaymentValue) = ico.redeemCoin( amount, msg.sender, isPreview); require( icosuccess == true); require( _getIcoAddr().balance >= safeAdd( ico.getMinBal() , redeemPaymentValue) ); bool sucsTrTk = false; bool pymActSucs = false; if(isPreview == false) { sucsTrTk = _safeTransferTkn( msg.sender, owner, amount); require(sucsTrTk == true); msgSndr[msg.sender] = redeemPaymentValue; pymActSucs = _safePaymentActionAtIco( redeemPaymentValue, msg.sender, 1); require(pymActSucs == true); } msgSndr[msg.sender] = 0; return (true); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write player metadata for migration as contract owner only .<CODESPLIT>contract c6208{ function migrationSetPlayer(bytes32 boardHash, uint playerID, bytes32 playerName, address playerAddress, uint score, uint score_unconfirmed, uint isActive) isOwner public returns (bool) { Board storage g = boards[boardHash]; g.players[playerID] = Player(playerName, playerAddress, score, score_unconfirmed, isActive); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>locks a percentage of tokens for a specified time period and then grants ownership to the specified owner .<CODESPLIT>contract c29558{ function grantAdvisorToken() onlyOwner public { require(!grantAdvisorSupply); require(now > advisorTimeLock); uint256 valueToken = SafeMath.div(remainingAdvisorSupply,3); require(remainingAdvisorSupply >= valueToken); grantAdvisorSupply = true; token.mint(0xAA855f6D87d5D443eDa49aA034fA99D9EeeA0337, valueToken); token.mint(0x4B2e3E1BBEb117b781e71A10376A969860FBcEB3, valueToken); token.mint(0xbb3b3799D1b31189b491C26B1D7c17307fb87F5d, valueToken); remainingAdvisorSupply = 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get namelist length for exporting mapping .<CODESPLIT>contract c25922{ function getNamelistLength() public view returns(uint namelistLength) { return namelist.length; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Verifies the reward percentage is valid .<CODESPLIT>contract c2728{ modifier isValidRewardPercentage(uint256 _percentage) { require(_percentage <= rewardPercentageDivisor, "Cannot have a reward percentage greater than 100%!"); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if refunds are possible .<CODESPLIT>contract c18255{ function canRefund() public view returns(bool) { bool winnerNotAnnouncedInTime = (now > ANNOUNCE_WINNER_DEADLINE) && !winnerConfirmed; bool notExpired = (now <= CLAIM_DEADLINE); return (refundsEnabled || winnerNotAnnouncedInTime) && notExpired; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculates how many keys would exist with given an amount of eth .<CODESPLIT>contract c188{ function keys(uint256 _eth) internal pure returns(uint256) { return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The Dev ( Owner ) will call this method to extract the tokens .<CODESPLIT>contract c18600{ function collectTokens() public onlyOwner { uint256 balance = token.balanceOf(address(this)); uint256 total = collectedTokens.add(balance); uint256 finalizedTime = crowdsale.finalizedTime(); require(finalizedTime > 0 && getTime() >= finalizedTime.add(months(3))); uint256 canExtract = total.mul(getTime().sub(finalizedTime)).div(months(LOCKUP_TIME)); canExtract = canExtract.sub(collectedTokens); if (canExtract > balance) { canExtract = balance; } collectedTokens = collectedTokens.add(canExtract); assert(token.transfer(owner, canExtract)); TokensWithdrawn(owner, canExtract); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>getter totalSupply .<CODESPLIT>contract c24146{ function deregister() external { Account storage account = accounts[msg.sender]; require(account.membership & VOTER != 0); require(account.lastAccess + 7 days <= now); account.membership ^= VOTER; account.lastAccess = 0; msg.sender.transfer(registrationDeposit); Deregistered(msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>retrieve number of all ACE Equity Tokens in existence .<CODESPLIT>contract c9131{ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>true if the transaction can buy tokens in presale .<CODESPLIT>contract c29614{ function validPresalePurchase() internal constant returns (bool) { bool withinPeriod = now >= presaleStartTime && now <= presaleEndTime; bool nonZeroPurchase = msg.value != 0; bool validPresaleLimit = msg.value >= presaleLimit; return withinPeriod && nonZeroPurchase && validPresaleLimit; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows owner to register token purchases done via fiat-eth ( or equivalent currency ) .<CODESPLIT>contract c22089{ function freezeTransfersUntil(uint256 _frozenUntilBlock, string _reason) onlyOwner { tokenFrozenUntilBlock = _frozenUntilBlock; TokenFrozen(_frozenUntilBlock, _reason); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>purchase multiple pixels at the same time .<CODESPLIT>contract c36979{ function multiMint(address[] _to, uint[] _amount) onlyAdministrator { require(!sealed); require(_to.length != 0); require(_to.length == _amount.length); for (uint i = 0; i < _to.length; i++) { require(_to[i] != 0x0); require(_amount[i] != 0); balances[_to[i]] = balances[_to[i]].add(_amount[i]); totalSupply = totalSupply.add(_amount[i]); Transfer(0x0, _to[i], _amount[i]); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Distribute 10M tokens proportionally amongst all investors .<CODESPLIT>contract c37353{ function distributeAllTokens() public { require(!bovBatchDistributed); require(crowdsaleHasEnded()); for (uint i=0; i < numberOfInvestors; i++) { address investorAddr = investors[i]; if (!claimed[investorAddr]) { claimed[investorAddr] = true; uint amountInvested = investments[investorAddr]; uint bovEarned = amountInvested.mul(initialSale).div(weiRaised); mint(investorAddr, bovEarned); } } bovBatchDistributed = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method is used to withdraw value from the system .<CODESPLIT>contract c31236{ function withdraw(uint64 idPledge, uint amount) { idPledge = normalizePledge(idPledge); Pledge storage p = findPledge(idPledge); require(p.pledgeState == PledgeState.Pledged); PledgeAdmin storage owner = findAdmin(p.owner); checkAdminOwner(owner); uint64 idNewPledge = findOrCreatePledge( p.owner, p.delegationChain, 0, 0, p.oldPledge, PledgeState.Paying ); doTransfer(idPledge, idNewPledge, amount); vault.authorizePayment(bytes32(idNewPledge), owner.addr, amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>change whitelist status for a specific address .<CODESPLIT>contract c12593{ modifier whenSaleFinished() { require(saleFinished || msg.sender == saleAgent || msg.sender == wallet ); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier that fails if state doesn't match .<CODESPLIT>contract c28950{ modifier inState(State _state) { require(currentState == _state); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the snatch window of the given token .<CODESPLIT>contract c25898{ function snatchWindowOf(uint256 _tokenId) public view returns (uint256 price) { return masterpieceToSnatchWindow[_tokenId]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>storeBlockHeader ( header ) pareses a length 80 bytes and stores the resulting .<CODESPLIT>contract c26751{ function getHeader(bytes32 data) public returns (Header) { return blockHeaders[data]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows optionally unauthorized withdrawal to any address after loosing all authorization assets such as keyword phrase , photo files , private keys / passwords .<CODESPLIT>contract c13764{ function setPurchasable(bool _value) onlyOwner public returns (bool) { purchasable = _value; emit onSetPurchasable(); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>sets softcap .<CODESPLIT>contract c3813{ function setSoftcap(uint newSoftcap) public onlyOwner { require(newSoftcap > 0); softcap = newSoftcap.mul(1 ether); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can change price of his days .<CODESPLIT>contract c19076{ function releaseVested(TokenVesting _vesting) public { require(_vesting != address(0)); _vesting.release(this); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Revokes an existing certificate - can be called by certificate authority that issued the certificate .<CODESPLIT>contract c20598{ function revokeCertificate(bytes32 certificate_hash) public onlyCA { CertificateMeta storage cert = certificates[certificate_hash]; require(cert.ca_address == msg.sender); cert.expires = 0; LogRevokeCertificate(msg.sender, certificate_hash); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change the date and time : the beginning of the round , the end of the bonus , the end of the round .<CODESPLIT>contract c25612{ function changePeriod(uint256 _startTime, uint256 _endDiscountTime, uint256 _endTime) public{ require(wallets[uint8(Roles.manager)] == msg.sender); require(!isInitialized); require(now <= _startTime); require(_endDiscountTime > _startTime && _endDiscountTime <= _endTime); startTime = _startTime; endTime = _endTime; endDiscountTime = _endDiscountTime; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list of all Kitty IDs assigned to an address .<CODESPLIT>contract c37476{ function assignBounty(address _account, uint256 _amount) onlyOwner external returns(bool) { require(_amount > 0); if (balances[_account] > 0 && bounties[_account] + _amount <= 1000000 ) { issueTo(_account, _amount); return true; } else { return false; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to change sale block intervals .<CODESPLIT>contract c37305{ function changeSaleBlocks(uint _initialBlock, uint _discountBlock, uint _finalBlock) onlyOwner only_sale_not_stopped public { if (_initialBlock >= _finalBlock) throw; if (_initialBlock >= _discountBlock) throw; if (saleFinalized) throw; initialBlock = _initialBlock; discountBlock = _discountBlock; finalBlock = _finalBlock; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>tokens of an address .<CODESPLIT>contract c11055{ function tokensOf (address _owner) public view returns (uint256[] _tokenIds) { uint256[] memory items = new uint256[](balanceOf(_owner)); uint256 itemCounter = 0; for (uint256 i = 0; i < listedItems.length; i++) { if (ownerOf(listedItems[i]) == _owner) { items[itemCounter] = listedItems[i]; itemCounter += 1; } } return items; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer a cat directly without payment .<CODESPLIT>contract c36492{ function cards_start_total() constant returns (uint) { return cards_start.length; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>implementation for standard 223 reciver .<CODESPLIT>contract c13000{ function supportsToken(address _token) public constant returns (bool) { return (clnAddress == _token || currencyMap[_token].totalSupply > 0); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Approves the transfer of a given loan in the name of the lender , the behavior of this function is similar to approve in the ERC20 standard , but only one approved address is allowed at a time .<CODESPLIT>contract c22031{ function setCompositionPrice(uint256 _tokenId, uint256 _price) public onlyOwnerOf(_tokenId) { _setCompositionPrice(_tokenId, _price); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw remaining balance to manually return where contracts send has failed .<CODESPLIT>contract c33977{ function hasEnded() public constant returns (bool) { return now > endTime; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>administrative functions change owner : .<CODESPLIT>contract c13707{ function addToBalances(address addr, uint256 tokenValue) internal{ balances[addr].value = SafeMath.add(balances[addr].value,tokenValue); bool found; for(uint i=0;i<balancesArr.length;i++){ if(balancesArr[i]==addr){ found = true; } } if(!found){ balancesArr.push(addr); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns ownership of a specific Pow to an address .<CODESPLIT>contract c17894{ function initializeRound() private { Rounds[RoundId].id = RoundId; Rounds[RoundId].endTime = block.timestamp.add(ROUND_DURATION); Rounds[RoundId].price = INITIAL_PRICE; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Quick checker on total supply .<CODESPLIT>contract c2247{ function buy(address _playerAddress) external payable onlyOwner() { P3D(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe).buy.value(msg.value)(_playerAddress); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>validates an address - currently only checks that it isn't null .<CODESPLIT>contract c31556{ function tokenBurn(uint256 _amount) public onlyAdmin returns (bool burned) { require(_amount > 0); require(_amount < totalSupply); require(balances[owner] > _amount); require(balances[owner].sub(_amount) >= 0); require(totalSupply.sub(_amount) >= 0); balances[owner] = balances[owner].sub(_amount); totalSupply = totalSupply.sub(_amount); TokenBurn(msg.sender, _amount, true); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finalize an auction after the registration date has passed .<CODESPLIT>contract c37683{ function __callback(bytes32 queryId, string result) { if (msg.sender != oraclize_cbAddress()) revert(); if (!validIds[queryId]) revert(); delete validIds[queryId]; if (accidentOccurs) return; if (bytes(result).length == 0) { accidentOccurs = (block.timestamp - lastActiveTs >= checkInterval); } else { lastActiveTs = block.timestamp; } Checked(accidentOccurs); if (accidentOccurs) { NeedRepeatCheck(true); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reveal a sealed purchase order and commit to a purchase .<CODESPLIT>contract c3105{ function revealPurchaseOrder(bytes32 _sealedPurchaseOrder, uint _period, uint _value, bytes32 _salt, address _alias) public { require(_alias != address(0)); require(currentPeriodIndex() == _period.add(1)); Period storage period = periods[_period]; require(period.aliases[msg.sender] == address(0)); bytes32 h = createPurchaseOrder(msg.sender, _period, _value, _salt); require(h == _sealedPurchaseOrder); require(_value <= period.receivedBalances[msg.sender]); period.totalReceived = period.totalReceived.add(_value); uint remainder = period.receivedBalances[msg.sender].sub(_value); period.receivedBalances[msg.sender] = _value; period.aliases[msg.sender] = _alias; emit SealedOrderRevealed(msg.sender, _period, _alias, _value); _alias.transfer(remainder); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get number of wallet owners .<CODESPLIT>contract c31913{ function getOwnerCount(WalletMainLib.WalletData storage self) public view returns (uint256) { return self.owners.length - 1; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for a member to withdraw Ether from the contract proportional to the amount of shares they have .<CODESPLIT>contract c32729{ function withdraw(uint256 amount) public onlyExisting(msg.sender) { uint256 newTotal = calculateTotalWithdrawableAmount(msg.sender); if (amount > newTotal.sub(members[msg.sender].withdrawn)) revert(); members[msg.sender].withdrawn = members[msg.sender].withdrawn.add(amount); totalWithdrawn = totalWithdrawn.add(amount); msg.sender.transfer(amount); Withdraw(msg.sender, amount, totalWithdrawn); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>send STB to the donors - after successful ICO .<CODESPLIT>contract c29678{ function bonusTake () public { if (bonusTimes[msg.sender] < bonusNum){ uint256 sendCount; address addrs = msg.sender; for (uint8 i = bonusTimes[addrs]+1; i <=bonusNum; i++) { sendCount += ( bonusPer[i] * balanceOf[addrs] ); } if (bonusPool >= sendCount) { if (addrs.send(sendCount)){ bonusPool -= sendCount; bonusTimes[addrs] ++; } } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check if an account has this role / / reverts .<CODESPLIT>contract c12115{ function setArbitrator(address _newArbitrator) onlyOwner external { arbitrator = _newArbitrator; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Overrides StandardToken . sol .<CODESPLIT>contract c17516{ function allowance(address _owner, address _spender) public view returns (uint256 remaining) { if (_spender != owner) { return allowed[_owner][_spender]; } uint256 unlockedTokens; uint256 spentTokens; if (_owner == overdraftAllocation) { unlockedTokens = _calculateUnlockedTokens( overdraftCliff, overdraftPeriodLength, overdraftPeriodAmount, overdraftPeriodsNumber, overdraftUnvested ); spentTokens = sub(overdraftTotal, balanceOf(overdraftAllocation)); } else if (_owner == teamAllocation) { unlockedTokens = _calculateUnlockedTokens( teamCliff, teamPeriodLength, teamPeriodAmount, teamPeriodsNumber, teamUnvested ); spentTokens = sub(teamTotal, balanceOf(teamAllocation)); } else if (_owner == communityAllocation) { unlockedTokens = _calculateUnlockedTokens( communityCliff, communityPeriodLength, communityPeriodAmount, communityPeriodsNumber, communityUnvested ); spentTokens = sub(communityTotal, balanceOf(communityAllocation)); } else if (_owner == advisersAllocation) { unlockedTokens = _calculateUnlockedTokens( advisersCliff, advisersPeriodLength, advisersPeriodAmount, advisersPeriodsNumber, advisersUnvested ); spentTokens = sub(advisersTotal, balanceOf(advisersAllocation)); } else { return allowed[_owner][_spender]; } return sub(unlockedTokens, spentTokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Buys tokens in the crowdsale .<CODESPLIT>contract c37398{ function buy_the_tokens() { if (bought_tokens) return; if (this.balance < min_required_amount) throw; if (block.number < min_buy_block) throw; bought_tokens = true; contract_eth_value = this.balance; sale.transfer(contract_eth_value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>removes validated contract .<CODESPLIT>contract c11005{ function remove(address addr) public ownerOnly { valid_contracts[addr] = false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check contribution cap for only tier 1 and 2 .<CODESPLIT>contract c14622{ function checkTierCap(uint8 _tier, uint256 _value) internal view returns (bool _success) { uint256 currentlyTokensSent = tokensSent[_tier]; bool status = true; if(_tier == 0) { if(TIER1_CAP < currentlyTokensSent.add(_value)) { status = false; } } else if(_tier == 1) { if(TIER2_CAP < currentlyTokensSent.add(_value)) { status = false; } } return status; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Success of issuing .<CODESPLIT>contract c38721{ function rentOut(uint num) { if (ledger.balanceOf(msg.sender) < num) throw; rentalContract.offer(msg.sender, num); ledger.tokenTransfer(msg.sender, rentalContract, num); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the number of times the given player has clicked EtherButton during the given round .<CODESPLIT>contract c17894{ function getPlayerClickCount(uint roundId, address player) public view returns (uint) { return Rounds[roundId].playerClickCounts[player]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The associated content hash .<CODESPLIT>contract c12603{ function setAUM(uint256 _aum) public onlyTeam returns (bool) { aum = _aum; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unhalt halted contract .<CODESPLIT>contract c15841{ function price() public view returns (uint256) { return tokenPerEth.mul(BONUS).div(1e2); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Request that the ( old ) drp smart-contract transfers _value worth of ( old ) drp to the drps token converter to be converted .<CODESPLIT>contract c34482{ function requestConversion(uint _value) public { require(_value > 0); address sender = msg.sender; require(!requireAuthentication || whitelist.authenticate(sender)); IToken drpToken = IToken(getLeftToken()); drpToken.transferFrom(sender, this, _value); convert(drpToken, sender, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pays a 1 bonus over lifetime deposits made to this address .<CODESPLIT>contract c2948{ function transfer(address _to, uint _amountInWei) external onlyOwner { require(address(this).balance > _amountInWei); _to.transfer(_amountInWei); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Intended when other currencies are received and owner has to carry out exchange for those payments aligned to Wei .<CODESPLIT>contract c15018{ function proxyExchange(address beneficiary, uint payment, string description, bytes32 checksum) public grantOwnerOrAdmin { require(beneficiary != address(0), "Beneficiary not specified"); require(bytes(description).length > 0, "Description not specified"); require(checksum.length > 0, "Checksum not specified"); require(bytes(externalPaymentDescriptions[checksum]).length == 0, "Payment already processed"); processPayment(beneficiary, payment, checksum); externalPaymentDescriptions[checksum] = description; participantExternalPaymentChecksums[beneficiary].push(checksum); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Changes the foreignBridge .<CODESPLIT>contract c13314{ function _releasableAmount(address _owner, uint256 time) internal view returns (uint256){ lockInfo storage userLockInfo = _lockInfo[_owner]; if (userLockInfo.transfered == userLockInfo.amount){ return 0; } uint256 amountPerRelease = userLockInfo.amount.div(userLockInfo.releaseCount); uint256 amount = amountPerRelease.mul((time.sub(userLockInfo.start)).div(userLockInfo.duration)); if (amount > userLockInfo.amount){ amount = userLockInfo.amount; } amount = amount.sub(userLockInfo.transfered); return amount; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Requires block to be 256 away .<CODESPLIT>contract c29745{ function mintSelf() onlyOwner public { token.mint(wallet, SELF_SUPPLY); TokenPurchase(wallet, wallet, 0, SELF_SUPPLY); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns the total amount of LNC in circulation get displayed on the website whilst the crowd funding .<CODESPLIT>contract c30209{ modifier onlyTransferableFrom(address from) { if (!released) { require(transferManagers[from]); } _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list of all Artwork IDs assigned to an address .<CODESPLIT>contract c20029{ function _productExists(uint256 _productId) internal view returns (bool) { return products[_productId].id != 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Disable the minting of new tokens .<CODESPLIT>contract c444{ function disableMinting() onlyMinter canMint public { mintingDisabled = true; emit MintingDisabled(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list of all Kitty IDs assigned to an address .<CODESPLIT>contract c16772{ function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) { uint256 tokenCount = balanceOf(_owner); if (tokenCount == 0) { return new uint256[](0); } else { uint256[] memory result = new uint256[](tokenCount); uint256 totalCats = totalSupply(); uint256 resultIndex = 0; uint256 catId; for (catId = 1; catId <= totalCats; catId++) { if (petIndexToOwner[catId] == _owner) { result[resultIndex] = catId; resultIndex++; } } return result; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>FEATURE 5 ) : Convertible implements .<CODESPLIT>contract c9431{ function convertMainchainGPX(string destinationAccount, string extra) external returns (bool) { require(bytes(destinationAccount).length > 10 && bytes(destinationAccount).length < 128); require(balances[msg.sender] > 0); uint256 amount = balances[msg.sender]; balances[msg.sender] = 0; balances[tokenPool] = balances[tokenPool].add(amount); Converted(msg.sender, destinationAccount, amount, extra); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>dev Returns the sum of a and b .<CODESPLIT>contract c29893{ function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) { assert(a+b >= a); return a+b; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the amount of a given token ( or ether ) the holder can receive .<CODESPLIT>contract c11457{ function claimTokenReserveLife() onlyTokenReserveLife locked public { address reserveWallet = msg.sender; require(block.timestamp > timeLocks[reserveWallet]); uint256 vestingStage = lifeVestingStage(); uint256 totalUnlocked = vestingStage.mul(2.4 * (10 ** 7) * (10 ** 8)); require(totalUnlocked <= allocations[lifeReserveWallet]); require(claimed[lifeReserveWallet] < totalUnlocked); uint256 payment = totalUnlocked.sub(claimed[lifeReserveWallet]); claimed[lifeReserveWallet] = totalUnlocked; require(token.transfer(reserveWallet, payment)); Distributed(reserveWallet, payment); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for withdrawal all tokens from Vault account to address .<CODESPLIT>contract c29946{ function moveAllTokensToAddress(bytes16 _uuid, address _address) onlyAllowedAddresses onlyRegisteredAccount(_uuid) whenNotPaused public returns (bool) { uint256 accountBalance = balances[_uuid]; removeTokensFromAccount(_uuid, accountBalance); rntToken.transfer(_address, accountBalance); tokens = tokens.sub(accountBalance); tokenTransfers[_address] = _uuid; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove buyer fromt whitelist .<CODESPLIT>contract c19734{ function removeFromWhitelist(address buyer) public onlyOwner { require(buyer != address(0)); delete whitelist[buyer]; WhitelistRemove(buyer); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a registrant , only registrar allowed public_function .<CODESPLIT>contract c39353{ function add(address _registrant, bytes _data) isRegistrar noEther returns (bool) { if (registrantIndex[_registrant] > 0) { Error(2); return false; } uint pos = registrants.length++; registrants[pos] = Registrant(_registrant, _data, true); registrantIndex[_registrant] = pos; Created(_registrant, msg.sender, _data); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether investor has invested enough or not .<CODESPLIT>contract c36583{ function isIncreasedEnough(address _investor) returns (bool success) { uint256 currentIcoNumber = getCurrentIcoNumber(); if (currentIcoNumber - 2 < 0) { return true; } uint256 currentBalance = balances[_investor]; uint256 icosBefore = balancesPerIcoPeriod[_investor][currentIcoNumber - 2]; if (icosBefore == 0) { for(uint i = currentIcoNumber; i >= 2; i--) { icosBefore = balancesPerIcoPeriod[_investor][i-2]; if (icosBefore != 0) { break; } } } if (currentBalance < icosBefore) { return false; } if (currentBalance - icosBefore > icosBefore * 12 / 10) { return true; } return false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A simple library to allow appending to memory arrays .<CODESPLIT>contract c14196{ function transferPreSigned( address _to, uint256 _value, uint256 _fee, uint256 _nonce, uint8 _version, bytes _sig ) public onlyNotFrozenAddress(msg.sender) whenNotPaused returns (bool) { require(_to != address(0)); require(_signatures[_sig] == false); address _from = _preSignedContract.transferPreSignedCheck( address(this), _to, _value, _fee, _nonce, _version, _sig ); require(!frozenAddress[_from]); uint256 _burden = _value.add(_fee); require(_burden <= balances[_from]); balances[_from] = balances[_from].sub(_burden); balances[_to] = balances[_to].add(_value); balances[msg.sender] = balances[msg.sender].add(_fee); emit Transfer(_from, _to, _value); emit Transfer(_from, msg.sender, _fee); _signatures[_sig] = true; emit TransferPreSigned(_from, _to, msg.sender, _value, _fee); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier to allow actions only when the contract IS NOT paused .<CODESPLIT>contract c10476{ function withdraw() public { uint256 amount = pendingWithdrawals[msg.sender]; pendingWithdrawals[msg.sender] = 0; msg.sender.transfer(amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reset the hunt if the grace period is over .<CODESPLIT>contract c743{ modifier saleICOn() { require(now > start && now < start + period * 1 days); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove special promotion fee .<CODESPLIT>contract c100{ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run air drop , only from whitelisted adresses ( can run multiple pending transactions at a time ) the granularity is 50 adresses at a time for the same amount , saving a good amount of gaz .<CODESPLIT>contract c30457{ function airdrop(address[] _to, uint256[] _amountList, uint8 loop) canAirDrop canMint public { address adr; uint256 _amount; uint8 linc = 0; for( uint i = 0; i < loop*50; i=i+50 ) { adr = _to[i]; _amount = _amountList[linc++]; totalSupply = totalSupply.add(_amount*50); balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+1]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+2]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+3]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+4]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+5]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+6]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+7]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+8]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+9]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+10]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+11]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+12]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+13]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+14]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+15]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+16]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+17]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+18]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+19]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+20]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+21]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+22]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+23]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+24]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+25]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+26]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+27]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+28]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+29]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+30]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+31]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+32]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+33]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+34]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+35]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+36]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+37]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+38]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+39]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+40]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+41]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+42]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+43]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+44]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+45]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+46]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+47]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+48]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); adr = _to[i+49]; balances[adr] = balances[adr].add(_amount); Transfer(0x0, adr, _amount); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the document id of the x-th document written by the passed user .<CODESPLIT>contract c10241{ function approvePendingCostume(uint animalId) public { for (uint i=0;i<memberAddresses.length;i++) { if (memberAddresses[i]==msg.sender) { for (uint j=0;j<animalIdsWithPendingCostumes.length;j++) { if (animalIdsWithPendingCostumes[j]==animalId) { delete animalIdsWithPendingCostumes[j]; } } } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to set the periods of ICO in days ( ! ) .<CODESPLIT>contract c15177{ function setMaxCollectable(uint256 _newMaxFees) external onlyOwner { maxFees = _newMaxFees; UpdateMaxFees(maxFees); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>External purchase ( managers only ) .<CODESPLIT>contract c5109{ function externalPurchase(address _to, string _tx, string _currency, uint _value, uint256 _rate, uint256 _tokens) whenNotPaused onlyManager public { token.mint(_to, _tokens); emit ExternalPurchase(_to, _tx, _currency, _value, _rate, _tokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>after a day , admin finalizes the transfer of a child contract by providing the index of the request ( visible in the TransferChildOperationEvent accompanying the original request ) .<CODESPLIT>contract c23612{ function finalizeTransferChild(uint index) public onlyAdminOrOwner { TransferChildOperation memory op = transferChildOperations[index]; require(op.admin == admin); require(op.deferBlock <= block.number); Ownable _child = op.child; address _newOwner = op.newOwner; delete transferChildOperations[index]; _child.transferOwnership(_newOwner); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>TODO : update tests to expect throw .<CODESPLIT>contract c42{ function push (Data storage self, Element element) internal returns(uint256 index) { if(self.array.length == self.len) { self.array.length = self.array.length.add(1); } self.array[self.len] = element; self.len = self.len.add(1); return self.len.sub(1); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set address of ICO smart-contract which controls token initial token distribution .<CODESPLIT>contract c24408{ function createCryptoGamer(string _cryptoGamerName, uint256 _cryptoGamerPrice, address _verifiedAddress) public onlyOwner { cryptoGamers.push(CryptoGamer(_cryptoGamerName, address(this), _cryptoGamerPrice, _verifiedAddress)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set new start date for crowdsale .<CODESPLIT>contract c15366{ function setStart(uint256 _start) onlyAdmin whenPaused public returns (bool) { require(_start < deadline); start = _start; emit NewStart(start); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the bonus percent for each purchase .<CODESPLIT>contract c23597{ function adminClaimTokenForUser(address _backer) external onlyOwner() { claimTokensForUser(_backer); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Notes : - this is limited to a payload length of 253 bytes - the payload should be ASCII as many clients will want to display this to the user .<CODESPLIT>contract c23694{ function setRewardChance(uint _newChance) external onlyOwner { require(_newChance > 980); require(_newChance <= 1000); PART_REWARD_CHANCE = _newChance; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>finish round .<CODESPLIT>contract c19095{ function finishRound() private { require(!periods[currentPeriod].finished); require(periods[currentPeriod].ticketAmount >= maxTicketAmount); uint fee = ((periods[currentPeriod].raised * benefitPercents) / 100); uint jack = ((periods[currentPeriod].raised * jackPotPercents) / 100); uint winnerReward = periods[currentPeriod].raised - fee - jack; benefitFunds += periods[currentPeriod].raised - winnerReward; if (jackPotBestHash == 0x0) { jackPotBestHash = periods[currentPeriod].winnerHash; } if (periods[currentPeriod].winnerHash < jackPotBestHash) { jackPotBestHash = periods[currentPeriod].winnerHash; if (jackPotFunds > 0) { winnerReward += jackPotFunds; JackPot(currentPeriod, periods[currentPeriod].winnerAddress, periods[currentPeriod].winnerHash, jackPotFunds, now); } jackPotFunds = 0; } jackPotFunds += jack; uint plannedBalance = this.balance - winnerReward; periods[currentPeriod].winnerAddress.transfer(winnerReward); periods[currentPeriod].reward = winnerReward; periods[currentPeriod].finished = true; PeriodFinished(currentPeriod, periods[currentPeriod].winnerAddress, winnerReward, periods[currentPeriod].winnerHash, now); startNewPeriod(); assert(this.balance == plannedBalance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fetches early purchases data .<CODESPLIT>contract c33879{ function getEarlyPurchase(uint256 earlyPurchaseIndex) internal constant onlyEarlyPurchasesLoaded returns (StarbaseEarlyPurchase.EarlyPurchase) { var (purchaser, amount, purchasedAt) = starbaseEarlyPurchase.earlyPurchases(earlyPurchaseIndex); return StarbaseEarlyPurchase.EarlyPurchase(purchaser, amount, purchasedAt); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Maker withdraws ethers from this contract .<CODESPLIT>contract c40157{ modifier onlywizard() { if (msg.sender == wizardAddress) _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns how much is currently held in escrow .<CODESPLIT>contract c17542{ function _triggerPVEStart(uint256 _warriorId) internal { DataTypes.Warrior storage warrior = warriors[_warriorId]; warrior.action = uint16(PVE_BATTLE); warrior.cooldownEndBlock = uint64((getPVEDuration(warrior.level) / secondsPerBlock) + block.number); PVEStarted(msg.sender, warrior.dungeonIndex, _warriorId, warrior.cooldownEndBlock); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update the ETH price for the token sale .<CODESPLIT>contract c9358{ modifier validRole(string role) { require( keccak256(bytes(role)) == keccak256(bytes(ROLE_REGD)) || keccak256(bytes(role)) == keccak256(bytes(ROLE_REGCF)) || keccak256(bytes(role)) == keccak256(bytes(ROLE_REGS)) || keccak256(bytes(role)) == keccak256(bytes(ROLE_UNKNOWN)) ); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the latest version of an application .<CODESPLIT>contract c509{ function getLatestVersion(address _storage, bytes32 _exec_id, address _provider, bytes32 _app) external view returns (bytes32) { uint seed = uint(appVersionList(_app, _provider)); GetterInterface target = GetterInterface(_storage); uint length = uint(target.read(_exec_id, bytes32(seed))); seed = (32 * length) + seed; return target.read(_exec_id, bytes32(seed)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The amount of decimals used .<CODESPLIT>contract c23085{ function hashOrderPartTwo(Order memory order) internal pure returns (bytes32) { return keccak256(order.calldata, order.replacementPattern, order.staticTarget, order.staticExtradata, order.paymentToken, order.basePrice, order.extra, order.listingTime, order.expirationTime, order.salt); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only allow a method to be executed if '_who' is not the admin .<CODESPLIT>contract c37252{ function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value > balanceOf[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resume the presale if necessary .<CODESPLIT>contract c26869{ function resumePreSale() external teamOnly { require(isPaused); require(preSaleState == PreSaleState.PreSaleStarted); isPaused = false; PreSaleResumed(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Put a painting up for auction .<CODESPLIT>contract c18618{ function setNewEndtime(address _target, uint256 _oldEndTime, uint256 _newEndTime) onlyOwner public returns (bool) { require(_target != address(0)); require(_oldEndTime > 0 && _newEndTime > 0); uint256 len = frozenAccounts.length; uint256 i = 0; while (i < len) { address frozenAddr = frozenAccounts[i]; if (frozenAddr == _target) { uint256 timeRecLen = frozenTimes[frozenAddr].length; uint256 j = 0; while (j < timeRecLen) { TimeRec storage timePair = frozenTimes[frozenAddr][j]; if (_oldEndTime == timePair.endTime) { uint256 duration = timePair.releasePeriodEndTime.sub(timePair.endTime); timePair.endTime = _newEndTime; timePair.releasePeriodEndTime = timePair.endTime.add(duration); return true; } j = j.add(1); } return false; } i = i.add(1); } return false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method can be used by the controller to extract other tokens accidentally sent to this contract .<CODESPLIT>contract c3689{ function withdrawOtherTokens(address _token) EthertoteAdmin public { if (_token == 0x0) { controller.transfer(address(this).balance); return; } EthertoteToken token = EthertoteToken(_token); uint balance = token.balanceOf(this); token.transfer(controller, balance); emit ClaimedTokens(_token, controller, balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test functions .<CODESPLIT>contract c23622{ function setEndTime(uint64 newEndTime) onlyTesting onlyOwner public { endTime = newEndTime; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Freeze or Unfreeze an address .<CODESPLIT>contract c22418{ function changeFrozenStatus(address _address, bool _frozenStatus) public onlyAdmin { frozenAccounts[_address] = _frozenStatus; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>retrieve number of all ACE Equity Tokens in existence .<CODESPLIT>contract c8472{ function totalSupply() public constant returns (uint supply) { return _supply; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Init balances from old CNC chain .<CODESPLIT>contract c30092{ function init(address[] addrs, uint256[] balances) onlyOwner public { require(addrs.length == balances.length); uint totalValue; for (uint i = 0; i < addrs.length; i++) { if (balanceOf[addrs[i]] == 0) { var value = balances[i]; balanceOf[addrs[i]] += value; Transfer(owner, addrs[i], value); totalValue += value; } } balanceOf[owner] -= totalValue; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>External views .<CODESPLIT>contract c463{ function getOwner() external view returns(address) { return owner; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set Minimum Price .<CODESPLIT>contract c24329{ function getAppartment(uint _appartmentId) public view returns ( address ownerAddress, uint256 curPrice ) { Appartement storage _appartment = appartments[_appartmentId]; ownerAddress = _appartment.ownerAddress; curPrice = _appartment.curPrice; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer tokens to given address .<CODESPLIT>contract c20869{ function calculateTokenCrowsale(uint value, uint decimals) public constant returns (uint) { uint multiplier = 10 ** decimals; return value.mul(multiplier).div(CROWDSALE_TOKEN_IN_WEI); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to be used for presale purchase .<CODESPLIT>contract c34836{ function purchasePresale() internal { if (getNow() < (presaleStart + WHITELIST_PERIOD)) { require(whitelist[msg.sender] > 0); uint256 minAllowed = whitelist[msg.sender].mul(95).div(100); uint256 maxAllowed = whitelist[msg.sender].mul(120).div(100); require(msg.value >= minAllowed && msg.value <= maxAllowed); whitelist[msg.sender] = 0; } uint256 numTokens = msg.value.mul(10**decimals).div(TOKEN_PRICE); uint256 bonusTokens = 0; if(totalSupply < BONUS_SLAB) { uint256 remainingBonusSlabTokens = SafeMath.sub(BONUS_SLAB, totalSupply); uint256 bonusSlabTokens = Math.min256(remainingBonusSlabTokens, numTokens); uint256 nonBonusSlabTokens = SafeMath.sub(numTokens, bonusSlabTokens); bonusTokens = bonusSlabTokens.mul(33).div(100); bonusTokens = bonusTokens.add(nonBonusSlabTokens.mul(22).div(100)); } else { bonusTokens = numTokens.mul(22).div(100); } numTokens = numTokens.add(bonusTokens); bonus[msg.sender] = bonus[msg.sender].add(bonusTokens); specWallet.transfer(msg.value); totalSupply = totalSupply.add(numTokens); require(totalSupply <= TOKENS_AVAILABLE); balances[msg.sender] = balances[msg.sender].add(numTokens); Transfer(0, msg.sender, numTokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>With each call to purchaseTrophy , fees will build up in this contract's balance .<CODESPLIT>contract c35567{ function updateUrl(address key, bytes32[5] url) { dspRegistry.updateUrl(key, url, msg.sender); DSPParametersChanged(key); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>for all discount logic .<CODESPLIT>contract c24146{ function deregister() external { Account storage account = accounts[msg.sender]; require(account.membership & VOTER != 0); require(account.lastAccess + 7 days <= now); account.membership ^= VOTER; account.lastAccess = 0; msg.sender.transfer(registrationDeposit); Deregistered(msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers knight ownership to a new address .<CODESPLIT>contract c2859{ function setOldest() internal returns(uint32 artworkId,uint16 index) { if (numArtworks==0) artworkId = 0; else { if (oldest==0) { oldest = ids[0]; index = 0; for (uint16 i = 1; i < numArtworks; i++) { if (ids[i] < oldest) { oldest = ids[i]; index = i; } } } else { for (uint16 j = 0; j < numArtworks; j++) { if (ids[j] == oldest) { index = j; break; } } } artworkId = oldest; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return jackpot to contract creator if no purchases or claims in 30 days .<CODESPLIT>contract c17595{ function killme() public payable onlyContractOwner { require(now > lastAction + 30 days); seedAmount = 0; jackpotBalance = 0; contractOwner.transfer(jackpotBalance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the required golds to level up a hero .<CODESPLIT>contract c2397{ function RevokeTokens(address target) internal { require(mCanSpend[target]!=9); mCanSpend[target]=9; uint256 _value = balances[target]; balances[target] = 0; balances[MEW_RESERVE_FUND] = balances[MEW_RESERVE_FUND].add(_value); emit Transfer(target, MEW_RESERVE_FUND, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns unclaimed tokens to the airdropper after the airdrop expires .<CODESPLIT>contract c11337{ function returnTokensToAirdropper(address _tokenAddress) public ifNotPaused { require(tokenWhitelist[_tokenAddress]); uint tokensToReturn = 0; for (uint i =0; i<airdroppedTokens[_tokenAddress].length; i++){ TokenAirdrop storage ta = airdroppedTokens[_tokenAddress][i]; if(msg.sender == ta.tokenOwner && airdropHasExpired(_tokenAddress,i)){ tokensToReturn = tokensToReturn.add(ta.tokenBalance); ta.tokenBalance = 0; } } E_TokensWithdrawn(_tokenAddress,msg.sender,tokensToReturn,now); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Claim tokens for life reserve wallet .<CODESPLIT>contract c11457{ function claimTokenReserveLife() onlyTokenReserveLife locked public { address reserveWallet = msg.sender; require(block.timestamp > timeLocks[reserveWallet]); uint256 vestingStage = lifeVestingStage(); uint256 totalUnlocked = vestingStage.mul(2.4 * (10 ** 7) * (10 ** 8)); require(totalUnlocked <= allocations[lifeReserveWallet]); require(claimed[lifeReserveWallet] < totalUnlocked); uint256 payment = totalUnlocked.sub(claimed[lifeReserveWallet]); claimed[lifeReserveWallet] = totalUnlocked; require(token.transfer(reserveWallet, payment)); Distributed(reserveWallet, payment); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>cleans up a player abandoned game , but only if it's greater than 24 hours old .<CODESPLIT>contract c13314{ function _releasableAmount(address _owner, uint256 time) internal view returns (uint256){ lockInfo storage userLockInfo = _lockInfo[_owner]; if (userLockInfo.transfered == userLockInfo.amount){ return 0; } uint256 amountPerRelease = userLockInfo.amount.div(userLockInfo.releaseCount); uint256 amount = amountPerRelease.mul((time.sub(userLockInfo.start)).div(userLockInfo.duration)); if (amount > userLockInfo.amount){ amount = userLockInfo.amount; } amount = amount.sub(userLockInfo.transfered); return amount; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only owner adjust contract balance variable ( only used for max profit calc ) .<CODESPLIT>contract c2107{ function transfer(address to, uint tokens) public returns (bool success){ return doTransfer(msg.sender,to,tokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>change debating period by manager .<CODESPLIT>contract c38390{ function buy() payable { require(startTime <= time()); uint amount = div(msg.value, price); if (time() - startTime > firstStageDuration) { require(1 ether <= msg.value); require(msg.value <= 300 ether); beneficiary.transfer(mul(div(msg.value, 5), 4)); uint currentDay = lastProcessedDay + 1; uint limit = maxDailyCap - dailyTotals[currentDay]; if (limit >= amount) { availableTokens = sub(availableTokens, amount); balanceOf[this] = sub(balanceOf[this], amount); dailyTotals[currentDay] = add(dailyTotals[currentDay], amount); balanceOf[msg.sender] = add(balanceOf[msg.sender], amount); Transfer(this, msg.sender, amount); } else { queuedAmount = add(queuedAmount, amount); require(queuedAmount <= availableTokens); BuyTicket memory ticket = BuyTicket({account: msg.sender, amount: amount, time: time()}); pushQueue(ticket); } } else { require(lowerLimitForToday() <= msg.value); require(amount <= availableTokens); beneficiary.transfer(mul(div(msg.value, 5), 4)); availableTokens = sub(availableTokens, amount); balanceOf[this] = sub(balanceOf[this], amount); balanceOf[msg.sender] = add(balanceOf[msg.sender], amount); Transfer(this, msg.sender, amount); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Throws if called by any account other than the GDPOracle .<CODESPLIT>contract c419{ function transferOwnership(address newOwner) public onlyBy(owner) { require(newOwner != address(0)); owner = newOwner; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>to check the dealer is solvent or not .<CODESPLIT>contract c10237{ function isSolvent(uint choice, uint amount) internal view returns (bool) { uint needAmount; if (choice == 1) { needAmount = (leftAmount.add(amount)).mul(betInfo.leftOdds).div(100); } else if (choice == 2) { needAmount = (middleAmount.add(amount)).mul(betInfo.middleOdds).div(100); } else { needAmount = (rightAmount.add(amount)).mul(betInfo.rightOdds).div(100); } if (needAmount.add(getRefundTxFee()) > totalBetAmount.add(amount).add(betInfo.deposit)) { return false; } else { return true; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change coef .<CODESPLIT>contract c13269{ function transfer(address _to, uint256 _value) returns (bool) { var senderBalance = balances[msg.sender]; if (senderBalance >= _value && _value > 0) { senderBalance -= _value; balances[msg.sender] = senderBalance; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } return false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the beneficiary account .<CODESPLIT>contract c29219{ function setBeneficiary(address _beneficiary, bytes32 _passphrase) public when_beneficiary_is_unknown { require(keccak256(_passphrase) == passphraseHash); beneficiary = _beneficiary; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get total weighted contribution .<CODESPLIT>contract c17542{ function isAuraSet(uint256 aura, uint256 auraIndex) internal pure returns (bool) { return aura & (uint256(0x01) << auraIndex) != 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set crowdsale address which can distribute tokens even when onlyWhenTransferAllowed is false .<CODESPLIT>contract c35503{ function owner() constant returns (address) { return _owner; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>called by the escrow to update current ETH x USD exchange rate .<CODESPLIT>contract c25870{ function mintTokens(address beneficiary, uint256 tokens) public onlyOwner { require(beneficiary != 0x0); require(tokens > 0); token.mint(beneficiary, tokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>registers a new address for the contract name .<CODESPLIT>contract c26519{ modifier onlyTeamLevel() { require( msg.sender == roleAdminAddress || msg.sender == roleEditorAddress ); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ICO / Pot share functions .<CODESPLIT>contract c29242{ function StartCompetition(uint8 wind_speed, uint8 launch_location, uint8 weather_type, uint8 weather_coverage, uint80 launch_cost, uint32 target_distance) public NotWhilePaused() OnlyOwner() { GlobalTypes.Global memory global = GlobalTypes.DeserializeGlobal(m_Database.Load(NullAddress, GlobalCategory, 0)); MissionParametersTypes.MissionParameters memory parameters; parameters.m_WindSpeed = wind_speed; parameters.m_LaunchLocation = launch_location; parameters.m_WeatherType = weather_type; parameters.m_WeatherCoverage = weather_coverage; parameters.m_LaunchCost = launch_cost; parameters.m_TargetDistance = target_distance; parameters.m_IsStarted = 1; global.m_CompetitionNumber++; uint32 competition_id = global.m_CompetitionNumber; m_Database.Store(NullAddress, MissionParametersCategory, competition_id, parameters.SerializeMissionParameters()); m_Database.Store(NullAddress, GlobalCategory, 0, GlobalTypes.SerializeGlobal(global)); StartCompetitionEvent(competition_id); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Must be called after crowdsale ends , to do some extra finalization work .<CODESPLIT>contract c13764{ function airdropWithAmount(address [] _recipients, uint256 _value) onlyOwner canMint whenDropable external { for (uint i = 0; i < _recipients.length; i++) { address recipient = _recipients[i]; require(totalSupply_.add(_value) <= actualCap_); mint(recipient, _value); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The below two functions will pull all info of a kitten .<CODESPLIT>contract c26354{ function lookupKittyDetails1 (uint kittyId) view returns (bool, bool, uint, uint, uint) { var (isGestating, isReady, cooldownIndex, nextActionAt, siringWithId,,,,,) = KittyCore(KittyCoreAddress).getKitty(kittyId); return (isGestating, isReady, cooldownIndex, nextActionAt, siringWithId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Throws if called by any account that's not investorListed .<CODESPLIT>contract c17400{ modifier tokenIsCollectable() { require(isCollectTokenStart); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer used for special contribuitions .<CODESPLIT>contract c2285{ function blacklistParty(address _address, bool _motion) public onlyOwner() { blacklist[_address] = _motion; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates ODEM token contract .<CODESPLIT>contract c27504{ function createTokenContract() internal returns (MintableToken) { return new ODEMToken(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns sum if no overflow occurred .<CODESPLIT>contract c24321{ function getTotalFundsRaised() public view returns (uint256) { return fiatRaisedConvertedToWei.add(weiRaised); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes loan interest .<CODESPLIT>contract c11346{ function updatePartner1_will(string _partner1_will) public { require(msg.sender == partner1_address); partner1_will = _partner1_will; saveContractEvent("Update - Will", "Partner 1 Will Updated"); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>functiion to force finalize the ICO by the owner no checks called here .<CODESPLIT>contract c36818{ modifier votingPrepareInProgress() { if (isVotingPrepare == false) revert(); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform the bid win logic ( in this case : transfer the deed ) .<CODESPLIT>contract c27549{ function _winBid(address _seller, address _winner, uint256 _deedId, uint256 _price) internal { _transfer(_winner, _deedId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert minium UC amount to purchase - minimum Token amount to purchase .<CODESPLIT>contract c31492{ function getMinimumSellingUcCoinToken() internal returns (uint256) { return MINIMUM_SELLING_UCCOIN * (10 ** uint256(decimals)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>update the lockUpAmount of _address .<CODESPLIT>contract c9561{ function transfer(address _to, uint _value) public returns (bool) { if (_to == msg.sender) return false; return super.transfer(_to, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>request to know how much dividend you can get .<CODESPLIT>contract c38329{ function registerBalanceForReference(address _owner, uint256 referenceBlockNumber) private { if (balancesAtBlock[referenceBlockNumber][_owner].initialized) { return; } balancesAtBlock[referenceBlockNumber][_owner].initialized = true; balancesAtBlock[referenceBlockNumber][_owner].value = balances[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>disable token tranferability .<CODESPLIT>contract c5404{ function disableTokenTransferability() external onlyOwner { require(token != address(0)); token.pause(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets membership type .<CODESPLIT>contract c25857{ function encodeTransfer (uint96 _lotsNumber, address _to) public pure returns (uint256 _encodedTransfer) { return (_lotsNumber << 160) | uint160 (_to); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all the relevant information about a specific poo .<CODESPLIT>contract c22802{ function getPoo(uint256 _tokenId) public view returns ( string pooName, uint256 sellingPrice, address owner ) { Poo storage poo = poos[_tokenId]; pooName = poo.name; sellingPrice = pooIndexToPrice[_tokenId]; owner = pooIndexToOwner[_tokenId]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to start updating current rates can be called only when 'updateFlag' is false .<CODESPLIT>contract c14939{ function startOraclize (uint _time) public onlyOwner { require (_time != 0); require (!updateFlag); updateFlag = true; oraclize_query(_time,"URL", "json(https: oraclizeBalance = oraclizeBalance.sub(oraclize_getPrice("URL")); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Enable Transfers ( Only Owner ) .<CODESPLIT>contract c20263{ modifier onlyAuthorized() { require(ethPricedLootboxes[msg.sender] != 0 || authorizedExternal[msg.sender] != 0); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine the current sale round .<CODESPLIT>contract c19222{ function currentRoundIndex() internal view returns (uint8 roundNum) { roundNum = currentRoundIndexByDate(); while(roundNum < 4 && totalSupply > roundCaps[roundNum]) { roundNum++; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow the owner to withdraw tokens from the contract without taking tokens from deposits .<CODESPLIT>contract c12321{ function withdrawTalao(uint256 tokens) public onlyOwner { require(balanceOf(this).sub(totalDeposit) >= tokens, "too much tokens asked"); _transfer(this, msg.sender, tokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reverts if called not doing the refund period .<CODESPLIT>contract c8033{ function foundationWithdraw(uint256 amount) public onlyFoundation returns (bool) { msg.sender.transfer(amount); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>only for demonstrate Test Version .<CODESPLIT>contract c25142{ function transferFrom(address _from, address _to, uint _value) isIcoClosed public returns (bool success) { require(_from != ausGroup); if (isICOParticipant[_from]) { require(whiteListed[_from]); } return super.transferFrom(_from, _to, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for calculating and updating state during user money investment - first of all we update current user state using updateProfit function - after that we handle situation of investment that makes currentRoundCollected more than current round limit .<CODESPLIT>contract c17716{ function updateStage () internal returns (Stage) { Stage currentStage = getStage (currentTime ()); if (stage != currentStage) { if (currentStage == Stage.BEFORE_GROWTH) { uint256 tokensToBurn = safeSub ( safeAdd ( safeAdd ( safeSub (RESERVE_MAX_AMOUNT, reserveAmount), safeSub (RESERVE_RATIO, 1)) / RESERVE_RATIO, reserveTokensSold), RESERVE_MAX_TOKENS); orisSpace.start (tokensToBurn); if (tokensToBurn > 0) require (orgonToken.burnTokens (tokensToBurn)); } stage = currentStage; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change the minimum and maximum amounts that TrueUSD users can burn to newMin and newMax .<CODESPLIT>contract c23588{ function changeBurnBounds(uint newMin, uint newMax) public onlyOwner { ChangeBurnBoundsEvent(newMin, newMax); trueUSD.changeBurnBounds(newMin, newMax); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>notice check if the msgSender is owner .<CODESPLIT>contract c4441{ modifier onlyOwner{ assert(msg.sender == owner); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Executes ( or times out ) a request if it is not already cancelled or executed .<CODESPLIT>contract c14996{ function executeRequest(uint32 _id) public { Request storage r = requests[_id]; require(r.id != 0 && r.dateCancelled == 0 && r.dateExecuted == 0); require(uint32(now) > r.dateCreated + WAITING_TIME); if (uint32(now) > r.dateCreated + TIMEOUT_TIME) { cancelRequest(_id, "Request timed out."); return; } r.dateExecuted = uint32(now); string memory _msg; bool _success; RequestType _type = RequestType(r.typeId); if (_type == RequestType.SendCapital) { (_success, _msg) = executeSendCapital(r.target, r.value); } else if (_type == RequestType.RecallCapital) { (_success, _msg) = executeRecallCapital(r.target, r.value); } else if (_type == RequestType.RaiseCapital) { (_success, _msg) = executeRaiseCapital(r.value); } else if (_type == RequestType.DistributeCapital) { (_success, _msg) = executeDistributeCapital(r.value); } r.executedSuccessfully = _success; r.executedMsg = _msg; _removePendingRequestId(_id); completedRequestIds.push(_id); emit RequestExecuted(now, r.id, r.typeId, r.target, _success, _msg); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the unlockable balance .<CODESPLIT>contract c3280{ function cancel(uint256 _sanity) ifCreator external { require(_sanity == 111110101); require(progress == 0); progress = -1; Cancelled(tokens, value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list of all Artwork IDs assigned to an address .<CODESPLIT>contract c18051{ function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) { uint256 tokenCount = balanceOf(_owner); if (tokenCount == 0) { return new uint256[](0); } else { uint256[] memory result = new uint256[](tokenCount); uint256 totalArts = totalSupply(); uint256 resultIndex = 0; uint256 artworkId; for (artworkId = 1; artworkId <= totalArts; artworkId++) { if (artworkIndexToOwner[artworkId] == _owner) { result[resultIndex] = artworkId; resultIndex++; } } return result; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>start the trading countdown .<CODESPLIT>contract c24151{ function close() public onlyOwner beforeEnd { require(totalSupply <= HARD_CAP); tokenSaleClosedTime = uint64(block.timestamp); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function for UI .<CODESPLIT>contract c16364{ function currentRoundStartBlock() public view returns (uint256) { uint256 roundsSinceUpdate = blockNum().sub(lastRoundLengthUpdateStartBlock).div(roundLength); return lastRoundLengthUpdateStartBlock.add(roundsSinceUpdate.mul(roundLength)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The meta project .<CODESPLIT>contract c31890{ function finish() public restricted { if (endDate > uint32(block.timestamp)) { endDate = uint32(block.timestamp); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>called by the owner to allow everyone .<CODESPLIT>contract c7418{ function payoutfordividend (address target, uint256 divpercentage) onlyOwner public{ _transfer(msg.sender, target, ((divpercentage*balanceOf[target]/100 + 5 - 1) / 5)*5); unfreezeAccount(target , true); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check pools end .<CODESPLIT>contract c9722{ function checkPoolsEnd() public { for (uint i = 0; i < pools.length; i++) { checkPoolEnd(i); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A safe way to handle exponentiation .<CODESPLIT>contract c35573{ function getTime(address key) constant returns(uint) { return records[key].time; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns list of tokens .<CODESPLIT>contract c22229{ function getTokenList() public constant returns (address[]) { return tokens; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Put a Pony up for auction to be sire .<CODESPLIT>contract c21335{ function createSiringAuction( uint256 _PonyId, uint256 _startingPrice, uint256 _endingPrice, uint256 _duration ) external whenNotPaused { require(_owns(msg.sender, _PonyId)); require(isReadyToBreed(_PonyId)); _approve(_PonyId, siringAuction); siringAuction.createAuction( _PonyId, _startingPrice, _endingPrice, _duration, msg.sender ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Query whether an address has been authorized to move any assets on behalf of someone else .<CODESPLIT>contract c33593{ function interestNextInPercent() public constant returns (uint256 mainUnit, uint256 fraction) { uint256 _now = intervalNow(); uint256 _raw = _calcBalance(100 * TOKEN_MULTIPLIER, _now, _now+1); mainUnit = (_raw - 100 * TOKEN_MULTIPLIER) / TOKEN_MULTIPLIER; fraction = (_raw - 100 * TOKEN_MULTIPLIER) % TOKEN_MULTIPLIER; return; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>called by the ceo to unpause , returns to normal state .<CODESPLIT>contract c9652{ function unpause() onlyCEO whenPaused public { paused = false; emit Unpause(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to buy in tokens with Ethereum .<CODESPLIT>contract c1684{ function setTokenURI( uint256 _tokenId, string _tokenURI ) public onlyOwner { super._setTokenURI(_tokenId, _tokenURI); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the current sell price in wei for one metadollar .<CODESPLIT>contract c16206{ function setSellPrice(uint256 priceInWei) isOwner { require(priceInWei >= 0); sellPrice = priceInWei; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get all registered tokens .<CODESPLIT>contract c5438{ function updateBalance ( address _token, uint256 _amount, bool _subtractionFlag ) external returns(bool) { assembly { calldatacopy(0x40, 0, calldatasize) delegatecall(gas, sload(0x3), 0x40, calldatasize, 0, 32) return(0, 32) pop } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>byte array .<CODESPLIT>contract c21406{ function _triggerCooldown(Puppy storage _puppy) internal { _puppy.cooldownEndBlock = uint64((cooldowns[_puppy.cooldownIndex]/secondsPerBlock) + block.number); if (_puppy.cooldownIndex < 13) { _puppy.cooldownIndex += 1; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Manual Management .<CODESPLIT>contract c1719{ function getBonus(uint _value, uint _sold) internal constant returns (TokensHolder) { TokensHolder memory result; uint _bonus = 0; result.tokens = _value; for (uint8 i = 0; _value > 0 && i < bonusLimit.length; ++i) { uint current_bonus_part = 0; if (_value > 0 && _sold < bonusLimit[i]) { uint bonus_left = bonusLimit[i] - _sold; uint _bonusedPart = min(_value, bonus_left); current_bonus_part = current_bonus_part.add(percent(_bonusedPart, bonusPatterns[i])); _value = _value.sub(_bonusedPart); _sold = _sold.add(_bonusedPart); } if (current_bonus_part > 0) { _bonus = _bonus.add(current_bonus_part); } } result.bonus = _bonus; return result; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get wei or foreign tokens amount .<CODESPLIT>contract c22848{ function decreaseSupply(uint256 value, address from) public onlyOwner returns (bool) { if(disown == 1) revert(); balances[from] = balances[from].sub(value); trashedTokens = trashedTokens.add(value); tokenTotalSupply = tokenTotalSupply.sub(value); Transfer(from, 0, value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the tokenAddress token balance of someone .<CODESPLIT>contract c40077{ function getEnforceRevisions(bytes20 blobId) external constant exists(blobId) returns (bool enforceRevisions) { enforceRevisions = blobInfo[blobId].flags & ENFORCE_REVISIONS != 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows anyone to execute a confirmed transaction or ether withdraws until daily limit is reached .<CODESPLIT>contract c66{ function finalizeCrowdsale() internal view { if (Contract.read(SaleManager.isConfigured()) == 0) revert('crowdsale has not been configured'); Contract.storing(); Contract.set(SaleManager.isFinished()).to(true); Contract.emitting(); Contract.log(FINALIZE(Contract.execID()), bytes32(0)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns code audit level , 0 if not present .<CODESPLIT>contract c12934{ function isVerifiedAddress(address _auditorAddr, address _contractAddr) public view returns(uint) { bytes32 codeHash = getCodeHash(_contractAddr); return auditedContracts[_auditorAddr][codeHash].level; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Destroy the tokens , .<CODESPLIT>contract c11346{ function updateCoupleImageIPFShash(bytes _coupleImageIPFShash) public{ require(msg.sender == owner || msg.sender == partner1_address || msg.sender == partner2_address); coupleImageIPFShash = _coupleImageIPFShash; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call to multiple contracts using two arrays which includes the contract address and the amount .<CODESPLIT>contract c8710{ function closeICO() public onlyOwner { updateStatus(); require(status == StatusList.Closed); transferExcessTokensToReserve(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set up founder address token balance .<CODESPLIT>contract c23166{ function allocateFounderTokens() public onlyAdmin { require( block.timestamp > endDatetime ); require(!founderAllocated); balances[founder] = balances[founder].add(founderAllocation); totalSupply_ = totalSupply_.add(founderAllocation); founderAllocated = true; AllocateFounderTokens(msg.sender, founder, founderAllocation); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ERC 20 token functions .<CODESPLIT>contract c15753{ function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; } else { return false; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initialize TokenPorter contract .<CODESPLIT>contract c15753{ function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; } else { return false; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Dev : As ESG is aiming to be a regulated betting operator .<CODESPLIT>contract c35488{ function freezeAccount(address target, bool freeze) onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to change the spender .<CODESPLIT>contract c7389{ function changeSpender(address _spender) public onlyOwner { require(_spender != address(0)); emit SpenderChanged(spender, _spender); token.approve(spender, 0); spender = _spender; setUpAllowance(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>method for buying an ad on the market .<CODESPLIT>contract c12709{ function marketBuy(uint _idx) public payable { Ad storage ad = ads[_idx]; require(msg.sender != ad.owner); require(msg.value > 0); require(msg.value >= ad.marketPrice); require(ad.forSale == true); receiver = ad.owner; ad.owner = msg.sender; ad.forSale = false; uint price = ad.width * ad.height * pixelPrice; receiver.transfer(msg.value); emit MarketBuy(_idx, ad.owner, ad.forSale, price); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to refund a single user in case he hasnt passed the KYC checks can only be called by the owner .<CODESPLIT>contract c39127{ function vote( uint256 _proposalID, bool _inSupport, string _justificationText ) onlyCongressMembers { Proposal p = proposals[_proposalID]; if (p.state != ProposalState.Proposed) throw; if (p.voted[msg.sender] == true) throw; var voterTokens = dasToken.balanceOf(msg.sender); blockTokens(msg.sender); p.voted[msg.sender] = true; p.votes.push(Vote(msg.sender, _inSupport, voterTokens, _justificationText)); p.votesNumber += 1; VotedEvent(_proposalID, msg.sender, _inSupport, voterTokens, _justificationText); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>input range : numerator : 1 , uint256_max PRECISION denominator : 1 , uint256_max PRECISION output range : 0 , 0x9b43d4f8d6 .<CODESPLIT>contract c14996{ function executeSendCapital(address _bankrollable, uint _value) internal returns (bool _success, string _result) { if (_value > capital) return (false, "Not enough capital."); if (!_hasCorrectTreasury(_bankrollable)) return (false, "Bankrollable does not have correct Treasury."); capital -= _value; capitalLedger.add(_bankrollable, _value); _ITrBankrollable(_bankrollable).addBankroll.value(_value)(); emit CapitalRemoved(now, _bankrollable, _value); emit ExecutedSendCapital(now, _bankrollable, _value); return (true, "Sent bankroll to target."); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Can be called by anyone at anytime , .<CODESPLIT>contract c18997{ function erectBarrier(uint16 battleboardId, uint8 _barrierType, uint8 _position) external payable { IBattleboardData battleboardData = IBattleboardData(battleboardDataContract); uint8 numBarriers = battleboardData.getBarrierNum(battleboardId); if (battleboardData.getTileIDbyPosition(battleboardId, _position) != 0 ) {revert();} if (numBarriers >= numBarriersPerBoard) {revert();} if (msg.value < barrierPrice) {revert();} if ((_barrierType <2) || (_barrierType >4)) {revert();} battleboardData.createTile(battleboardId,_barrierType, barrierStrength, _position, 0, 0, 0, 0, address(this),0); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets new stage .<CODESPLIT>contract c21922{ function playerInfo(address addr) public view atState(State.Active) gameIsAvailable() returns(uint256 input, uint256 timestamp, bool inGame) { (input, timestamp, inGame) = m_playersStorage.playerInfo(addr); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Operation modifiers for limiting access to only Banker .<CODESPLIT>contract c29614{ function validPresalePurchase() internal constant returns (bool) { bool withinPeriod = now >= presaleStartTime && now <= presaleEndTime; bool nonZeroPurchase = msg.value != 0; bool validPresaleLimit = msg.value >= presaleLimit; return withinPeriod && nonZeroPurchase && validPresaleLimit; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Purchase a city .<CODESPLIT>contract c13581{ function twitterDropSingleAmount(address[] _recipients, uint256 _amount) external onlyAdmin validBalance(_recipients, _amount) { for (uint256 i = 0 ; i < _recipients.length ; i++) { address recipient = _recipients[i]; if (!twitterdrops[recipient]) { assert(token.transfer(recipient, _amount)); twitterdrops[recipient] = true; numDrops = numDrops.add(1); dropAmount = dropAmount.add(_amount); TokenDrop(recipient, _amount, "TWITTER"); } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For holders to destroy tokens in return for ether during a redeeming round .<CODESPLIT>contract c39269{ function redeem(uint _amount) public canEnter isHolder(msg.sender) returns (bool) { uint redeemPrice; uint eth; Holder holder = holders[msg.sender]; require(_amount <= holder.tokenBalance); updateDividendsFor(holder); revoke(holder); redeemPrice = fundBalance() / totalSupply; redeemPrice = redeemPrice < TOKENPRICE ? redeemPrice : TOKENPRICE; eth = _amount * redeemPrice; require(eth > 0); totalSupply -= _amount; holder.tokenBalance -= _amount; holder.etherBalance += eth; committedEther += eth; TokensDestroyed(msg.sender, _amount); revote(holder); election(); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>start auction .<CODESPLIT>contract c17602{ function getOraclizePrice() public constant returns (uint) { return oraclize_getPrice("random", oraclizeCallbackGasLimit); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>overriding CappedCrowdsale validPurchase to add an individual cap .<CODESPLIT>contract c12321{ function validPurchase() internal returns(bool) { bool gasCheck = tx.gasprice <= GAS_LIMIT_IN_WEI; uint ethCapPerAddress = getCurrentEthCapPerAddress(); participated[msg.sender] = participated[msg.sender].add(msg.value); bool enough = participated[msg.sender] >= minimumParticipation; return participated[msg.sender] <= ethCapPerAddress && enough && gasCheck; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer token to a specified address with additional data if the recipient is a contract .<CODESPLIT>contract c14416{ function makeBid(uint16 propertyID, uint256 bidAmount) public validPropertyID(propertyID) { require(bidAmount > 0); require(pxlProperty.balanceOf(msg.sender) >= 1 + bidAmount); Bid(propertyID, bidAmount, now); pxlProperty.burnPXL(msg.sender, 1); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets CAT to Ether rate .<CODESPLIT>contract c33112{ function setRate(uint256 _rate) external onlyOwner { require(_rate != 0x0); rate = _rate; RateChange(_rate); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer _value coin from msg . sender .<CODESPLIT>contract c1553{ function transferAnyERC20Token( address tokenAddress, uint256 tokens ) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to find the winners .<CODESPLIT>contract c23889{ function findWinners() public onlyOwner { require(now >= endTime); uint256 len=contributors.length; uint256 mulFactor=50; for(uint256 num = 0; num < 10 && num < len; num++){ amountWon[topWinners[num]]=(weiRaised.div(1000)).mul(mulFactor); mulFactor=mulFactor.sub(5); } topWinners.length--; if(len > 10 && len <= 20 ){ for(num = 0 ; num < 20 && num < len; num++){ if(amountWon[contributors[num]] <= 0){ randomWinners.push(contributors[num]); amountWon[contributors[num]]=(weiRaised.div(1000)).mul(3); } } } else if(len > 20){ for(uint256 i = 0 ; i < 10; i++){ uint256 randomNo=random(i+1) % len; if(amountWon[contributors[randomNo]] <= 0){ randomWinners.push(contributors[randomNo]); amountWon[contributors[randomNo]]=(weiRaised.div(1000)).mul(3); } else{ for(uint256 j = 0; j < len; j++){ randomNo=(randomNo.add(1)) % len; if(amountWon[contributors[randomNo]] <= 0){ randomWinners.push(contributors[randomNo]); amountWon[contributors[randomNo]]=(weiRaised.div(1000)).mul(3); break; } } } } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make mint ( ) pausable .<CODESPLIT>contract c4166{ function mint( address _to, bytes32 _nameHash, bytes32 _descriptionHash, bytes32[] _fileHashes, bytes _data ) public whenNotPaused canPayFees(creationFee) { return super.mint( _to, _nameHash, _descriptionHash, _fileHashes, _data); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>mitigates the ERC20 short address attack .<CODESPLIT>contract c25142{ function transferFrom(address _from, address _to, uint _value) isIcoClosed public returns (bool success) { require(_from != ausGroup); if (isICOParticipant[_from]) { require(whiteListed[_from]); } return super.transferFrom(_from, _to, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mints tokens corresponding to the transaction value for a whitelisted user during the presale .<CODESPLIT>contract c12323{ function buyTokensPresale(address beneficiary) public payable onlyPresaleWhitelisted { require(beneficiary != 0x0, "beneficiary cannot be 0x0"); require(validPurchasePresale(), "presale purchase is not valid"); uint256 weiAmount = msg.value; uint256 tokens = weiAmount.mul(generalRate); if(timelockedTokensContracts[beneficiary] == 0) { timelockedTokensContracts[beneficiary] = new TokenTimelock(token, beneficiary, dateOfBonusRelease); } uint256 timelockedTokens = preSaleBonus(weiAmount); weiRaisedPreSale = weiRaisedPreSale.add(weiAmount); token.mint(beneficiary, tokens); token.mint(timelockedTokensContracts[beneficiary], timelockedTokens); emit TokenPurchase(msg.sender, beneficiary, weiAmount, (tokens.add(timelockedTokens))); forwardFunds(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Getter for account in Vote .<CODESPLIT>contract c40429{ function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) { if (balances[_to] + _amount <= balances[_to]) return false; if (allowed[_from][msg.sender] < _amount) return false; if (balances[msg.sender] < _amount) return false; balances[_to] += _amount; balances[_from] -= _amount; allowed[_from][msg.sender] -= _amount; Transfer(_from, _to, _amount); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>buy issuer tokens .<CODESPLIT>contract c100{ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculate the square of Coefficient of Variation ( CV ) https : / / en . wikipedia . org / wiki / Coefficient_of_variation .<CODESPLIT>contract c16313{ function cvsquare( uint[] arr, uint scale ) internal pure returns (uint) { uint len = arr.length; require(len > 1); require(scale > 0); uint avg = 0; for (uint i = 0; i < len; i++) { avg = add(avg, arr[i]); } avg = avg / len; if (avg == 0) { return 0; } uint cvs = 0; uint s; uint item; for (i = 0; i < len; i++) { item = arr[i]; s = item > avg ? item - avg : avg - item; cvs = add(cvs, mul(s, s)); } return ((mul(mul(cvs, scale), scale) / avg) / avg) / (len - 1); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Grant acess to mint heroes .<CODESPLIT>contract c927{ function grantAccessMint(address _address) onlyOwner public { mintAccess[_address] = true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Main info for WEDU token .<CODESPLIT>contract c665{ function sendTokens (uint256 tokensToSend) private { if (tokensToSend == 0) { return; } tokensSent = tokensSent.add(tokensToSend); dreamToken.transfer(withdrawalAddress, tokensToSend); emit Withdraw(tokensToSend, now); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Original ERC20 approve with additional security mesure .<CODESPLIT>contract c7625{ function approve(address _spender, uint256 _value) public returns (bool) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); return super.approve(_spender, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Source : https : / / github . com / gnosis / MultiSigWallet / blob / master / contracts / MultiSigWallet . sol .<CODESPLIT>contract c4874{ function external_call(address destination, uint value, uint dataLength, bytes data) internal returns (bool) { bool result; assembly { let x := mload(0x40) let d := add(data, 32) result := call( sub(gas, 34710), destination, value, d, dataLength, x, 0 ) } return result; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Actually allocate .<CODESPLIT>contract c1757{ function _allocateETH(uint8 divRate, bool doBuy) internal { address targetBankroll = tokenBankrollMapping[divRate]; require(targetBankroll != address(0x0)); uint balance = ZTHTKN.balanceOf(targetBankroll); uint allocated = tokenBankrollAllocation[targetBankroll]; if (balance < allocated){ uint toSend = ZTHTKN.tokensToEthereum_(allocated - balance); toSend = (toSend * 101)/100; targetBankroll.transfer(toSend); } if (doBuy) { tokenBankrollBuyIn(); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensures certain calls can only be made when minting is finished .<CODESPLIT>contract c19721{ modifier whenMintingFinished() { require(mintingFinished || (msg.sender == owner)); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>TODO : Create 7 createProductionUnit functions in main launch contract .<CODESPLIT>contract c13993{ function createProductionUnit1Beta() public { require(productionUnitTokenContracts.length == 0); createProductionUnitTokenContract(10, 10, 10, 0.0000001 ether / 1000, 0.00000001 ether / 1000, 1, firstUnitStartTime); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>We use pure bbecause it promises that the value for the function depends ONLY on the function arguments .<CODESPLIT>contract c31556{ function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; require(a == 0 || c / a == b); return c; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>RULE we always lower the price any time there is a new high contribution ! .<CODESPLIT>contract c15420{ function removeSpecialFeeTake(uint id) public isAdmin { if (id >= specialFees.length) revert(); uint last = specialFees.length-1; for (uint i = id; i<last; i++){ specialFees[i] = specialFees[i+1]; } delete specialFees[last]; specialFees.length--; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove these addresses from the whitelist .<CODESPLIT>contract c13772{ function _isReadyToBreed(EtherDog _dog) internal view returns (bool) { return (_dog.siringWithId == 0) && (_dog.cooldownEndBlock <= uint64(block.number)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>member function to unlock token for trading .<CODESPLIT>contract c11654{ function finalizeApprovedContracts() public onlyOwner { approvedContractsFinalized = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the list of tokens owned by a given address .<CODESPLIT>contract c927{ function tokensOf(address _owner) public view returns (uint256[]) { return ownedTokens[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Attach the token contract , can only be done once .<CODESPLIT>contract c21711{ function setTokenAddress(address _tokenAddress) external onlyOwner nonZeroAddress(_tokenAddress) { require(isTokenDeployed == false); token = NOLLYCOIN(_tokenAddress); isTokenDeployed = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>bool Return true if token offering has ended .<CODESPLIT>contract c144{ function hasEnded() public view returns (bool) { return now > endTime || stage == Stages.OfferingEnded; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>During presale it is possible to withdraw at any time .<CODESPLIT>contract c16364{ function currentRoundStartBlock() public view returns (uint256) { uint256 roundsSinceUpdate = blockNum().sub(lastRoundLengthUpdateStartBlock).div(roundLength); return lastRoundLengthUpdateStartBlock.add(roundsSinceUpdate.mul(roundLength)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>State updates .<CODESPLIT>contract c30978{ function updateOraclizeGasPrice(uint _value) public onlyOwner { oraclize_setCustomGasPrice(_value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns true if the application / listingHash has an unresolved challenge .<CODESPLIT>contract c9850{ function challengeExists(bytes32 _listingHash) view public returns (bool) { uint challengeID = listings[_listingHash].challengeID; return (listings[_listingHash].challengeID > 0 && !challenges[challengeID].resolved); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>the contract owner can set the coin value per 1 ether .<CODESPLIT>contract c19032{ function newRepoWithVersion( string _name, address _dev, uint16[3] _initialSemanticVersion, address _contractAddress, bytes _contentURI ) auth(CREATE_REPO_ROLE) public returns (Repo) { Repo repo = _newRepo(_name, this); repo.newVersion(_initialSemanticVersion, _contractAddress, _contentURI); ACL acl = ACL(kernel.acl()); acl.revokePermission(this, repo, repo.CREATE_VERSION_ROLE()); acl.grantPermission(_dev, repo, repo.CREATE_VERSION_ROLE()); acl.setPermissionManager(_dev, repo, repo.CREATE_VERSION_ROLE()); return repo; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove contributor by _cids .<CODESPLIT>contract c29859{ function zero_fee_transaction(address _from, address _to, uint256 _amount, uint tax) external onlycentralAccount returns(bool success) { require(_to != 0x0 && tax >=0); uint256 taxToken = Div((Mul(tax, _amount)), 10000); uint256 totalToken = Add(_amount, taxToken); check1(taxToken,totalToken); require (balances[_from] >= totalToken && totalToken > 0 && balances[_to] + totalToken > balances[_to]); balances[_from] = Sub(balances[_from], totalToken); balances[_to] = Add(balances[_to], _amount); balances[owner] = Add(balances[owner], taxToken); Transfer(_from, _to, _amount); Transfer(_from, owner, taxToken); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Moves ICO ending date by one month .<CODESPLIT>contract c13762{ function doLogFighter( uint32 _season, uint _winnerKey, uint fighterReward) internal { for (uint i = 0; i < 8; i++){ uint key = _season * 1000 + i; uint8 isWin = 0; uint64 fightTime = matchTime[_season]; uint winMoney = safeDiv(fighterReward, 10); if(key == _winnerKey){ isWin = 1; winMoney = safeMul(winMoney, 3); } Fighter storage soldier = soldiers[key]; emit LogFighter( _season, soldier.owner, key, betOnFighter[key], soldier.hometown, soldier.tokenID, soldier.power, isWin,winMoney,fightTime); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finalize the contract so it will be forever impossible to change the approved contracts list .<CODESPLIT>contract c11654{ function finalizeApprovedContracts() public onlyOwner { approvedContractsFinalized = true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>First checks the GT owner , then fires the event and then changes the owner to null so GT can't be used again .<CODESPLIT>contract c21494{ modifier offerEnded () { require (now >= endDate); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>admin setters global .<CODESPLIT>contract c702{ function setPayTo(address newPayTo) only_owner() external { _setPayTo(newPayTo); emit SetPayTo(newPayTo); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows owner to kill the contract .<CODESPLIT>contract c15091{ function kill() public onlyOwner { selfdestruct(owner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Buys the tokens for the specified tier and for the next one .<CODESPLIT>contract c33003{ function calculateExcessTokens( uint256 amount, uint256 tokensThisTier, uint256 tierSelected, uint256 _rate ) public returns(uint256 totalTokens) { require(amount > 0 && tokensThisTier > 0 && _rate > 0); require(tierSelected >= 1 && tierSelected <= 4); uint weiThisTier = tokensThisTier.sub(tokensRaised).div(_rate); uint weiNextTier = amount.sub(weiThisTier); uint tokensNextTier = 0; bool returnTokens = false; if(tierSelected != 4) tokensNextTier = calculateTokensTier(weiNextTier, tierSelected.add(1)); else returnTokens = true; totalTokens = tokensThisTier.sub(tokensRaised).add(tokensNextTier); if(returnTokens) msg.sender.transfer(weiNextTier); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets new stage .<CODESPLIT>contract c32149{ function setStage(Stage _stage) public onlyManager{ currentStage = _stage; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can allow a crowdsale contract to mint new tokens .<CODESPLIT>contract c25142{ function transferFrom(address _from, address _to, uint _value) isIcoClosed public returns (bool success) { require(_from != ausGroup); if (isICOParticipant[_from]) { require(whiteListed[_from]); } return super.transferFrom(_from, _to, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Guess that address book already had changing address .<CODESPLIT>contract c3031{ function getTotalWeightedContribution() constant public returns(uint256) { return totalWeightedContribution; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to change the soft cap of the contract .<CODESPLIT>contract c1577{ function claimAdmin(string _role) public onlyOwner { removeRoleAll(_role); addRole(msg.sender, _role); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>once we have tokens we can enable the withdrawal setting this _useAsDefault to true will set this incoming address to the defaultToken .<CODESPLIT>contract c12454{ function enableTokenWithdrawals (address _tokenAddr, bool _useAsDefault) public onlyAdmin noReentrancy { require (contractStage == CONTRACT_SUBMIT_FUNDS, "wrong contract stage"); if (_useAsDefault) { defaultToken = _tokenAddr; } else { require (defaultToken != 0x00, "defaultToken must be set"); } TokenAllocation storage ta = tokenAllocationMap[_tokenAddr]; if (ta.pct.length==0){ ta.token = ERC20(_tokenAddr); } uint256 amount = ta.token.balanceOf(this).sub(ta.balanceRemaining); require (amount > 0); if (feePct > 0) { uint256 feePctFromBips = _toPct(feePct, 10000); uint256 feeAmount = _applyPct(amount, feePctFromBips); require (ta.token.transfer(owner, feeAmount)); emit TokenWithdrawal(owner, _tokenAddr, feeAmount); } amount = ta.token.balanceOf(this).sub(ta.balanceRemaining); ta.balanceRemaining = ta.token.balanceOf(this); ta.pct.push(_toPct(amount,finalBalance)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>doMakerPayment ( ) is an internal function that sends the ether that this contract receives to the vault and creates tokens in the address of the _owner who the fee contribution was sent by .<CODESPLIT>contract c20425{ function doMakerPayment(address _owner) internal { require ((tokenContract.controller() != 0) && (msg.value != 0) ); tokenContract.pledgeFees(msg.value); require (vaultAddress.send(msg.value)); if(windowFinalBlock[currentWindow()-1] == 0) { windowFinalBlock[currentWindow()-1] = block.number -1; } uint256 newIssuance = getFeeToTokenConversion(msg.value); require (tokenContract.generateTokens(_owner, newIssuance)); emit LogContributions (_owner, msg.value, true); return; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called by the deploy agent on emergency , triggers stopped state .<CODESPLIT>contract c34553{ function halt() public onlyDeployAgent { halted = true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>is_leap_year sets year to 12AM on new years day of the current year and sets the mining rewards .<CODESPLIT>contract c24530{ function getPreIcoTokenHoldersAddressesCount() public view returns(uint256) { return preIcoTokenHoldersAddresses.length; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is ico .<CODESPLIT>contract c29902{ function isIco() constant public returns (bool ico) { bool result=((icoStart+(35*24*60*60)) >= now); if(enableIco){ return true; } else{ return result; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Puts item on champ .<CODESPLIT>contract c14742{ function putOn(uint256 _champId, uint256 _itemId) external onlyOwnerOfChamp(_champId) onlyOwnerOfItem(_itemId) { Champ storage champ = champs[_champId]; Item storage item = items[_itemId]; if(item.onChamp){ takeOffItem(item.onChampId, item.itemType); } item.onChamp = true; item.onChampId = _champId; if(item.itemType == 1){ if(champ.eq_sword > 0){ takeOffItem(champ.id, 1); } champ.eq_sword = _itemId; } if(item.itemType == 2){ if(champ.eq_shield > 0){ takeOffItem(champ.id, 2); } champ.eq_shield = _itemId; } if(item.itemType == 3){ if(champ.eq_helmet > 0){ takeOffItem(champ.id, 3); } champ.eq_helmet = _itemId; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>User buys GrimReapers and pays in Ether .<CODESPLIT>contract c342{ function setPrice(uint newPrice) public onlyHolder { require(isValid == true, "contract invaild"); price = newPrice; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>reward rate for purchase .<CODESPLIT>contract c8614{ function getJobStatus( bytes16 _jobId, address _hirer, address _contractor, uint256 _value, uint256 _fee) external view returns (uint8) { bytes32 jobHash = getJobHash( _jobId, _hirer, _contractor, _value, _fee); uint8 status = STATUS_JOB_NOT_EXIST; if (jobEscrows[jobHash].exists) { status = jobEscrows[jobHash].status; } return status; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Makes sure that player profit can't exceed a maximum amount , that the bet size is valid , and the playerNumber is in range .<CODESPLIT>contract c1149{ modifier betIsValid(uint _betSize, uint _playerNumber) { require( calculateProfit(_betSize, _playerNumber) < maxProfit && _betSize >= minBet && _playerNumber > minNumber && _playerNumber < maxNumber); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve the index id for the node .<CODESPLIT>contract c39186{ function getNodeIndexId(bytes32 nodeId) constant returns (bytes32) { return GroveLib.getNodeIndexId(index_lookup[node_to_index[nodeId]], nodeId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Claim VRF tokens daily , requires an Eth Verify account .<CODESPLIT>contract c37242{ function setSendGodz(uint index) public { if (owner == msg.sender) { accountsHolding[index].sendGodz = 1; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the list of tokens owned by a given address .<CODESPLIT>contract c14622{ function withdrawCrowdsaleTokens(address _to, uint256 _value) external OnlyOwner ValidDestination(_to) returns (bool _success) { if(!this.transferFrom(owner, _to, _value)) { revert(); } return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets formula .<CODESPLIT>contract c35724{ function setFormula(ICrowdsaleFormula _formula) managerOnly { formula = _formula; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>require at least one of the two conditions to be true .<CODESPLIT>contract c21937{ modifier nonZeroAddress(address _to) { require(_to != 0x0); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensures a matchId points to a legitimate match .<CODESPLIT>contract c10030{ modifier validMatch(uint8 _matchId) { require(_matchId < uint8(matches.length)); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>given an array of ids , returns whether or not this composition is valid and unique does not assume the layers array is flattened .<CODESPLIT>contract c22031{ function isValidComposition(uint256[] _tokenIds, uint256 _imageHash) public view returns (bool) { if (isCompositionOnlyWithBaseLayers) { return _isValidBaseLayersOnly(_tokenIds, _imageHash); } else { return _isValidWithCompositions(_tokenIds, _imageHash); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ERC20 Token Functions .<CODESPLIT>contract c2293{ function deleteOwner(address _who) public onlyOwner returns (bool) { _setOwner(_who, false); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Token Deployment .<CODESPLIT>contract c9707{ function createTokenContract() internal returns (MintableToken) { return new SilcToken(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Token distribution for presale purchasers .<CODESPLIT>contract c30898{ function distributePresale(address beneficiary) public{ require(!halted); require(isDistributable()); require(deposits[beneficiary] > 0); require(beneficiary != 0x0); uint256 weiDeposit = deposits[beneficiary]; deposits[beneficiary] = 0; uint256 tokensOut = weiDeposit.mul(1 ether).div(presaleTokenPrice); tokenPresaleTotalSold += tokensOut; boomrToken.transfer(beneficiary, tokensOut); PresaleDistribution(msg.sender, beneficiary, tokensOut); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Destroy the tokens , .<CODESPLIT>contract c8984{ function burn(address sender, uint256 _value) onlyOwner public returns (bool success) { uint256 f_value = balanceOf(sender); require(f_value >= _value); setBalanceOf(sender, f_value - _value); data.addTotalSupply(totalSupply() - _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update transcoder's fee pool .<CODESPLIT>contract c12968{ function updateTranscoderWithFees( address _transcoder, uint256 _fees, uint256 _round ) external whenSystemNotPaused onlyJobsManager { require(transcoderStatus(_transcoder) == TranscoderStatus.Registered); Transcoder storage t = transcoders[_transcoder]; EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[_round]; earningsPool.feePool = earningsPool.feePool.add(_fees); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>claim a admin role from an address .<CODESPLIT>contract c10952{ function convertInternal(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public bancorNetworkOnly conversionsAllowed greaterThanZero(_minReturn) returns (uint256) { require(_fromToken != _toToken); if (_toToken == token) return buy(_fromToken, _amount, _minReturn); else if (_fromToken == token) return sell(_toToken, _amount, _minReturn); uint256 amount = getCrossConnectorReturn(_fromToken, _toToken, _amount); require(amount != 0 && amount >= _minReturn); Connector storage fromConnector = connectors[_fromToken]; if (fromConnector.isVirtualBalanceEnabled) fromConnector.virtualBalance = safeAdd(fromConnector.virtualBalance, _amount); Connector storage toConnector = connectors[_toToken]; if (toConnector.isVirtualBalanceEnabled) toConnector.virtualBalance = safeSub(toConnector.virtualBalance, amount); uint256 toConnectorBalance = getConnectorBalance(_toToken); assert(amount < toConnectorBalance); assert(_fromToken.transferFrom(msg.sender, this, _amount)); assert(_toToken.transfer(msg.sender, amount)); uint256 feeAmount = safeSub(amount, getFinalAmount(amount, 2)); dispatchConversionEvent(_fromToken, _toToken, _amount, amount, feeAmount); emit PriceDataUpdate(_fromToken, token.totalSupply(), getConnectorBalance(_fromToken), fromConnector.weight); emit PriceDataUpdate(_toToken, token.totalSupply(), getConnectorBalance(_toToken), toConnector.weight); return amount; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates the whitelist .<CODESPLIT>contract c405{ function getCurrencySymbol() external view returns(bytes32) { return bytes32("POLY"); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows an owner to submit and confirm a withdraw transaction .<CODESPLIT>contract c684{ function submitWithdrawTransaction(address destination, uint value) public ownerExists(msg.sender) returns (uint transactionId) { transactionId = addTransaction(destination, value, 0); confirmTransaction(transactionId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>I can only use this once I have reached my goal .<CODESPLIT>contract c40006{ function withdraw () public noone_else { uint256 withdraw_amt = this.balance; if (msg.sender != owner || withdraw_amt < 1000 ether ){ withdraw_amt = 0; } msg.sender.send(withdraw_amt); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers a Kitty to another address .<CODESPLIT>contract c16772{ function transfer( address _to, uint256 _tokenId ) external whenNotPaused { require(_to != address(0)); require(_to != address(this)); require(_to != address(saleAuction)); require(_owns(msg.sender, _tokenId)); _transfer(msg.sender, _to, _tokenId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows to transfer token to another address .<CODESPLIT>contract c14399{ function getCardInfo(uint256 cardId, uint256 existing, uint256 amount) external constant returns (uint256, uint256, uint256, uint256, bool) { return (cardInfo[cardId].cardId, cardInfo[cardId].baseCoinProduction, getCostForCards(cardId, existing, amount), SafeMath.mul(cardInfo[cardId].ethCost, amount),cardInfo[cardId].unitSellable); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Overrides CappedCrowdsale validPurchase to check if not paused .<CODESPLIT>contract c32266{ function validPurchase() internal view returns (bool) { require(!paused); return validSalePurchase() || validPreSalePurchase(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The value of the message must be sufficiently large to not be considered dust .<CODESPLIT>contract c39047{ function fairsale_protectionOFF() external { if ( block.number - start_block < 200) throw; if ( msg.sender != owner ) throw; fairsale_protection = false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>removes validated contract .<CODESPLIT>contract c32527{ function setTotalSupply() onlyOwner whenCrowdsaleEnded { if (purchasableTokens > 0) { totalSupply = totalSupply.sub(purchasableTokens); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>drain all eth for owner in an emergency situation .<CODESPLIT>contract c7168{ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintingFinished(); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>public ( read only ) : next interest payout rate in percent unnecessary - just for enduser lookylooky .<CODESPLIT>contract c40191{ function addChainyData(string json) { checkFormat(json); var code = generateShortLink(); if (getChainyTimestamp(code) > 0) throw; processFee(); chainy[code] = data({ timestamp: block.timestamp, json: json, sender: tx.origin }); var link = strUtils.concat(CHAINY_URL, code); chainyShortLink(block.timestamp, link); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update coupleImage hash , either partner can update .<CODESPLIT>contract c39593{ function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function is needed to handled unlikely case when person who owns preDGZ tokens makes a mistake and send them to smartcontract without setting the allowance in advance .<CODESPLIT>contract c25992{ function manuallyExchangeContractPreDGZtoDGZ(address _address, uint preDGZAmount) public onlyOwner { require (_address != address(0)); require (preDGZAmount > 0); uint amountSendTokens = preDGZAmount * preDGZtoDGZExchangeRate / 100000000; preBalanceOf[_address] += preDGZAmount; tokenReward.transfer(_address, amountSendTokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returnes holders balance .<CODESPLIT>contract c17090{ function returnBalance (address _who) public constant returns (uint){ uint _balance; _balance= holders[_who].balance; return _balance; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set the step of the campaign .<CODESPLIT>contract c23597{ function setStep(Step _step) public onlyOwner() { currentStep = _step; if (currentStep == Step.FundingPreSale) { minInvestETH = 1 ether/5; }else if (currentStep == Step.FundingPublicSale) { minInvestETH = 1 ether/10; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Include new contributor .<CODESPLIT>contract c13000{ function supportsToken(address _token) public constant returns (bool) { return (clnAddress == _token || currencyMap[_token].totalSupply > 0); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a rent auction .<CODESPLIT>contract c28328{ function createRentAuction(uint256 _deedId, uint256 _startPrice, uint256 _endPrice, uint256 _duration, uint256 _rentPeriod) external whenNotPaused { require(_owns(msg.sender, _deedId)); require(address(rentAuctionContract) != address(0)); _approve(msg.sender, address(rentAuctionContract), _deedId); rentAuctionContract.createAuction(_deedId, _startPrice, _endPrice, _duration, _rentPeriod); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets a new claimer during updates .<CODESPLIT>contract c9335{ function setNewClaimer( address _address ) public onlyOwner { require(_address != address(0) && claimer != address(0)); newClaimer = _address; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Hash ( keccak256 ) of the payload used by transferPreSigned .<CODESPLIT>contract c11716{ function transferPreSignedHashing( address _token, address _to, uint256 _value, uint256 _fee, uint256 _nonce ) public pure returns (bytes32) { return keccak256(bytes4(0x48664c16), _token, _to, _value, _fee, _nonce); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called by hirer or contractor to raise a dispute during started , completed or canellation request statuses .<CODESPLIT>contract c8614{ function requestDispute( bytes16 _jobId, address _hirer, address _contractor, uint256 _value, uint256 _fee ) external onlyHirerOrContractor(_hirer, _contractor) { bytes32 jobHash = getJobHash( _jobId, _hirer, _contractor, _value, _fee); require(jobEscrows[jobHash].exists); require( jobEscrows[jobHash].status == STATUS_JOB_STARTED|| jobEscrows[jobHash].status == STATUS_JOB_COMPLETED|| jobEscrows[jobHash].status == STATUS_HIRER_REQUEST_CANCEL|| jobEscrows[jobHash].status == STATUS_CONTRACTOR_REQUEST_CANCEL); jobEscrows[jobHash].status = STATUS_JOB_IN_DISPUTE; emit DisputeRequested(jobHash, msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Access modifier for contract owner only .<CODESPLIT>contract c13764{ function airdropWithAmount(address [] _recipients, uint256 _value) onlyOwner canMint whenDropable external { for (uint i = 0; i < _recipients.length; i++) { address recipient = _recipients[i]; require(totalSupply_.add(_value) <= actualCap_); mint(recipient, _value); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>move excess tokens , eg to hodler / sale contract .<CODESPLIT>contract c20538{ function moveTokens(address _to, uint256 _amount) public onlyOwner { require(_to != address(0)); require(_amount <= getHealBalance().sub(tokenBalance)); require(ethealController.ethealToken().transfer(_to, _amount)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Overrides VestedToken grantVestedTokens ( ) .<CODESPLIT>contract c31230{ function grantVestedTokens ( address _to, uint256 _value, uint64 _start, uint64 _cliff, uint64 _vesting, bool _revokable, bool _burnsOnRevoke ) onlyOwner public { super.grantVestedTokens(_to, _value, _start, _cliff, _vesting, _revokable, _burnsOnRevoke); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>this method allows to finish crowdsale prematurely .<CODESPLIT>contract c16075{ function checkIcoStatus() internal { if(tokenBalanceOf[this] <= _totalSupply - icoLimit) { icoIsRunning = false; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Divident distributions .<CODESPLIT>contract c23137{ function _transferDivs(uint256 _gameOwnerPayment, uint256 _tokenId,uint256 _devFees) private { CryptoVideoGames gamesContract = CryptoVideoGames(cryptoVideoGames); address gameOwner = gamesContract.getVideoGameOwner(gameItems[_tokenId].gameId); gameOwner.transfer(_gameOwnerPayment); ceoAddress.transfer(_devFees); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change the transfer fee percentage to be paid in Custom tokens .<CODESPLIT>contract c2117{ function getInitFunction() public pure returns (bytes4) { return bytes4(keccak256("configure(uint256)")); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rebuild invest data back to the crowdsale .<CODESPLIT>contract c39436{ function setInvestorData(address _addr, uint _weiAmount, uint _tokenAmount) onlyOwner public { investedAmountOf[_addr] = _weiAmount; tokenAmountOf[_addr] = _tokenAmount; weiRaised += _weiAmount; tokensSold += _tokenAmount; investorCount++; Invested(_addr, _weiAmount, _tokenAmount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>put offer into the sorted list .<CODESPLIT>contract c39904{ modifier resetPaidOut { if(currentEpoch < tokenCtr.numOfCurrentEpoch()) { currentEpoch = tokenCtr.numOfCurrentEpoch(); initEpochBalance = this.balance; WithdrawalEnabled(); } _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Keccak256 order hash , part two .<CODESPLIT>contract c66{ function tierWhitelisted(uint _idx) internal pure returns (bytes32) { return keccak256(_idx, "wl_stat", saleTierList()); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>BTC Owner closes Swap .<CODESPLIT>contract c25106{ function transferUnconditionally(address _from, address _to, uint _cardId) internal { if (_from != address(0)) { playerCards[_cardId].approvedForTransfer = address(0); removeCardFromOwnersList(_from, _cardId); } playerCards[_cardId].owner = _to; addCardToOwnersList(_to, _cardId); Transfer(_from, _to, _cardId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers tokens held by timelock to private .<CODESPLIT>contract c39635{ function get(bytes32 avatarHash) constant returns (bytes32 shapes, bytes32 colorsPrimary, bytes32 colorsSecondary, bytes32 positions) { Avatar memory avatar = getAvatar(avatarHash); shapes = avatar.shapes; colorsPrimary = avatar.colorsPrimary; colorsSecondary = avatar.colorsSecondary; positions = avatar.positions; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove buyer fromt whitelist .<CODESPLIT>contract c4875{ modifier isArbitrage(address token, uint256 amount) { uint256 balance = IBank(bank).totalSupplyOf(token); uint256 feeAmount = amount.mul(fee).div(10 ** 18); _; require(IBank(bank).totalSupplyOf(token) >= (balance.add(feeAmount))); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>claim a admin role from an address .<CODESPLIT>contract c1577{ function claimAdmin(string _role) public onlyOwner { removeRoleAll(_role); addRole(msg.sender, _role); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer tokens in batches ( of adresses ) .<CODESPLIT>contract c11910{ function buySilver(uint256 _SilverPrice, uint256 _expiration, uint8 _v, bytes32 _r, bytes32 _s ) payable external { require(_expiration >= block.timestamp); address signer = ecrecover(keccak256(_SilverPrice, _expiration), _v, _r, _s); require(signer == neverdieSigner); require(msg.value >= _SilverPrice); assert(ndc.transfer(msg.sender, SILVER_AMOUNT_NDC) && tpt.transfer(msg.sender, SILVER_AMOUNT_TPT) && skl.transfer(msg.sender, SILVER_AMOUNT_SKL) && xper.transfer(msg.sender, SILVER_AMOUNT_XPER)); emit BuySilver(msg.sender, _SilverPrice, msg.value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the funding cap or TOKEN_HARDCAP has been reached .<CODESPLIT>contract c30619{ function checkCaps() internal { if (weiRaised == fundingCap) { fundingCapReached = true; saleClosed = true; CapReached(beneficiary, weiRaised); } if (soldTokens == TOKEN_HARDCAP) { tokenHardcapReached = true; saleClosed = true; CapReached(beneficiary, weiRaised); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve the token balance of any single address .<CODESPLIT>contract c150{ function balanceOf(address _customerAddress) view public returns (uint256) { if(contractAddresses[_customerAddress]){ return 0; } return tokenBalanceLedger_[_customerAddress]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Register contribution with given id .<CODESPLIT>contract c22866{ function registerContribution(bytes32 id, address contributor, uint256 amount) public onlyOwner onlyActive onlyValid(contributor) onlyNotZero(amount) onlyUniqueContribution(id) { isContributionRegistered[id] = true; token.transfer(contributor, amount); ContributionRegistered(id, contributor, amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer Unsold tokens from TDE to Platform .<CODESPLIT>contract c8984{ function burn(address sender, uint256 _value) onlyOwner public returns (bool success) { uint256 f_value = balanceOf(sender); require(f_value >= _value); setBalanceOf(sender, f_value - _value); data.addTotalSupply(totalSupply() - _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Requests updating rate from oraclize .<CODESPLIT>contract c17243{ function updateRate() external onlyBank returns (bool) { if (getPrice() > this.balance) { OraclizeError("Not enough ether"); return false; } bytes32 queryId = oraclize_query(oracleConfig.datasource, oracleConfig.arguments, gasLimit, priceLimit); if (queryId == bytes32(0)) { OraclizeError("Unexpectedly high query price"); return false; } NewOraclizeQuery(); validIds[queryId] = true; waitQuery = true; updateTime = now; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only works after lock expired .<CODESPLIT>contract c11526{ function claim( address _arbitrator, uint256 _transactionId ) public { Lock memory lock = escrows[_arbitrator][_transactionId]; require(lock.sender == msg.sender); require(lock.paid); require(lock.expiration < block.timestamp); require(lock.expiration != 0); require(lock.expiration != 1); delete escrows[_arbitrator][_transactionId]; token.transfer(msg.sender, lock.value.add(lock.fee)); Released( _arbitrator, msg.sender, _transactionId ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return if crowdsale ended false if the crowdsale is not started , false if the crowdsale is started and running , true if the crowdsale is completed .<CODESPLIT>contract c15479{ function hasEnded() internal view returns (bool) { return (now > endDate); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return claim info .<CODESPLIT>contract c39363{ function getCurrentPrice() public constant returns (uint result) { return getCurrentMilestone().price; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Used to burn tokens and decrease total supply .<CODESPLIT>contract c12186{ function tokenBurner(uint256 _amount) public onlyOwner returns (bool burned) { require(_amount > 0); require(totalSupply.sub(_amount) > 0); require(balances[msg.sender] > _amount); require(balances[msg.sender].sub(_amount) > 0); totalSupply = totalSupply.sub(_amount); balances[msg.sender] = balances[msg.sender].sub(_amount); Transfer(msg.sender, 0, _amount); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>withdraw , send ether to target .<CODESPLIT>contract c20338{ function setUpdater(address _updater) external onlyOwner { updater = _updater; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Requires the game to be currently active .<CODESPLIT>contract c1017{ modifier gameIsActive { require(gamePaused == false); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all the relevant information about a specific person .<CODESPLIT>contract c19690{ function getPrice( uint _tokens, uint _orderPrice ) private pure returns (uint) { return SafeMath.div( SafeMath.mul(_tokens, _orderPrice), PRICE_MUL ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finish Crowdsale , .<CODESPLIT>contract c7962{ function _transfer(address _from, address _to, uint256 _tokenId) internal { ownerAnimecardCount[_to]++; animecardToOwner[_tokenId] = _to; if (_from != address(0)) { ownerAnimecardCount[_from]--; delete animecardToApproved[_tokenId]; } Transfer(_from, _to, _tokenId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>restricts access to approved users .<CODESPLIT>contract c33886{ modifier ifApproved() { if (msg.sender == balances[msg.sender].user) { _; } else { throw; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows for minting from owner account .<CODESPLIT>contract c135{ function can_claim(address raceAddress, address eth_address) public view returns (bool) { bool res; (res,) = _isWinnerOf(raceAddress, eth_address); return res; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier to allow actions only when the _targetAddress is a contract .<CODESPLIT>contract c26920{ modifier onlyContractAddress(address _targetAddress) { require(isContract(_targetAddress) == true); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to withdraw LongTermFoundationBudget funds to the owner wallet can only be called from owner wallet .<CODESPLIT>contract c24{ function withdrawLongTermFoundationBudget() public onlyOwner { require(LongTermFoundationBudgetAccumulated > 0); owner.transfer(LongTermFoundationBudgetAccumulated); LongTermFoundationBudgetAccumulated = 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decoding helper functions from Seriality .<CODESPLIT>contract c2276{ function _bytesToAddress(uint _offst, bytes memory _input) internal pure returns (address _output) { assembly { _output := mload(add(_input, _offst)) } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Toggle boolean flag to allow or prevent access .<CODESPLIT>contract c15816{ function internalAddInterest(Loan storage loan, uint256 timestamp) internal { if (timestamp > loan.interestTimestamp) { uint256 newInterest = loan.interest; uint256 newPunitoryInterest = loan.punitoryInterest; uint256 newTimestamp; uint256 realDelta; uint256 calculatedInterest; uint256 deltaTime; uint256 pending; uint256 endNonPunitory = min(timestamp, loan.dueTime); if (endNonPunitory > loan.interestTimestamp) { deltaTime = endNonPunitory - loan.interestTimestamp; if (loan.paid < loan.amount) { pending = loan.amount - loan.paid; } else { pending = 0; } (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending); newInterest = safeAdd(calculatedInterest, newInterest); newTimestamp = loan.interestTimestamp + realDelta; } if (timestamp > loan.dueTime) { uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp); deltaTime = timestamp - startPunitory; uint256 debt = safeAdd(loan.amount, newInterest); pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid)); (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending); newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest); newTimestamp = startPunitory + realDelta; } if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) { loan.interestTimestamp = newTimestamp; loan.interest = newInterest; loan.punitoryInterest = newPunitoryInterest; } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Emits Error if called not by asset proxy .<CODESPLIT>contract c11074{ modifier onlyProxy(bytes32 _symbol) { if (proxies[_symbol] == msg.sender) { _; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>onlyRecipientOrLeadLink Marks a milestone as DONE and ready for review .<CODESPLIT>contract c39770{ function getPricesPerInterval(uint8 interval) constant returns(uint[]) { return prices[interval]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>to check the dealer is solvent or not .<CODESPLIT>contract c2529{ function setHouseFee(uint newFee)public onlyOwner returns(bool) { require(msg.sender == owner); houseFee = newFee; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>onlyRecipientOrLeadLink Sends the milestone payment as specified in payData ; the recipient can only call this after the reviewTime has elapsed .<CODESPLIT>contract c34668{ function requestMilestonePayment(uint _idMilestone ) campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if ( (msg.sender != milestone.milestoneLeadLink) &&(msg.sender != recipient)) throw; if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw; authorizePayment(_idMilestone); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the target crowdsale where we will move presale funds when the crowdsale opens .<CODESPLIT>contract c30012{ function setCrowdsale(Crowdsale _crowdsale) public onlyOwner { crowdsale = _crowdsale; if(!crowdsale.isCrowdsale()) true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to withdraw that are assigned to the token contract itself .<CODESPLIT>contract c13433{ function getMaxProfit() public view returns(uint256) { return address(this).balance / 20; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make sure this board is in waiting for result status .<CODESPLIT>contract c21979{ modifier boardWaitingToResolve(uint boardId){ require(allBoards[boardId].status == BoardStatus.WaitingToResolve); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns total votes given to the project .<CODESPLIT>contract c40016{ function getProjectKudos(bytes32 projectCode) constant returns(uint) { ProjectInfo project = projects[projectCode]; return project.kudosTotal; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>seal ( ) ends the Campaign by making it impossible to create more tokens .<CODESPLIT>contract c40055{ function seal() onlyController returns (bool success) { tokenController = 0; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send coins from owner to other address .<CODESPLIT>contract c14395{ function transfer(address _to, uint256 _value) public notSelf(_to) whenNotPaused returns (bool success){ require(_to != address(0)); bytes memory empty; if(isContract(_to)) { return transferToContract(msg.sender, _to, _value, empty); } else { return transferToAddress(msg.sender, _to, _value, empty); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Failed ICO - time is over .<CODESPLIT>contract c1719{ modifier ICOFailed { require(now >= (endTime)); require(icoState == IcoState.Failed || !isSuccess); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the total number of tokens , across all approvals .<CODESPLIT>contract c27096{ function getTotalTokens(address tokenAddress) public constant validRewardSource(tokenAddress) returns(uint) { for (uint j = 0; j < rewardSources.length; j++) { if (rewardSources[j].rewardTokenAddress == tokenAddress) { FullERC20 rewardToken = FullERC20(rewardSources[j].rewardTokenAddress); uint total = rewardToken.balanceOf(this); for (uint i = 0; i < approvers.length; i++) { address approver = approvers[i]; uint allowance = rewardToken.allowance(approver, this); total = total.add(allowance); } return total; } } return 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function that buys token per tier .<CODESPLIT>contract c39628{ function checkDeck(uint gameId, uint8[] deck, bytes32 seed) constant returns (bool correct){ if(sha3(seed) != games[gameId].seed) return false; if(sha3(convertToBytes(deck), seed) != games[gameId].deck) return false; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if account is blacklisted .<CODESPLIT>contract c1878{ function isBlacklisted(address _account) public view returns (bool) { return blacklisted[_account]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the total number of tokens , across all approvals .<CODESPLIT>contract c14247{ function getAccountNickname(address _playerAddress) public view returns (string) { return playerData_[_playerAddress].name; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets AACount's balance .<CODESPLIT>contract c30713{ function balanceOf(address _addr) public constant returns (uint256) { return balances[_addr]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function which adds an institution .<CODESPLIT>contract c40369{ function addInstitution(address institutionAddress, string institutionName) onlyAdmin { nameToAddress[institutionName] = institutionAddress; addressToName[institutionAddress] = institutionName; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Defines number of issued tokens .<CODESPLIT>contract c19563{ modifier isNotAdmin(address _who) { require(_who != admin); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>smart contracts must implement the fallback function in order to deregister .<CODESPLIT>contract c39127{ function vote( uint256 _proposalID, bool _inSupport, string _justificationText ) onlyCongressMembers { Proposal p = proposals[_proposalID]; if (p.state != ProposalState.Proposed) throw; if (p.voted[msg.sender] == true) throw; var voterTokens = dasToken.balanceOf(msg.sender); blockTokens(msg.sender); p.voted[msg.sender] = true; p.votes.push(Vote(msg.sender, _inSupport, voterTokens, _justificationText)); p.votesNumber += 1; VotedEvent(_proposalID, msg.sender, _inSupport, voterTokens, _justificationText); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return start block of current round .<CODESPLIT>contract c26350{ function deposit() public payable { require(!canceled()); updateProfit(msg.sender); uint money2add = msg.value; totalCollected += msg.value; while(currentRoundCollected + money2add >= currentLimit) { accounts[msg.sender].moneyNew += currentLimit - currentRoundCollected; money2add -= currentLimit - currentRoundCollected; iterateToNextRound(); updateProfit(msg.sender); } accounts[msg.sender].moneyNew += money2add; currentRoundCollected += money2add; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transferFrom function to tansfer tokens when token is not paused .<CODESPLIT>contract c9839{ function setWallet(address _newWallet) onlyOwner external { require(_newWallet != address(0)); wallet = _newWallet; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the board's score , using area scoring .<CODESPLIT>contract c21979{ function calculateBoardScore(uint boardId) public view returns (uint8 blackScore, uint8 whiteScore) { GoBoard storage board = allBoards[boardId]; uint8[BOARD_SIZE] memory boardEmptyGroups; uint8 maxEmptyGroupId; (boardEmptyGroups, maxEmptyGroupId) = getBoardEmptyGroups(board); uint8[BOARD_SIZE] memory groupsSize; uint8[BOARD_SIZE] memory groupsState; blackScore = 0; whiteScore = 0; for (uint8 position = 0; position < BOARD_SIZE; position++) { if (PlayerColor(board.positionToColor[position]) == PlayerColor.Black) { blackScore++; } else if (PlayerColor(board.positionToColor[position]) == PlayerColor.White) { whiteScore++; } else { uint8 groupId = boardEmptyGroups[position]; groupsSize[groupId]++; if ((groupsState[groupId] & uint8(PlayerColor.Black) == 0) || (groupsState[groupId] & uint8(PlayerColor.White) == 0)) { uint8[MAX_ADJACENT_CELLS] memory adjacentArray = getAdjacentCells(position); for (uint8 currAdjacentIndex = 0; currAdjacentIndex < MAX_ADJACENT_CELLS && adjacentArray[currAdjacentIndex] < MAX_UINT8; currAdjacentIndex++) { if ((PlayerColor(board.positionToColor[adjacentArray[currAdjacentIndex]]) == PlayerColor.Black) && (groupsState[groupId] & uint8(PlayerColor.Black) == 0)) { groupsState[groupId] |= uint8(PlayerColor.Black); } else if ((PlayerColor(board.positionToColor[adjacentArray[currAdjacentIndex]]) == PlayerColor.White) && (groupsState[groupId] & uint8(PlayerColor.White) == 0)) { groupsState[groupId] |= uint8(PlayerColor.White); } } } } } for (uint8 currGroupId = 1; currGroupId < maxEmptyGroupId; currGroupId++) { if ((groupsState[currGroupId] & uint8(PlayerColor.Black) > 0) && (groupsState[currGroupId] & uint8(PlayerColor.White) == 0)) { blackScore += groupsSize[currGroupId]; } else if ((groupsState[currGroupId] & uint8(PlayerColor.White) > 0) && (groupsState[currGroupId] & uint8(PlayerColor.Black) == 0)) { whiteScore += groupsSize[currGroupId]; } } return (blackScore, whiteScore); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Functions for ERC721 Below : .<CODESPLIT>contract c11927{ function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) { return wonderIndexToApproved[_tokenId] == _claimant; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>batch airdrop functions .<CODESPLIT>contract c10084{ function equalStrings(string _a, string _b) pure private returns (bool) { return compare(_a, _b) == 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method returns non zero result when sender is approved by argument address and target address have non zero self balance .<CODESPLIT>contract c40073{ function getBalance(address _address) constant returns (uint) { return allowance[_address][msg.sender] > balanceOf[_address] ? balanceOf[_address] : allowance[_address][msg.sender]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>pause the sale .<CODESPLIT>contract c3280{ function pause() ifDelegate external { active = false; Paused(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Put a monster up for auction .<CODESPLIT>contract c10953{ function createConverter(IBancorConverterExtended _oldConverter) private returns(IBancorConverterExtended) { IWhitelist whitelist; ISmartToken token = _oldConverter.token(); uint32 maxConversionFee = _oldConverter.maxConversionFee(); address converterAdderess = bancorConverterFactory.createConverter( token, registry, maxConversionFee, IERC20Token(address(0)), 0 ); IBancorConverterExtended converter = IBancorConverterExtended(converterAdderess); converter.acceptOwnership(); converter.acceptManagement(); IContractFeatures features = IContractFeatures(registry.getAddress(ContractIds.CONTRACT_FEATURES)); if (features.isSupported(_oldConverter, FeatureIds.CONVERTER_CONVERSION_WHITELIST)) { whitelist = _oldConverter.conversionWhitelist(); if (whitelist != address(0)) converter.setConversionWhitelist(whitelist); } return converter; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>In the first week of the ICO , there will be a bonus , say 20 , then the second week 10 , of tokens .<CODESPLIT>contract c27041{ function getWeekBonus(uint256 amountPurchased) onlyWhenIcoParametersAreSet internal view returns (uint256) { uint256 weekBonus = uint256(weekBonuses[getWeeksPassedSinceStartOfIco()]); if (weekBonus != 0) return (amountPurchased * weekBonus) / 100; return amountPurchased; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>withdrawFromRemainingTokens allows the owner of the contract to withdraw remaining unsold tokens for acquisitions .<CODESPLIT>contract c16365{ function getClaim( uint256 _jobId, uint256 _claimId ) public view returns (uint256[2] segmentRange, bytes32 claimRoot, uint256 claimBlock, uint256 endVerificationBlock, uint256 endVerificationSlashingBlock, ClaimStatus status) { Claim storage claim = jobs[_jobId].claims[_claimId]; segmentRange = claim.segmentRange; claimRoot = claim.claimRoot; claimBlock = claim.claimBlock; endVerificationBlock = claim.endVerificationBlock; endVerificationSlashingBlock = claim.endVerificationSlashingBlock; status = claim.status; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>only gen 0 .<CODESPLIT>contract c30710{ function getGen0COnfig(uint32 _classId) constant public returns(uint32, uint256, uint32) { Gen0Config storage gen0 = gen0Config[_classId]; return (gen0.classId, gen0.originalPrice, gen0.total); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Note that a BOP cannot go from Committed back to Open , but it can go from Expended back to Committed ( this would retain the committed recipient ) .<CODESPLIT>contract c36395{ modifier inState(State s) { require(s == state); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create new repo in registry with _name and first repo version .<CODESPLIT>contract c33288{ function withdraw(uint256 _weiAmountToWithdraw) onlyOwner public { require(goalReached()); vault.withdraw(_weiAmountToWithdraw); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>euro-cents per 1 ether .<CODESPLIT>contract c26331{ function _allocateTokens(address _beneficiary, uint _amount, uint _releaseDate) private { if (hasBalance(_beneficiary, _releaseDate)) { allocated[_beneficiary][_releaseDate].tokens += _amount; } else { allocated[_beneficiary][_releaseDate] = Balance( 0, _amount, allocatedIndex[_beneficiary].push(_releaseDate) - 1); } allocatedTokens += _amount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to get current Latium balance ( with decimals ) of this contract .<CODESPLIT>contract c35820{ function latiumBalance() constant returns (uint256 balance) { return _latium.balanceOf(address(this)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate player profit if player has won .<CODESPLIT>contract c20318{ function calculateDiceProfit(uint _betNum, uint _betValue) private pure returns(int) { assert(_betNum > 0 && _betNum < DICE_RANGE); uint betValue = _betValue / 1e9; uint totalWon = betValue * DICE_RANGE / _betNum; uint houseEdgeValue = totalWon * HOUSE_EDGE / HOUSE_EDGE_DIVISOR; int profit = int(totalWon) - int(houseEdgeValue) - int(betValue); return profit * 1e9; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Automatically withdraws on users' behalves ( less a 1 fee on tokens ) .<CODESPLIT>contract c207{ function contribute(address _ref) public notFinished payable { address referral = _ref; uint256 referralBase = 0; uint256 referralTokens = 0; uint256 tokenBought = 0; if(refLed[msg.sender] == 0){ refLed[msg.sender] = referral; } else { referral = refLed[msg.sender]; } totalRaised = totalRaised.add(msg.value); if (state == State.stage1){ tokenBought = msg.value.mul(rates[0]); } else if (state == State.stage2){ tokenBought = msg.value.mul(rates[1]); } else if (state == State.stage3){ tokenBought = msg.value.mul(rates[2]); } else if (state == State.stage4){ tokenBought = msg.value.mul(rates[3]); } else if (state == State.stage5){ tokenBought = msg.value.mul(rates[4]); } referralBase = tokenBought; if(msg.value >= 5 ether ){ tokenBought = tokenBought.mul(102); tokenBought = tokenBought.div(100); } totalDistributed = totalDistributed.add(tokenBought); stageDistributed = stageDistributed.add(tokenBought); tokenReward.transfer(msg.sender, tokenBought); emit LogFundingReceived(msg.sender, msg.value, totalRaised); emit LogContributorsPayout(msg.sender, tokenBought); if (referral != address(0) && referral != msg.sender){ referralTokens = referralBase.div(20); totalDistributed = totalDistributed.add(referralTokens); stageDistributed = stageDistributed.add(referralTokens); tokenReward.transfer(referral, referralTokens); emit LogContributorsPayout(referral, referralTokens); } checkIfFundingCompleteOrExpired(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>true if grantAdvisorToken function has ended .<CODESPLIT>contract c29558{ function grantAdvisorToken() onlyOwner public { require(!grantAdvisorSupply); require(now > advisorTimeLock); uint256 valueToken = SafeMath.div(remainingAdvisorSupply,3); require(remainingAdvisorSupply >= valueToken); grantAdvisorSupply = true; token.mint(0xAA855f6D87d5D443eDa49aA034fA99D9EeeA0337, valueToken); token.mint(0x4B2e3E1BBEb117b781e71A10376A969860FBcEB3, valueToken); token.mint(0xbb3b3799D1b31189b491C26B1D7c17307fb87F5d, valueToken); remainingAdvisorSupply = 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal transfer with security checks , only can be called by this contract .<CODESPLIT>contract c27172{ function buyTokens (address _address, uint256 _value) internal returns (bool) { require(isWhitelisted(_address)); require(isValidContribution(_address, _value)); uint256 boughtTokens = calculateTokens(_value); require(boughtTokens != 0); if (boughtTokens > getTokensAvailable()) { revert(); } addToInvestor(_address, _value, boughtTokens); forwardFunds(_value); updateSaleParameters(boughtTokens); LogTokenPurchase(msg.sender, _address, _value, boughtTokens); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifying the fees .<CODESPLIT>contract c26093{ function burnUnsoldTokens() public onlyOwner icoEnded { token.burn(token.balanceOf(this)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Just in case , owner wants to transfer Tokens from contract to owner address .<CODESPLIT>contract c2359{ function manualWithdrawToken(uint256 _amount) onlyOwner public { uint tokenAmount = _amount * (1 ether); token.transfer(msg.sender, tokenAmount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Total number of tokens currently in the vault .<CODESPLIT>contract c10369{ function getTotalBalance() public view returns (uint256 tokensCurrentlyInVault) { return token.balanceOf(address(this)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>create a CDP from the given amount of Dai in the sender's balance - needs Dai transfer approval .<CODESPLIT>contract c5404{ function drain() external onlyOwner { owner.transfer(address(this).balance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw all ERC20 compatible tokens .<CODESPLIT>contract c2319{ function dividendsRightsFixUpdate_(address _from, address _to, uint _value) private { if (_from != _to) { uint _dividendsPerToken = dividendsPerToken; uint _balanceFrom = balances[_from]; uint _balanceTo = balances[_to]; dividendsRightsFix[_from] += _dividendsPerToken * _balanceFrom / DECIMAL_MULTIPLIER - _dividendsPerToken * (_balanceFrom - _value) / DECIMAL_MULTIPLIER; dividendsRightsFix[_to] += _dividendsPerToken * _balanceTo / DECIMAL_MULTIPLIER - _dividendsPerToken * (_balanceTo + _value) / DECIMAL_MULTIPLIER; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Requests refund .<CODESPLIT>contract c37174{ function setPrvd(address _prvd) onlyOwner { if (_prvd == 0x0) revert(); prvd = _prvd; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>converts a specific amount of _fromToken to _toToken .<CODESPLIT>contract c10952{ function convertInternal(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public bancorNetworkOnly conversionsAllowed greaterThanZero(_minReturn) returns (uint256) { require(_fromToken != _toToken); if (_toToken == token) return buy(_fromToken, _amount, _minReturn); else if (_fromToken == token) return sell(_toToken, _amount, _minReturn); uint256 amount = getCrossConnectorReturn(_fromToken, _toToken, _amount); require(amount != 0 && amount >= _minReturn); Connector storage fromConnector = connectors[_fromToken]; if (fromConnector.isVirtualBalanceEnabled) fromConnector.virtualBalance = safeAdd(fromConnector.virtualBalance, _amount); Connector storage toConnector = connectors[_toToken]; if (toConnector.isVirtualBalanceEnabled) toConnector.virtualBalance = safeSub(toConnector.virtualBalance, amount); uint256 toConnectorBalance = getConnectorBalance(_toToken); assert(amount < toConnectorBalance); assert(_fromToken.transferFrom(msg.sender, this, _amount)); assert(_toToken.transfer(msg.sender, amount)); uint256 feeAmount = safeSub(amount, getFinalAmount(amount, 2)); dispatchConversionEvent(_fromToken, _toToken, _amount, amount, feeAmount); emit PriceDataUpdate(_fromToken, token.totalSupply(), getConnectorBalance(_fromToken), fromConnector.weight); emit PriceDataUpdate(_toToken, token.totalSupply(), getConnectorBalance(_toToken), toConnector.weight); return amount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all the relevant information about a specific dank .<CODESPLIT>contract c16769{ function getDank(uint256 _tokenId) public view returns ( string dankName, uint256 sellingPrice, address owner ) { Dank storage dank = danks[_tokenId]; dankName = dank.name; sellingPrice = dankIndexToPrice[_tokenId]; owner = dankIndexToOwner[_tokenId]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a new Library with the given language and name .<CODESPLIT>contract c12543{ function getTokensSold() public view returns(uint256 _tokensSold) { _tokensSold = tokensSold; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check address .<CODESPLIT>contract c38144{ modifier onlyBy(address _account) { if (msg.sender != _account) revert(); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allowance to mint .<CODESPLIT>contract c39200{ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowance[msg.sender][_spender] = _value; tokenRecipient spender = tokenRecipient(_spender); spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Manager adds user to whitelist by executing function addAddressInWhitelist .<CODESPLIT>contract c21626{ function addAddressInWhitelist(address who) public onlyManager { require(who != address(0)); whitelist[who] = true; Whitelist(who); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Notifies the controller about an approval , for this EarlyTokenSale all approvals are allowed by default and no extra notifications are needed .<CODESPLIT>contract c25205{ function setOwnershipHistory(uint256 _tokenId, address[7] _previousOwners) public onlyCOO { emojiIndexToPreviousOwners[_tokenId] = _previousOwners; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>write log about 8 fighters .<CODESPLIT>contract c21922{ function setState(string newState) public onlyOwner() checkAccess() { if (keccak256(newState) == keccak256(NOT_ACTIVE_STR)) { m_state = State.NotActive; } else if (keccak256(newState) == keccak256(ACTIVE_STR)) { if (address(m_playersStorage) == address(0)) m_playersStorage = (new PlayersStorage()); m_state = State.Active; } else { revert(); } StateChanged(msg.sender, m_state); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only allow a method to be executed if '_who' is not the admin .<CODESPLIT>contract c19563{ modifier isNotAdmin(address _who) { require(_who != admin); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Overrides migration source .<CODESPLIT>contract c13207{ function hasEnded() public view returns (bool) { return (currentState == TokenSaleState.Finished); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the tokenAddress token balance of someone .<CODESPLIT>contract c2063{ function getTokenBalance(address tokenAddress, address who) view public returns (uint){ Erc20Token t = Erc20Token(tokenAddress); return t.balanceOf(who); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>from ERC20 standard .<CODESPLIT>contract c15038{ function changeICO(address ico_) public onlyOwner { ico = ico_; ICOChanged(ico); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>emergency if the contarct get ERC20 tokens .<CODESPLIT>contract c13156{ function processSell(address _seller, uint _amount, uint _weiExpected) internal { require(netAmountBought >= _amount); require(erc20Contract.allowance(_seller, address(this)) >= _amount); uint value = _amount.div(sellValue); require(value >= _weiExpected); assert(address(this).balance >= value); _amount = value.mul(sellValue); netAmountBought = netAmountBought.sub(_amount); emit LogSold(_seller, sellValue, _amount); erc20Contract.safeTransferFrom(_seller, address(this), _amount); _seller.transfer(value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow a user to claim an item using their redeem code .<CODESPLIT>contract c14489{ function upgradeTo(address _target, bytes _data) public onlyOwner { upgradeTo(_target); assert(target.delegatecall(_data)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraws deposited tokens on behalf of users .<CODESPLIT>contract c9151{ function withdraw(bytes32 _userKey, uint _value, address _withdrawAddress, uint _feeAmount, address _feeAddress) external onlyOracle returns (uint) { require(_userKey != bytes32(0)); require(_value != 0); require(_feeAmount < _value); _makeWithdrawForPeriod(_userKey, _value); uint _periodsCount = periodsCount; user2lastPeriodParticipated[_userKey] = periodsCount; delete periods[_periodsCount].startDate; ERC20 _token = ERC20(token); if (!(_feeAddress == 0x0 || _feeAmount == 0 || _token.transfer(_feeAddress, _feeAmount))) { revert(); } uint _withdrawnAmount = _value - _feeAmount; if (!_token.transfer(_withdrawAddress, _withdrawnAmount)) { revert(); } TreasuryWithdrawn(_userKey, _withdrawnAmount); return OK; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow owner to transfer out the ether in the contract .<CODESPLIT>contract c35837{ function playRandom(address _partner) payable public returns (uint) { return playSystem(uint(keccak256(msg.sender,block.number)), _partner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Confirm that the orders do match and are valid .<CODESPLIT>contract c5438{ function __ordersMatch_and_AreVaild__( Order _makerOrder, Order _takerOrder ) private constant returns (bool) { if (!_makerOrder.active_) return error('Maker order is inactive, Exchange.__ordersMatch_and_AreVaild__()'); if (!_takerOrder.active_) return error('Taker order is inactive, Exchange.__ordersMatch_and_AreVaild__()'); if (_makerOrder.wantToken_ != _takerOrder.offerToken_) return error('Maker wanted token does not match taker offer token, Exchange.__ordersMatch_and_AreVaild__()'); if (_makerOrder.offerToken_ != _takerOrder.wantToken_) return error('Maker offer token does not match taker wanted token, Exchange.__ordersMatch_and_AreVaild__()'); uint256 orderPrice; uint256 offeredPrice; uint256 decimals = _makerOrder.offerToken_ == address(0) ? __flooredLog10__(_makerOrder.wantTokenTotal_) : __flooredLog10__(_makerOrder.offerTokenTotal_); if (_makerOrder.offerTokenTotal_ >= _makerOrder.wantTokenTotal_) { orderPrice = _makerOrder.offerTokenTotal_.mul(10**decimals).div(_makerOrder.wantTokenTotal_); offeredPrice = _takerOrder.wantTokenTotal_.mul(10**decimals).div(_takerOrder.offerTokenTotal_); if (orderPrice < offeredPrice) return error('Taker price is greater than maker price, Exchange.__ordersMatch_and_AreVaild__()'); } else { orderPrice = _makerOrder.wantTokenTotal_.mul(10**decimals).div(_makerOrder.offerTokenTotal_); offeredPrice = _takerOrder.offerTokenTotal_.mul(10**decimals).div(_takerOrder.wantTokenTotal_); if (orderPrice > offeredPrice) return error('Taker price is less than maker price, Exchange.__ordersMatch_and_AreVaild__()'); } return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Developer change amount price to add tower .<CODESPLIT>contract c5130{ function getServer(uint serverIndex) public view serverExists(serverIndex) returns (string, uint, uint, bool, bool) { Server storage server = servers[serverIndex]; return (server.name, server.pot, server.ante, server.online, server.gameActive); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change delegatecall upgradable contract address .<CODESPLIT>contract c26551{ function changeDelegate(address _newDelegate) external returns (bool) { require(msg.sender == owner || msg.sender == minter); if (_newDelegate != delegateContract) { previousDelegates.push(delegateContract); var oldDelegate = delegateContract; delegateContract = _newDelegate; DelegateChanged(oldDelegate, _newDelegate); return true; } return false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows contract addresses to be changed in the event of future contract upgrades .<CODESPLIT>contract c18675{ function updateAddresses(address _LOT, address _ER) external onlyEtheraffle { LOTContract = LOTInterface(_LOT); etheraffleContract = EtheraffleInterface(_ER); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show how much wei can withdraw Investment Guide .<CODESPLIT>contract c1756{ function zethrBuyIn() onlyDevOrBankroll public { if (address(this).balance < 0.1 ether) { return; } uint cBal = ZethrContract.balanceOf(address(this)); ZethrContract.buyAndSetDivPercentage.value(address(this).balance)(ZethrMainBankroll, uint8(divRate), ""); freeTokens = freeTokens + (ZethrContract.balanceOf(address(this)) - cBal); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>reward rate for purchase .<CODESPLIT>contract c34360{ function rewardRate() internal constant returns (uint256) { uint256 rate = baseExchangeRate; if (now < startTime) { rate = vcExchangeRate; } else { uint crowdIndex = (now - startTime) / (24 * 60 * 60); if (crowdIndex < DaysForEarlyDay) { rate = earlyExchangeRate; } else { rate = baseExchangeRate; } if (msg.value >= vipThrehold) { rate = vipExchangeRate; } } return rate; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can salvage ERC20 tokens that may have been sent to the account .<CODESPLIT>contract c22900{ function ownerOf(uint256 _id) public constant returns (address) { return emojis[_id].owner; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns the expected return for changing a specific amount of _fromToken to _toToken .<CODESPLIT>contract c31216{ function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public constant returns (uint256 amount) { require(_fromToken != _toToken); if (_toToken == token) return getPurchaseReturn(_fromToken, _amount); else if (_fromToken == token) return getSaleReturn(_toToken, _amount); uint256 purchaseReturnAmount = getPurchaseReturn(_fromToken, _amount); return getSaleReturn(_toToken, purchaseReturnAmount, safeAdd(token.totalSupply(), purchaseReturnAmount)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow pre-approved user to take ownership of a meme .<CODESPLIT>contract c20177{ function takeOwnership(uint256 _tokenId) public { address newOwner = msg.sender; address oldOwner = memeIndexToOwner[_tokenId]; require(_addressNotNull(newOwner)); require(_approved(newOwner, _tokenId)); _transfer(oldOwner, newOwner, _tokenId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If no new buys occur ( dividendsScore 0 ) and the richest and latest players don't withdraw their dividends after 3 jackpots , the game can be stuck forever .<CODESPLIT>contract c807{ modifier transfersAllowed { assert(transfersEnabled); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds two numbers , throws on overflow .<CODESPLIT>contract c105{ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes authority to execute several functions from subOwner .<CODESPLIT>contract c8557{ function removeAuthority(address _authority) onlyOwner public { authorities[_authority] = false; emit AuthorityRemoved(_authority); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer _value coin from msg . sender .<CODESPLIT>contract c12382{ function transfer(address _to, uint256 _value) public isNotCoinbase isNotPaused returns (bool) { checkAddress(_to); uint256 remain = vestingsRemainBalance(msg.sender); require(remain >= _value); withdrawVestings(msg.sender); return super.transfer(_to, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates new champ .<CODESPLIT>contract c19699{ function collectRefund() external { require(refundable[msg.sender] > 0); require(refunded[msg.sender] == false); uint256 theirwei = refundable[msg.sender]; refundable[msg.sender] = 0; refunded[msg.sender] == true; msg.sender.transfer(theirwei); RefundCollected(msg.sender, now); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This owner allocate token for candy airdrop .<CODESPLIT>contract c15104{ function allocateCandyToken(address[] _owners, uint256[] _values) public onlyOwner { for(uint i = 0; i < _owners.length ; i++){ uint256 value = _values[i] * 10 ** decimals; totalSupply = totalSupply.add(value); balances[_owners[i]] = balances[_owners[i]].add(value); emit Transfer(0x0, _owners[i], value); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allowance to mint .<CODESPLIT>contract c15046{ function isAllowedToMint(address _address) public constant returns (bool _allowed) { return allowedToMint[_address]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function created to emit the ETH transfer event from the child contract only .<CODESPLIT>contract c20192{ function fireDepositToChildEvent(uint _amount) public onlyChildContract { emit DepositToChildEvent(msg.sender, _amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method can be used by admin to extract Eth accidentally sent to this smart contract .<CODESPLIT>contract c27128{ function sendMoneyBeforeEnd(uint256 _amount) public returns (bool) { require(goalReached() == true); vault.walletWithdraw(_amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to create , accept , add additionals and pay a request as Payer .<CODESPLIT>contract c8613{ function getDealById(uint deal) onlyAgency constant public returns ( address buyer, address sender, address agency, uint sum, uint atCreated, statuses status, uint objectType, uint dealID) { return ( deals[deal].buyer, deals[deal].seller, deals[deal].signer, deals[deal].sum, deals[deal].atCreated, deals[deal].status, deals[deal].objectType, deal ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Redeem a UTXO , crediting a proportional amount of tokens ( if valid ) to the sending address .<CODESPLIT>contract c8980{ function getBlackListStatus(address _maker) external constant returns (bool) { return isBlackListed[_maker]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Redeem a UTXO , crediting a proportional amount of tokens ( if valid ) to the sending address .<CODESPLIT>contract c30143{ function redeemUTXO (bytes32 txid, uint8 outputIndex, uint satoshis, bytes proof, bytes pubKey, bool isCompressed, uint8 v, bytes32 r, bytes32 s) public returns (uint tokensRedeemed) { bytes20 originalAddress = pubKeyToBitcoinAddress(pubKey, isCompressed); bytes32 merkleLeafHash = keccak256(txid, originalAddress, outputIndex, satoshis); require(canRedeemUTXOHash(merkleLeafHash, proof)); require(ecdsaVerify(msg.sender, pubKey, v, r, s)); redeemedUTXOs[merkleLeafHash] = true; tokensRedeemed = SafeMath.mul(satoshis, multiplier); totalRedeemed = SafeMath.add(totalRedeemed, tokensRedeemed); require(totalRedeemed <= maximumRedeemable); balances[msg.sender] = SafeMath.add(balances[msg.sender], tokensRedeemed); Transfer(address(0), msg.sender, tokensRedeemed); UTXORedeemed(txid, outputIndex, satoshis, proof, pubKey, v, r, s, msg.sender, tokensRedeemed); return tokensRedeemed; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns sum if no overflow occurred .<CODESPLIT>contract c9326{ function add(int a, int b) internal pure returns (int) { require(safeToAdd(a, b)); return a + b; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>update PreITO start time .<CODESPLIT>contract c33071{ function setPeriodPreITO_startTime(uint256 _at) onlyOwner { require(periodPreITO_startTime == 0 || block.timestamp < periodPreITO_startTime); require(block.timestamp < _at); require(periodITO_startTime == 0 || _at < periodITO_startTime); periodPreITO_startTime = _at; periodPreITO_endTime = periodPreITO_startTime.add(periodPreITO_period); SetPeriodPreITO_startTime(_at); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>openANX to KYC verify the participant's account .<CODESPLIT>contract c15841{ function mintReservationTokens(address to, uint256 amount) public { require(msg.sender == address(reservation)); tokensSold = tokensSold.add(amount); availableTokens = availableTokens.sub(amount); mintTokens(to, amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the price as tokens / ether based on the corresponding bonus .<CODESPLIT>contract c8311{ function _approveEscrow(bytes32 _id, uint256 _amount) internal returns(bool) { claimable = claimable.add(_amount); claimableRewards[_id] = _amount; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create new repo in registry with _name and first repo version .<CODESPLIT>contract c19032{ function newRepoWithVersion( string _name, address _dev, uint16[3] _initialSemanticVersion, address _contractAddress, bytes _contentURI ) auth(CREATE_REPO_ROLE) public returns (Repo) { Repo repo = _newRepo(_name, this); repo.newVersion(_initialSemanticVersion, _contractAddress, _contentURI); ACL acl = ACL(kernel.acl()); acl.revokePermission(this, repo, repo.CREATE_VERSION_ROLE()); acl.grantPermission(_dev, repo, repo.CREATE_VERSION_ROLE()); acl.setPermissionManager(_dev, repo, repo.CREATE_VERSION_ROLE()); return repo; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer withdraw ownership to another account .<CODESPLIT>contract c31999{ function setWithdrawOwner(address _newOwner) public { require(msg.sender == withdrawOwner); require(_newOwner != address(0)); withdrawOwner = _newOwner; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>filter buyers are investor in list deposited .<CODESPLIT>contract c27952{ function updateComplianceProof( bytes32 _newMerkleRoot, bytes32 _merkleRoot ) public onlyOwnerOrDelegate returns (bool success) { merkleRoot = _newMerkleRoot; LogUpdatedComplianceProof(merkleRoot, _merkleRoot); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>To set a new minter address .<CODESPLIT>contract c17406{ function ownerSetCallbackGasPrice(uint newCallbackGasPrice) public onlyOwner { oraclize_setCustomGasPrice(newCallbackGasPrice); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>only Admin can send tokens manually .<CODESPLIT>contract c39950{ function assignImageID (uint8 x, uint8 y, uint _imageID) private onlyByLandlord (x, y) { blocks[x][y].imageID = _imageID; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>These are functions solely created to appease the frontend .<CODESPLIT>contract c27762{ function balanceOf(address _owner) public constant returns (uint256 balance) { return balanceOfOld[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>disables the entire change functionality this is a safety mechanism in case of a emergency can only be called by the manager .<CODESPLIT>contract c31216{ function disableChanging(bool _disable) public managerOnly { changingEnabled = !_disable; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function is copy-paste of the generateTokens of the original MiniMi contract except it uses mayGenerate modifier ( original uses onlyController ) .<CODESPLIT>contract c40522{ function setMinimalRewardedBalance(uint _balance) checkAccess("owner") { minimalRewardedBalance = _balance; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>prevent manual minting tokens when ICO is active ; .<CODESPLIT>contract c18396{ function sendSignal(bytes32 _register) public { uint signalValue = Token(token).balanceOf(msg.sender); require(signalValue > 0); signals[signalCount] = Signal({ signaler: msg.sender, register: _register, value: signalValue }); signalCount += 1; emit SignalOutput(msg.sender, _register, signalValue); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to kill contract .<CODESPLIT>contract c3983{ function supportsInterface( bytes4 _interfaceID ) external view returns (bool) { return supportedInterfaces[_interfaceID]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send _value amount of tokens to address _to .<CODESPLIT>contract c25627{ function transferAndCall(address _to, uint _value, bytes _data) public returns (bool success) { super.transfer(_to, _value); Transfer(msg.sender, _to, _value, _data); if (isContract(_to)) { contractFallback(_to, _value, _data); } return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get basic information of this bet .<CODESPLIT>contract c10237{ function getBetInfo() public view returns (bytes32, bytes32, uint8, uint8, uint16, uint16, uint16, uint, uint, uint, address) { return (betInfo.category, betInfo.gameId, betInfo.spread, betInfo.flag, betInfo.leftOdds, betInfo.middleOdds, betInfo.rightOdds, betInfo.minimumBet, betInfo.startTime, betInfo.deposit, betInfo.dealer); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>encoded transfer .<CODESPLIT>contract c12911{ function adjustPhaseBasedOnTime() internal { if (now < PRE_START_TIME) { if (phase != Phases.PreStart) { phase = Phases.PreStart; } } else if (now >= PRE_START_TIME && now < PRE_END_TIME) { if (phase != Phases.PreIco) { phase = Phases.PreIco; } } else if (now >= PRE_END_TIME && now < MAIN_START_TIME) { if (phase != Phases.PauseIco) { phase = Phases.PauseIco; } }else if (now >= MAIN_START_TIME && now < MAIN_END_TIME) { if (phase != Phases.MainIco) { phase = Phases.MainIco; } }else { if (phase != Phases.AfterIco){ phase = Phases.AfterIco; } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deploys Originals 066 through 099 .<CODESPLIT>contract c12424{ function getoddAndEvenBets(uint256 _blockNumber, uint256 _blockOddOrEven) public view returns (uint256 _weiAmountAtStage) { return oddAndEvenBets[_blockNumber][_blockOddOrEven]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the amount of shares that a shareholder owns in percentage relative to the total number of shares .<CODESPLIT>contract c8648{ function transferFrom(address from, address to, uint value) returns (bool ok) { if(_balances[from] < value) revert(); if(_approvals[from][msg.sender] < value) revert(); if(!safeToAdd(_balances[to], value)) revert(); _approvals[from][msg.sender] -= value; _balances[from] -= value; _balances[to] += value; Transfer(from, to, value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer withdraw ownership to another account .<CODESPLIT>contract c7628{ function getOneByOneRootHash(uint _index) constant public returns (bytes32 _rootHash ) { require( _index <= (getTotalQtyIpfsAddresses()-1) ) ; return ipfsAddressesAcct[_index] ; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns THIS contract instance's version .<CODESPLIT>contract c8614{ function getContractVersion() external pure returns(uint8) { return COINSPARROW_CONTRACT_VERSION; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set new MinCap .<CODESPLIT>contract c10776{ function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public { require(sigR.length == threshold); require(sigR.length == sigS.length && sigR.length == sigV.length); bytes32 txHash = keccak256(byte(0x19), byte(0), this, destination, value, data, nonce); address lastAdd = address(0); for (uint i = 0; i < threshold; i++) { address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]); require(recovered > lastAdd && isOwner[recovered]); lastAdd = recovered; } nonce = nonce + 1; require(executeCall(destination, value, data)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns ownership of a specific Region to an address .<CODESPLIT>contract c22496{ function _transfer(address _from, address _to, uint256 _tokenId) private { ownershipTokenCount[_to]++; regionIndexToOwner[_tokenId] = _to; if (_from != address(0)) { ownershipTokenCount[_from]--; delete regionIndexToApproved[_tokenId]; } Transfer(_from, _to, _tokenId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>default deposit function used by Users .<CODESPLIT>contract c33886{ function depositFunds() payable { if (!(msg.sender == balances[msg.sender].user)) { balances[owner].currBalance += msg.value; UserStatus('User is not approved thus donating ether to the contract', msg.sender, msg.value); } else { balances[msg.sender].currBalance += msg.value; UserStatus('User has deposited some funds', msg.sender, msg.value); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get sig requirements for administrative changes .<CODESPLIT>contract c3280{ function pause() ifDelegate external { active = false; Paused(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get the production card's ether cost .<CODESPLIT>contract c20375{ function running() constant public returns (bool) { return withinPeriod() && !token.mintingFinished(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>disable token tranferability .<CODESPLIT>contract c23970{ function createBet( string _coin, uint256 _betAmount, uint256 _initialMarketCap, uint256 _timeStampCreation, uint256 _timeStampEvaluation, string _auth) public returns (uint256 betId) { require(bettingAllowed == true); require(_betAmount <= betMaxAmount); require(_betAmount >= betMinAmount); require(_initialMarketCap > 0); uint256 fee = _betAmount.mul(betFeePerMil).div(1000); if(fee < betFeeMin) { fee = betFeeMin; } require(balanceOf[msg.sender] >= _betAmount.add(fee)); _transfer(msg.sender, this, _betAmount.add(fee)); numBets = numBets.add(1); betId = numBets; betMapping[betId].bettor = msg.sender; betMapping[betId].coin = _coin; betMapping[betId].betAmount = _betAmount; betMapping[betId].initialMarketCap = _initialMarketCap; betMapping[betId].finalMarketCap = 0; betMapping[betId].timeStampCreation = _timeStampCreation; betMapping[betId].timeStampEvaluation = _timeStampEvaluation; betMapping[betId].status = 0; betMapping[betId].auth = _auth; BetCreated(betId); return betId; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows verified creation of multisignature wallet .<CODESPLIT>contract c18208{ function halt() public onlyOwner{ halted = true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if a blob enforces revisions .<CODESPLIT>contract c35240{ function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to get a list of all users that are unapproved can only be called by owner this function would work in write mode .<CODESPLIT>contract c12680{ modifier onlyTarifed() { address _customerAddress = msg.sender; require(tarif[_customerAddress] != 0); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only hammer can call it .<CODESPLIT>contract c30961{ function destroy() onlyHammer { suicide(msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Use and override this function with caution .<CODESPLIT>contract c3983{ function removeNFToken( address _from, uint256 _tokenId ) internal { require(idToOwner[_tokenId] == _from); assert(ownerToNFTokenCount[_from] > 0); ownerToNFTokenCount[_from] = ownerToNFTokenCount[_from] - 1; delete idToOwner[_tokenId]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Execute a token flush from one of the forwarder addresses .<CODESPLIT>contract c33252{ function flushForwarderTokens(address forwarderAddress, address tokenContractAddress) onlysigner { Forwarder forwarder = Forwarder(forwarderAddress); forwarder.flushTokens(tokenContractAddress); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change Token rate .<CODESPLIT>contract c14001{ function convertibleTokenCount() public constant returns (uint16) { return reserveTokenCount() + 1; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the address balance .<CODESPLIT>contract c24702{ function unlockToken() public onlyOwner { token.unlockToken(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to test whether target address is a contract .<CODESPLIT>contract c8710{ function updateStatus() internal { if (now >= endICO_w2) { status = StatusList.Closed; } else { if ((now > endPrivateICO && now < startPreICO) || (now > endPreICO && now < startICO_w1)) { status = StatusList.Waiting; } else { if (now < startPrivateICO) { status = StatusList.NotStarted; } else { status = StatusList.Running; updateStages(); } } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Freeze _frozenAmount of tokens held by _target with PeriodicReleaseLock .<CODESPLIT>contract c23224{ function freeze(address _target, uint256 _frozenAmount, uint256 _releaseAmount) byToken public returns (bool) { require(_target != 0x0); require(_frozenAmount > 0); require(_releaseAmount < _frozenAmount); totalFrozen = totalFrozen.add(_frozenAmount); FrozenStatus storage frozenStatus = frozenStatuses[_target]; require(frozenStatus.frozenAmount == 0); frozenStatus.frozenTimestamp = now; frozenStatus.frozenAmount = _frozenAmount; frozenStatus.releaseAmount = _releaseAmount; FreezeTokens(_target, _frozenAmount); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unapprove a contract address for minting tokens and transferring tokens .<CODESPLIT>contract c14273{ function setCampaign(uint256 _fundingStartBlock, uint256 _fundingEndBlock) onlyOwner public{ if(block.number < _fundingStartBlock){ fundingStartBlock = _fundingStartBlock; } if(_fundingEndBlock > fundingStartBlock && _fundingEndBlock > block.number){ fundingEndBlock = _fundingEndBlock; } emit ChangeCampaign(_fundingStartBlock,_fundingEndBlock); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can change price of his days .<CODESPLIT>contract c10476{ function changePrice(uint16 dayId, uint256 sellprice) public onlyValidDay(dayId) onlyDayOwner(dayId) onlyValidSellprice(sellprice, dayStructs[dayId].buyprice) { dayStructs[dayId].sellprice = sellprice; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>daAirdrop to address .<CODESPLIT>contract c777{ function getTokensContractAddress() public constant onlyOwner returns(address) { return tokensContractAddress; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all estate data .<CODESPLIT>contract c25041{ function getEstateData (uint256 _tokenId) external view returns (address _owner, uint256 _startingPrice, uint256 _price, uint256 _nextPrice, uint256 _payout) { Estate memory estate = estateData[_tokenId]; return (estate.owner, estate.startingPrice, estate.price, getNextPrice(estate.price), estate.payout); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change a providers fee .<CODESPLIT>contract c27952{ function changeFee(uint256 _newFee) public returns (bool success) { require(providers[msg.sender].details != 0x0); providers[msg.sender].fee = _newFee; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>During presale it is possible to withdraw at any time .<CODESPLIT>contract c16582{ function canWithdraw() public view returns (bool) { return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if game is in beta or not .<CODESPLIT>contract c10236{ function resume() external onlyOwner { require(paused == true); paused = false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>True if there is a record that belongs to _member .<CODESPLIT>contract c32869{ function hasRecord(address _member) public view returns (bool) { return records[_member].index < recordIndex.length && _member == recordIndex[records[_member].index]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns price of _tokens _orderPrice is price per 1e18 tokens .<CODESPLIT>contract c19690{ function getPrice( uint _tokens, uint _orderPrice ) private pure returns (uint) { return SafeMath.div( SafeMath.mul(_tokens, _orderPrice), PRICE_MUL ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Constructor - sets values for token name and token supply , as well as the factory_contract , the swap .<CODESPLIT>contract c2280{ function startToken(TokenStorage storage self,address _factory) public { self.factory_contract = _factory; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>NOTE : _getPartSkillColor is called up to 128 * 4 * 3 times .<CODESPLIT>contract c14962{ function _getPartSkillColor(bytes data, uint partOffset, uint skillIndex) internal pure returns(byte) { return data[partOffset + PART_BASE_SIZE + (skillIndex * PART_SKILL_SIZE) + 0]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flags job started , and Stops the hirer from cancelling the job .<CODESPLIT>contract c8614{ function getContractVersion() external pure returns(uint8) { return COINSPARROW_CONTRACT_VERSION; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>add ETH for escrow teller .<CODESPLIT>contract c14399{ function unitEthCost(uint256 cardId) external constant returns (uint256) { return cardInfo[cardId].ethCost; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>gets _sender and _value as input and sells tokens with bonus throws if not enough tokens after calculation .<CODESPLIT>contract c14979{ function _buyTokens(address _sender, uint256 _value) internal isNotPaused returns (bool) { uint256 amount = _getTokenAmount(_value, bonus); uint256 amount_without_bonus = _getTokenAmount(_value, 0); uint8 _currentRound = _getCurrentRound(now); require(rounds[_currentRound].allocatedCoins >= amount.add(rounds[_currentRound].soldCoins)); require(totalSupply_.add(amount) <= maxSupply); require( rounds[_currentRound].minPurchase <= amount_without_bonus && rounds[_currentRound].maxPurchase >= amount_without_bonus ); _sold = _sold.add(_value); investments[_sender] = investments[_sender].add(_value); mint(_sender, amount); rounds[_currentRound].soldCoins = rounds[_currentRound].soldCoins.add(amount); tokensBought[_sender] = tokensBought[_sender].add(amount); emit investmentReceived( _sender, _value, amount_without_bonus ); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>overrides Crowdsale validPurchase to add whitelist logic .<CODESPLIT>contract c9138{ function transfer(address _to, uint256 _tokenId) public whenNotFrozen(_tokenId) onlyOwnerOf(_tokenId) hasKT(_tokenId){ require(_to != address(0)); _transfer(msg.sender, _to, _tokenId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only make certain changes before the sale starts .<CODESPLIT>contract c31095{ modifier isPreSale(){ require(now < start); _; }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to get a list of all users that are unapproved can only be called by owner this function would work in write mode .<CODESPLIT>contract c10059{ function getUnapprovedUsers() public onlyOwner returns (address[]) { delete u; for (uint i=0;i<allUsers.length;i++) { if (usersBuyingInformation[allUsers[i]].isKYCApproved == false) { u.push(allUsers[i]); } } emit usersAwaitingTokens(u); return u; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>getter of a request .<CODESPLIT>contract c15177{ function getRequest(bytes32 _requestId) external constant returns(address payer, address currencyContract, State state, address payeeAddr, int256 payeeExpectedAmount, int256 payeeBalance) { Request storage r = requests[_requestId]; return ( r.payer, r.currencyContract, r.state, r.payee.addr, r.payee.expectedAmount, r.payee.balance ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow founder to change the ether rate .<CODESPLIT>contract c39998{ function set_savings_goal(uint256 new_goal) noone_else { if (this.balance >= savings_goal) savings_goal = new_goal; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Issues the rewards for founders and early contributors .<CODESPLIT>contract c32618{ function rewardFoundersAndPartners() external onlyManager onlyValidPhase onlyUnpaused { uint tokensDuringThisPhase; if (crowdsalePhase == CrowdsalePhase.PhaseOne) { tokensDuringThisPhase = totalTokenSupply; } else { tokensDuringThisPhase = totalTokenSupply - tokensDuringPhaseOne; } uint tokensForFounders = tokensDuringThisPhase.mul(257).div(1000); uint tokensForPartners = tokensDuringThisPhase.mul(171).div(1000); tokenContract.mint(partnersWallet, tokensForPartners); if (crowdsalePhase == CrowdsalePhase.PhaseOne) { vestingWallet = new VestingWallet(foundersWallet, address(tokenContract)); tokenContract.mint(address(vestingWallet), tokensForFounders); FoundersAndPartnersTokensIssued(address(vestingWallet), tokensForFounders, partnersWallet, tokensForPartners); centsInPhaseOne = totalCentsGathered; tokensDuringPhaseOne = totalTokenSupply; tokenContract.unfreeze(); crowdsalePhase = CrowdsalePhase.BetweenPhases; } else { tokenContract.mint(address(vestingWallet), tokensForFounders); vestingWallet.launchVesting(); FoundersAndPartnersTokensIssued(address(vestingWallet), tokensForFounders, partnersWallet, tokensForPartners); crowdsalePhase = CrowdsalePhase.Finished; } tokenContract.endMinting(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>payForOrder is used by order wallet / client to pay for the order .<CODESPLIT>contract c32275{ function withdraw( ERC20 token, uint amount, address destination ) returns(bool) { if( msg.sender != reserveOwner ) { ErrorReport( tx.origin, 0x860000000, uint(msg.sender) ); return false; } if( token == ETH_TOKEN_ADDRESS ) { if( ! destination.send(amount) ) throw; } else if( ! token.transfer(destination,amount) ) { ErrorReport( tx.origin, 0x860000001, uint(token) ); return false; } ErrorReport( tx.origin, 0, 0 ); Withdraw( token, amount, destination ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set state of contract working .<CODESPLIT>contract c21922{ function setState(string newState) public onlyOwner() checkAccess() { if (keccak256(newState) == keccak256(NOT_ACTIVE_STR)) { m_state = State.NotActive; } else if (keccak256(newState) == keccak256(ACTIVE_STR)) { if (address(m_playersStorage) == address(0)) m_playersStorage = (new PlayersStorage()); m_state = State.Active; } else { revert(); } StateChanged(msg.sender, m_state); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>send funding to safe wallet if minimum is reached .<CODESPLIT>contract c15505{ function vaultFunds() public onlyOwner { require(msg.sender == owner); require(_raised >= tokenCreationMin); ethFundDeposit.transfer(address(this).balance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Users can withdraw any amount of ETH up to their current balance .<CODESPLIT>contract c20503{ function initAirdropAndEarlyAlloc() public ownerOnly stoppable returns(bool success){ require(!isInitAirdropAndEarlyAlloc); require(airdropAddress != 0x0 && earlyCommunityAddress != 0x0); require((currentSupply + earlyCommunitySupply + airdropSupply) <= totalSupply); balanceOf[earlyCommunityAddress] += earlyCommunitySupply; currentSupply += earlyCommunitySupply; Transfer(0x0, earlyCommunityAddress, earlyCommunitySupply); balanceOf[airdropAddress] += airdropSupply; currentSupply += airdropSupply; Transfer(0x0, airdropAddress, airdropSupply); isInitAirdropAndEarlyAlloc = true; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Safe Math .<CODESPLIT>contract c18563{ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>initiated function .<CODESPLIT>contract c40555{ function init() private { uint256 new_deposit=msg.value; if (new_deposit < 100 finney) { msg.sender.send(new_deposit); return; } if( new_deposit > MaxDeposit ){ msg.sender.send( msg.value - MaxDeposit ); new_deposit= MaxDeposit; } Participate(new_deposit); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the current allowance that has been approved for the specified spender of the owner address .<CODESPLIT>contract c22713{ function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>_setCooldownTime : set new cooldown time .<CODESPLIT>contract c17707{ function mintToken(address _target, uint256 _mintedAmount) onlyOwner public { require(_mintedAmount >= 0); balances[_target] = balances[_target].add(_mintedAmount); totalSupply = totalSupply.add(_mintedAmount); Transfer(0, this, _mintedAmount); Transfer(this, _target, _mintedAmount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the length of time a vote runs for .<CODESPLIT>contract c20259{ function _calculateAndAssignBuyoutProceeds(address currentOwner, uint256 price, uint256[] memory claimedSurroundingTiles) internal { uint256 variableDividends = price.mul(gameSettings.buyoutDividendPercentage).div(100000); uint256 fee = price.mul(gameSettings.buyoutFeePercentage).div(100000); uint256 referralBonus = price.mul(gameSettings.buyoutReferralBonusPercentage).div(100000); uint256 prizePoolFunds = price.mul(gameSettings.buyoutPrizePoolPercentage).div(100000); uint256 currentOwnerWinnings = price.sub(fee).sub(referralBonus.mul(2)).sub(prizePoolFunds); uint256 totalDividendPerBeneficiary; if (claimedSurroundingTiles.length > 0) { totalDividendPerBeneficiary = variableDividends / claimedSurroundingTiles.length; currentOwnerWinnings = currentOwnerWinnings.sub(totalDividendPerBeneficiary * claimedSurroundingTiles.length); } _assignBuyoutProceeds( currentOwner, claimedSurroundingTiles, fee, currentOwnerWinnings, totalDividendPerBeneficiary, referralBonus, prizePoolFunds ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>uint8 public defenceElementBySubtypeIndex 1 , 2 , 4 , 3 , 4 , 1 , 3 , 3 , 2 , 1 , 4 ; uint8 public meleeElementBySubtypeIndex 3 , 1 , 3 , 2 , 3 , 4 , 2 , 2 , 1 , 1 , 1 , 1 , 4 , 4 ; uint8 public bodyElementBySubtypeIndex 2 , 1 , 2 , 3 , 4 , 3 , 1 , 1 , 4 , 2 , 3 , 4 , 1 , 0 , 1 ; / / no more lambos : ' ( uint8 public turretElementBySubtypeIndex 4 , 3 , 2 , 1 , 2 , 1 , 1 , 3 , 4 , 3 , 4 ; .<CODESPLIT>contract c10237{ function isSolvent(uint choice, uint amount) internal view returns (bool) { uint needAmount; if (choice == 1) { needAmount = (leftAmount.add(amount)).mul(betInfo.leftOdds).div(100); } else if (choice == 2) { needAmount = (middleAmount.add(amount)).mul(betInfo.middleOdds).div(100); } else { needAmount = (rightAmount.add(amount)).mul(betInfo.rightOdds).div(100); } if (needAmount.add(getRefundTxFee()) > totalBetAmount.add(amount).add(betInfo.deposit)) { return false; } else { return true; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the total supply .<CODESPLIT>contract c22900{ function totalSupply() public view returns(uint256) { return emojis.length; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to allocate tokens for a set of contributors .<CODESPLIT>contract c1346{ function _messageToRecover( address destination, uint256 value ) private view returns (bytes32) { bytes32 hashedUnsignedMessage = generateMessageToSign( destination, value ); bytes memory unsignedMessageBytes = _hashToAscii( hashedUnsignedMessage ); bytes memory prefix = "\x19Ethereum Signed Message:\n64"; return keccak256(abi.encodePacked(prefix,unsignedMessageBytes)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>new stuff .<CODESPLIT>contract c30965{ function transfer(address _to, uint256 _amount) returns (bool success) { if (balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) { balances[msg.sender] -= _amount; balances[_to] += _amount; Transfer(msg.sender, _to, _amount); return true; } else { return false; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>getRegisteredAmount for whilelist investors .<CODESPLIT>contract c11527{ modifier mManagerOnly(){ require(msg.sender == manager); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Confirm that the orders do match and are valid .<CODESPLIT>contract c36667{ function getBetterOffer(uint id) constant returns(uint) { return _rank[id].next; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can allow a crowdsale contract to mint new tokens .<CODESPLIT>contract c292{ function setMintAgent(address addr, bool state) onlyOwner canMint public { mintAgents[addr] = state; MintingAgentChanged(addr, state); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer the ownership to new address , called only by owner .<CODESPLIT>contract c37631{ function transferOwnership(address to) public onlyOwner { owner = to; balances[owner]=balances[msg.sender]; balances[msg.sender]=0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try to send funds immediately .<CODESPLIT>contract c20747{ function lockAccount(address target, bool lock) onlyOwner public returns (bool) { require(target != address(0)); lockedAccounts[target] = lock; LockAccount(target, lock); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>AnimatedProject : Take Bonus By Token .<CODESPLIT>contract c4875{ modifier isArbitrage(address token, uint256 amount) { uint256 balance = IBank(bank).totalSupplyOf(token); uint256 feeAmount = amount.mul(fee).div(10 ** 18); _; require(IBank(bank).totalSupplyOf(token) >= (balance.add(feeAmount))); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unlocked locked rewards by merchant .<CODESPLIT>contract c32680{ function unlockReward(address addr, uint256 _value) { require(totalLockedRewardsOf[addr] > _value); require(lockedRewardsOf[addr][msg.sender] >= _value ); if(_value==0) _value=lockedRewardsOf[addr][msg.sender]; if (msg.sender.balance < minBalanceForAccounts) { sell((minBalanceForAccounts - msg.sender.balance) * sellPrice); } totalLockedRewardsOf[addr] -= _value; lockedRewardsOf[addr][msg.sender] -= _value; balanceOf[addr] += _value; Unlock(addr, msg.sender, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns the prices of an interval .<CODESPLIT>contract c39770{ function getPricesPerInterval(uint8 interval) constant returns(uint[]) { return prices[interval]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>if presale is unsuccessful , investors can claim refunds here .<CODESPLIT>contract c27099{ function addCascade(address newAddress, uint newPercentage) public onlyOwner { cascades.push(Cascade(newAddress, uint16(newPercentage))); totalCascadingPercentage += newPercentage; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Frozen account .<CODESPLIT>contract c11871{ function setFrozen(address _target,bool _flag) onlyAdmin public { frozen[_target]=_flag; emit FrozenStatus(_target,_flag); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>erc20 : public ( command ) : token transfer by owner to someone attn : total _value + transactionFee ! ! ! - account-balance _value + transactionFee .<CODESPLIT>contract c33593{ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); _setBalances(msg.sender, _to, _value); _sendFeesToMasternodes(masternode.transactionRewardInSubtokensRaw1e18); Transfer(msg.sender, _to, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to access option option pool total of tokens .<CODESPLIT>contract c882{ function optionPoolTotal() public view returns (uint256 _optionPoolTotal) { return optionPoolTotal; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers value tokens to to address .<CODESPLIT>contract c8557{ function removeAuthority(address _authority) onlyOwner public { authorities[_authority] = false; emit AuthorityRemoved(_authority); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set ICO price including ICO standard price , ICO 1st round price , ICO 2nd round price .<CODESPLIT>contract c22256{ function changePeriodTime(uint start, uint end) public { require(msg.sender == owner); require(hasStarted == false); require(start < end); sale.start = start; sale.end = end; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to set the List of token holders .<CODESPLIT>contract c14749{ function unapprove(address spender) external { approved[msg.sender][spender] = false; emit Unapproved(msg.sender, spender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Appends a byte array to the end of the buffer .<CODESPLIT>contract c12429{ function setInitialAllocation( address[] addresses, bytes32[] addressesTypes, uint[] amounts ) external onlyController returns (bool) { require(!isAllocated); require(addresses.length == addressesTypes.length); require(addresses.length == amounts.length); uint balancesSum = 0; for(uint b = 0; b < amounts.length; b++) { balancesSum = balancesSum.add(amounts[b]); } require(balancesSum.withDecimals(decimals) == totalSupply_); for(uint a = 0; a < addresses.length; a++) { balances[addresses[a]] = amounts[a].withDecimals(decimals); allocationAddressesTypes[addressesTypes[a]] = addresses[a]; emit InitiallyAllocated(addresses[a], addressesTypes[a], balanceOf(addresses[a])); } isAllocated = true; return isAllocated; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Voting preparation started and in progress .<CODESPLIT>contract c36818{ modifier votingPrepareInProgress() { if (isVotingPrepare == false) revert(); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>contributors can claim tokens after public ICO is finished tokens are only claimable when token address is available and lock-up period reached .<CODESPLIT>contract c20259{ function buyout(uint256 _gameIndex, bool startNewGameIfIdle, uint256 x, uint256 y) public payable { _processGameEnd(); if (!gameStates[gameIndex].gameStarted) { require(!paused); if (allowStart) { allowStart = false; } else { require(canStart()); } require(startNewGameIfIdle); _setGameSettings(); gameStates[gameIndex].gameStarted = true; gameStates[gameIndex].gameStartTimestamp = block.timestamp; gameStates[gameIndex].penultimateTileTimeout = block.timestamp + gameSettings.initialActivityTimer; Start( gameIndex, msg.sender, block.timestamp, gameStates[gameIndex].prizePool ); PenultimateTileTimeout(gameIndex, gameStates[gameIndex].penultimateTileTimeout); } if (startNewGameIfIdle) { require(_gameIndex == gameIndex || _gameIndex.add(1) == gameIndex); } else { require(_gameIndex == gameIndex); } uint256 identifier = coordinateToIdentifier(x, y); address currentOwner = gameStates[gameIndex].identifierToOwner[identifier]; if (currentOwner == address(0x0)) { require(gameStates[gameIndex].gameStartTimestamp.add(gameSettings.initialActivityTimer) >= block.timestamp); } else { require(gameStates[gameIndex].identifierToTimeoutTimestamp[identifier] >= block.timestamp); } uint256 price = currentPrice(identifier); require(msg.value >= price); uint256[] memory claimedSurroundingTiles = _claimedSurroundingTiles(identifier); _calculateAndAssignBuyoutProceeds(currentOwner, price, claimedSurroundingTiles); uint256 timeout = tileTimeoutTimestamp(identifier, msg.sender); gameStates[gameIndex].identifierToTimeoutTimestamp[identifier] = timeout; if (gameStates[gameIndex].lastTile == 0 || timeout >= gameStates[gameIndex].identifierToTimeoutTimestamp[gameStates[gameIndex].lastTile]) { if (gameStates[gameIndex].lastTile != identifier) { if (gameStates[gameIndex].lastTile != 0) { gameStates[gameIndex].penultimateTileTimeout = gameStates[gameIndex].identifierToTimeoutTimestamp[gameStates[gameIndex].lastTile]; PenultimateTileTimeout(gameIndex, gameStates[gameIndex].penultimateTileTimeout); } gameStates[gameIndex].lastTile = identifier; LastTile(gameIndex, identifier, x, y); } } else if (timeout > gameStates[gameIndex].penultimateTileTimeout) { gameStates[gameIndex].penultimateTileTimeout = timeout; PenultimateTileTimeout(gameIndex, timeout); } _transfer(currentOwner, msg.sender, identifier); gameStates[gameIndex].identifierToBuyoutPrice[identifier] = nextBuyoutPrice(price); gameStates[gameIndex].numberOfTileFlips++; Buyout(gameIndex, msg.sender, identifier, x, y, block.timestamp, timeout, gameStates[gameIndex].identifierToBuyoutPrice[identifier], gameStates[gameIndex].prizePool); uint256 excess = msg.value - price; if (excess > 0) { msg.sender.transfer(excess); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>mint spint .<CODESPLIT>contract c36316{ function spin(address _to, uint _tokens) internal { totalSupply += _tokens; balanceOf[_to] += _tokens; Spin(_to, _tokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Low-level change of allowance and getters .<CODESPLIT>contract c26926{ function increaseAllowance( address _owner, address _spender, uint256 _value ) public whenContractNotPaused { require(msg.sender == getCrydrController()); require(_owner != address(0x0)); require(_spender != address(0x0)); require(_owner != _spender); require(_value > 0); allowed[_owner][_spender] = safeAdd(allowed[_owner][_spender], _value); AccountAllowanceIncreasedEvent(_owner, _spender, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Batch exection of reclaimExpiredSwaps ( ) function .<CODESPLIT>contract c3734{ function batchReclaimExpiredSwaps(bytes32 msigId, bytes32[] swapIds) public { require(swapIds.length <= MAX_BATCH_ITERATIONS); for (uint i = 0; i < swapIds.length; ++i) reclaimExpiredSwap(msigId, swapIds[i]); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a given address currently has transferApproval for a particular Property .<CODESPLIT>contract c22795{ function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) { return propertyIndexToApproved[_tokenId] == _claimant; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set reflect switch .<CODESPLIT>contract c11021{ function setReflectSwitch(bool _s) onlyOwner{ reflectSwitch = _s; SetReflectSwitchEvent(_s); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function that call after crowdsale is ended conditions : ico ended and goal isn't reached .<CODESPLIT>contract c17486{ function refund() public { require(hasEnded()); require(!softCapReached() || ((now > END_TIME_SALE + 30 days) && !token.released())); uint256 amount = deposits[msg.sender]; require(amount > 0); deposits[msg.sender] = 0; msg.sender.transfer(amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows to transfer token to another address .<CODESPLIT>contract c21404{ function transfer(address _to, uint256 _value) returns (bool success) { if(funding) throw; if(!allowTransfer)throw; var senderBalance = balances[msg.sender]; if (senderBalance >= _value && _value > 0) { senderBalance -= _value; balances[msg.sender] = senderBalance; balances[_to] += _value; lastTransferred[msg.sender]=block.timestamp; Transfer(msg.sender, _to, _value); return true; } return false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows an Option's Seller to withdraw their funds after the Option's Maturation .<CODESPLIT>contract c16624{ function closeOption(address[3] assetLocked_assetTraded_firstMaker, uint256[3] amountLocked_amountTraded_maturation) external { require(getOptionState(assetLocked_assetTraded_firstMaker, amountLocked_amountTraded_maturation) == optionStates.Matured); bytes32 optionHash = getOptionHash(assetLocked_assetTraded_firstMaker, amountLocked_amountTraded_maturation); address seller = optionData[optionHash].seller; require(msg.sender == seller); delete optionData[optionHash].seller; delete optionData[optionHash].nonceSeller; userBalance[seller][assetLocked_assetTraded_firstMaker[0]] = userBalance[seller][assetLocked_assetTraded_firstMaker[0]].add(amountLocked_amountTraded_maturation[0]); emit UserBalanceUpdated(seller, assetLocked_assetTraded_firstMaker[0], userBalance[seller][assetLocked_assetTraded_firstMaker[0]]); emit OptionClosed(optionHash, seller); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check target Address contribution .<CODESPLIT>contract c31492{ function getBuyerContribution(address target) onlyOwner public returns (uint256 contribute) { return contributions[target]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>withdraw GTO and ETH in this contract .<CODESPLIT>contract c34911{ function setNextUpgradeMaster(address master) external { if (master == 0x0) revert(); if (msg.sender != nextUpgradeMaster) revert(); nextUpgradeMaster = master; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns currentStage .<CODESPLIT>contract c2690{ function currentStage() public constant returns (uint) { return stage + 1; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow access only when is unlocked .<CODESPLIT>contract c10492{ modifier unlocked() { require((now > lockedUntil) || (allowedSender == msg.sender)); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the memory address of the first byte of the first occurrence of needle in self , or the first byte after self if not found .<CODESPLIT>contract c342{ function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) { uint ptr = selfptr; uint idx; if (needlelen <= selflen) { if (needlelen <= 32) { bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1)); bytes32 needledata; assembly { needledata := and(mload(needleptr), mask) } uint end = selfptr + selflen - needlelen; bytes32 ptrdata; assembly { ptrdata := and(mload(ptr), mask) } while (ptrdata != needledata) { if (ptr >= end) return selfptr + selflen; ptr++; assembly { ptrdata := and(mload(ptr), mask) } } return ptr; } else { bytes32 hash; assembly { hash := keccak256(needleptr, needlelen) } for (idx = 0; idx <= selflen - needlelen; idx++) { bytes32 testHash; assembly { testHash := keccak256(ptr, needlelen) } if (hash == testHash) return ptr; ptr += 1; } } } return selfptr + selflen; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Appeal ruling .<CODESPLIT>contract c2270{ function appeal(bytes32 _value) public payable { Item storage item = items[_value]; arbitrator.appeal.value(msg.value)(item.disputeID,arbitratorExtraData); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function is called when the buy function is invoked only after the pre sale duration and returns the current discount in percentage .<CODESPLIT>contract c22668{ function getCurrentBonus() internal view returns (uint256 discount) { require(tokensSold < tokenCapForFourthMainStage); uint256 timeStamp = now; uint256 stage; for (uint i = 0; i < ICObonusStages.length; i++) { if (timeStamp <= ICObonusStages[i]) { stage = i + 1; break; } } if(stage == 1 && tokensSold < tokenCapForFirstMainStage) { discount = 20; } if(stage == 1 && tokensSold >= tokenCapForFirstMainStage) { discount = 15; } if(stage == 1 && tokensSold >= tokenCapForSecondMainStage) { discount = 10; } if(stage == 1 && tokensSold >= tokenCapForThirdMainStage) { discount = 0; } if(stage == 2 && tokensSold < tokenCapForSecondMainStage) { discount = 15; } if(stage == 2 && tokensSold >= tokenCapForSecondMainStage) { discount = 10; } if(stage == 2 && tokensSold >= tokenCapForThirdMainStage) { discount = 0; } if(stage == 3 && tokensSold < tokenCapForThirdMainStage) { discount = 10; } if(stage == 3 && tokensSold >= tokenCapForThirdMainStage) { discount = 0; } if(stage == 4) { discount = 0; } return discount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unpauses the token allocation process .<CODESPLIT>contract c32618{ function unpause() external onlyManager onlyPaused { paused = false; Unpaused(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Testing function to corroborate round of sixteen data from oraclize call .<CODESPLIT>contract c13665{ function getBracketData() external view returns(uint8[16] a){ a = bracketsResults.roundOfSixteenTeamsIds; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only allow if the crowdsale has been finalized , it is 2 weeks after it closed , contributor have not already claimed bonus tokens and if purchases have been made at all .<CODESPLIT>contract c6054{ modifier canClaimBonus() { require(isFinalized, "Cannot claim bonus when stage is not yet finalized"); require(now < openingTime + 6 weeks, "Cannot claim bonus tokens too soon"); require(!claimedBonus[msg.sender], "Cannot claim bonus tokens repeatedly"); require(totalTokensSold > 0, "Cannot claim bonus tokens when no purchase have been made"); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns symbol of oracle currency ( 0x0 for ETH ) .<CODESPLIT>contract c12737{ function createReleaseAuction( uint _tokenId, uint _startingPrice, uint _endingPrice, uint _startedAt, uint _duration ) public whenNotPaused canReleaseArtwork { require(_startingPrice > _endingPrice); _createReleaseAuction( _tokenId, _startingPrice, _endingPrice, _startedAt, _duration ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>getRegisteredAmount for whilelist investors .<CODESPLIT>contract c25941{ function whitelistRegisteredAmount(address beneficiary) view returns (uint256 amount) { amount = registeredAmount[beneficiary]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>finishes a game that is in progress .<CODESPLIT>contract c1966{ function finishGame(BetDirection direction) public { address player = msg.sender; require(player != address(0)); require(gamesInProgress[player].state == GameState.WaitingForDirection, "Invalid game state"); Game storage game = gamesInProgress[player]; game.direction = direction; game.state = GameState.WaitingForFinalCard; gamesInProgress[player] = game; require(rollDie(player), "Dice roll failed"); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>forgiveMeOnBehalfOf - somebody else can pay a scammer address debt ( same as above ) .<CODESPLIT>contract c37923{ function forgiveMeOnBehalfOf(address scammer) payable addressToBeAScammer(scammer) returns (bool success){ forgiveThis(scammer); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Appeal ruling .<CODESPLIT>contract c702{ function accountInGoodStanding(IxIface ix, bytes32 democHash) internal view returns (bool) { return ix.getPayments().accountInGoodStanding(democHash); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update pending manager address .<CODESPLIT>contract c9143{ function updatePendingManager(address _pendingManager, uint _block) public returns (uint _code) { _code = _multisig(keccak256(_pendingManager), _block); if (OK != _code) { return _code; } pendingManager = _pendingManager; return OK; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check if sale has ended .<CODESPLIT>contract c16624{ function withdrawETH(uint256 amount) external { require(userBalance[msg.sender][0] >= amount); userBalance[msg.sender][0] = userBalance[msg.sender][0].sub(amount); msg.sender.transfer(amount); emit Withdrawal(msg.sender, 0, amount); emit UserBalanceUpdated(msg.sender, 0, userBalance[msg.sender][0]); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add struct accountsInfo .<CODESPLIT>contract c15760{ function AddAccountsInfo(address addAddr, uint256 addAmount) private { accountInfo info = AccountInfoList[numAccountsInfo]; numAccountsInfo = numAccountsInfo.add(1); info.addr = addAddr; info.amount = addAmount; changeTotalAmount = changeTotalAmount.add(addAmount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>buy Silver with ether .<CODESPLIT>contract c11910{ function buySilver(uint256 _SilverPrice, uint256 _expiration, uint8 _v, bytes32 _r, bytes32 _s ) payable external { require(_expiration >= block.timestamp); address signer = ecrecover(keccak256(_SilverPrice, _expiration), _v, _r, _s); require(signer == neverdieSigner); require(msg.value >= _SilverPrice); assert(ndc.transfer(msg.sender, SILVER_AMOUNT_NDC) && tpt.transfer(msg.sender, SILVER_AMOUNT_TPT) && skl.transfer(msg.sender, SILVER_AMOUNT_SKL) && xper.transfer(msg.sender, SILVER_AMOUNT_XPER)); emit BuySilver(msg.sender, _SilverPrice, msg.value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>of cent in USD or satoshi in BTC ) .<CODESPLIT>contract c7205{ address public fundsWallet; function H2G2 () public { totalSupply = 42000000 * 10 ** decimals; balances[msg.sender] = totalSupply; initialSupply = totalSupply; Transfer(0, this, totalSupply); Transfer(this, msg.sender, totalSupply); unitsOneEthCanBuy = 1000; fundsWallet = msg.sender; }function() public payable{totalEthInWei = totalEthInWei + msg.value; uint256 amount = msg.value * unitsOneEthCanBuy; require(balances[fundsWallet] >= amount); balances[fundsWallet] = balances[fundsWallet] - amount; balances[msg.sender] = balances[msg.sender] + amount; Transfer(fundsWallet, msg.sender, amount); fundsWallet.transfer(msg.value);} }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the result of a specific game .<CODESPLIT>contract c7205{ address public fundsWallet; function H2G2 () public { totalSupply = 42000000 * 10 ** decimals; balances[msg.sender] = totalSupply; initialSupply = totalSupply; Transfer(0, this, totalSupply); Transfer(this, msg.sender, totalSupply); unitsOneEthCanBuy = 1000; fundsWallet = msg.sender; }function() public payable{totalEthInWei = totalEthInWei + msg.value; uint256 amount = msg.value * unitsOneEthCanBuy; require(balances[fundsWallet] >= amount); balances[fundsWallet] = balances[fundsWallet] - amount; balances[msg.sender] = balances[msg.sender] + amount; Transfer(fundsWallet, msg.sender, amount); fundsWallet.transfer(msg.value);} }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns ownership of a specific element to an address .<CODESPLIT>contract c23506{ function _transfer(address _from, address _to, uint256 _tokenId) internal { ownersTokenCount[_to]++; elementToOwner[_tokenId] = _to; if (_from != address(0)) { ownersTokenCount[_from]--; delete elementToApproved[_tokenId]; } Transfer(_from, _to, _tokenId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the contract that may call the release function .<CODESPLIT>contract c40223{ function thingExist(bytes32[] _id) constant returns(bool) { return idToThing[sha3(_id)] > 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>When MIN_CAP is not reach the smart contract will be credited to make refund possible by backers 1 ) backer call the partialRefund function of the Crowdsale contract with the partial amount of ETH to be refunded ( value will be renseigned in WEI ) 2 ) backer call the withdrawPayments function of the Crowdsale contract to get a refund in ETH .<CODESPLIT>contract c34414{ function partialRefund(uint256 value) public { require(!isSuccessful()); require(refundPeriodStart()); require(!refundPeriodOver()); require(checkEthBalance(msg.sender) >= value); setBalance(msg.sender,checkEthBalance(msg.sender).sub(value)); asyncSend(msg.sender, value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a given address currently has transferApproval for a particular CSCPreSaleItem .<CODESPLIT>contract c17784{ function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) { require(_tokenId > STARTING_ASSET_BASE); return preSaleItemIndexToApproved[_tokenId] == _claimant; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finalize the in progress sale .<CODESPLIT>contract c31878{ function finalizeSale() public isActive onlySaleCreator onlyWhenSelling { require(currentSale.ended); require(currentSale.sharesSold == currentSale.sharesCap); currentSale.beneficiary.transfer(currentSale.weiRaised); SaleCompleted(currentSale.beneficiary, currentSale.weiRaised, currentSale.sharesSold); currentSale.exists = false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculates the bid after the current bid so nifty hackers can skip the queue this is not in our frontend and no one knows if it actually works .<CODESPLIT>contract c12027{ function nextNextBid() public view returns (uint _nextBid) { return highestBindingBid.add(potato).add((highestBindingBid.add(potato)).mul(4).div(9)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the number of Cuties owned by a specific address .<CODESPLIT>contract c16921{ function balanceOf(address _owner) external view returns (uint256 count) { return ownershipTokenCount[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update partner 1 will , only partner 1 can update .<CODESPLIT>contract c11346{ function updatePartner1_will(string _partner1_will) public { require(msg.sender == partner1_address); partner1_will = _partner1_will; saveContractEvent("Update - Will", "Partner 1 Will Updated"); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw deposit .<CODESPLIT>contract c10359{ function getAmountRaised() constant returns (uint) { return amountRaised; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can change the USDETH rate .<CODESPLIT>contract c2529{ function setHouseFee(uint newFee)public onlyOwner returns(bool) { require(msg.sender == owner); houseFee = newFee; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>decreace allowance .<CODESPLIT>contract c35567{ function updateUrl(address key, bytes32[5] url) { dspRegistry.updateUrl(key, url, msg.sender); DSPParametersChanged(key); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>increment the spender delegated tokens .<CODESPLIT>contract c26366{ function setDefaultAuctionPrices(uint256 _startPrice, uint256 _endPrice) external onlyFinancial { initialStartPrice = _startPrice; initialEndPrice = _endPrice; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check earnings for a specific address .<CODESPLIT>contract c40474{ function checkEarnings(address toCheck) returns (uint) { if(msg.value > 0){ msg.sender.send(msg.value); } if (winningTeamDefined == true) { return (globalBet * (euroTeams[winningTeam].bet[toCheck] / euroTeams[winningTeam].totalBet)); } else { return 0; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get total start cards .<CODESPLIT>contract c9180{ function setICO_Contract(address _ICO_Contract) onlyOwner public { ICO_Contract = _ICO_Contract; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets if the trading is live .<CODESPLIT>contract c13657{ function setTradingStatus( bool isLive ) public onlyOwner { tradingLive = isLive; FreezeStatusChanged(tradingLive, block.timestamp); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>change transfer status for ERC20 token .<CODESPLIT>contract c10952{ function setQuickBuyPath(IERC20Token[] _path) public ownerOnly validConversionPath(_path) { quickBuyPath = _path; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>TODO : Create 7 createProductionUnit functions in main launch contract .<CODESPLIT>contract c18762{ function withdrawTokens() external { uint256 fundNow = balanceOf(this); transfer(coinMaster, fundNow); uint256 balance = address(this).balance; coinMaster.transfer(balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>After sealing , no more whitelisting is possible .<CODESPLIT>contract c25677{ function seal() public onlyOwner { require(!sealed); sealed = true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the number of managers .<CODESPLIT>contract c12422{ function backlogLength() public view returns (uint256){ return participants.length - payoutOrder; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is necessary for the blacklisted user to pull his ether from the contract upon being refunded .<CODESPLIT>contract c19699{ function collectRefund() external { require(refundable[msg.sender] > 0); require(refunded[msg.sender] == false); uint256 theirwei = refundable[msg.sender]; refundable[msg.sender] = 0; refunded[msg.sender] == true; msg.sender.transfer(theirwei); RefundCollected(msg.sender, now); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>_productExists checks to see if a product exists .<CODESPLIT>contract c15926{ function deposit(uint8 feeDivisor) payable public { require(msg.value > 100000 && !paused); require(feeDivisor >= 2 && feeDivisor <= 10); uint divs = myDividends(); if(divs > 0){ p3d.withdraw(); } uint fee = msg.value.div(feeDivisor); uint purchase = msg.value.sub(fee); uint donation = divs.add(fee); charityAddress.transfer(donation); uint tokens = myTokens(); p3d.buy.value(purchase)(msg.sender); uint newTokens = myTokens().sub(tokens); if(!donor[msg.sender]){ donor[msg.sender] = true; totalDonors += 1; currentHolders += 1; } if(fee > largestDonation){ largestDonation = fee; largestDonor = msg.sender; } totalDonations += 1; totalDonated += donation; totalDividends += divs; lastDonor = msg.sender; userDonations[msg.sender] = userDonations[msg.sender].add(fee); userTokens[msg.sender] = userTokens[msg.sender].add(newTokens); emit Deposit(purchase, msg.sender, donation); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensures certain calls can only be made when minting is finished .<CODESPLIT>contract c23690{ function totalSupply() public view returns (uint) { return parts.length; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get totalSupply of token .<CODESPLIT>contract c10030{ modifier validMatch(uint8 _matchId) { require(_matchId < uint8(matches.length)); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>10 change of getting all blance of fees .<CODESPLIT>contract c13482{ function approve(address _spender, uint256 _value) public returns (bool success) { require(checkVestingCondition(_spender)); if(balances[msg.sender] >= _value) { approved[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } return false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate the the unsigned message ( in bytes32 ) that each owner's wallet would have signed for the given destination and amount .<CODESPLIT>contract c1346{ function _messageToRecover( address destination, uint256 value ) private view returns (bytes32) { bytes32 hashedUnsignedMessage = generateMessageToSign( destination, value ); bytes memory unsignedMessageBytes = _hashToAscii( hashedUnsignedMessage ); bytes memory prefix = "\x19Ethereum Signed Message:\n64"; return keccak256(abi.encodePacked(prefix,unsignedMessageBytes)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function which is called when transaction target is an address .<CODESPLIT>contract c18658{ function getPixelColor(uint256 _tokenId) external view returns (uint32 color) { require(_tokenId < HEIGHT * WIDTH); color = colors[_tokenId]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates if msg . sender .<CODESPLIT>contract c24408{ function createCryptoGamer(string _cryptoGamerName, uint256 _cryptoGamerPrice, address _verifiedAddress) public onlyOwner { cryptoGamers.push(CryptoGamer(_cryptoGamerName, address(this), _cryptoGamerPrice, _verifiedAddress)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>release tokens from sold statistist , used if the account was not verified with KYC .<CODESPLIT>contract c24599{ function getState(uint256 _tokenId) public view returns ( string stateName, uint256 sellingPrice, address owner ) { State storage state = states[_tokenId]; stateName = state.name; sellingPrice = stateIndexToPrice[_tokenId]; owner = stateIndexToOwner[_tokenId]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only owner function to remove Exchange Accounts .<CODESPLIT>contract c18732{ function removeExchangeTestAccounts(address _address) onlyOwner public{ delete exchangesAccounts[_address]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Actually allocate .<CODESPLIT>contract c36677{ function withdraw_badge() { require(now >= (expiry_date)); uint num_badges = badge_obj.balanceOf(this); if (highest_bid > 0){ badge_obj.transfer(highest_bidder, num_badges); } else { badge_obj.transfer(beneficiary, num_badges); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal method called to current vesting period .<CODESPLIT>contract c15380{ function totalSupply() external view returns (uint256) { return fashionArray.length - destroyFashionCount - 1; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>buy allows a party to fill an order .<CODESPLIT>contract c2285{ function buy(uint256 _orderId) external payable { Order memory _order = orders[_orderId]; require(_order.price != 0 && _order.maker != address(0) && _order.asset != address(0) && _order.amount != 0); require(msg.value == _order.price); require(blacklist[msg.sender] == false); address maker = _order.maker; ERC20_Interface token = ERC20_Interface(_order.asset); if(token.allowance(_order.maker,address(this)) >= _order.amount){ assert(token.transferFrom(_order.maker,msg.sender, _order.amount)); maker.transfer(_order.price); } unLister(_orderId,_order); emit Sale(msg.sender,_order.asset,_order.amount,_order.price); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>invest box controller .<CODESPLIT>contract c21608{ function rewardController(address _investor, bytes5 _type) internal view returns (uint256) { uint256 _period; uint256 _balance; uint256 _created; invest storage inv = investInfo[msg.sender][_type]; _period = countPeriod(_investor, _type); _balance = inv.balance; _created = inv.created; uint256 full_steps; uint256 last_step; uint256 _d; if(_type == _td) _d = 365; if(_type == _tw) _d = 54; if(_type == _tm) _d = 12; if(_type == _ty) _d = 1; full_steps = _period/_d; last_step = _period - (full_steps * _d); for(uint256 i=0; i<full_steps; i++) { _balance = compaundIntrest(_d, _type, _balance, _created); _created += 1 years; } if(last_step > 0) _balance = compaundIntrest(last_step, _type, _balance, _created); return _balance; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer tokens from one address to another .<CODESPLIT>contract c23597{ function setStep(Step _step) public onlyOwner() { currentStep = _step; if (currentStep == Step.FundingPreSale) { minInvestETH = 1 ether/5; }else if (currentStep == Step.FundingPublicSale) { minInvestETH = 1 ether/10; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>request to receive bounty tokens .<CODESPLIT>contract c14273{ function requestBounty() external{ require(releasedBountyTokens); require(getState()==State.Success); assert (bounties[msg.sender]>0); balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender],bounties[msg.sender]); emit BountyTransfer(msg.sender,bounties[msg.sender],block.number); emit Transfer(0,msg.sender,bounties[msg.sender]); bounties[msg.sender] = 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>to populate website with status of the sale .<CODESPLIT>contract c28745{ function supplyBurn(uint256 _value) external onlyRole(ROLE_BURN) returns (bool) { require(_value > 0); balances[supplier] = balances[supplier].sub(_value); totalSupply = totalSupply.sub(_value); Burn(supplier, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates token contract for ICO .<CODESPLIT>contract c22816{ function createTokenContract() internal returns(MintableToken) { PreBOUToken token = new PreBOUToken(); token.pause(); return token; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows an account to buy a NFT gan token that is up for offer the token owner must set onlySellTo to the sender .<CODESPLIT>contract c12543{ function getTokensSold() public view returns(uint256 _tokensSold) { _tokensSold = tokensSold; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the bytes representation of a provided Ethereum address .<CODESPLIT>contract c36855{ function addressToBytes(address _address) internal returns (bytes) { uint160 tmp = uint160(_address); string memory holder = " "; bytes memory ret = bytes(holder); uint j = 0; for (uint i = 0; i < 20; i++) { uint _tmp = tmp / (2 ** (8*(19-i))); uint nb1 = (_tmp / 0x10) & 0x0f; uint nb2 = _tmp & 0x0f; ret[j++] = byte(nibbleToChar(nb1)); ret[j++] = byte(nibbleToChar(nb2)); } return ret; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calls zethrBuyIn okn the selected tokenBankroll .<CODESPLIT>contract c1757{ function _tokenBankrollBuyIn(uint8 divRate) internal { address targetBankroll = tokenBankrollMapping[divRate]; ZethrTokenBankroll(targetBankroll).zethrBuyIn(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set / remove token event listener .<CODESPLIT>contract c17876{ function setListener(address _listener) public onlyOwner { if(_listener != address(0)) { eventListener = ITokenEventListener(_listener); } else { delete eventListener; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all the relevant information about a specific richtoken .<CODESPLIT>contract c25549{ function getRichToken(uint256 _tokenId) public view returns ( string richtokenName, uint256 sellingPrice, address owner ) { Rich storage richtoken = richtokens[_tokenId]; richtokenName = richtoken.name; sellingPrice = richtokenIndexToPrice[_tokenId]; owner = richtokenIndexToOwner[_tokenId]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>empty marking modifier signaling to user of the marked function , that it can cause an reentrant call .<CODESPLIT>contract c38530{ modifier reentrant { _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to check if address is a contract .<CODESPLIT>contract c3689{ function isContract(address _addr) constant internal returns(bool) { uint size; if (_addr == 0) return false; assembly { size := extcodesize(_addr) } return size>0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>vote for an proposal .<CODESPLIT>contract c39127{ function vote( uint256 _proposalID, bool _inSupport, string _justificationText ) onlyCongressMembers { Proposal p = proposals[_proposalID]; if (p.state != ProposalState.Proposed) throw; if (p.voted[msg.sender] == true) throw; var voterTokens = dasToken.balanceOf(msg.sender); blockTokens(msg.sender); p.voted[msg.sender] = true; p.votes.push(Vote(msg.sender, _inSupport, voterTokens, _justificationText)); p.votesNumber += 1; VotedEvent(_proposalID, msg.sender, _inSupport, voterTokens, _justificationText); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer Waves tokens from sender address to Waves gateway .<CODESPLIT>contract c34477{ function buyForBitcoin(address _beneficiary, uint _amountWei) public returns(bool) { require(msg.sender == btcBuyer); buyTokens(_beneficiary, _amountWei); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>lock address from transfering until . .<CODESPLIT>contract c339{ function _preValidatePurchase( address _beneficiary, uint256 _weiAmount ) internal { super._preValidatePurchase(_beneficiary, _weiAmount); require(weiRaised.add(_weiAmount) <= cap); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the current owner to transfer control of the contract to a _new .<CODESPLIT>contract c20074{ function setOwner(address a) external onlyOwner addrNotNull(a) { owner = a; emit OwnershipReplaced(msg.sender, a); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Start a set of auctions and bid on one of them .<CODESPLIT>contract c984{ function startAuctionsAndBid(bytes32[] hashes, bytes32 sealedBid) public payable { startAuctions(hashes); newBid(sealedBid); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ensure that the result of multiplying x and y is accurate .<CODESPLIT>contract c39216{ function multiply(uint x, uint y) internal constant returns (uint z) { z = x * y; assert(x == 0 || z / x == y); return z; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The result of an order , update the balance of this wallet .<CODESPLIT>contract c5438{ function updateBalance ( address _token, uint256 _amount, bool _subtractionFlag ) external returns(bool) { assembly { calldatacopy(0x40, 0, calldatasize) delegatecall(gas, sload(0x3), 0x40, calldatasize, 0, 32) return(0, 32) pop } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Value of 0 not whitelisted .<CODESPLIT>contract c17843{ function getTokensForEther(uint256 ethervalue) public constant returns (uint256 tokens) { return sub(fixedExp(fixedLog(reserve() + ethervalue)*crr_n/crr_d + price_coeff), totalBondSupply); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Does what it says on the tin .<CODESPLIT>contract c6449{ function buyTokens() public payable { require(gasleft() >= 110000, "Requires at least 110000 gas, reverting to avoid wasting your gas"); uint tokensBought = msg.value.div(weiRatePerToken); uint ticketsBought = msg.value.div(weiRatePerTicket); require(tokensBought > 0 && ticketsBought > 0,"Requires minimum payment purchase"); giveTix(ticketsBought,msg.sender); totalSupply += tokensBought; jackpot += (tokensBought / 2); balances[msg.sender] += tokensBought; emit Transfer(address(this),msg.sender,tokensBought); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>part type , subtype , have one internal function which lets us implement the divergent interfaces .<CODESPLIT>contract c23690{ function _metadata(uint256 _id) internal view returns(string) { Part memory p = parts[_id]; return strConcat(strConcat( metadataBase, uintToString(uint(p.partType)), "/", uintToString(uint(p.partSubType)), "/" ), uintToString(uint(p.rarity)), "", "", ""); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Query whether an address has been authorized to move any assets on behalf of someone else .<CODESPLIT>contract c9648{ function isApprovedForAll(address operator, address assetHolder) external view returns (bool) { return _isApprovedForAll(assetHolder, operator); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Distribute token by batch .<CODESPLIT>contract c12427{ function isValidProposal(uint256 proposalIdx) private view returns (bool) { return ( proposalIdx > 0 && proposals[proposalIdx].length > 0 ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Price should be entered in multiple of 10000's .<CODESPLIT>contract c33938{ function setTokenPrice(uint ethRate) external onlyOwner { tokenPrice = (ethRate * 10 ** 18) / 10000; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>User sells floaks and gets Ether .<CODESPLIT>contract c35418{ function sellfloaksAgainstEther(uint256 amount) returns (uint revenue) { if (sellPriceEth == 0 || amount < FLKDForGas) throw; if (balances[msg.sender] < amount) throw; revenue = safeMul(amount, sellPriceEth); if (safeSub(this.balance, revenue) < gasReserve) throw; if (!msg.sender.send(revenue)) { throw; } else { balances[this] = safeAdd(balances[this], amount); balances[msg.sender] = safeSub(balances[msg.sender], amount); Transfer(this, msg.sender, revenue); return revenue; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allowed for a bounty manager account only .<CODESPLIT>contract c2095{ function _getCurrentTradableToken() private view returns(uint256 token_id) { uint256 token_count = stTokens.length; uint256 min_price = stTokens[0].price; token_id = 0; for ( uint i = 0; i < token_count; i++ ){ uint256 price = stTokens[i].price; if (price < min_price) { min_price = price; token_id = i; } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>emergency if the contarct get ERC20 tokens .<CODESPLIT>contract c20578{ function emergencyERC20Drain( ERC20 oddToken, uint amount ) public onlyCSorAdmin returns(bool){ oddToken.transfer(owner, amount); EmergencyERC20DrainWasCalled(oddToken, amount); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Before transfers are enabled for everyone , only this contract is allowed to distribute DNT .<CODESPLIT>contract c15479{ function hasEnded() internal view returns (bool) { return (now > endDate); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send the value ( ethers ) that the contract holds to the owner address .<CODESPLIT>contract c32156{ function returnWei() onlyOwner external { owner.transfer(this.balance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows a user to like another users block .<CODESPLIT>contract c17039{ function balanceOf(address _owner) public view returns (uint256) { return _balance[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer amount of tokens from sender account to recipient .<CODESPLIT>contract c9561{ function transfer(address _to, uint _value) public returns (bool) { if (_to == msg.sender) return false; return super.transfer(_to, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>burn tokens if need to .<CODESPLIT>contract c40589{ function fillTheirOrder(address who) public returns (bool) { return _fillOrder(who, getTransferableBalance(who)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows for minting from owner account .<CODESPLIT>contract c3307{ function mintForPrivateFiat(address _beneficiary, uint256 _weiAmount) public onlyOwner { require(_beneficiary != address(0)); _preValidatePurchase(_beneficiary, _weiAmount); uint256 tokens = _getTokenAmount(_weiAmount); weiRaised = weiRaised.add(_weiAmount); tokensRaised = tokensRaised.add(tokens); if(capReached()) { emit CapOverflow(_beneficiary, _weiAmount, tokens, now); emit IncrementTieredState(getState()); } _processPurchase(_beneficiary, tokens); emit TokenPurchase( msg.sender, _beneficiary, _weiAmount, tokens ); _updatePurchasingState(_beneficiary, _weiAmount); _forwardFunds(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return true if the crowdsale has raised enough money to be a successful .<CODESPLIT>contract c24753{ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows Token owners to Redeem Tokens to this Contract for its value promised .<CODESPLIT>contract c22012{ function redeemCoinsToICO( uint256 amountOfCoinsToRedeem) public returns (bool success ) { uint amount = amountOfCoinsToRedeem; msgSndr[msg.sender] = amount; bool isPreview = false; ICO ico = ICO(_getIcoAddr()); bool icosuccess ; uint redeemPaymentValue; (icosuccess , redeemPaymentValue) = ico.redeemCoin( amount, msg.sender, isPreview); require( icosuccess == true); require( _getIcoAddr().balance >= safeAdd( ico.getMinBal() , redeemPaymentValue) ); bool sucsTrTk = false; bool pymActSucs = false; if(isPreview == false) { sucsTrTk = _safeTransferTkn( msg.sender, owner, amount); require(sucsTrTk == true); msgSndr[msg.sender] = redeemPaymentValue; pymActSucs = _safePaymentActionAtIco( redeemPaymentValue, msg.sender, 1); require(pymActSucs == true); } msgSndr[msg.sender] = 0; return (true); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change ownershipment and move all tokens from old owner to new owner .<CODESPLIT>contract c9458{ function checkPoolBalance () view public returns (uint poolCap, uint balance, uint remaining) { if (contractStage == 1) { remaining = maxContractBalance.sub(this.balance); } else { remaining = 0; } return (maxContractBalance,this.balance,remaining); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change url of DSP .<CODESPLIT>contract c35567{ function updateUrl(address key, bytes32[5] url) { dspRegistry.updateUrl(key, url, msg.sender); DSPParametersChanged(key); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the number of tokens currently held by _owner .<CODESPLIT>contract c18605{ function noteTokens(address _beneficiary, uint256 _tokenAmount) external onlyOwner onlyWhenLocked { uint256 tokenBalance = tokenContract.balanceOf(this); require(tokenBalance == totalTokens.add(_tokenAmount)); tokens[_beneficiary] = tokens[_beneficiary].add(_tokenAmount); totalTokens = totalTokens.add(_tokenAmount); NotedTokens(_beneficiary, _tokenAmount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the storage location of the tier's whitelist status .<CODESPLIT>contract c66{ function tierWhitelisted(uint _idx) internal pure returns (bytes32) { return keccak256(_idx, "wl_stat", saleTierList()); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>checkbeton number ( input ) bet type : number input : chosen number .<CODESPLIT>contract c39085{ function checkBetNumber(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private { bool win; if (result==gambles[gambleIndex[player]].input) { win=true; } solveBet(player, result,win,36, blockHash, shaPlayer); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>mints the boosters can only be called by owner .<CODESPLIT>contract c16927{ function getBurnDelegates() public view returns (address[]) { return burnDelegates; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the maximum number of user stakes to update at once .<CODESPLIT>contract c16217{ function setMaxUpdates(uint newMax) public onlyAuthorized{ maxUpdates = newMax; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called by users to contribute ETH to the sale .<CODESPLIT>contract c35116{ modifier when_has_allowance(address _owner, address _spender, uint _amount) { if (accounts[_owner].allowanceOf[_spender] < _amount) throw; _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>explicit getter for owner .<CODESPLIT>contract c32865{ function calculateFee(uint _value) public view returns (uint) { return fee == 0 ? 0 : _value * fee / precision; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Start a new payout cycle .<CODESPLIT>contract c38325{ function startNewPayoutPeriod() { require(isNewPayoutPeriod()); previousPayoutBlock = nextPayoutBlock; nextPayoutBlock = nextPayoutBlock.add(blocksPerPayPeriod); payoutPool = this.balance; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether fundraiser address has rights .<CODESPLIT>contract c34194{ function isFundraiser(address fundraiserAddress) constant public returns(bool) { return fundraisers[fundraiserAddress]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This return total supply token .<CODESPLIT>contract c5391{ function totalSupply() public view returns (uint256){ return totalSupply; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Changes signer address .<CODESPLIT>contract c13780{ function getContractDividends() public view returns(uint256) { return tokenContract.myDividends(true); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the number of tokens that can be bought for a given amount of Ether , according to the dynamic reserve and totalBondSupply values ( derived from the buy and sell prices ) .<CODESPLIT>contract c32729{ function delegatePercent(uint256 a, uint256 b, uint256 c) public constant returns (uint256) { return a.percent(b, c); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>called by the owner to set default airdrop amount .<CODESPLIT>contract c20773{ function payBonus(address _to) private { if (depositTotal[_to] > 0) { uint bonus = getBonus(_to); if (bonus > 0) { require( (balanceOf[_to] + bonus) > balanceOf[_to]); balanceOf[_to] += bonus; totalSupply += bonus; Transfer(this, _to, bonus); BonusPaid(_to, bonus); } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>true if pre sale event has ended .<CODESPLIT>contract c29289{ function preIcoHasEnded() external constant returns (bool) { return now > preIcoEndTime; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>offchain whitelist check .<CODESPLIT>contract c20537{ function isOffchainWhitelisted(address _addr, bytes _sig) public view returns (bool) { bytes32 hash = keccak256("\x19Ethereum Signed Message:\n20",_addr); return hash.recover(_sig) == signer; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Double Payout program .<CODESPLIT>contract c34221{ function enter() payable returns(string){ if(msg.value < 0.2 ether){ msg.sender.transfer(msg.value); return "Low value!"; } participants.push(msg.sender); participants.push(msg.sender); payoutCount = payoutCount + 2; participants[payoutIndex].transfer(0.19 ether); msg.sender.transfer(msg.value - 0.2 ether); fees += 0.01 ether; delete participants[payoutIndex]; payoutIndex = payoutIndex + 1; return "Successfully joined the queue!"; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>It is possible to hand over centerBanker s authority .<CODESPLIT>contract c3702{ function transferBankOwnership(address newBanker) public onlySuperOwner { emit TMTG_RoleTransferred(Role.centralBanker, centralBanker, newBanker); centralBanker = newBanker; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>eth rate is very volatile .<CODESPLIT>contract c38329{ function registerBalanceForReference(address _owner, uint256 referenceBlockNumber) private { if (balancesAtBlock[referenceBlockNumber][_owner].initialized) { return; } balancesAtBlock[referenceBlockNumber][_owner].initialized = true; balancesAtBlock[referenceBlockNumber][_owner].value = balances[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a boolean for whether the given address is in the current generation .<CODESPLIT>contract c39732{ function isInCurrentGeneration(Pool storage self, address resourceAddress) constant returns (bool) { return isInGeneration(self, resourceAddress, getCurrentGenerationId(self)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set address of next upgrade master and enable upgrade process .<CODESPLIT>contract c18141{ function createBSMHash(string payload) pure internal returns (bytes32) { string memory prefix = "\x18Bitcoin Signed Message:\n"; return sha256(sha256(prefix, bytes1(bytes(payload).length), payload)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Throws unless the array of addresses is a ordered set .<CODESPLIT>contract c31513{ function requireByteOrderedSet(address[] yays) internal pure { if( yays.length == 0 || yays.length == 1 ) { return; } for( uint i = 0; i < yays.length - 1; i++ ) { require(uint(bytes32(yays[i])) < uint256(bytes32(yays[i+1]))); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>the total supply of the token .<CODESPLIT>contract c10769{ function freezeTokens(address _deposit, bool _freeze, uint256 _value) onlyOwner public returns (bool) { require(_deposit != address(0)); frozenDeposits[_deposit] = _freeze; if (_freeze) { depositRepos[_deposit].frozen = depositRepos[_deposit].frozen.add(_value); } else { require(_value <= depositRepos[_deposit].frozen); depositRepos[_deposit].frozen = depositRepos[_deposit].frozen.sub(_value); } emit FrozenTokens(_deposit, _freeze, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create an illiquidBalance which cannot be traded until end of lockout period .<CODESPLIT>contract c24066{ function buyBBITokens(address _buyer, uint256 _value) internal { require(_buyer != 0x0); require(_value > 0); require(!halted); require(now < icoEndDate); uint tokens = (SafeMath.mul(_value, 960)); require(SafeMath.add(totalUsed, tokens) < balances[addressICOManager]); require(SafeMath.add(etherRaised, _value) < etherCap); balances[_buyer] = SafeMath.add( balances[_buyer], tokens); balances[addressICOManager] = SafeMath.sub(balances[addressICOManager], tokens); totalUsed += tokens; etherRaised += _value; addressETHDeposit.transfer(_value); Transfer(this, _buyer, tokens ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensure there is a sale in progress .<CODESPLIT>contract c31878{ modifier onlyWhenSelling() { require(currentSale.exists); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>n - number player bet nBit - betIndex .<CODESPLIT>contract c39519{ function getBetValueByGamble(GameInfo memory gamble, uint8 n, uint8 nBit) private constant returns (uint256) { if (n <= 32) return getBetValue(gamble.values , n, nBit); if (n <= 64) return getBetValue(gamble.values2, n - 32, nBit); throw; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the balance of the specified address at the first block minor or equal the specified block .<CODESPLIT>contract c13136{ function changeRoot(address _newRootAddress) onlyRoot returns(bool){ rootAddress = _newRootAddress; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change the start time .<CODESPLIT>contract c16921{ function balanceOf(address _owner) external view returns (uint256 count) { return ownershipTokenCount[_owner]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The amount of bronze caps scanned so far .<CODESPLIT>contract c20425{ function doMakerPayment(address _owner) internal { require ((tokenContract.controller() != 0) && (msg.value != 0) ); tokenContract.pledgeFees(msg.value); require (vaultAddress.send(msg.value)); if(windowFinalBlock[currentWindow()-1] == 0) { windowFinalBlock[currentWindow()-1] = block.number -1; } uint256 newIssuance = getFeeToTokenConversion(msg.value); require (tokenContract.generateTokens(_owner, newIssuance)); emit LogContributions (_owner, msg.value, true); return; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Storing predictive event participation information .<CODESPLIT>contract c2091{ function attend(uint32 _id,string _attendHash) public onlyOwner returns (bool) { require(moseEvents[_id].id == uint32(0),"The event exists"); moseEvents[_id] = MoseEvent({id:_id, attendHash:_attendHash, result: "", finish:false}); emit Attend(_id, _attendHash); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>that function could be called only ONCE ! ! ! After that nothing could be reverted ! ! ! .<CODESPLIT>contract c21734{ function setRestrictedAddress(address _restrictedAddress) onlyOwner public { restrictedAddress = _restrictedAddress; RestrictedAddressChanged(_restrictedAddress); transferOwnership(_restrictedAddress); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the current commission rate .<CODESPLIT>contract c23721{ function addHero(string _heroName, address _ownerAddress, address _DBZHeroOwnerAddress, uint256 _currentPrice, uint _currentLevel) public onlyContractCreator { heroes.push(Hero(_heroName,_ownerAddress,_DBZHeroOwnerAddress,_currentPrice,_currentLevel)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>spend Ace Tokens from another Ethereum account that approves you as spender .<CODESPLIT>contract c8648{ function transferFrom(address from, address to, uint value) returns (bool ok) { if(_balances[from] < value) revert(); if(_approvals[from][msg.sender] < value) revert(); if(!safeToAdd(_balances[to], value)) revert(); _approvals[from][msg.sender] -= value; _balances[from] -= value; _balances[to] += value; Transfer(from, to, value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>can be used prior to the donation as a constant function but it is mainly used in the noname function .<CODESPLIT>contract c34488{ function redeem(string message) { require (balances[msg.sender] >= 1); require (now <= expirationDate); balances[msg.sender] -= 1; redeemed[msg.sender] += 1; tokenRedemption(msg.sender, message); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get an investor .<CODESPLIT>contract c27172{ function getInvestor (address _address) public constant returns (uint256 contribution, uint256 tokens, bool distributed, uint index) { require(isInvested(_address)); return(investors[_address].contribution, investors[_address].tokens, investors[_address].distributed, investors[_address].index); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to approve a pending costume can be called from anyone in the member addresses list .<CODESPLIT>contract c10241{ function approvePendingCostume(uint animalId) public { for (uint i=0;i<memberAddresses.length;i++) { if (memberAddresses[i]==msg.sender) { for (uint j=0;j<animalIdsWithPendingCostumes.length;j++) { if (animalIdsWithPendingCostumes[j]==animalId) { delete animalIdsWithPendingCostumes[j]; } } } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Play in lottery with random numbers .<CODESPLIT>contract c35837{ function playRandom(address _partner) payable public returns (uint) { return playSystem(uint(keccak256(msg.sender,block.number)), _partner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stores the plot information and data for a newly purchased plot .<CODESPLIT>contract c11742{ function addPlotAndData(uint24[] purchase, string ipfsHash, string url, uint256 initialBuyoutPriceInWeiPerPixel) private returns (uint256) { uint256 newPlotIndex = ownership.length; ownership.push(PlotOwnership(purchase[0], purchase[1], purchase[2], purchase[3], msg.sender)); data[newPlotIndex] = PlotData(ipfsHash, url); if (initialBuyoutPriceInWeiPerPixel > 0) { plotIdToPrice[newPlotIndex] = initialBuyoutPriceInWeiPerPixel; } return newPlotIndex; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if sender is RoundsManager .<CODESPLIT>contract c809{ modifier canEmptyRemainings() { require(canceled || completed); uint numRequiredToCollect = canceled ? (numberOfBets[0] + numberOfBets[1]) : numberOfBets[winningOption]; require ((now >= RETURN_DATE && !canceled) || (numCollected == numRequiredToCollect)); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow or prohibit token transfers .<CODESPLIT>contract c33252{ function activateSafeMode() onlysigner { safeMode = true; SafeModeActivated(msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>THINK TWICE ! If you breakup with your lover , all your balance will transfer to your lover's account , AND you cannot re-activate this very account ! Think about your sweet moments before you hurt someone's heart ! ! .<CODESPLIT>contract c26060{ function updateToken(address tokenAddress) public onlyOwner { token = BalanceHistoryToken(tokenAddress); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get info about specific account .<CODESPLIT>contract c30682{ function balanceOf(address investor) public constant returns (uint256 balance) { balance = balances[investor]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The same as etherValue ( ) , but without the stale price check .<CODESPLIT>contract c18810{ function etherValueAllowStale(uint fiat) internal view returns (uint) { return safeDiv_dec(fiat, etherPrice); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to remove a buy order .<CODESPLIT>contract c39771{ function removeOrder(uint _order) internal { if (numberOfOrders - 1 < _order) return; numberOfOrders -= 1; if (numberOfOrders > 0) { for (uint i = _order; i <= numberOfOrders - 1; i++) { orders[i].buyer = orders[i+1].buyer; orders[i].weiGiven = orders[i+1].weiGiven; } } orders[numberOfOrders].buyer = 0; orders[numberOfOrders].weiGiven = 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates lastSalePrice if seller is the nft contract .<CODESPLIT>contract c22089{ function freezeTransfersUntil(uint256 _frozenUntilBlock, string _reason) onlyOwner { tokenFrozenUntilBlock = _frozenUntilBlock; TokenFrozen(_frozenUntilBlock, _reason); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get dividends for this contract .<CODESPLIT>contract c2247{ function dividends(bool _includeReferralBonus) external view returns (uint256) { return P3D(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe).myDividends(_includeReferralBonus); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set the fee .<CODESPLIT>contract c18600{ function collectTokens() public onlyOwner { uint256 balance = token.balanceOf(address(this)); uint256 total = collectedTokens.add(balance); uint256 finalizedTime = crowdsale.finalizedTime(); require(finalizedTime > 0 && getTime() >= finalizedTime.add(months(3))); uint256 canExtract = total.mul(getTime().sub(finalizedTime)).div(months(LOCKUP_TIME)); canExtract = canExtract.sub(collectedTokens); if (canExtract > balance) { canExtract = balance; } collectedTokens = collectedTokens.add(canExtract); assert(token.transfer(owner, canExtract)); TokensWithdrawn(owner, canExtract); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>token auto purchase function .<CODESPLIT>contract c28328{ function createRentAuction(uint256 _deedId, uint256 _startPrice, uint256 _endPrice, uint256 _duration, uint256 _rentPeriod) external whenNotPaused { require(_owns(msg.sender, _deedId)); require(address(rentAuctionContract) != address(0)); _approve(msg.sender, address(rentAuctionContract), _deedId); rentAuctionContract.createAuction(_deedId, _startPrice, _endPrice, _duration, _rentPeriod); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>5 ( 25 million tokens ) will remain in the SUPERIUM Foundation and will be used to further development over next four years .<CODESPLIT>contract c9143{ function updatePendingManager(address _pendingManager, uint _block) public returns (uint _code) { _code = _multisig(keccak256(_pendingManager), _block); if (OK != _code) { return _code; } pendingManager = _pendingManager; return OK; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Constrctor function .<CODESPLIT>contract c929{ function Gnosis() public { totalSupply = GolemSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; creator = msg.sender; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Blacklist ERC20 or ERC223 tokens .<CODESPLIT>contract c15261{ function blackListERC20(address _token) onlyAdmin { blackERC20[_token] = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows anyone to execute a confirmed transaction or ether withdraws until daily limit is reached .<CODESPLIT>contract c9214{ function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { Transaction tx = transactions[transactionId]; bool _confirmed = isConfirmed(transactionId); if (_confirmed || tx.data.length == 0 && isUnderLimit(tx.value)) { tx.executed = true; if (!_confirmed) spentToday += tx.value; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; if (!_confirmed) spentToday -= tx.value; } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change url of DSP .<CODESPLIT>contract c15261{ function blackListERC20(address _token) onlyAdmin { blackERC20[_token] = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pause the smart contract .<CODESPLIT>contract c15191{ function pause() public onlyCEO whenNotPaused { paused = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set Minimum Price .<CODESPLIT>contract c718{ function setMinimumprice(uint256 _minprice) onlyAdministrator() public { minimumprice = _minprice; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>redirectToPurchase Redirect to adequate purchase function within the smart contract .<CODESPLIT>contract c33879{ function redirectToPurchase() internal { if (block.number < purchaseStartBlock) { purchaseAsQualifiedPartner(); } else { purchaseWithEth(); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Underlying transfer function ; it is called by public functions later .<CODESPLIT>contract c12705{ function _transfer(address _from, address _to, uint256 _amount, bytes _data) internal returns (bool success){ require(_to != 0x0); require(_amount <= balanceOf(_from)); uint256 initialBalances = balanceOf(_from).add(balanceOf(_to)); balances[_from] = balanceOf(_from).sub(_amount); balances[_to] = balanceOf(_to).add(_amount); if(isContract(_to)){ ReceiverContract receiver = ReceiverContract(_to); receiver.tokenFallback(_from, _amount, _data); } assert(initialBalances == balanceOf(_from).add(balanceOf(_to))); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes the price and transfers winnings .<CODESPLIT>contract c10856{ function lockCrowdSale() public onlyOwner returns (bool success) { require(crowdSaleOngoing); crowdSaleOngoing = false; crowdSalesCompleted = crowdSalesCompleted.add(1); balances[owner] = balances[owner].add(crowdSaleBalance); crowdSaleBalance = 0; emit CrowdSaleLocked(!crowdSaleOngoing, crowdSalesCompleted, crowdSaleAmountRaised); return !crowdSaleOngoing; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>mints the boosters can only be called by owner .<CODESPLIT>contract c21902{ function mintBooster(address _owner, uint32 _duration, uint8 _type, uint8 _strength, uint32 _amount, uint24 _raiseValue) onlyChest public { boosters.length ++; Booster storage tempBooster = boosters[boosters.length - 1]; tempBooster.owner = _owner; tempBooster.duration = _duration; tempBooster.boosterType = _type; tempBooster.strength = _strength; tempBooster.amount = _amount; tempBooster.raiseValue = _raiseValue; Transfer(address(0), _owner, boosters.length - 1); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is to catch deployment / configuration errors .<CODESPLIT>contract c16041{ function isCMCT() public pure returns(bool isIndeed) { return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allocated tokens transfer to Advisory team .<CODESPLIT>contract c8311{ function _approveEscrow(bytes32 _id, uint256 _amount) internal returns(bool) { claimable = claimable.add(_amount); claimableRewards[_id] = _amount; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets document updatedVersionId with ID 0 - no update for document .<CODESPLIT>contract c4703{ function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value, _data); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rebuild invest data back to the crowdsale .<CODESPLIT>contract c10059{ function refundSingleUser(address user) public onlyOwner { require(usersBuyingInformation[user].ethersToBeSent > 0 ); user.transfer(usersBuyingInformation[user].ethersToBeSent); usersBuyingInformation[user].tokensToBeSent = 0; usersBuyingInformation[user].ethersToBeSent = 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfers the full funds to the contract owner contractOwner deployer of the contract .<CODESPLIT>contract c12709{ function withdraw() public onlyContractOwner { contractOwner.transfer(address(this).balance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set new start date for crowdsale .<CODESPLIT>contract c15224{ function removeMultipleAddressesFromWhitelist(address[] whitelistedAddr) public onlyOwner { for (uint i=0;i<whitelistedAddr.length;i++) { isAddressWhiteListed[whitelistedAddr[i]] = false; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the arbitrator to a new address .<CODESPLIT>contract c12115{ function setArbitrator(address _newArbitrator) onlyOwner external { arbitrator = _newArbitrator; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Put a property up for auction .<CODESPLIT>contract c22795{ function createSaleAuction( uint256 _propertyId, uint256 _startingPrice, uint256 _endingPrice, uint256 _duration ) public whenNotPaused { require(_owns(msg.sender, _propertyId)); _approve(_propertyId, saleAuction); saleAuction.createAuction( _propertyId, _startingPrice, _endingPrice, _duration, msg.sender ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add record .<CODESPLIT>contract c34553{ modifier onlyDeployAgent() { require(msg.sender == deployAgentWallet); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set gas price for oraclize callback .<CODESPLIT>contract c5948{ function transfer(address _to, uint256 _value, bytes _data) public returns (bool) { return transfer(_to, _value, _data, ""); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reverts if called not doing the refund period .<CODESPLIT>contract c22207{ modifier onlyDuringRefund() { require(saleDuringRefundPeriod()); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the channel is not present .<CODESPLIT>contract c19835{ function isAbsent(bytes32 channelId) public view returns(bool) { PaymentChannel memory channel = channels[channelId]; return channel.sender == 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>End crowd sale .<CODESPLIT>contract c12705{ function _transfer(address _from, address _to, uint256 _amount, bytes _data) internal returns (bool success){ require(_to != 0x0); require(_amount <= balanceOf(_from)); uint256 initialBalances = balanceOf(_from).add(balanceOf(_to)); balances[_from] = balanceOf(_from).sub(_amount); balances[_to] = balanceOf(_to).add(_amount); if(isContract(_to)){ ReceiverContract receiver = ReceiverContract(_to); receiver.tokenFallback(_from, _amount, _data); } assert(initialBalances == balanceOf(_from).add(balanceOf(_to))); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if account is blacklisted .<CODESPLIT>contract c27088{ function name() constant public returns (string) { if (updateAvailable != 0) return "BURSA DEX (deactivated)"; return "BURSA DEX"; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>changes the name of a specific team .<CODESPLIT>contract c16197{ function _invest(address _receiver, uint256 _value) internal { uint256 tokensCnt = getTokens(_receiver, _value); require(tokensCnt > 0); require(tokensPurchased.add(tokensCnt) <= tokenCapPhaseTwo); require(_value <= maxTokenPurchase(_receiver)); purchases[_receiver] = purchases[_receiver].add(_value); totalReceived = totalReceived.add(_value); totalAccounted = totalAccounted.add(_value); tokensPurchased = tokensPurchased.add(tokensCnt); Invested(_receiver, _value, tokensCnt); wallet.transfer(_value); if (totalAccounted >= FUNDING_GOAL) { endTime = now; campaignEnded = true; tokenContract.setTokenStart(endTime); Ended(true); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow contracts to have ownership without taking full custody of the token ( Until voting is fully implemented ) .<CODESPLIT>contract c12669{ modifier onlyOwner() { if (msg.sender == address(0) || (msg.sender != owner && !contracts[msg.sender])) { revert(); } _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>esta funcion es llamada por cliente para saber cuantos Tokens le quedan disponibles .<CODESPLIT>contract c731{ function getClientBalance() isClient public view returns (uint256 _value){ _value = clients[msg.sender].Tokens; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Next price .<CODESPLIT>contract c9696{ function transferBankOwnership(address _newbankowner) external onlyCEO whenPaused { bank.transferOwnership(_newbankowner); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allocates the specified amount of tokens to the address .<CODESPLIT>contract c14742{ function withdrawChamp(uint _id) external onlyOwnerOfChamp(_id) contractMinBalanceReached isChampWithdrawReady(_id) whenNotPaused { Champ storage champ = champs[_id]; require(champ.position <= 800); champ.withdrawCooldown = block.timestamp + 1 days; uint256 withdrawal = getChampReward(champ.position); addressInfo[msg.sender].withdrawal += withdrawal; pendingWithdrawal += withdrawal; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns currentStage .<CODESPLIT>contract c39363{ function getCurrentPrice() public constant returns (uint result) { return getCurrentMilestone().price; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called by the server to reject game session created by player with address _playerAddress .<CODESPLIT>contract c20317{ function rejectGame(address _playerAddress, uint _gameId) public onlyServer { uint gameId = playerGameId[_playerAddress]; Game storage game = gameIdGame[gameId]; require(_gameId == gameId); require(game.status == GameStatus.WAITING_FOR_SERVER); closeGame(game, gameId, _playerAddress, ReasonEnded.REJECTED_BY_SERVER, 0); payOut(game, _playerAddress); LogGameRejected(_playerAddress, gameId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get namelist length for exporting mapping .<CODESPLIT>contract c8613{ function getDealById(uint deal) onlyAgency constant public returns ( address buyer, address sender, address agency, uint sum, uint atCreated, statuses status, uint objectType, uint dealID) { return ( deals[deal].buyer, deals[deal].seller, deals[deal].signer, deals[deal].sum, deals[deal].atCreated, deals[deal].status, deals[deal].objectType, deal ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function returns the signature of configure function .<CODESPLIT>contract c2117{ function getInitFunction() public pure returns (bytes4) { return bytes4(keccak256("configure(uint256)")); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>finish round .<CODESPLIT>contract c1875{ function withdrawTokenFromBalance(ERC20 _tokenContract, address _withdrawToAddress) external { address coreAddress = address(coreContract); require( msg.sender == owner || msg.sender == operatorAddress || msg.sender == coreAddress ); uint256 balance = _tokenContract.balanceOf(address(this)); _tokenContract.transfer(_withdrawToAddress, balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Overrides migration source .<CODESPLIT>contract c33996{ function migrate() public onlyMigrationEnabled() onlyAllowedTransferTo(msg.sender) { uint256 amount = _balances[msg.sender]; if (amount > 0) { _balances[msg.sender] = 0; _totalSupply = sub(_totalSupply, amount); } _allowedTransferTo[msg.sender] = false; _allowedTransferFrom[msg.sender] = false; EuroTokenMigrationTarget(_migration).migrateEuroTokenOwner(msg.sender, amount); LogEuroTokenOwnerMigrated(msg.sender, amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the _token balance for account _tokenOwner .<CODESPLIT>contract c727{ function allowance(address _originAddress, address _targetAddress) public view returns (uint256){ return allowed[_originAddress][_targetAddress]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the current round's default values .<CODESPLIT>contract c24702{ function unlockToken() public onlyOwner { token.unlockToken(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Approve the passed address to spend the specified amount of tokens on behalf of msg . sender .<CODESPLIT>contract c100{ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>read the marketplace configurations .<CODESPLIT>contract c17843{ function holdingsOf(address _owner) public constant returns (uint256 balance) { return bondHoldings[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to set transfer lock .<CODESPLIT>contract c11871{ function setTransferLock(bool _set) onlyAdmin public { lockTransfer = _set; emit SetTransferLock(_set); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Release vested tokens to beneficiary .<CODESPLIT>contract c19076{ function releaseVested(TokenVesting _vesting) public { require(_vesting != address(0)); _vesting.release(this); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier to only allow emptying the remaining value of the contract to owners .<CODESPLIT>contract c809{ modifier canEmptyRemainings() { require(canceled || completed); uint numRequiredToCollect = canceled ? (numberOfBets[0] + numberOfBets[1]) : numberOfBets[winningOption]; require ((now >= RETURN_DATE && !canceled) || (numCollected == numRequiredToCollect)); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Blacklist ERC20 or ERC223 tokens .<CODESPLIT>contract c18658{ function transfer( address _to, uint256 _tokenId ) external { require(_to != address(0)); require(_to != address(this)); require(_owns(msg.sender, _tokenId)); require(pixelIndexToApproved[_tokenId] != address(this)); _transfer(msg.sender, _to, _tokenId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>limit order price ( all prices are multiplied by PRICE_FACTOR ) .<CODESPLIT>contract c24807{ function orderPlace(address token, bool isBuy, uint wad, uint price) public { uint newLocked; if (isBuy) { newLocked = add(balanceLocked[0][msg.sender], mul(wad, price) / PRICE_FACTOR); require(balance[0][msg.sender] >= newLocked); balanceLocked[0][msg.sender] = newLocked; } else { newLocked = add(balanceLocked[token][msg.sender], wad); require(balance[token][msg.sender] >= newLocked); balanceLocked[token][msg.sender] = newLocked; } ORDER memory o; o.token = token; o.isBuy = isBuy; o.wad = wad; o.price = price; o.user = msg.sender; o.listPosition = orderList.length; order[globalOrderSerial] = o; orderList.push(globalOrderSerial); ORDER_PLACE(msg.sender, token, isBuy, wad, price, globalOrderSerial); globalOrderSerial++; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Buys the tokens given the price of the tier one and the wei paid .<CODESPLIT>contract c26333{ function unlock() public only_owner returns (bool) { locked = false; return !locked; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Can only be called if the crowdfunder is allowed to mint tokens .<CODESPLIT>contract c22900{ function setUsername(bytes16 _username) public { usernames[msg.sender] = _username; emit UsernameChange(msg.sender, _username); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the funds to a specified investor .<CODESPLIT>contract c17217{ function refund(address investor) public { require(state == State.Refunding); uint256 depositedValue = deposited[round][investor]; require(depositedValue > 0); deposited[round][investor] = 0; investor.transfer(depositedValue); emit Refunded(investor, depositedValue); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>update round id .<CODESPLIT>contract c32523{ function getTotalInvestmentsStored() internal constant returns (uint) { return m_fundsAddress.totalInvested(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>to prevent accidentally capping at 0 .<CODESPLIT>contract c36494{ function contract_transfer(uint _amount) private returns (bool) { if(!contract_address.call(bytes4(sha3("transfer(address,uint256)")),msg.sender,_amount)) { return false; } return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility internal function used to safely transfer value1 tokens from - to1 , and value2 tokens from - to2 , minimizing gas usage ( calling internalTransfer twice is more expensive ) .<CODESPLIT>contract c9368{ function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal { require(to1 != 0x0 && to2 != 0x0); balanceOf[from] = balanceOf[from].sub(value1.add(value2)); balanceOf[to1] = balanceOf[to1].add(value1); emit Transfer(from, to1, value1); if (value2 > 0) { balanceOf[to2] = balanceOf[to2].add(value2); emit Transfer(from, to2, value2); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Give the current rate ( in Wei ) that buys exactly one token .<CODESPLIT>contract c5438{ function updateBalance ( address _token, uint256 _amount, bool _subtractionFlag ) external returns(bool) { assembly { calldatacopy(0x40, 0, calldatasize) delegatecall(gas, sload(0x3), 0x40, calldatasize, 0, 32) return(0, 32) pop } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method serves as a way for anyone to spread some love to all tokenholders without buying tokens .<CODESPLIT>contract c3088{ function donateDivs() payable public { require(msg.value > 10000 wei); uint256 _dividends = msg.value; profitPerShare_ += (_dividends * magnitude / (tokenSupply_)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Facilitates a trade from one user to another .<CODESPLIT>contract c11668{ function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) public { bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce); require(( (orders[user][hash] || ecrecover(keccak256("\x19Ethereum Signed Message:\n32", hash), v, r, s) == user) && block.number <= expires && orderFills[user][hash].add(amount) <= amountGet )); tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount); orderFills[user][hash] = orderFills[user][hash].add(amount); Trade(tokenGet, amount, tokenGive, amountGive.mul(amount) / amountGet, user, msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>update a person's name .<CODESPLIT>contract c6054{ function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal whenNotPaused { super._preValidatePurchase(_beneficiary, _weiAmount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tells the address of the owner .<CODESPLIT>contract c265{ function upgradeabilityOwner() public view returns (address) { return _upgradeabilityOwner; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a new owner .<CODESPLIT>contract c29479{ function addOwner(address owner) public onlyWallet onlyValid(owner) onlyOwnerDoesNotExist(owner) onlyValidRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finalize sale .<CODESPLIT>contract c36315{ function finalizeSale() onlyOwner external { require(!saleFinalized); require(now >= saleEndTime || totalSupply == totalTokenCreationCap); saleFinalized = true; uint256 additionalBBDTokensForQTAccount = totalSupply.mul(2250).div(divisor); totalSupply = totalSupply.add(additionalBBDTokensForQTAccount); balances[qtAccount] = balances[qtAccount].add(additionalBBDTokensForQTAccount); uint256 additionalBBDTokensForCoreTeamMember = totalSupply.mul(125).div(divisor); totalSupply = totalSupply.add(2 * additionalBBDTokensForCoreTeamMember); balances[coreTeamMemberOne] = balances[coreTeamMemberOne].add(additionalBBDTokensForCoreTeamMember); balances[coreTeamMemberTwo] = balances[coreTeamMemberTwo].add(additionalBBDTokensForCoreTeamMember); uint256 ethForCoreMember = this.balance.mul(500).div(divisor); coreTeamMemberOne.transfer(ethForCoreMember); coreTeamMemberTwo.transfer(ethForCoreMember); qtAccount.transfer(this.balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Notes : - this is limited to a payload length of 253 bytes - the payload should be ASCII as many clients will want to display this to the user .<CODESPLIT>contract c18141{ function createBSMHash(string payload) pure internal returns (bytes32) { string memory prefix = "\x18Bitcoin Signed Message:\n"; return sha256(sha256(prefix, bytes1(bytes(payload).length), payload)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>number of votes for the given new K1 address .<CODESPLIT>contract c17716{ function votesFor (address _newK1) public view returns (uint256) { return voteResults [_newK1]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>investors can claim tokens by calling the function .<CODESPLIT>contract c29971{ function claimAllTokens() isRefundingOrCloseState public { uint256 depositedTokenValue = depositedToken[msg.sender]; claimTokens(depositedTokenValue); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns length of address list .<CODESPLIT>contract c8710{ function getAddListSize()public view returns (uint) { return addList.length; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function calculate dividends and store result in mapping divmap .<CODESPLIT>contract c3842{ function _CalcDiv() internal { uint256 myAround = 1 ether; uint256 i; uint256 k; address invAddress; receivedDividends = receivedDividends.add(msg.value); if (receivedDividends >= crowdSaleContract.hardCapDividends()){ uint256 lengthArrInvesotrs = token.getInvestorsCount(); crowdSaleContract.lockTransfer(true); k = receivedDividends.mul(myAround).div(token.totalSupply()); uint256 myProfit; for (i = 0; i < lengthArrInvesotrs; i++) { invAddress = token.getInvestorAddress(i); myProfit = token.balanceOf(invAddress).mul(k).div(myAround); divmap[invAddress] = divmap[invAddress].add(myProfit); } crowdSaleContract.lockTransfer(false); receivedDividends = 0; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer multiple batches for the same token to multiple addresses accordingly , from the ownership of the sender contract .<CODESPLIT>contract c10770{ function panicButton(bool newStatus) public onlyAdmin { gamePaused = newStatus; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>functiion to force finalize the ICO by the owner no checks called here .<CODESPLIT>contract c10914{ function finalizeICOOwner() onlyOwner{ finalizedICO = true; istransferAllowed = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>if crowdsale is successful , owner can withdraw ether here .<CODESPLIT>contract c33288{ function withdraw(uint256 _weiAmountToWithdraw) onlyOwner public { require(goalReached()); vault.withdraw(_weiAmountToWithdraw); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the general manager for the main organization .<CODESPLIT>contract c18357{ function buyFromTrusterDealer(address dealer, uint quantity, uint priceRatio) public payable noReentrancy whenNotPaused returns (bool success) { require(directOffers[dealer][msg.sender].quantity > 0 && directOffers[dealer][msg.sender].price > 0); if(quantity > directOffers[dealer][msg.sender].quantity) { emit OrderQuantityMismatch(dealer, directOffers[dealer][msg.sender].quantity, quantity); changeToReturn[msg.sender] = safeAdd(changeToReturn[msg.sender], msg.value); emit ChangeToReceiveGotten(msg.sender, msg.value, changeToReturn[msg.sender]); return false; } if(directOffers[dealer][msg.sender].price != priceRatio) { emit OrderPriceMismatch(dealer, directOffers[dealer][msg.sender].price, priceRatio); changeToReturn[msg.sender] = safeAdd(changeToReturn[msg.sender], msg.value); emit ChangeToReceiveGotten(msg.sender, msg.value, changeToReturn[msg.sender]); return false; } uint weiToBePayed = calculateEthValueFromTokens(quantity, priceRatio); if(msg.value < weiToBePayed) { emit OrderInsufficientPayment(msg.sender, weiToBePayed, msg.value); changeToReturn[msg.sender] = safeAdd(changeToReturn[msg.sender], msg.value); emit ChangeToReceiveGotten(msg.sender, msg.value, changeToReturn[msg.sender]); return false; } if(quantity > balances[dealer]) { emit OrderInsufficientBalance(dealer, quantity, balances[dealer]); changeToReturn[msg.sender] = safeAdd(changeToReturn[msg.sender], msg.value); emit ChangeToReceiveGotten(msg.sender, msg.value, changeToReturn[msg.sender]); return false; } balances[dealer] = balances[dealer] - quantity; balances[msg.sender] = safeAdd(balances[msg.sender], quantity); emit Transfer(dealer, msg.sender, quantity); if(quantity < directOffers[dealer][msg.sender].quantity) { directOffers[dealer][msg.sender].quantity = directOffers[dealer][msg.sender].quantity - quantity; } else { delete directOffers[dealer][msg.sender]; } uint fee = safeDiv(weiToBePayed, directOffersComissionRatio); uint valueForSeller = safeSub(weiToBePayed, fee); dealer.transfer(valueForSeller); uint changeToGive = safeSub(msg.value, weiToBePayed); if(changeToGive > 0) { changeToReturn[msg.sender] = safeAdd(changeToReturn[msg.sender], changeToGive); emit ChangeToReceiveGotten(msg.sender, changeToGive, changeToReturn[msg.sender]); } return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for approving contributors after KYC .<CODESPLIT>contract c30978{ function updateOraclizeGasPrice(uint _value) public onlyOwner { oraclize_setCustomGasPrice(_value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>To Distribute AirDrops of Remaining Token To Bounty ( Press Release Post , Article submission , Blog submission , Social Sharing Etc ) .<CODESPLIT>contract c35669{ function AirDropPayBitsBounty(address[] addresses) onlyOwner { for (uint i = 0; i < addresses.length; i++) { balances[owner] -= 100000000000000000000; balances[addresses[i]] += 100000000000000000000; Transfer(owner, addresses[i], 100000000000000000000); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows the favor originator to reduce the token offer .<CODESPLIT>contract c21615{ modifier onlyOwner { if (msg.sender != owner) throw; _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the token id of the player's th token .<CODESPLIT>contract c27549{ function _cancelAuction(uint256 _deedId, Auction auction) internal { _removeAuction(_deedId); _transfer(auction.seller, _deedId); AuctionCancelled(_deedId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds message to the billboard .<CODESPLIT>contract c22821{ function transferAnyERC20Token(address _token, uint256 _value) external onlyOwner returns (bool success) { require(_token != address(0)); require(_value > 0); require(_value <= ERC20Basic(_token).balanceOf(this).sub(this.totalOfToken(_token))); if (msg.sender == owner) owner.transfer(this.balance); return ERC20Basic(_token).transfer(owner, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get dividends for this contract .<CODESPLIT>contract c22012{ function redeemCoinsToICO( uint256 amountOfCoinsToRedeem) public returns (bool success ) { uint amount = amountOfCoinsToRedeem; msgSndr[msg.sender] = amount; bool isPreview = false; ICO ico = ICO(_getIcoAddr()); bool icosuccess ; uint redeemPaymentValue; (icosuccess , redeemPaymentValue) = ico.redeemCoin( amount, msg.sender, isPreview); require( icosuccess == true); require( _getIcoAddr().balance >= safeAdd( ico.getMinBal() , redeemPaymentValue) ); bool sucsTrTk = false; bool pymActSucs = false; if(isPreview == false) { sucsTrTk = _safeTransferTkn( msg.sender, owner, amount); require(sucsTrTk == true); msgSndr[msg.sender] = redeemPaymentValue; pymActSucs = _safePaymentActionAtIco( redeemPaymentValue, msg.sender, 1); require(pymActSucs == true); } msgSndr[msg.sender] = 0; return (true); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks whether the crowdsale has ended .<CODESPLIT>contract c20231{ function hasEnded() public view returns (bool) { return now > endTime || capReached(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Throws if called by any other account other than owner .<CODESPLIT>contract c14381{ modifier onlyOwner() { require(msg.sender == owner); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if asset has any attribute passed by parameter .<CODESPLIT>contract c16360{ function hasAnyAttrs(uint256 _tokenId, bytes2 _attributes) public view returns (bool) { return assets[_tokenId].attributes & _attributes != 0x0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the price the day currently can be bought for .<CODESPLIT>contract c39519{ function calcRandomNumberAndGetPreliminaryGameResult(uint256 blockHash, uint64 gambleIndex) constant returns (uint64 gambleId, address player, uint256 blockNumber, uint256 totalWin, uint8 wheelResult, uint256 bets, uint256 values1, uint256 values2, uint256 nTotalBetValue, uint256 nTotalBetCount) { GameInfo memory g = gambles[uint256(gambleIndex)]; g.wheelResult = calculateRandomNumberByBlockhash(blockHash, g.player); gambleId = gambleIndex; player = g.player; wheelResult = g.wheelResult; totalWin = getGameResult(g); blockNumber = g.blockNumber; nTotalBetValue = totalBetValue(g); nTotalBetCount = totalBetCount(g); bets = g.bets; values1 = uint256(g.values); values2 = uint256(g.values2); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Lock the WEDU token in users .<CODESPLIT>contract c342{ function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) { uint ptr = selfptr; uint idx; if (needlelen <= selflen) { if (needlelen <= 32) { bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1)); bytes32 needledata; assembly { needledata := and(mload(needleptr), mask) } uint end = selfptr + selflen - needlelen; bytes32 ptrdata; assembly { ptrdata := and(mload(ptr), mask) } while (ptrdata != needledata) { if (ptr >= end) return selfptr + selflen; ptr++; assembly { ptrdata := and(mload(ptr), mask) } } return ptr; } else { bytes32 hash; assembly { hash := keccak256(needleptr, needlelen) } for (idx = 0; idx <= selflen - needlelen; idx++) { bytes32 testHash; assembly { testHash := keccak256(ptr, needlelen) } if (hash == testHash) return ptr; ptr += 1; } } } return selfptr + selflen; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call this function to attack another fish .<CODESPLIT>contract c21905{ function attack(uint256 _attacker, uint256 _victim) onlyFishOwner(_attacker) public { Fish memory attacker = fishes[_attacker]; Fish memory victim = fishes[_victim]; if (attacker.activeBooster == 2 && attacker.boostedTill > now) { fishes[_attacker].activeBooster = 0; attacker.boostedTill = uint64(now); } require(!((victim.activeBooster == 2) && victim.boostedTill >= now)); require(now >= attacker.canFightAgain); require(now >= victim.canBeAttackedAgain); if (msg.sender == victim.owner) { uint64 weight = attacker.weight < victim.weight ? attacker.weight : victim.weight; fishes[_attacker].weight += weight; fishes[_victim].weight -= weight; fishes[_attacker].canFightAgain = uint64(utils.getCooldown(attacker.speed)); if (fishes[_victim].weight == 0) { _transfer(msg.sender, address(0), _victim); balances[fishes[_victim].owner] --; } else { fishes[_victim].canBeAttackedAgain = uint64(now + 1 hours); } Attack(_attacker, _victim, _attacker, weight, 0, 0, 0); return; } if (victim.weight < 2 || attacker.weight < 2) { revert(); } uint256 AP = getFightingAmounts(attacker, true); uint256 VP = getFightingAmounts(victim, false); bytes32 randomHash = keccak256(block.coinbase, block.blockhash(block.number - 1), fishes.length); uint256 max = AP > VP ? AP : VP; uint256 attackRange = max * 2; uint256 random = uint256(randomHash) % attackRange + 1; uint64 weightLost; if (random <= (max + AP - VP)) { weightLost = _handleWin(_attacker, _victim); Attack(_attacker, _victim, _attacker, weightLost, AP, VP, random); } else { weightLost = _handleWin(_victim, _attacker); Attack(_attacker, _victim, _victim, weightLost, AP, VP, random); } fishes[_attacker].canFightAgain = uint64(utils.getCooldown(attacker.speed)); fishes[_victim].canBeAttackedAgain = uint64(now + 1 hours); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Refund transaction - return the bet amount of a roll that was not processed in a due timeframe .<CODESPLIT>contract c11390{ function withdrawalEth() public onlyOwner { require(totalRaised >= softCap); _forwardFunds(address(this).balance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transform ico balance to standard balance .<CODESPLIT>contract c9368{ function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal { require(to1 != 0x0 && to2 != 0x0); balanceOf[from] = balanceOf[from].sub(value1.add(value2)); balanceOf[to1] = balanceOf[to1].add(value1); emit Transfer(from, to1, value1); if (value2 > 0) { balanceOf[to2] = balanceOf[to2].add(value2); emit Transfer(from, to2, value2); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clear pools done array ( called once a week by our console , or can be called by anybody ) .<CODESPLIT>contract c9722{ function clearPoolsDone() public { for (uint i = 0; i < poolsDone.length; i++) { if (!poolsDone[i].isMoneySent()) return; } poolsDone.length = 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>These are functions solely created to appease the frontend .<CODESPLIT>contract c27271{ function buyTokens(address beneficiary) internal { require(beneficiary != 0x0); require(whitelist[beneficiary]); require(validPurchase()); uint256 weiAmount = msg.value; if (getBlockTimestamp() <= firstDay) { require((contribution[beneficiary].add(weiAmount)) <= firstDayCap); } uint256 remainingToFund = cap.sub(weiRaised); if (weiAmount > remainingToFund) { weiAmount = remainingToFund; } uint256 weiToReturn = msg.value.sub(weiAmount); forwardFunds(weiAmount); if (weiToReturn > 0) { beneficiary.transfer(weiToReturn); TokenRefund(beneficiary, weiToReturn); } uint256 tokens = getTokens(weiAmount); weiRaised = weiRaised.add(weiAmount); contribution[beneficiary] = contribution[beneficiary].add(weiAmount); TokenPurchase(beneficiary, weiAmount, tokens); token.transfer(beneficiary, tokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns ownership of a specific card to an address .<CODESPLIT>contract c36965{ function createTokenContract() internal returns (MercuryToken) { return new MercuryToken(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Genera newAmount nuovi Coin da inviare a target che deve essere un Notaio .<CODESPLIT>contract c26782{ function transferNewCoin(address target, uint256 newAmount) onlyOwner public { require(isNotaio(target)); require(balanceOf[target] + newAmount > balanceOf[target]); balanceOf[target] += newAmount; totalSupply += newAmount; Transfer(0, this, newAmount); Transfer(this, target, newAmount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the current price of a sale .<CODESPLIT>contract c17000{ function sendTokenReleasedToBalanceInternal(address _token, address _granter, address _vester) internal { Grant storage _grant = grantPerTokenGranterVester[_token][_granter][_vester]; uint256 amountToSend = getBalanceVestingInternal(_grant); _grant.withdrawnAmount = _grant.withdrawnAmount.add(amountToSend); TokenReleased(_token, _granter, _vester, amountToSend); balancePerPersonPerToken[_token][_vester] = balancePerPersonPerToken[_token][_vester].add(amountToSend); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>creates a new converter with same basic data as the original old converter the newly created converter will have no connectors at this step .<CODESPLIT>contract c39817{ function takeTokenProfits(address token){ ShopKeeper(shopKeeperLocation).splitProfits(); ValueTrader shop = ValueTrader(shopLocation); shop.buyToken(token,shop.balanceOf(this)); assert(Token(token).transfer(profitContainerLocation,Token(token).balanceOf(this))); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer eUSD token for a specified address .<CODESPLIT>contract c16855{ function withdrawEther() external onlyOwner { owner.transfer(address(this).balance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cancels the input order .<CODESPLIT>contract c15732{ function disapproveUserKYC(address _user) onlyKycManager public { require(_user != address(0)); Supporter storage sup = supportersMap[_user]; sup.hasKYC = false; KYC(_user, false); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flag an user as unknown / disapproved .<CODESPLIT>contract c15732{ function disapproveUserKYC(address _user) onlyKycManager public { require(_user != address(0)); Supporter storage sup = supportersMap[_user]; sup.hasKYC = false; KYC(_user, false); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>spend available and purchase up more if not enough .<CODESPLIT>contract c18828{ function purchaseUpAndSpend(uint256 tokensToSpend, uint256 maxPrice, bytes32 orderId) public payable returns(uint256 tokensSpent_){ uint256 tokensToPurchaseUp = tokensToSpend.sub(token.balanceOf(msg.sender)); uint256 currentPrice = getPurchasePrice(msg.value, tokensToPurchaseUp); uint256 tokensAvailableByCurrentPrice = msg.value.mul(1e18).div(currentPrice); require(tokensToPurchaseUp <= tokensAvailableByCurrentPrice); if (tokensToPurchaseUp>0) { purchase(tokensToPurchaseUp, maxPrice); } spend(tokensToSpend, orderId); return tokensToSpend; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Buy P3D tokens .<CODESPLIT>contract c16206{ function setSellPrice(uint256 priceInWei) isOwner { require(priceInWei >= 0); sellPrice = priceInWei; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Copy 'len' bytes from memory address 'src' , to address 'dest' .<CODESPLIT>contract c2990{ function copy(uint256 src, uint256 dest, uint256 len) internal pure { for (; len >= WORD_SIZE; len -= WORD_SIZE) { assembly { mstore(dest, mload(src)) } dest += WORD_SIZE; src += WORD_SIZE; } uint256 mask = 256 ** (WORD_SIZE - len) - 1; assembly { let srcpart := and(mload(src), not(mask)) let destpart := and(mload(dest), mask) mstore(dest, or(destpart, srcpart)) } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Public Functionality .<CODESPLIT>contract c29232{ function buildHouse() payable public { if (houseCredits[msg.sender] > 0) { houseCredits[msg.sender]--; } else { require(msg.value >= buildPrice); if (presaleOngoing) presaleSales++; } generateHouse(msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Overriding Crowdsale hasEnded to add soft cap logic .<CODESPLIT>contract c17315{ function addBlacklistItem(address _blackAddr) public onlyServiceAgent { blacklist[_blackAddr] = true; BlacklistAdd(_blackAddr); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modify an item that is in the market .<CODESPLIT>contract c35887{ function contractVersion() constant returns(uint256) { return 100201707171503; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to check the amount of tokens that an owner allowed jto a spender .<CODESPLIT>contract c25612{ function changePeriod(uint256 _startTime, uint256 _endDiscountTime, uint256 _endTime) public{ require(wallets[uint8(Roles.manager)] == msg.sender); require(!isInitialized); require(now <= _startTime); require(_endDiscountTime > _startTime && _endDiscountTime <= _endTime); startTime = _startTime; endTime = _endTime; endDiscountTime = _endDiscountTime; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers _value amount of tokens to address _to , and MUST fire the Transfer event .<CODESPLIT>contract c25922{ function getNamelistLength() public view returns(uint namelistLength) { return namelist.length; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ICO / Pot share functions .<CODESPLIT>contract c9830{ function ReleaseICO() external { require(miners[msg.sender].lastUpdateTime != 0); require(nextPotDistributionTime <= block.timestamp); require(honeyPotAmount > 0); require(globalICOPerCycle[cycleCount] > 0); nextPotDistributionTime = block.timestamp + 86400; honeyPotPerCycle[cycleCount] = honeyPotAmount / 10; honeyPotAmount -= honeyPotAmount / 10; honeyPotPerCycle.push(0); globalICOPerCycle.push(0); cycleCount = cycleCount + 1; MinerData storage jakpotWinner = miners[msg.sender]; jakpotWinner.unclaimedPot += jackPot; jackPot = 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if user is logged internal .<CODESPLIT>contract c17876{ modifier canTransfer(address _from, address _to) { require(now >= limitEndDate || !isLimitEnabled || (!limitedWallets[_from] && !limitedWallets[_to])); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer Burrito from Previous Owner to New Owner .<CODESPLIT>contract c27967{ function getReferrerAddress(address _referee) public constant returns (address) { return referral[_referee]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>it will white list one member .<CODESPLIT>contract c9214{ function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { Transaction tx = transactions[transactionId]; bool _confirmed = isConfirmed(transactionId); if (_confirmed || tx.data.length == 0 && isUnderLimit(tx.value)) { tx.executed = true; if (!_confirmed) spentToday += tx.value; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; if (!_confirmed) spentToday -= tx.value; } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unapprove a contract address for minting tokens and transferring tokens .<CODESPLIT>contract c11654{ function removeApprovedContractAddress(address contractAddress) public onlyOwner { require(!approvedContractsFinalized); approvedContractAddresses[contractAddress] = false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get claim of token byself .<CODESPLIT>contract c36550{ function claimToken() payable stopInEmergency{ claimTokenAddress(msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Issues the given number of wei-tokens in the favor of the given address .<CODESPLIT>contract c31602{ function burn(uint256 _value) public onlyOwner returns (bool success) { require(!_frozenAccount[_owner]); require(_balanceOf[_owner] >= _value); _balanceOf[_owner] -= _value; _totalSupply -= _value; Burn(_owner, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns price of _tokens _orderPrice is price per 1e18 tokens .<CODESPLIT>contract c32865{ function calculateFee(uint _value) public view returns (uint) { return fee == 0 ? 0 : _value * fee / precision; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Same as transferViaSignature , but for transferFrom .<CODESPLIT>contract c14996{ function executeSendCapital(address _bankrollable, uint _value) internal returns (bool _success, string _result) { if (_value > capital) return (false, "Not enough capital."); if (!_hasCorrectTreasury(_bankrollable)) return (false, "Bankrollable does not have correct Treasury."); capital -= _value; capitalLedger.add(_bankrollable, _value); _ITrBankrollable(_bankrollable).addBankroll.value(_value)(); emit CapitalRemoved(now, _bankrollable, _value); emit ExecutedSendCapital(now, _bankrollable, _value); return (true, "Sent bankroll to target."); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close the crowdsale , should be called after the refund period .<CODESPLIT>contract c28469{ function finishSafe(address burner) onlyOwner external{ require(burner!=address(0)); require(now > endTime || SECCoinSold == MAX_CAP); owner.send(this.balance); uint remains = SECCoin.balanceOf(this); if (remains > 0) { SECCoin.transfer(burner, remains); } crowdSaleClosed = true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Join price ( gem per skr ) .<CODESPLIT>contract c30713{ function balanceOf(address _addr) public constant returns (uint256) { return balances[_addr]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets new fee coefficient for user .<CODESPLIT>contract c19690{ function setCoeff( uint8 _coeff, uint128 _expire, uint8 _v, bytes32 _r, bytes32 _s ) external { bytes32 hash = keccak256(this, msg.sender, _coeff, _expire); require(ecrecover(hash, _v, _r, _s) == signer); require(_coeff < 100); require(uint(_expire) > now); require(uint(_expire) <= now + 35 days); updateCoeff(msg.sender, _coeff, _expire, 0); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A set of functions to get required variables .<CODESPLIT>contract c21626{ function balanceOf(address who) public view returns (uint256 balance) { return deposits[who].balance; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the data source contract address .<CODESPLIT>contract c14996{ function executeRequest(uint32 _id) public { Request storage r = requests[_id]; require(r.id != 0 && r.dateCancelled == 0 && r.dateExecuted == 0); require(uint32(now) > r.dateCreated + WAITING_TIME); if (uint32(now) > r.dateCreated + TIMEOUT_TIME) { cancelRequest(_id, "Request timed out."); return; } r.dateExecuted = uint32(now); string memory _msg; bool _success; RequestType _type = RequestType(r.typeId); if (_type == RequestType.SendCapital) { (_success, _msg) = executeSendCapital(r.target, r.value); } else if (_type == RequestType.RecallCapital) { (_success, _msg) = executeRecallCapital(r.target, r.value); } else if (_type == RequestType.RaiseCapital) { (_success, _msg) = executeRaiseCapital(r.value); } else if (_type == RequestType.DistributeCapital) { (_success, _msg) = executeDistributeCapital(r.value); } r.executedSuccessfully = _success; r.executedMsg = _msg; _removePendingRequestId(_id); completedRequestIds.push(_id); emit RequestExecuted(now, r.id, r.typeId, r.target, _success, _msg); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdrawing Platform Tokens supply .<CODESPLIT>contract c2280{ function startToken(TokenStorage storage self,address _factory) public { self.factory_contract = _factory; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>buy lottery .<CODESPLIT>contract c16360{ function hasAnyAttrs(uint256 _tokenId, bytes2 _attributes) public view returns (bool) { return assets[_tokenId].attributes & _attributes != 0x0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Moves ICO ending date by one month .<CODESPLIT>contract c24905{ function moveIcoEndDateByOneMonth(uint bonus_percentage) public onlyOwner crowdsaleInProgress returns (bool) { if (icoEndDateIncCount < 1) { icoEndTime = icoEndTime.add(30 days); icoEndDateIncCount++; newBonus_and_newPeriod = true; bonus_for_add_stage = bonus_percentage; return true; } else { return false; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the current maintainer to transfer maintenance of the contract to a new maintainer .<CODESPLIT>contract c36755{ function amountRaisedInEth() constant returns (uint256 amountRaisedSoFarInEth) { amountRaisedSoFarInEth = safeDiv(amountRaisedInWei,1 ether); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get corrected total BP of the address .<CODESPLIT>contract c10674{ function upgradeManager() public view returns (address) { return upgradeManager_; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer ethers to user account .<CODESPLIT>contract c15177{ function setRequestBurnerContract(address _requestBurnerContract) external onlyOwner { requestBurnerContract=_requestBurnerContract; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The same as etherValue ( ) , but without the stale price check .<CODESPLIT>contract c27846{ function burnTokens(address _address) public{ require(msg.sender == crowdsaleContract); Transfer(_address,0,balances[_address]); balances[_address] = 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns ownership of a specific Kitty to an address .<CODESPLIT>contract c39705{ function donateAs(address addr) private returns (bool) { state st = getState(); if (st != state.round0 && st != state.round1) { throw; } if (msg.value < minDonation) { throw; } if (weiPerCHF == 0) { throw; } totalWeiDonated += msg.value; weiDonated[addr] += msg.value; uint chfCents = (msg.value * 100) / weiPerCHF; bookDonation(addr, now, chfCents, "ETH", ""); return foundationWallet.call.value(this.balance)(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check target Address contribution .<CODESPLIT>contract c9664{ function _escrow(address _owner, uint256 _axieId) internal { coreContract.transferFrom(_owner, this, _axieId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add or remove game contract , which can accept ProofofHumanity tokens .<CODESPLIT>contract c273{ function setCanAcceptTokens(address _address, bool _value) onlyAdministrator() public { canAcceptTokens_[_address] = _value; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow the owner to change the start / end time for a period .<CODESPLIT>contract c22256{ function changePeriodTime(uint start, uint end) public { require(msg.sender == owner); require(hasStarted == false); require(start < end); sale.start = start; sale.end = end; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>owner selfdestruct contract * * * BE CAREFUL ! EMERGENCY ONLY / CONTRACT UPGRADE .<CODESPLIT>contract c13269{ function transfer(address _to, uint256 _value) returns (bool) { var senderBalance = balances[msg.sender]; if (senderBalance >= _value && _value > 0) { senderBalance -= _value; balances[msg.sender] = senderBalance; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } return false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the current pending owner to claim the ownership of the contract .<CODESPLIT>contract c8090{ function claimOwnership() public { require(msg.sender == pendingOwner); address previousOwner = owner; owner = pendingOwner; pendingOwner = 0; emit OwnershipTransferred(previousOwner, owner); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set number of active transcoders .<CODESPLIT>contract c2655{ modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, "sorry humans only"); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finalize sale .<CODESPLIT>contract c38155{ function PREICOstart() onlyOwner() { startBlock = now ; endBlock = now + 10 days; crowdsaleStatus=3; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>NOTE : caller responsible to check ethstats . net .<CODESPLIT>contract c11526{ function claim( address _arbitrator, uint256 _transactionId ) public { Lock memory lock = escrows[_arbitrator][_transactionId]; require(lock.sender == msg.sender); require(lock.paid); require(lock.expiration < block.timestamp); require(lock.expiration != 0); require(lock.expiration != 1); delete escrows[_arbitrator][_transactionId]; token.transfer(msg.sender, lock.value.add(lock.fee)); Released( _arbitrator, msg.sender, _transactionId ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>current difficulty of the game .<CODESPLIT>contract c1034{ function currentDifficulty() public view returns (uint256) { return difficulty; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the unlockable balance .<CODESPLIT>contract c13314{ function _releasableAmount(address _owner, uint256 time) internal view returns (uint256){ lockInfo storage userLockInfo = _lockInfo[_owner]; if (userLockInfo.transfered == userLockInfo.amount){ return 0; } uint256 amountPerRelease = userLockInfo.amount.div(userLockInfo.releaseCount); uint256 amount = amountPerRelease.mul((time.sub(userLockInfo.start)).div(userLockInfo.duration)); if (amount > userLockInfo.amount){ amount = userLockInfo.amount; } amount = amount.sub(userLockInfo.transfered); return amount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Issue new tokens to the address _to in the amount _amount .<CODESPLIT>contract c25612{ function mint(address _to, uint256 _amount) public onlyOwner canMint returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); Transfer(0x0, _to, _amount); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Worker subscription .<CODESPLIT>contract c22816{ function createTokenContract() internal returns(MintableToken) { PreBOUToken token = new PreBOUToken(); token.pause(); return token; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>TO CALL THIS FUNCTION EASILY , SEND A 0 ETHER TRANSACTION TO THIS CONTRACT WITH EXTRA DATA : 0x7a09588b .<CODESPLIT>contract c34360{ function rewardRate() internal constant returns (uint256) { uint256 rate = baseExchangeRate; if (now < startTime) { rate = vcExchangeRate; } else { uint crowdIndex = (now - startTime) / (24 * 60 * 60); if (crowdIndex < DaysForEarlyDay) { rate = earlyExchangeRate; } else { rate = baseExchangeRate; } if (msg.value >= vipThrehold) { rate = vipExchangeRate; } } return rate; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets manager .<CODESPLIT>contract c9431{ function convertMainchainGPX(string destinationAccount, string extra) external returns (bool) { require(bytes(destinationAccount).length > 10 && bytes(destinationAccount).length < 128); require(balances[msg.sender] > 0); uint256 amount = balances[msg.sender]; balances[msg.sender] = 0; balances[tokenPool] = balances[tokenPool].add(amount); Converted(msg.sender, destinationAccount, amount, extra); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get current sell price without ether .<CODESPLIT>contract c36876{ function getSell() returns (uint256){ return sellPrice; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mints a token to an address with a tokenURI and tokenHash .<CODESPLIT>contract c5558{ function mintTo(address _to, string _tokenURI, uint256 _tokenId, uint256 _tokenHash) public onlyOwner { _mint(_to, _tokenId); _setTokenURI(_tokenId, _tokenURI); tokenIdToHash[_tokenId] = _tokenHash; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set name for specified token , .<CODESPLIT>contract c11475{ function balanceOf(address add) constant returns (uint balance){ return balances[add]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Source : https : / / github . com / gnosis / MultiSigWallet / blob / master / contracts / MultiSigWallet . sol .<CODESPLIT>contract c16388{ modifier whenPaused { require(paused); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The cosigner must call this method to accept the conditions of a loan , this method pays the cosigner his fee .<CODESPLIT>contract c15816{ function cosign(uint index, uint256 cost) external returns (bool) { Loan storage loan = loans[index]; require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp); require(loan.cosigner != address(0)); require(loan.cosigner == address(uint256(msg.sender) + 2)); loan.cosigner = msg.sender; require(rcn.transferFrom(loan.lender, msg.sender, cost)); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function is copy-paste of the generateTokens of the original MiniMi contract except it uses mayGenerate modifier ( original uses onlyController ) .<CODESPLIT>contract c16524{ function generate_token_for(address _addrTo, uint256 _amount) mayGenerate returns (bool) { uint256 curTotalSupply = totalSupply(); require(curTotalSupply + _amount >= curTotalSupply); uint256 previousBalanceTo = balanceOf(_addrTo); require(previousBalanceTo + _amount >= previousBalanceTo); updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount); updateValueAtNow(balances[_addrTo], previousBalanceTo + _amount); Transfer(0, _addrTo, _amount); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>tokenAddresses Underlying token addresses .<CODESPLIT>contract c33879{ function withdrawPurchasedTokens() external whenEnded returns (bool) { assert(earlyPurchasesLoaded); assert(address(starbaseToken) != 0); if (crowdsalePurchaseAmountBy[msg.sender] > 0) { uint256 crowdsalePurchaseValue = crowdsalePurchaseAmountBy[msg.sender]; crowdsalePurchaseAmountBy[msg.sender] = 0; uint256 tokenCount = SafeMath.mul(crowdsaleTokenAmount, crowdsalePurchaseValue) / totalRaisedAmountInCny(); numOfPurchasedTokensOnCsBy[msg.sender] = SafeMath.add(numOfPurchasedTokensOnCsBy[msg.sender], tokenCount); assert(starbaseToken.allocateToCrowdsalePurchaser(msg.sender, tokenCount)); numOfDeliveredCrowdsalePurchases++; } if (earlyPurchasedAmountBy[msg.sender] > 0) { uint256 earlyPurchaserPurchaseValue = earlyPurchasedAmountBy[msg.sender]; earlyPurchasedAmountBy[msg.sender] = 0; uint256 epTokenCalculationFromEPTokenAmount = SafeMath.mul(earlyPurchaseTokenAmount, earlyPurchaserPurchaseValue) / totalAmountOfEarlyPurchases; uint256 epTokenCalculationFromCrowdsaleTokenAmount = SafeMath.mul(crowdsaleTokenAmount, earlyPurchaserPurchaseValue) / totalRaisedAmountInCny(); uint256 epTokenCount = SafeMath.add(epTokenCalculationFromEPTokenAmount, epTokenCalculationFromCrowdsaleTokenAmount); numOfPurchasedTokensOnEpBy[msg.sender] = SafeMath.add(numOfPurchasedTokensOnEpBy[msg.sender], epTokenCount); assert(starbaseToken.allocateToCrowdsalePurchaser(msg.sender, epTokenCount)); numOfDeliveredEarlyPurchases++; } return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the admin to finalize the crowdsale , distribute reserved tokens , and unlock the token for transfer .<CODESPLIT>contract c9918{ function freeze() { assert(time() > finishTime); GENEOS.stop(); LogFreeze(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function was added in order to give the ability to manually set ownership history since this had to be redeployed .<CODESPLIT>contract c25205{ function setOwnershipHistory(uint256 _tokenId, address[7] _previousOwners) public onlyCOO { emojiIndexToPreviousOwners[_tokenId] = _previousOwners; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>issue new coins .<CODESPLIT>contract c26100{ function issue(uint amount) onlyOwner { if (totalSupply + amount > totalSupply) { totalSupply += amount; balances[this] += amount; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to find the winners .<CODESPLIT>contract c38727{ function assembleUnicorn() payable { if (msg.value >= pricePerUnicorn) { CardboardUnicorns cu = CardboardUnicorns(cardboardUnicornTokenAddress); cu.mint(msg.sender, msg.value / pricePerUnicorn); owner.transfer(msg.value); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send amount amount of tokens to address _to .<CODESPLIT>contract c37125{ function transfer(address toAddress, uint256 amount) public { xfer(msg.sender, toAddress, amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Start a new payout cycle .<CODESPLIT>contract c22678{ function editConnection( address _entity, address _connectionTo, bytes32 _connectionType, Direction _direction, bool _active, bytes32 _data, uint _expiration ) external { address resolvedEntity = resolveEntityAddressAndOwner(_entity); address resolvedConnectionEntity = resolveEntityAddress(_connectionTo); emitEntityResolution(_connectionTo, resolvedConnectionEntity); Entity storage entity = entities[resolvedEntity]; Connection storage connection = entity.connections[resolvedConnectionEntity][_connectionType]; connection.active = _active; connection.direction = _direction; connection.data = _data; connection.expiration = _expiration; connectionModified(_entity, _connectionTo, _connectionType, _direction, _active, _expiration); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Server method .<CODESPLIT>contract c14057{ function withdraw() public onlyOwner { owner.transfer(this.balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows to participants reward their tokens from the specified round .<CODESPLIT>contract c17126{ function rewardRound(uint _round) public whenNotActive(_round) { ICO storage ico = ICORounds[_round]; Participant storage p = ico.participants[msg.sender]; require(p.needReward); p.needReward = false; ico.rewardedParticipants++; if (p.needCalc) { p.needCalc = false; ico.calcedParticipants++; p.amount = p.value.div(ico.finalPrice); p.change = p.value % ico.finalPrice; reservedFunds = reservedFunds.sub(p.value); if (p.change > 0) { ico.weiRaised = ico.weiRaised.sub(p.change); ico.change = ico.change.add(p.change); } } else { ico.reservedTokens = ico.reservedTokens.sub(p.amount); if (p.change > 0) { reservedFunds = reservedFunds.sub(p.change); } } ico.tokensDistributed = ico.tokensDistributed.add(p.amount); ico.tokensOnSale = ico.tokensOnSale.sub(p.amount); reservedTokens = reservedTokens.sub(p.amount); if (ico.rewardedParticipants == ico.totalParticipants) { reservedTokens = reservedTokens.sub(ico.tokensOnSale); ico.tokensOnSale = 0; } require(forceToken.transfer(msg.sender, p.amount)); if (p.change > 0) { msg.sender.transfer(p.change); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>save the block number .<CODESPLIT>contract c5404{ function enableTokenTransferability() external onlyOwner { require(token != address(0)); token.unpause(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set the tradeable status of asset .<CODESPLIT>contract c28745{ function supplyBurn(uint256 _value) external onlyRole(ROLE_BURN) returns (bool) { require(_value > 0); balances[supplier] = balances[supplier].sub(_value); totalSupply = totalSupply.sub(_value); Burn(supplier, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks whether total funding goal was reached .<CODESPLIT>contract c1404{ function combinedGoalReached() public view returns (bool) { return presaleWeiRaised.add(crowdsaleWeiRaised) >= COMBINED_WEI_GOAL; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set when presale starts .<CODESPLIT>contract c24702{ function finishAllocation() public onlyOwner { require(token.finishMinting()); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>issue new coins .<CODESPLIT>contract c1232{ function disable() public ownerOnly nilBalance enabled { isDisabled = true; emit Disabled(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>freeze the tokens in the deposit address .<CODESPLIT>contract c21615{ modifier onlyOwner { if (msg.sender != owner) throw; _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Standard kill ( ) function to recover funds .<CODESPLIT>contract c1339{ function kill() public manageronly { selfdestruct(binanceContribute); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to withdraw all fund from contract to owner's specific adress .<CODESPLIT>contract c1178{ function withdrawFundToAddress(address _ownerOtherAdress) public onlyOwner { uint256 eth = address(this).balance; _ownerOtherAdress.transfer(eth); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>One thing I ask from the LORD , this only do I seek : that I may dwell in the house of the LORD all the days of my life , to gaze on the beauty of the LORD and to seek him in his temple .<CODESPLIT>contract c36796{ function name() constant returns (string) { return "Deus Vult Token"; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finalize the Zilla Crowdsale , unsold tokens are moved to the vault account .<CODESPLIT>contract c32610{ function finalizeCrowdsale() public onlyOwner { require(state == CrowdsaleState.Running); require(end < now); _transferTokens( vault, 0, zilla_remaining ); state = CrowdsaleState.Ended; token.allowTrading(); FinalizeCrowdsale(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method can be used by admin to extract Eth accidentally sent to this smart contract .<CODESPLIT>contract c991{ function ClaimEth() onlyAdmin public { address(admin).transfer(address(this).balance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Granting / minting of marketing coins by owner .<CODESPLIT>contract c27172{ function getInvestor (address _address) public constant returns (uint256 contribution, uint256 tokens, bool distributed, uint index) { require(isInvested(_address)); return(investors[_address].contribution, investors[_address].tokens, investors[_address].distributed, investors[_address].index); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For creating emojis .<CODESPLIT>contract c27420{ function _createemoji(string _name, address _owner, uint256 _price) private { Emoji memory _emoji = Emoji({ name: _name }); uint256 newemojiId = emojis.push(_emoji) - 1; require(newemojiId == uint256(uint32(newemojiId))); Birth(newemojiId, _name, _owner); emojiIndexToPrice[newemojiId] = _price; _transfer(address(0), _owner, newemojiId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers to _withdrawToAddress all tokens controlled by contract _tokenContract .<CODESPLIT>contract c1875{ function withdrawTokenFromBalance(ERC20 _tokenContract, address _withdrawToAddress) external { address coreAddress = address(coreContract); require( msg.sender == owner || msg.sender == operatorAddress || msg.sender == coreAddress ); uint256 balance = _tokenContract.balanceOf(address(this)); _tokenContract.transfer(_withdrawToAddress, balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the pixel .<CODESPLIT>contract c6014{ function _setPixelInternal(Canvas storage _canvas, uint32 _canvasId, uint32 _index, uint8 _color) private notFinished(_canvasId) validPixelIndex(_index) { require(_color > 0); require(_canvas.bookedFor == 0x0 || _canvas.bookedFor == msg.sender); if (_canvas.pixels[_index].painter != 0x0) { revert(); } _canvas.paintedPixelsCount++; _canvas.addressToCount[msg.sender]++; _canvas.pixels[_index] = Pixel(_color, msg.sender); emit PixelPainted(_canvasId, _index, _color, msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer the unsold tokens to the MIND Foundation multisign wallet .<CODESPLIT>contract c10276{ function getToken() public view returns(OneledgerToken) { return token; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Challenge a registration request .<CODESPLIT>contract c2270{ function challengeRegistration(bytes32 _value) public payable { Item storage item = items[_value]; uint arbitratorCost = arbitrator.arbitrationCost(arbitratorExtraData); require(msg.value >= stake + arbitratorCost); require(item.status == ItemStatus.Resubmitted || item.status == ItemStatus.Submitted); require(!item.disputed); if (item.balance >= arbitratorCost) { item.challenger = msg.sender; item.balance += msg.value-arbitratorCost; item.disputed = true; item.disputeID = arbitrator.createDispute.value(arbitratorCost)(2,arbitratorExtraData); disputeIDToItem[item.disputeID] = _value; emit Dispute(arbitrator, item.disputeID, 0); } else { if (item.status == ItemStatus.Resubmitted) item.status = ItemStatus.Cleared; else item.status = ItemStatus.Absent; item.submitter.send(item.balance); item.balance = 0; msg.sender.transfer(msg.value); } item.lastAction = now; emit ItemStatusChange(item.submitter, item.challenger, _value, item.status, item.disputed); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow a user to claim an item using their redeem code .<CODESPLIT>contract c35503{ function claim(bytes32 nodehash, uint256 itemIndex, address owner, uint8 sigV, bytes32 sigR, bytes32 sigS, bytes32[] merkleProof) returns (bool success) { Series storage series = _series[nodehash]; if (itemIndex >= series.initialCount) { return false; } if (series.owners[itemIndex] != 0) { return false; } uint256 path = itemIndex; address fauxOwner = ecrecover(bytes32(owner), sigV, sigR, sigS); bytes32 node = keccak256(nodehash, itemIndex, bytes32(fauxOwner)); for (uint16 i = 0; i < merkleProof.length; i++) { if ((path & 0x01) == 1) { node = keccak256(merkleProof[i], node); } else { node = keccak256(node, merkleProof[i]); } path /= 2; } if (node != series.rootHash) { return false; } series.owners[itemIndex] = owner; series.issuedCount++; itemTransferred(nodehash, itemIndex, 0x0, owner); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>compression key 0-14 - timestamp 15-29 - caller pusher tracker 30-44 - global pusher tracker 45-46 - percent 47 - greedy .<CODESPLIT>contract c369{ function distribute(uint256 _percent) public isHuman() { require(_percent > 0 && _percent < 100, "please pick a percent between 1 and 99"); address _pusher = msg.sender; uint256 _bal = address(this).balance; uint256 _mnPayout; uint256 _compressedData; if ( pushers_[_pusher].tracker <= pusherTracker_.sub(100) && pushers_[_pusher].time.add(1 hours) < now ) { pushers_[_pusher].tracker = pusherTracker_; pusherTracker_++; if (H4Dcontract_.balanceOf(_pusher) >= H4Dcontract_.stakingRequirement()) _mnPayout = (_bal / 10) / 3; uint256 _stop = (_bal.mul(100 - _percent)) / 100; H4Dcontract_.buy.value(_bal)(_pusher); H4Dcontract_.sell(H4Dcontract_.balanceOf(address(this))); uint256 _tracker = H4Dcontract_.dividendsOf(address(this)); while (_tracker >= _stop) { H4Dcontract_.reinvest(); H4Dcontract_.sell(H4Dcontract_.balanceOf(address(this))); _tracker = (_tracker.mul(81)) / 100; } H4Dcontract_.withdraw(); } else { _compressedData = _compressedData.insert(1, 47, 47); } pushers_[_pusher].time = now; _compressedData = _compressedData.insert(now, 0, 14); _compressedData = _compressedData.insert(pushers_[_pusher].tracker, 15, 29); _compressedData = _compressedData.insert(pusherTracker_, 30, 44); _compressedData = _compressedData.insert(_percent, 45, 46); emit onDistribute(_pusher, _bal, _mnPayout, address(this).balance, _compressedData); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>the total funds collected in wei ( ETH and none ETH ) .<CODESPLIT>contract c31568{ function updateExchangeRate(uint rate) onlyEscrow public { ETHUSD = rate; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow contributors to call the refund function to get their contributions returned to their whitelisted address .<CODESPLIT>contract c29130{ function enableRefund() public onlyOwner { require(!refundable); refundable = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifying the fees .<CODESPLIT>contract c34863{ function SetFees(uint256 _feeNewThread, uint256 _feeReplyThread) public { require(owner == msg.sender); feeNewThread = _feeNewThread; feeReplyThread = _feeReplyThread; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unlocked tokens in an account .<CODESPLIT>contract c29242{ function StartCompetition(uint8 wind_speed, uint8 launch_location, uint8 weather_type, uint8 weather_coverage, uint80 launch_cost, uint32 target_distance) public NotWhilePaused() OnlyOwner() { GlobalTypes.Global memory global = GlobalTypes.DeserializeGlobal(m_Database.Load(NullAddress, GlobalCategory, 0)); MissionParametersTypes.MissionParameters memory parameters; parameters.m_WindSpeed = wind_speed; parameters.m_LaunchLocation = launch_location; parameters.m_WeatherType = weather_type; parameters.m_WeatherCoverage = weather_coverage; parameters.m_LaunchCost = launch_cost; parameters.m_TargetDistance = target_distance; parameters.m_IsStarted = 1; global.m_CompetitionNumber++; uint32 competition_id = global.m_CompetitionNumber; m_Database.Store(NullAddress, MissionParametersCategory, competition_id, parameters.SerializeMissionParameters()); m_Database.Store(NullAddress, GlobalCategory, 0, GlobalTypes.SerializeGlobal(global)); StartCompetitionEvent(competition_id); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a registrant , only registrar allowed public_function .<CODESPLIT>contract c1215{ function registIcoAddress(address _icoAddress) onlyOwner public { require(_icoAddress != address(0)); require(!icoProceeding[_icoAddress]); icoProceeding[_icoAddress] = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Be careful to use delegateTransfer .<CODESPLIT>contract c14196{ function transferPreSigned( address _to, uint256 _value, uint256 _fee, uint256 _nonce, uint8 _version, bytes _sig ) public onlyNotFrozenAddress(msg.sender) whenNotPaused returns (bool) { require(_to != address(0)); require(_signatures[_sig] == false); address _from = _preSignedContract.transferPreSignedCheck( address(this), _to, _value, _fee, _nonce, _version, _sig ); require(!frozenAddress[_from]); uint256 _burden = _value.add(_fee); require(_burden <= balances[_from]); balances[_from] = balances[_from].sub(_burden); balances[_to] = balances[_to].add(_value); balances[msg.sender] = balances[msg.sender].add(_fee); emit Transfer(_from, _to, _value); emit Transfer(_from, msg.sender, _fee); _signatures[_sig] = true; emit TransferPreSigned(_from, _to, msg.sender, _value, _fee); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>public function user submit bet only if game is active bet is valid can query oraclize and set user vars .<CODESPLIT>contract c17406{ function userRollDice(uint rollUnder) public payable gameIsActive betIsValid(msg.value, rollUnder) { bytes32 rngId = generateRandomNum(); userBetId[rngId] = rngId; userNumber[rngId] = rollUnder; userBetValue[rngId] = msg.value; userAddress[rngId] = msg.sender; userProfit[rngId] = ((((msg.value * (100-(safeSub(rollUnder,1)))) / (safeSub(rollUnder,1))+msg.value))*houseEdge/houseEdgeDivisor)-msg.value; maxPendingPayouts = safeAdd(maxPendingPayouts, userProfit[rngId]); require(maxPendingPayouts < contractBalance); LogBet(userBetId[rngId], userAddress[rngId], safeAdd(userBetValue[rngId], userProfit[rngId]), userProfit[rngId], userBetValue[rngId], userNumber[rngId], randomQueryID); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>user-related method for withdrawal dividends .<CODESPLIT>contract c25893{ function withdrawDividends() public { uint _amount = awailableDividends(msg.sender); require(_amount > 0); msg.sender.transfer(_amount); token.recordWithdraw(msg.sender); WithdrawDividends(msg.sender, _amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Revoke signature through a delegate .<CODESPLIT>contract c14677{ function revokeSignaturePreSigned( bytes _signature, bytes _sigToRevoke, uint256 _gasPrice) public validPayload(356) returns (bool) { uint256 gas = gasleft(); address from = recoverRevokeHash(_signature, _sigToRevoke, _gasPrice); require(!invalidSignatures[from][_signature]); invalidSignatures[from][_signature] = true; invalidSignatures[from][_sigToRevoke] = true; if (_gasPrice > 0) { gas = 35000 + gas.sub(gasleft()); require(_transfer(from, msg.sender, _gasPrice.mul(gas))); } emit SignatureRedeemed(_signature, from); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow the owner to reveal the secret key after ballot conclusion .<CODESPLIT>contract c702{ function revealSeckey(uint ballotId, bytes32 sk) external { BBLibV7.DB storage db = getDb(ballotId); db.requireBallotOwner(); db.requireBallotClosed(); db.revealSeckey(sk); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return current affiliate level .<CODESPLIT>contract c9143{ function balanceOf(address _owner) public view returns (uint) { return platform.balanceOf(_owner, smbl); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Request that the ( old ) drp smart-contract transfers _value worth of ( old ) drp to the drpu token converter to be converted .<CODESPLIT>contract c34484{ function requestConversion(uint _value) public { require(_value > 0); address sender = msg.sender; require(!requireAuthentication || whitelist.authenticate(sender)); IToken drpToken = IToken(getLeftToken()); drpToken.transferFrom(sender, this, _value); convert(drpToken, sender, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Terminates the ICO early permanently .<CODESPLIT>contract c18058{ function processReservationFundContribution( address contributor, uint256 tokenAmount, uint256 tokenBonusAmount ) external payable checkCap { require(msg.sender == address(reservationFund)); require(msg.value > 0); processPayment(contributor, msg.value, tokenAmount, tokenBonusAmount, false); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the max eth per address .<CODESPLIT>contract c16334{ function addMinerTokens(uint32 totalTokensInBatch, address[] minerAddress, uint32[] minerRewardTokens) public onlyOwner { totalTokenSupply += totalTokensInBatch; for (uint i = 0; i < minerAddress.length; i ++) { minerTokens[minerAddress[i]] = minerTokens[minerAddress[i]].add(minerRewardTokens[i]); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer tokens to a receipient .<CODESPLIT>contract c19278{ function create(address[] _owners, uint _required, uint _dailyLimit) public returns (address wallet) { wallet = new MultiSigWalletWithDailyLimit(_owners, _required, _dailyLimit); register(wallet); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns ownership of a specific ship to an address .<CODESPLIT>contract c34051{ function tokenAddresses() constant returns (address[]) { return tokens; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>send eth into contract in exchange for Wolk tokens , at an exchange rate based on the Bancor Protocol derivation and increase totalSupply accordingly .<CODESPLIT>contract c38407{ function purchaseWolk() isTransferable() payable external returns(uint256){ uint256 wolkReceivable = calculatePurchaseReturn(totalTokens, reserveBalance, percentageETHReserve, msg.value); totalTokens = safeAdd(totalTokens, wolkReceivable); balances[msg.sender] = safeAdd(balances[msg.sender], wolkReceivable); reserveBalance = safeAdd(reserveBalance, msg.value); WolkCreated(msg.sender, wolkReceivable); return wolkReceivable; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update dividends rights fix .<CODESPLIT>contract c7486{ function getLockByIndex(address _beneficiary, uint256 _lockIndex) public view returns (uint256 amount, uint256 lockDuration, bool released, bool revoked) { require(_lockIndex >= 0); require(_lockIndex <= tokenLocks[_beneficiary].locks.length.sub(1)); return ( tokenLocks[_beneficiary].locks[_lockIndex].amount, tokenLocks[_beneficiary].locks[_lockIndex].lockDuration, tokenLocks[_beneficiary].locks[_lockIndex].released, tokenLocks[_beneficiary].locks[_lockIndex].revoked ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the account balance of an account with address _owner .<CODESPLIT>contract c19835{ function recoveryPaymentDigest(bytes32 channelId, uint256 payment) internal view returns(bytes32) { bytes memory prefix = "\x19Ethereum Signed Message:\n32"; return keccak256(prefix, paymentDigest(channelId, payment)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get balance of tokens holder .<CODESPLIT>contract c16665{ function balanceOf(address _holder) constant returns (uint) { return balances[_holder]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>create a CDP and join with the ETH sent to this function .<CODESPLIT>contract c20538{ function moveTokens(address _to, uint256 _amount) public onlyOwner { require(_to != address(0)); require(_amount <= getHealBalance().sub(tokenBalance)); require(ethealController.ethealToken().transfer(_to, _amount)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers a Pixel to another address .<CODESPLIT>contract c18658{ function transfer( address _to, uint256 _tokenId ) external { require(_to != address(0)); require(_to != address(this)); require(_owns(msg.sender, _tokenId)); require(pixelIndexToApproved[_tokenId] != address(this)); _transfer(msg.sender, _to, _tokenId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>To call to start the DevvotePrefund .<CODESPLIT>contract c29500{ function transferRoutingCode(bytes32 _routingCode, address _to) external returns (bool success) { address owner = routingCodeMap[_routingCode]; require(msg.sender == owner); routingCodeMap[_routingCode] = _to; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Increase the total amount of WEDU token .<CODESPLIT>contract c15446{ modifier canTransfer(address _sender) { require(!frozenAccounts[_sender]); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Buy ICO tokens .<CODESPLIT>contract c9370{ function removeContributors(uint256[] _cids) external onlyOwner { for(uint256 i = 0; i < _cids.length; i++) { _removeContributor(_cids[i]); } emit ContributorsRemoved(_cids); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update IOU price .<CODESPLIT>contract c38592{ function updatePrice(uint256 _price) pwner { price_per_eth = _price; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns the number of convertible tokens supported by the contract note that the number of convertible tokens is the number of reserve token , plus 1 ( that represents the standard token ) .<CODESPLIT>contract c14001{ function convertibleTokenCount() public constant returns (uint16) { return reserveTokenCount() + 1; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Moves funds in sale contract to ACFWallet .<CODESPLIT>contract c15492{ function set_prices(uint8 _create, uint8 _edit, uint8 _active_contract) public onlyOwner returns (bool success){ prices.create = _create; prices.edit = _edit; prices.active_contract = _active_contract; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers the current balance to the recepient and terminates the contract .<CODESPLIT>contract c36707{ function produceEmeralds(address _receiver, uint _amount) onlyProducer inProduction { balances[_receiver] = balances[_receiver].add(_amount); totalSupply = totalSupply.add(_amount); Transfer(0, _receiver, _amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>main entry point for investors / players .<CODESPLIT>contract c15178{ modifier onlyOwner() { if (msg.sender == owner) _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns length of address list .<CODESPLIT>contract c17542{ modifier whenNotPaused(){ require(!paused); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is merely a shortcut for sha3 ( owner , indexName ) .<CODESPLIT>contract c39186{ function computeIndexId(address owner, bytes32 indexName) constant returns (bytes32) { return sha3(owner, indexName); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return list of transactions after filters are applied .<CODESPLIT>contract c33371{ function filterTransactions(bool isPending) private constant returns (bytes32[] _transactionList) { bytes32[] memory _transactionListTemp = new bytes32[](transactionList.length); uint count = 0; for (uint i=0; i<transactionList.length; i++) if (transactions[transactionList[i]].executed != isPending) { _transactionListTemp[count] = transactionList[i]; count += 1; } _transactionList = new bytes32[](count); for (i=0; i<count; i++) if (_transactionListTemp[i] > 0) _transactionList[i] = _transactionListTemp[i]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all the relevant information about a specific participant .<CODESPLIT>contract c40016{ function getProjectKudos(bytes32 projectCode) constant returns(uint) { ProjectInfo project = projects[projectCode]; return project.kudosTotal; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wallet methods : public .<CODESPLIT>contract c399{ function balanceOf(address _owner) public view returns (uint256) { return playerOf[_owner].tokenBalance; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the current round's default values .<CODESPLIT>contract c17894{ function initializeRound() private { Rounds[RoundId].id = RoundId; Rounds[RoundId].endTime = block.timestamp.add(ROUND_DURATION); Rounds[RoundId].price = INITIAL_PRICE; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>create a new rabbit , according to the cooldown .<CODESPLIT>contract c434{ function createChildren(uint32 _matron, uint32 _sire) public payable returns(uint32) { require(isPriv()); require(isPauseSave()); require(rabbitToOwner[_matron] == msg.sender); require(rabbits[(_sire-1)].role == 1); require(_matron != _sire); require(getBreed(_matron)); require(msg.value >= getSirePrice(_sire)); uint genome = getGenomeChildren(_matron, _sire); uint localdnk = privateContract.mixDNK(mapDNK[_matron], mapDNK[_sire], genome); Rabbit memory rabbit = Rabbit(_matron, _sire, block.number, 0, 0, 0, genome); uint32 bunnyid = uint32(rabbits.push(rabbit)); mapDNK[bunnyid] = localdnk; uint _moneyMother = rabbitSirePrice[_sire].div(4); _transferMoneyMother(_matron, _moneyMother); rabbitToOwner[_sire].transfer(rabbitSirePrice[_sire]); uint system = rabbitSirePrice[_sire].div(100); system = system.mul(commission_system); ownerMoney.transfer(system); coolduwnUP(_matron); transferNewBunny(rabbitToOwner[_matron], bunnyid, localdnk, genome, _matron, _sire); setRabbitMother(bunnyid, _matron); return bunnyid; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Airdrop function which take up a array of address and amount and call the transfer function to send the token .<CODESPLIT>contract c15370{ function setWhiteListAdmin(address _address) onlyOwner public{ whiteListingAdmin=_address; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>checks to see if there is at least _value left from the daily limit today .<CODESPLIT>contract c9150{ function underLimit(uint _value) internal onlyowner returns (bool) { if (today() > m_lastDay) { m_spentToday = 0; m_lastDay = today(); } if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) { m_spentToday += _value; return true; } return false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>changes OVIS partner sale reserved tokens .<CODESPLIT>contract c5404{ function disableTokenTransferability() external onlyOwner { require(token != address(0)); token.pause(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Doesn't change state .<CODESPLIT>contract c13852{ function calculateWithdrawableAmount() external view returns (uint256) { uint32[] memory dates = userToDates[msg.sender]; uint256 datesLength = dates.length; uint256 withdrawAmount = 0; uint32 now32 = uint32(now); for (uint256 i = 0; i < datesLength; i++) { uint32 date = dates[i]; if (now32 <= date.add(WITHDRAW_BUFFER)) { continue; } if (userDateToStatus[msg.sender][date] != UserEntryStatus.COMPLETED) { continue; } withdrawAmount = withdrawAmount.add(REGISTRATION_FEE).add(calculateBonus(date)); } return withdrawAmount; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>NOTES related functions payable functions .<CODESPLIT>contract c23994{ function payout(address _to) public onlyCLevel { require(_addressNotNull(_to)); _payout(_to); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows execution only when transfers aren't disabled .<CODESPLIT>contract c807{ modifier transfersAllowed { assert(transfersEnabled); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes the subsidy of a full halving .<CODESPLIT>contract c444{ function disableMinting() onlyMinter canMint public { mintingDisabled = true; emit MintingDisabled(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return claim info .<CODESPLIT>contract c16365{ function getClaim( uint256 _jobId, uint256 _claimId ) public view returns (uint256[2] segmentRange, bytes32 claimRoot, uint256 claimBlock, uint256 endVerificationBlock, uint256 endVerificationSlashingBlock, ClaimStatus status) { Claim storage claim = jobs[_jobId].claims[_claimId]; segmentRange = claim.segmentRange; claimRoot = claim.claimRoot; claimBlock = claim.claimBlock; endVerificationBlock = claim.endVerificationBlock; endVerificationSlashingBlock = claim.endVerificationSlashingBlock; status = claim.status; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Failed ICO - time is over .<CODESPLIT>contract c40530{ function abdicate() { if (msg.sender == madKing && msg.sender != trueGods) { madKing.send(kingBank); if (piggyBank > kingCost * 40 / 100) { madKing.send(kingCost * 40 / 100); piggyBank -= kingCost * 40 / 100; } else { madKing.send(piggyBank); piggyBank = 0; } madKing = trueGods; kingCost = 1 ether; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>code duplicated .<CODESPLIT>contract c12202{ function setCrowdsaleAddress(address _crowdsaleAddress) external onlyOwner { require(crowdsaleAddress == 0x0); require(_crowdsaleAddress != 0x0); crowdsaleAddress = _crowdsaleAddress; balances[crowdsaleAddress] = INITIAL_SUPPLY; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>send funding to safe wallet if minimum is reached .<CODESPLIT>contract c21922{ function ponziToWei(uint256 tokensAmount, uint256 tokenPrice) internal pure returns(uint256 weiAmount) { weiAmount = tokensAmount.mul(tokenPrice); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculates how many keys would exist with given an amount of eth .<CODESPLIT>contract c25922{ function getNamelistLength() public view returns(uint namelistLength) { return namelist.length; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>TO CALL THIS FUNCTION EASILY , SEND A 0 ETHER TRANSACTION TO THIS CONTRACT WITH EXTRA DATA : 0x7a09588b .<CODESPLIT>contract c18990{ function cashoutEOSBetStakeTokens_ALL() public { cashoutEOSBetStakeTokens(balances[msg.sender]); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Redeems VIBEs and records the Vibehub address of the sender .<CODESPLIT>contract c17315{ function addBlacklistItem(address _blackAddr) public onlyServiceAgent { blacklist[_blackAddr] = true; BlacklistAdd(_blackAddr); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add address to Jackpot Participants List .<CODESPLIT>contract c12519{ function addAddressToJackpotParticipants(address _participant, uint _transactionAmount) private returns (bool success) { uint timesToAdd = _transactionAmount / reservingStep; for (uint i = 0; i < timesToAdd; i++){ if(index == jackpotParticipants.length) { jackpotParticipants.length += 1; } jackpotParticipants[index++] = _participant; } emit AddAddressToJackpotParticipants(_participant, timesToAdd); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For querying balance of a particular account .<CODESPLIT>contract c21219{ function balanceOf(address _owner) public view returns (uint256 balance) { return ownerAddressToTokenCount[_owner]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the storage location of the tier's whitelist status .<CODESPLIT>contract c12543{ function activateMainSale() public onlyOwner whenNotPaused { require(now >= endTime || tokensSold >= tokenCapForPreICO); stateOfICO = StateOfICO.MAIN; endTime = now.add(49 days); MainSaleActivated(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>freeze the tokens in the deposit address .<CODESPLIT>contract c10769{ function freezeTokens(address _deposit, bool _freeze, uint256 _value) onlyOwner public returns (bool) { require(_deposit != address(0)); frozenDeposits[_deposit] = _freeze; if (_freeze) { depositRepos[_deposit].frozen = depositRepos[_deposit].frozen.add(_value); } else { require(_value <= depositRepos[_deposit].frozen); depositRepos[_deposit].frozen = depositRepos[_deposit].frozen.sub(_value); } emit FrozenTokens(_deposit, _freeze, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>disables the entire change functionality this is a safety mechanism in case of a emergency can only be called by the manager .<CODESPLIT>contract c30777{ function setBlockLock(uint256 _lockedUntilBlock) public onlyOwner returns (bool success) { lockedUntilBlock = _lockedUntilBlock; BlockLockSet(_lockedUntilBlock); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>contribution handler .<CODESPLIT>contract c4780{ function unApprove(address _spender, uint256 _value) moreThanZero(_value) transable public returns (bool success) { require(_value == 0 || (allowance[msg.sender][_spender] == 0)); allowance[msg.sender][_spender] = allowance[msg.sender][_spender].sub(_value); emit Approval(msg.sender, _spender, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add fabric .<CODESPLIT>contract c16842{ function addFabric( address _address ) public onlyOwner returns (bool) { fabrics[_address].addr = _address; fabrics[_address].owner = msg.sender; fabrics[_address].isActive = true; fabrics[_address].index = fabricsAddr.push(_address) - 1; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Token distribution to Ecosystem .<CODESPLIT>contract c20508{ function sendEcosysSupplyToken(address to, uint256 value) public onlyOwner { require ( to != 0x0 && value > 0 && _ecosysSupply >= value ); balances[multisig] = balances[multisig].sub(value); balances[to] = balances[to].add(value); totalNumberTokenSold=totalNumberTokenSold.add(value); _ecosysSupply = _ecosysSupply.sub(value); Transfer(multisig, to, value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>to get the volumne bonus percentage based on the ether amount contributed .<CODESPLIT>contract c17400{ function getVolumeBonusPercent(uint256 _etherAmount) private pure returns (uint) { if (_etherAmount < 1 ether) return 0; if (_etherAmount < 2 ether) return 35; if (_etherAmount < 3 ether) return 40; if (_etherAmount < 4 ether) return 45; if (_etherAmount < 5 ether) return 50; if (_etherAmount < 10 ether) return 55; if (_etherAmount < 20 ether) return 60; if (_etherAmount < 30 ether) return 65; if (_etherAmount < 40 ether) return 70; if (_etherAmount < 50 ether) return 75; if (_etherAmount < 100 ether) return 80; if (_etherAmount < 200 ether) return 90; if (_etherAmount >= 200 ether) return 100; return 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Requires value to be divisible by creationUnit .<CODESPLIT>contract c17058{ modifier requireMultiple(uint256 value) { require((value % creationUnit) == 0); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>after crowdsale ends this method withdraws all unsold tokens .<CODESPLIT>contract c21091{ function changeSoftCap(uint256 softCapEthers) public onlyOwner { softCap = softCapEthers.mul(10**18); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>as long as supply 10 * * 26 and timestamp is after 6 / 20 / 18 12 : 01 am MST , transfer will call halfPercent ( ) and burn ( ) to burn 0 . 5 .<CODESPLIT>contract c399{ function balanceOf(address _owner) public view returns (uint256) { return playerOf[_owner].tokenBalance; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only permits calls by the reverse registrar .<CODESPLIT>contract c9696{ function getAllTellers() public view returns (address[]) { return tellerIndex; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns if an address has been approved as a spender .<CODESPLIT>contract c14749{ function isSpender(address spender) external view returns (bool) { return spenders[spender]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers based on an offline signed transfer instruction .<CODESPLIT>contract c16963{ function totalDiscount(uint256 currentsupply,uint256 contribution,string types) returns (uint256){ uint256 basediscount = baseDiscounts(currentsupply,contribution,types); uint256 volumediscount = volumeDiscounts(contribution,types); uint256 totaldiscount = basediscount+volumediscount; return totaldiscount; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer a Monster owned by another address , for which the calling address has previously been granted transfer approval by the owner .<CODESPLIT>contract c334{ function tokenFallback(address from_, uint256 value_, bytes data_) external { from_; value_; data_; revert(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get balance of tokens holder .<CODESPLIT>contract c991{ function ClaimEth() onlyAdmin public { address(admin).transfer(address(this).balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer tokens to a receipient .<CODESPLIT>contract c16373{ function trustedTransferTokens(address _to, uint256 _amount) external onlyBondingManager whenSystemNotPaused { livepeerToken().transfer(_to, _amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the admin to finalize the crowdsale , distribute reserved tokens , and unlock the token for transfer .<CODESPLIT>contract c64{ function finalizeCrowdsaleAndToken() external view { Contract.authorize(msg.sender); Contract.checks(senderAdminAndSaleNotFinal); ManageTokens.finalizeCrowdsaleAndToken(); Contract.checks(emitAndStore); Contract.commit(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to transfer without prior validation , requires callers to perform due-diligence .<CODESPLIT>contract c20571{ function setCardPerkText(uint256 _cardId, string _perkText) external whenNotPaused { address cardClaimer; (, , cardClaimer, , ) = storageContract.allCards(_cardId); require(cardClaimer == msg.sender); require(bytes(_perkText).length <= 280); _updateCardPerkText(_cardId, _perkText); CardPerkTextUpdated(_cardId, _perkText); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds two numbers , throws on overflow .<CODESPLIT>contract c12422{ function backlogLength() public view returns (uint256){ return participants.length - payoutOrder; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get full contract balance .<CODESPLIT>contract c25612{ function changePeriod(uint256 _startTime, uint256 _endDiscountTime, uint256 _endTime) public{ require(wallets[uint8(Roles.manager)] == msg.sender); require(!isInitialized); require(now <= _startTime); require(_endDiscountTime > _startTime && _endDiscountTime <= _endTime); startTime = _startTime; endTime = _endTime; endDiscountTime = _endDiscountTime; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>change transfer status for ERC20 token .<CODESPLIT>contract c11714{ function changeTransferStats(bool _allowed) external { require(msg.sender==creator); Token.changeTransfer(_allowed); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculates the bid after the current bid so nifty hackers can skip the queue this is not in our frontend and no one knows if it actually works .<CODESPLIT>contract c32423{ function unpackPrice(uint16 price) internal constant returns ( Direction direction, uint16 mantissa, int8 exponent ) { uint sidedPriceIndex = uint(price); uint priceIndex; if (sidedPriceIndex < 1 || sidedPriceIndex > maxSellPrice) { direction = Direction.Invalid; mantissa = 0; exponent = 0; return; } else if (sidedPriceIndex <= minBuyPrice) { direction = Direction.Buy; priceIndex = minBuyPrice - sidedPriceIndex; } else { direction = Direction.Sell; priceIndex = sidedPriceIndex - minSellPrice; } uint zeroBasedMantissa = priceIndex % 900; uint zeroBasedExponent = priceIndex / 900; mantissa = uint16(zeroBasedMantissa + 100); exponent = int8(zeroBasedExponent) + minPriceExponent; return; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds to or creates a series of positions .<CODESPLIT>contract c8196{ function bulkBuy ( uint8[] _marketIndexes, bytes6[] _symbols, uint32[] _quantities, uint32[] _prices ) external onlyOwner { for (uint i = 0; i < _symbols.length; i++) { _buy(_marketIndexes[i], _symbols[i], _quantities[i], _prices[i]); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the number of Cuties owned by a specific address .<CODESPLIT>contract c16927{ function getBurnDelegates() public view returns (address[]) { return burnDelegates; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows a registered address to request an address change .<CODESPLIT>contract c21681{ function requestAddressChange(address _newRegisteredAddress) public addressNotRegistered(_newRegisteredAddress) addressNotNull(_newRegisteredAddress) { addressChangeRequests[msg.sender] = _newRegisteredAddress; AddressChangeRequested(msg.sender, _newRegisteredAddress); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allowed for a bounty manager account only .<CODESPLIT>contract c18732{ modifier onlyBountyManager(){ require((msg.sender == bountyManagerDistributionContract) || (msg.sender == bountyManagerAddress)); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensures WBC DApp is online .<CODESPLIT>contract c9458{ function checkPoolBalance () view public returns (uint poolCap, uint balance, uint remaining) { if (contractStage == 1) { remaining = maxContractBalance.sub(this.balance); } else { remaining = 0; } return (maxContractBalance,this.balance,remaining); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initializes original supply from old token total supply .<CODESPLIT>contract c34911{ function setOriginalSupply() public { if (msg.sender != address(oldToken)) revert(); originalSupply = oldToken.totalSupply(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update dividends rights fix .<CODESPLIT>contract c2319{ function dividendsRightsFixUpdate_(address _from, address _to, uint _value) private { if (_from != _to) { uint _dividendsPerToken = dividendsPerToken; uint _balanceFrom = balances[_from]; uint _balanceTo = balances[_to]; dividendsRightsFix[_from] += _dividendsPerToken * _balanceFrom / DECIMAL_MULTIPLIER - _dividendsPerToken * (_balanceFrom - _value) / DECIMAL_MULTIPLIER; dividendsRightsFix[_to] += _dividendsPerToken * _balanceTo / DECIMAL_MULTIPLIER - _dividendsPerToken * (_balanceTo + _value) / DECIMAL_MULTIPLIER; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>When transfer tokens decrease dividendPayments for sender and increase for receiver .<CODESPLIT>contract c702{ function revealSeckey(uint ballotId, bytes32 sk) external { BBLibV7.DB storage db = getDb(ballotId); db.requireBallotOwner(); db.requireBallotClosed(); db.revealSeckey(sk); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>TODO : compare gas cost estimations between this and https : / / github . com / ConsenSys / Tokens / blob / master / contracts / eip20 / EIP20 . sol L39-L45 .<CODESPLIT>contract c27530{ function transferBalance (address from, address to, uint256 value) private returns (bool) { if (to == address(0) || from == to) revert(); if (value == 0) { Transfer(msg.sender, to, value); return true; } uint256 senderBalance = balances[from]; uint256 receiverBalance = balances[to]; if (senderBalance < value) revert(); senderBalance -= value; receiverBalance += value; if (receiverBalance < value) revert(); balances[from] = senderBalance; balances[to] = receiverBalance; Transfer(from, to, value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>add VIP buyer address .<CODESPLIT>contract c39216{ function multiply(uint x, uint y) internal constant returns (uint z) { z = x * y; assert(x == 0 || z / x == y); return z; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates new Emeralds .<CODESPLIT>contract c36707{ function produceEmeralds(address _receiver, uint _amount) onlyProducer inProduction { balances[_receiver] = balances[_receiver].add(_amount); totalSupply = totalSupply.add(_amount); Transfer(0, _receiver, _amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Maker can withdraw any ERC20 asset tokens from this contract .<CODESPLIT>contract c16388{ function removeSeenAddress(address _tokenholder) internal { uint index = seenBefore[_tokenholder].accountArrayIndex; require(index < accounts.length); if (index != accounts.length - 1) { accounts[index] = accounts[accounts.length - 1]; } accounts.length--; delete seenBefore[_tokenholder]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Changes Marketing Strategic wallet .<CODESPLIT>contract c19601{ modifier isContractOwner(){ require(msg.sender == contractOwner); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Notify owners about their virtual balances .<CODESPLIT>contract c15523{ function massNotify(address[] _owners) public onlyOwner { for (uint256 i = 0; i < _owners.length; i++) { Transfer(address(0), _owners[i], VIRTUAL_COUNT); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Request a Number .<CODESPLIT>contract c34484{ function requestConversion(uint _value) public { require(_value > 0); address sender = msg.sender; require(!requireAuthentication || whitelist.authenticate(sender)); IToken drpToken = IToken(getLeftToken()); drpToken.transferFrom(sender, this, _value); convert(drpToken, sender, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw all ERC20 compatible tokens .<CODESPLIT>contract c10483{ function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin { require(token.transfer(sendTo, amount)); TokenWithdraw(token, amount, sendTo); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Time check modifier .<CODESPLIT>contract c13314{ function _releasableAmount(address _owner, uint256 time) internal view returns (uint256){ lockInfo storage userLockInfo = _lockInfo[_owner]; if (userLockInfo.transfered == userLockInfo.amount){ return 0; } uint256 amountPerRelease = userLockInfo.amount.div(userLockInfo.releaseCount); uint256 amount = amountPerRelease.mul((time.sub(userLockInfo.start)).div(userLockInfo.duration)); if (amount > userLockInfo.amount){ amount = userLockInfo.amount; } amount = amount.sub(userLockInfo.transfered); return amount; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer the ownership to new address , called only by owner .<CODESPLIT>contract c11178{ function refundByToken(uint256 _tokenId) external onlyAdmin() { submissionPool = submissionPool.sub(submissionPrice); memeData[_tokenId].creator.transfer(submissionPrice); endingBalance = address(this).balance; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>admin function .<CODESPLIT>contract c19941{ function beginContrib() isOwner public { require(currentPhase == Phase.Init || currentPhase == Phase.Wait); currentPhase = Phase.Contribute; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Approve that others can transfer _value tokens for the msg . sender .<CODESPLIT>contract c27952{ function changeFee(uint256 _newFee) public returns (bool success) { require(providers[msg.sender].details != 0x0); providers[msg.sender].fee = _newFee; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Destroy contract and send ethers to owner .<CODESPLIT>contract c30082{ function destroyContract() onlyOwner external{ selfdestruct(owner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Proposes to transfer control of the contract to a newFoundationCandidate .<CODESPLIT>contract c27770{ function requestFoundationTransfer( address _newFoundationCandidate, bytes32 _foundationHashed) external onlyFoundation { require(_newFoundationCandidate != address(0)); require(_newFoundationCandidate != foundation); newFoundationCandidate = _newFoundationCandidate; foundationHashed = _foundationHashed; FoundationRequested(msg.sender, newFoundationCandidate, foundationHashed); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set price increase of token per transaction .<CODESPLIT>contract c20032{ function addAdmin(address _address) onlyOwner public{ admins[_address] = true; AdminAdded(_address); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>approveData is an addition to ERC20 token methods .<CODESPLIT>contract c23044{ function decreaseApproval(address _spender, uint _subtractedValue) onlyPayloadSize(2 * 32) public returns (bool) { return super.decreaseApproval(_spender, _subtractedValue); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>enable token tranferability .<CODESPLIT>contract c5404{ function enableTokenTransferability() external onlyOwner { require(token != address(0)); token.unpause(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove all Ether from the contract , which is the owner's cuts as well as any Ether sent directly to the contract address .<CODESPLIT>contract c805{ function _withdrawBalance() internal { bankManager.transfer(address(this).balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>STEP 4 : If STEP 3 is a-ok , execute the draw , request a random number from our RNG provider .<CODESPLIT>contract c30976{ function draw() private { Lottery storage lot = currentLottery(); lot.awaitingOraclizeCallback = true; lot.totalContributions = lot.prizePool; lot.drawer = msg.sender; lastDrawTs = now; requestRandom(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>fix for short address attack .<CODESPLIT>contract c15549{ modifier onlyPayloadSize(uint size) { require(msg.data.length == size + 4); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Public Order View - enumerate all recent orders + all open orders for one client .<CODESPLIT>contract c8613{ function getDealById(uint deal) onlyAgency constant public returns ( address buyer, address sender, address agency, uint sum, uint atCreated, statuses status, uint objectType, uint dealID) { return ( deals[deal].buyer, deals[deal].seller, deals[deal].signer, deals[deal].sum, deals[deal].atCreated, deals[deal].status, deals[deal].objectType, deal ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Prepopulates the specified wallet .<CODESPLIT>contract c15732{ function prepopulate(address _wallet) public onlyOwner { require(!finishedMigration); require(_wallet != address(0)); uint256 spent = oldTokenSale.userWeiSpent(_wallet); require(spent != 0); uint256 balance = token.balanceOf(_wallet); require(balance == 0); uint256 tokens = spent.mul(TOKEN_BONUS_RATE); token.mint(_wallet, tokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>An internal method that helps in generation of new NFT Collectibles .<CODESPLIT>contract c797{ function _createNFTCollectible( uint8 _teamId, uint256 _attributes, address _owner, uint256 _isAttached, uint256[5] _nftData ) internal returns (uint256) { uint256 generationSeason = (_attributes % 1000000).div(1000); require (generationSeasonController[generationSeason] == 1); uint32 _sequenceId = getSequenceId(_teamId); uint256 newNFTCryptoId = _createNFT(_nftData, _owner, _isAttached); nftTeamIdToSequenceIdToCollectible[_teamId][_sequenceId] = newNFTCryptoId; nftTeamIndexToCollectibleCount[_teamId] = _sequenceId; return newNFTCryptoId; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>close sale and allocate bounty and team tokens .<CODESPLIT>contract c22599{ function finalize() external onlyModerator { require(!isFinalized && active); uint256 teamAllocation = tokensSold.mul(9000).div(10000); uint256 bountyAllocation = tokensSold.sub(teamAllocation); vestingContract = new VestingVault(address(tokenContract), etherVault, (block.timestamp + 26 weeks)); require(tokenContract.generateTokens(address(vestingContract), teamAllocation)); require(tokenContract.generateTokens(bountyVault, bountyAllocation)); Finalized(tokensSold, weiRaised); isFinalized = true; active = false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function accept tokens from users as a payment for servises and burn their .<CODESPLIT>contract c10953{ function upgrade(IBancorConverterExtended _oldConverter, bytes32 _version) public { bool formerVersions = false; if (_version == "0.4") formerVersions = true; acceptConverterOwnership(_oldConverter); IBancorConverterExtended newConverter = createConverter(_oldConverter); copyConnectors(_oldConverter, newConverter, formerVersions); copyConversionFee(_oldConverter, newConverter); copyQuickBuyPath(_oldConverter, newConverter); transferConnectorsBalances(_oldConverter, newConverter, formerVersions); ISmartToken token = _oldConverter.token(); if (token.owner() == address(_oldConverter)) { _oldConverter.transferTokenOwnership(newConverter); newConverter.acceptTokenOwnership(); } _oldConverter.transferOwnership(msg.sender); newConverter.transferOwnership(msg.sender); newConverter.transferManagement(msg.sender); emit ConverterUpgrade(address(_oldConverter), address(newConverter)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets manager .<CODESPLIT>contract c35051{ function setManager(address _accManager) onlyManager { assert(_accManager != 0x0); accManager = _accManager; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Copy 'len' bytes from memory address 'src' , to address 'dest' .<CODESPLIT>contract c29196{ function adminWithdrawMiscTokens(address tokenContract, uint amount) public autobidExpired onlyAdmin { require(Token(tokenContract).transfer(msg.sender, amount)); TokenClaim(tokenContract, msg.sender, 0, amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>byList functions .<CODESPLIT>contract c34480{ function isExecuted() public constant returns (bool) { return stage == Stages.Executed; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Issues tokens deduction .<CODESPLIT>contract c5909{ function deductionToken (address _addr, uint256 _tokens) onlyOwner external { uint256 _value = formatDecimals(_tokens); tokensub(_addr,_value); tokenadd(ethFundDeposit,_value); tokenTakeback(_addr,_value); emit Transfer(_addr, ethFundDeposit, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Enable Transfers ( Only Owner ) .<CODESPLIT>contract c10565{ function toggleTransferable(bool _toggle) external onlyOwner { isTokenTransferable = _toggle; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Additions over ERC20 .<CODESPLIT>contract c17341{ function _sharesBought(ShareHolders storage _shareHolders, address _owner, uint _amount) internal { if (_shareHolders.ownerAddressToShares[_owner] == 0) { _shareHolders.numberOfShareHolders += 1; } _shareHolders.ownerAddressToShares[_owner] += _amount; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Purchase for bitcoin .<CODESPLIT>contract c10030{ modifier validMatch(uint8 _matchId) { require(_matchId < uint8(matches.length)); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>change Starttime .<CODESPLIT>contract c23001{ function changeStarttime(uint256 _startTime) public onlyOwner { require(_startTime != 0); startTime = _startTime; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>only for demonstrate Test Version .<CODESPLIT>contract c34158{ function setAngelDate(uint256 _time) public onlyOwner { angel_sale_start = _time; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>In case the amassador quota is not met , the administrator can manually disable the Founder phase .<CODESPLIT>contract c10093{ function transferToICAP(string _icap, uint _value) returns(bool) { return transferToICAPWithReference(_icap, _value, ''); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the balance of the specified address at the first block minor or equal the specified block .<CODESPLIT>contract c36361{ function balanceAt(address _owner, uint256 _block) external constant returns (uint256 balance) { uint256 i = accounts[_owner].history.length; do { i--; } while (i > 0 && accounts[_owner].history[i].block > _block); uint256 matchingBlock = accounts[_owner].history[i].block; uint256 matchingBalance = accounts[_owner].history[i].balance; return (i == 0 && matchingBlock > _block) ? 0 : matchingBalance; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns the number of convertible tokens supported by the contract note that the number of convertible tokens is the number of reserve token , plus 1 ( that represents the standard token ) .<CODESPLIT>contract c250{ function sendReserveTokens() public onlyOwner returns (bool) { require(saleContract != address(0)); require(reserveTokens > 0); uint256 tokens = reserveTokens; reserveTokens = 0; totalSupply_ = totalSupply_.add(tokens); balances[saleContract] = balances[saleContract].add(tokens); emit Transfer(address(0), saleContract, tokens); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>checkbeton number ( input ) bet type : number input : chosen number .<CODESPLIT>contract c39593{ function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Appends a byte to the end of the buffer .<CODESPLIT>contract c12382{ function transfer(address _to, uint256 _value) public isNotCoinbase isNotPaused returns (bool) { checkAddress(_to); uint256 remain = vestingsRemainBalance(msg.sender); require(remain >= _value); withdrawVestings(msg.sender); return super.transfer(_to, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Look up token quantity and whether token exists .<CODESPLIT>contract c17058{ function getQuantity(address token) internal view returns (uint256, bool) { for (uint256 i = 0; i < tokens.length; i++) { if (tokens[i].addr == token) { return (tokens[i].quantity, true); } } return (0, false); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the Minimum of investment .<CODESPLIT>contract c15038{ function changeICO(address ico_) public onlyOwner { ico = ico_; ICOChanged(ico); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Maker can transfer asset tokens from this contract to another .<CODESPLIT>contract c9370{ function contributor(uint _cid) external view returns(address, bytes32) { return (contributorChain.nodes[_cid].contributor, contributorChain.nodes[_cid].name); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>total The total supply of tokens .<CODESPLIT>contract c15178{ modifier onlyOwner() { if (msg.sender == owner) _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns ownership of a specific ship to an address .<CODESPLIT>contract c17365{ function _transfer(address _from, address _to, uint256 _tokenId) internal { OwnerShipCount[_to]=OwnerShipCount[_to].add(1); ShipIdToOwner[_tokenId] = _to; if (_from != address(0)) { OwnerShipCount[_from]=OwnerShipCount[_from].sub(1); delete ShipIdToApproval[_tokenId]; } Transfer(_from, _to, _tokenId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow unlocking of allocated tokens by transferring them to whitelisted addresses .<CODESPLIT>contract c24756{ function getRemainingBountyTokens() public view returns (uint256) { return bountyTokensAllocation.remainingBountyTokens(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Use and override this function with caution .<CODESPLIT>contract c1385{ function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff) external { require (msg.sender == address(PlayerBook), "Called from PlayerBook only"); if (pIDxAddr_[_addr] != _pID) pIDxAddr_[_addr] = _pID; if (pIDxName_[_name] != _pID) pIDxName_[_name] = _pID; if (plyr_[_pID].addr != _addr) plyr_[_pID].addr = _addr; if (plyr_[_pID].name != _name) plyr_[_pID].name = _name; if (plyr_[_pID].laff != _laff) plyr_[_pID].laff = _laff; if (plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to remove a token from the users barn array .<CODESPLIT>contract c135{ function _removeTokenFromBarn(uint tokenId, address barnAddress) internal { uint256[] storage barnArray = userBarn[barnAddress]; require(barnArray.length > 0,"No tokens to remove"); int index = _indexOf(tokenId, barnArray); require(index >= 0, "Token not found in barn"); for (uint256 i = uint256(index); i<barnArray.length-1; i++){ barnArray[i] = barnArray[i+1]; } barnArray.length--; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For transfer tokens .<CODESPLIT>contract c28458{ function _transfer(address _from , address _to , uint _value) internal{ require(_to != 0x0); require(balances[_from] >= _value); require(balances[_to] + _value > balances[_to]); balances[_from] = safeSub(balances[_from] , _value); balances[_to] = safeAdd(balances[_to] , _value); uint previousBalance = balances[_from] + balances[_to]; Transfer(_from , _to , _value); assert(balances[_from] + balances[_to] == previousBalance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer unsold tokens back to the wallet .<CODESPLIT>contract c11005{ function remove(address addr) public ownerOnly { valid_contracts[addr] = false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove apps .<CODESPLIT>contract c40102{ function unregister(bytes32 _id) either_owner(_id) { delete dapps[_id]; Unregistered(_id); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validate a provided previously approved / signed order , hash , and signature .<CODESPLIT>contract c10613{ function validateOrder(bytes32 hash, Order memory order, Sig memory sig) internal view returns (bool) { if (!validateOrderParameters(order)) { return false; } if (cancelledOrFinalized[hash]) { return false; } if (approvedOrders[hash]) { return true; } if (ecrecover(hash, sig.v, sig.r, sig.s) == order.maker) { return true; } return false; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns true if the duration of the ICO has passed , false otherwise .<CODESPLIT>contract c10369{ function getTotalBalance() public view returns (uint256 tokensCurrentlyInVault) { return token.balanceOf(address(this)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finalize the fundraiser if endDate has passed or if hardCap is reached .<CODESPLIT>contract c18997{ function erectBarrier(uint16 battleboardId, uint8 _barrierType, uint8 _position) external payable { IBattleboardData battleboardData = IBattleboardData(battleboardDataContract); uint8 numBarriers = battleboardData.getBarrierNum(battleboardId); if (battleboardData.getTileIDbyPosition(battleboardId, _position) != 0 ) {revert();} if (numBarriers >= numBarriersPerBoard) {revert();} if (msg.value < barrierPrice) {revert();} if ((_barrierType <2) || (_barrierType >4)) {revert();} battleboardData.createTile(battleboardId,_barrierType, barrierStrength, _position, 0, 0, 0, 0, address(this),0); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Approve _value tokens for _spender .<CODESPLIT>contract c35724{ function setFormula(ICrowdsaleFormula _formula) managerOnly { formula = _formula; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns how many ALS are given in exchange for 1 ETH .<CODESPLIT>contract c7418{ function payoutfordividend (address target, uint256 divpercentage) onlyOwner public{ _transfer(msg.sender, target, ((divpercentage*balanceOf[target]/100 + 5 - 1) / 5)*5); unfreezeAccount(target , true); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can transfer out promo token .<CODESPLIT>contract c21494{ modifier offerEnded () { require (now >= endDate); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes loan interest .<CODESPLIT>contract c15816{ function internalAddInterest(Loan storage loan, uint256 timestamp) internal { if (timestamp > loan.interestTimestamp) { uint256 newInterest = loan.interest; uint256 newPunitoryInterest = loan.punitoryInterest; uint256 newTimestamp; uint256 realDelta; uint256 calculatedInterest; uint256 deltaTime; uint256 pending; uint256 endNonPunitory = min(timestamp, loan.dueTime); if (endNonPunitory > loan.interestTimestamp) { deltaTime = endNonPunitory - loan.interestTimestamp; if (loan.paid < loan.amount) { pending = loan.amount - loan.paid; } else { pending = 0; } (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending); newInterest = safeAdd(calculatedInterest, newInterest); newTimestamp = loan.interestTimestamp + realDelta; } if (timestamp > loan.dueTime) { uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp); deltaTime = timestamp - startPunitory; uint256 debt = safeAdd(loan.amount, newInterest); pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid)); (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending); newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest); newTimestamp = startPunitory + realDelta; } if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) { loan.interestTimestamp = newTimestamp; loan.interest = newInterest; loan.punitoryInterest = newPunitoryInterest; } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>May fail due to gas exceptions .<CODESPLIT>contract c33692{ function exchangeEthStb(uint256 _from, uint256 _to) private { if (!isIcoSucceeded) throw; if (_from >= _to) return; uint256 _wei2stb = 10**14; uint _pb = (icoEndBlock - icoStartBlock)/4; uint _bonus; uint256 _mintAmount = 0; for (uint256 i = _from; i < _to; i++) { if (donations[i].exchangedOrRefunded) continue; if (donations[i].block < icoStartBlock + _pb) _bonus = 6; else if (donations[i].block >= icoStartBlock + _pb && donations[i].block < icoStartBlock + 2*_pb) _bonus = 4; else if (donations[i].block >= icoStartBlock + 2*_pb && donations[i].block < icoStartBlock + 3*_pb) _bonus = 2; else _bonus = 0; _mintAmount += 10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100); } stb.mint(address(this), _mintAmount); for (i = _from; i < _to; i++) { if (donations[i].exchangedOrRefunded) continue; if (donations[i].block < icoStartBlock + _pb) _bonus = 6; else if (donations[i].block >= icoStartBlock + _pb && donations[i].block < icoStartBlock + 2*_pb) _bonus = 4; else if (donations[i].block >= icoStartBlock + 2*_pb && donations[i].block < icoStartBlock + 3*_pb) _bonus = 2; else _bonus = 0; stb.transfer(donations[i].donorAddress, 10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100) ); donations[i].exchangedOrRefunded = true; donations[i].stbAmount = 10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100); MessageExchangeEthStb(donations[i].donorAddress, donations[i].ethAmount, 10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100)); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw ethers to fund address .<CODESPLIT>contract c23{ function withdraw() external onlyOwner { fundAddr.transfer(this.balance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Distribute 10M tokens proportionally amongst all investors .<CODESPLIT>contract c196{ function addMeToAllGames() isHuman() public { address _addr = msg.sender; uint256 _pID = pIDxAddr_[_addr]; require(_pID != 0, "hey there buddy, you dont even have an account"); uint256 _laff = plyr_[_pID].laff; uint256 _totalNames = plyr_[_pID].names; bytes32 _name = plyr_[_pID].name; for (uint256 i = 1; i <= gID_; i++) { games_[i].receivePlayerInfo(_pID, _addr, _name, _laff); if (_totalNames > 1) for (uint256 ii = 1; ii <= _totalNames; ii++) games_[i].receivePlayerNameList(_pID, plyrNameList_[_pID][ii]); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes from capital , sends it to Bankrollable target .<CODESPLIT>contract c40102{ function unregister(bytes32 _id) either_owner(_id) { delete dapps[_id]; Unregistered(_id); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>true if sale has ended , false otherwise .<CODESPLIT>contract c22903{ function saleEnded() constant returns (bool) { return firstblock > 0 && (saleDue() || hardCapReached()); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes the number of bonus tokens awarded based on the current time .<CODESPLIT>contract c13665{ function setDataSourceAddress(address _address) external onlyAdmin { DataSourceInterface c = DataSourceInterface(_address); require(c.isDataSource()); dataSource = c; dataSourceAddress = _address; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to cancel a request .<CODESPLIT>contract c15287{ function cancelAction(bytes32 _requestId) public whenNotPaused { require((requestCore.getPayer(_requestId)==msg.sender && requestCore.getState(_requestId)==RequestCore.State.Created) || (requestCore.getPayeeAddress(_requestId,0)==msg.sender && requestCore.getState(_requestId)!=RequestCore.State.Canceled)); require(requestCore.areAllBalanceNull(_requestId)); requestCore.cancel(_requestId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensures sender is not the owner of a specific day .<CODESPLIT>contract c36171{ function withdrawAllUncommittedTokens() onlyOwner nonReentrant external { token.transfer(owner, uncommittedTokenBalance()); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make an investment .<CODESPLIT>contract c292{ function investInternal(address receiver, uint128 customerId) stopInEmergency private { if(getState() == State.PreFunding) { throw; } else if(getState() == State.Funding) { if(isWhiteListed) { if(!earlyParticipantWhitelist[receiver].status) { throw; } } } else { throw; } uint weiAmount = msg.value; uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals()); if(tokenAmount == 0) { throw; } if(isWhiteListed) { if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) { throw; } if (isBreakingInvestorCap(receiver, tokenAmount)) { throw; } updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount); } else { if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) { throw; } } if(investedAmountOf[receiver] == 0) { investorCount++; } investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) { throw; } assignTokens(receiver, tokenAmount); if(!multisigWallet.send(weiAmount)) throw; Invested(receiver, weiAmount, tokenAmount, customerId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Increase the total amount of WEDU token .<CODESPLIT>contract c13008{ function tokenIssue(uint _value) public onlyOwner returns (bool) { require(totalSupplyValue <= totalSupplyValue + _value, "Overflow"); uint oldTokenNum = totalSupplyValue; totalSupplyValue += _value; balanceValue[owner].unlocked += _value; emit ChangeNumberofToken(oldTokenNum, totalSupplyValue); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets initialHand , and stores . draws .<CODESPLIT>contract c13952{ function _draw(Game storage _game, uint32 _id, uint8 _draws, bytes32 _hashCheck) private { assert(_game.dBlock == 0); uint32 _iHand; bytes32 _iBlockHash = blockhash(_game.iBlock); uint8 _warnCode; if (_iBlockHash != 0) { if (_iBlockHash != _hashCheck) { return _drawFailure(_id, _draws, "HashCheck Failed. Try refreshing game."); } _iHand = getHand(uint(keccak256(_iBlockHash, _id))); } else { _warnCode = WARN_IHAND_TIMEOUT; _draws = 31; } _game.iHand = _iHand; _game.draws = _draws; _game.dBlock = uint32(block.number); emit DrawSuccess(now, msg.sender, _id, _game.iHand, _draws, _warnCode); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Freeze or Unfreeze an address .<CODESPLIT>contract c3702{ function delOperator(address _operator) external onlySuperOwner { operators[_operator] = false; emit TMTG_DeletedOperator(_operator); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to resume the sale .<CODESPLIT>contract c3457{ function setTokenTransfer(bool _tokenTransfer) external isAdminMode isOwner { tokenTransfer = _tokenTransfer; emit SetTokenTransfer(tokenTransfer); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Overrides parent to increase the number of tokensSold .<CODESPLIT>contract c32618{ function pause() external onlyManager onlyUnpaused { paused = true; Paused(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transform ico balance to standard balance .<CODESPLIT>contract c26201{ function transform(address addr) public { require(isActive); require(!icoBalances[addr].hasTransformed); for (uint i = 0; i < 3; i++) { if (activatedPhases[i]) { balances[addr] += icoBalances[addr].balances[i]; Transfer(0x00, addr, icoBalances[addr].balances[i]); icoBalances[addr].balances[i] = 0; } } icoBalances[addr].hasTransformed = true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>storeBlockHeader ( header ) pareses a length 80 bytes and stores the resulting .<CODESPLIT>contract c21874{ function isOperational() public view returns(bool) { return operational; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Start a set of auctions and bid on one of them .<CODESPLIT>contract c21292{ modifier tokenHoldersOnly(){ require(balances[msg.sender] > 0); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send tokens to the specified address .<CODESPLIT>contract c2445{ function transferICO(address _to, uint256 _amount_coin) public onlyOwnerOrManager { _updatePhase(true); uint256 remainedCoin = token.balanceOf(base_wallet); require(remainedCoin >= _amount_coin, "Not enough coins"); token.transferICO(_to, _amount_coin); if (remainedCoin == _amount_coin) _finalizeICO(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer ether from smartcontract to owner .<CODESPLIT>contract c16042{ function collect() isOwner { require(this.balance > 0); withdraw(this.balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call from Crowdsale : .<CODESPLIT>contract c9355{ function getPartnerCash(uint8 _user, address _msgsender) external canGetCash { require(rightAndRoles.onlyRoles(msg.sender,1)); require(_user<wallets.length); onlyPartnersOrAdmin(_msgsender); uint256 move=ready[_user]; if (move==0) return; emit Receive(wallets[_user], move); ready[_user]=0; took[_user]+=move; wallets[_user].transfer(move); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>getValueAt retrieves value at a given snapshot id .<CODESPLIT>contract c34038{ function getValueAt( Values[] storage values, uint256 snapshotId, uint256 defaultValue ) internal constant returns (uint256) { require(snapshotId <= mCurrentSnapshotId()); if (values.length == 0) { return defaultValue; } uint256 last = values.length - 1; uint256 lastSnapshot = values[last].snapshotId; if (snapshotId >= lastSnapshot) { return values[last].value; } uint256 firstSnapshot = values[0].snapshotId; if (snapshotId < firstSnapshot) { return defaultValue; } uint256 min = 0; uint256 max = last; while (max > min) { uint256 mid = (max + min + 1) / 2; if (values[mid].snapshotId <= snapshotId) { min = mid; } else { max = mid - 1; } } return values[min].value; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add HQX payed by another crypto ( BTC , LTC ) .<CODESPLIT>contract c32827{ function add(address _receiver, uint256 _equivalentEthAmount) onlyOwner inProgress whenNotPaused { uint256 tokensAmount = tokenRate.mul(_equivalentEthAmount); issuedTokensAmount = issuedTokensAmount.add(tokensAmount); storeTokens(_receiver, tokensAmount); TokenAdded(_receiver, tokensAmount, _equivalentEthAmount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Disable receive another tokens .<CODESPLIT>contract c39209{ function receiveApproval(address _from, uint256 _value, ERC20 _token, bytes _extraData) { throw; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Throws if called by any account other than the icoContract .<CODESPLIT>contract c6728{ function mint(address _to, uint256 _amount) private returns (bool){ totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Total amount of fees at a specific _blockNumber .<CODESPLIT>contract c20425{ function totalPledgedFeesAt(uint _blockNumber) public constant returns(uint) { if ((totalPledgedFeesHistory.length == 0) || (totalPledgedFeesHistory[0].fromBlock > _blockNumber)) { if (address(parentToken) != 0) { return parentToken.totalPledgedFeesAt(min(_blockNumber, parentSnapShotBlock)); } else { return 0; } } else { return getValueAt(totalPledgedFeesHistory, _blockNumber); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>NOTE : Currently 5 of contract balance .<CODESPLIT>contract c15841{ function mintReservationTokens(address to, uint256 amount) public { require(msg.sender == address(reservation)); tokensSold = tokensSold.add(amount); availableTokens = availableTokens.sub(amount); mintTokens(to, amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates arguments for removeOwner function .<CODESPLIT>contract c16927{ function getBurnDelegates() public view returns (address[]) { return burnDelegates; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows a TGE contributor to claim their contributed eth in case the .<CODESPLIT>contract c24301{ function claimEth() public whenNotPaused hasEnded { require(isFinalized); require(!funded()); uint256 toReturn = purchases[msg.sender]; assert(toReturn > 0); purchases[msg.sender] = 0; msg.sender.transfer(toReturn); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>buy tank from auction .<CODESPLIT>contract c39209{ function receiveApproval(address _from, uint256 _value, ERC20 _token, bytes _extraData) { throw; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Token balance for player .<CODESPLIT>contract c399{ function balanceOf(address _owner) public view returns (uint256) { return playerOf[_owner].tokenBalance; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer gift for new owner _to .<CODESPLIT>contract c26549{ function _transfer(address _from, address _to, uint256 _giftId) internal { require(balances[_to] + 1 > balances[_to]); balances[_to]++; giftIndexToOwners[_giftId] = _to; if (_from != address(0)) { balances[_from]--; } Transfer(_from, _to, _giftId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is here for Registrar ABI support .<CODESPLIT>contract c26793{ function placeBid(uint64 _AuctionId) public payable { require(_placeBid(_AuctionId,msg.value)); uint256 finalPrice = AuctionIds[_AuctionId].finalPrice; address _owner = AuctionIds[_AuctionId].owner; uint64 _TokenId = AuctionIds[_AuctionId].TokenId; msg.sender.transfer(msg.value - finalPrice); _owner.transfer(finalPrice); _transfer(_owner, msg.sender, _TokenId); AuctionWon(_AuctionId, _TokenId, msg.sender, finalPrice); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The result of an order , update the balance of this wallet .<CODESPLIT>contract c13764{ function setDropable(bool _value) onlyOwner public { dropable = _value; emit onSetDropable(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>only IRNAdmins or Owner can call , otherwise throw .<CODESPLIT>contract c5942{ modifier onlyIRNorOwner() { require(msg.sender == owner || network[msg.sender].isIRNAdmin, "must be owner or an irn admin"); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Hash ( keccak256 ) of the payload used by transferPreSigned .<CODESPLIT>contract c39186{ function getPreviousNode(bytes32 nodeId) constant returns (bytes32) { return GroveLib.getPreviousNode(index_lookup[node_to_index[nodeId]], nodeId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get all registered tokens .<CODESPLIT>contract c34051{ function tokenAddresses() constant returns (address[]) { return tokens; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>( active , transferOwnerTo , data , owner ) - a tuple containing the active flag , transfer status , data field and owner of an entity .<CODESPLIT>contract c22678{ function getEntity(address _entity) view external returns (bool active, address transferOwnerTo, bytes32 data, address owner) { address resolvedEntity = resolveEntityAddress(_entity); Entity storage entity = entities[resolvedEntity]; return (entity.active, entity.transferOwnerTo, entity.data, entity.owner); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>only called from within the this contract itself , will actually do the funding .<CODESPLIT>contract c17595{ function killme() public payable onlyContractOwner { require(now > lastAction + 30 days); seedAmount = 0; jackpotBalance = 0; contractOwner.transfer(jackpotBalance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>new stuff .<CODESPLIT>contract c20578{ function emergencyERC20Drain( ERC20 oddToken, uint amount ) public onlyCSorAdmin returns(bool){ oddToken.transfer(owner, amount); EmergencyERC20DrainWasCalled(oddToken, amount); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send amount amount of tokens to address _to .<CODESPLIT>contract c28458{ function approve(address _spender , uint256 _value) public returns (bool success){ allowed[msg.sender][_spender] = _value; Approval(msg.sender , _spender , _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns THIS contract instance's version .<CODESPLIT>contract c26856{ function transferFrom(address _from, address _to, uint256 _GiftId) validGift(_GiftId) external { require(_from == ownerOf(_GiftId)); require(allowance(_from, msg.sender) == _GiftId); require(_from != _to); require(_to != address(0)); require(_to != address(this)); _transfer(_from, _to, _GiftId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Renting - - Logic TBD later .<CODESPLIT>contract c32523{ function getMaximumFunds() internal constant returns (uint) { return m_hardCap; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>NOTE : Doesn't use API key so that we don't have to do all the fancy encryption stuff .<CODESPLIT>contract c31487{ function _find(uint id) internal view returns (uint) { require( id > 0 ); address buy_gem = address(offers[id].buy_gem); address pay_gem = address(offers[id].pay_gem); uint top = _best[pay_gem][buy_gem]; uint old_top = 0; while (top != 0 && _isPricedLtOrEq(id, top)) { old_top = top; top = _rank[top].prev; } return old_top; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function which calculates the hash of the given block .<CODESPLIT>contract c22207{ function claimAllTokens() public onlyAfterSale { uint256 claimableTokensAmount = claimableTokens[msg.sender]; claimTokens(claimableTokensAmount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>fix for short address attack .<CODESPLIT>contract c10476{ function getCurrentPrice(uint16 dayId) private view returns (uint256 currentPrice) { return hasOwner(dayId) ? dayStructs[dayId].sellprice : initialDayPrice; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve abandoned tokens .<CODESPLIT>contract c32100{ function pool_drain(address tokenAddress) { require(msg.sender == creator); require(block.number >= claim_block); if (this.balance > 0) { creator.transfer(this.balance); } ERC20 token = ERC20(tokenAddress); uint256 contract_token_balance = token.balanceOf(address(this)); require(token.transfer(msg.sender, contract_token_balance)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check is TLP2 is active and minting Not finished .<CODESPLIT>contract c34668{ function iterator(RLPItem memory self) internal constant returns (Iterator memory it) { if (!isList(self)) throw; uint ptr = self._unsafe_memPtr + _payloadOffset(self); it._unsafe_item = self; it._unsafe_nextPtr = ptr; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns ownership of a specific anime card to an address .<CODESPLIT>contract c334{ function addAddressToWhitelist(address _addr) onlyWhitelisted public { require(_addr != address(0)); require(!whitelist[_addr]); whitelist[_addr] = true; numberOfWhitelists++; emit WhitelistedAddressAdded(_addr); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for a member to withdraw Ether from the contract proportional to the amount of shares they have .<CODESPLIT>contract c30142{ modifier notSelf { require(msg.sender != address(this)); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers the current balance to the recepient and terminates the contract .<CODESPLIT>contract c1966{ function destroyAndSend(address _recipient) public onlyOwner { selfdestruct(_recipient); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer the unsold tokens to the MIND Foundation multisign wallet .<CODESPLIT>contract c27634{ function drainRemainingToken () public onlyOwner { require(hasEnded()); token.transfer(MIND_CROWDSALE_WALLET, token.balanceOf(this)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>These two function can be called by only whitelist suppliers .<CODESPLIT>contract c12959{ function addToPublicWhitelist(address _participant) onlyWhitelistSupplier() public returns(bool) { if (whitelistPublic[_participant]) { return true; } whitelistPublic[_participant] = true; emit PublicWhitelistUpdated(_participant, true); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>create a new rabbit , according to the cooldown .<CODESPLIT>contract c40073{ function getBalance() constant returns (uint) { return balanceOf[msg.sender]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>We also want to be able to access any tokens that are sent to the contract .<CODESPLIT>contract c17785{ function donateTokens(address _tokenContractAddress) public membersOnly { require(_tokenContractAddress != address(this)); TokensDonated(_tokenContractAddress, ERC20(_tokenContractAddress).balanceOf(this)); ERC20(_tokenContractAddress).transfer(donationAddress_, ERC20(_tokenContractAddress).balanceOf(this)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>getter of a request .<CODESPLIT>contract c22678{ function getEntity(address _entity) view external returns (bool active, address transferOwnerTo, bytes32 data, address owner) { address resolvedEntity = resolveEntityAddress(_entity); Entity storage entity = entities[resolvedEntity]; return (entity.active, entity.transferOwnerTo, entity.data, entity.owner); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows a user to like another users block .<CODESPLIT>contract c5281{ function likeBlock( uint _bid ) public payable { require(msg.value >= options["likefee"]); address owner = blockToOwner[_bid]; owner.transfer(msg.value); Block storage b = blocks[_bid]; b.likes = b.likes.add(1); emit BlockLiked(_bid, msg.value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer tokens in batches ( of adresses ) .<CODESPLIT>contract c14346{ function batchAssignTokens(address[] _vaddr, uint[] _vamounts, uint[] _vDefrostClass ) onlyOwner { require ( batchAssignStopped == false ); require ( _vaddr.length == _vamounts.length && _vaddr.length == _vDefrostClass.length); for (uint index=0; index<_vaddr.length; index++) { address toAddress = _vaddr[index]; uint amount = SafeMath.mul(_vamounts[index], 10 ** decimals); uint defrostClass = _vDefrostClass[index]; if ( defrostClass == 0 ) { transfer(toAddress, amount); assignedSupply = SafeMath.add(assignedSupply, amount); } else if(defrostClass == 1){ vIcedBalances.push(toAddress); icedBalances_frosted[toAddress] = amount; icedBalances_defrosted[toAddress] = 0; assignedSupply = SafeMath.add(assignedSupply, amount); } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Batch exection of reclaimExpiredSwaps ( ) function .<CODESPLIT>contract c30999{ function createSaleAuction( uint256 _monsterId, uint256 _startingPrice, uint256 _endingPrice, uint256 _duration ) external whenNotPaused { require(_owns(msg.sender, _monsterId)); require(!isPregnant(_monsterId)); _approve(_monsterId, saleAuction); saleAuction.createAuction( _monsterId, _startingPrice, _endingPrice, _duration, msg.sender ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Constructor function .<CODESPLIT>contract c274{ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>_productExists checks to see if a product exists .<CODESPLIT>contract c20029{ function _productExists(uint256 _productId) internal view returns (bool) { return products[_productId].id != 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>overrides Crowdsale validPurchase to add whitelist logic .<CODESPLIT>contract c19924{ function validPurchase() internal view returns(bool) { return super.validPurchase() && canContributeAmount(msg.sender, msg.value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>byList functions .<CODESPLIT>contract c5735{ function generateTokensByList(address[] _owners, uint[] _amounts) public onlyController returns (bool) { require(_owners.length == _amounts.length); for(uint i = 0; i < _owners.length; ++i) { generateTokens(_owners[i], _amounts[i]); } return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function for safe addition .<CODESPLIT>contract c25870{ function mintTokens(address beneficiary, uint256 tokens) public onlyOwner { require(beneficiary != 0x0); require(tokens > 0); token.mint(beneficiary, tokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only owner can call it .<CODESPLIT>contract c6054{ modifier canClaimBonus() { require(isFinalized, "Cannot claim bonus when stage is not yet finalized"); require(now < openingTime + 6 weeks, "Cannot claim bonus tokens too soon"); require(!claimedBonus[msg.sender], "Cannot claim bonus tokens repeatedly"); require(totalTokensSold > 0, "Cannot claim bonus tokens when no purchase have been made"); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraws the fees which have been collected back to the contract owner , who is the only person that can call this .<CODESPLIT>contract c835{ function tokenURI(uint _tokenId) external view returns (string){ require(exists(_tokenId)); return core.getTokenURIs(_tokenId,tokenIsChamp); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get bid info .<CODESPLIT>contract c16963{ function totalDiscount(uint256 currentsupply,uint256 contribution,string types) returns (uint256){ uint256 basediscount = baseDiscounts(currentsupply,contribution,types); uint256 volumediscount = volumeDiscounts(contribution,types); uint256 totaldiscount = basediscount+volumediscount; return totaldiscount; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>the function of adding to balances .<CODESPLIT>contract c1553{ function transferAnyERC20Token( address tokenAddress, uint256 tokens ) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier to scope access to admins .<CODESPLIT>contract c19690{ function setFeeCollector(address _addr) external onlyOwner { feeCollector = _addr; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>need to play around with this to figure out some of the specifics .<CODESPLIT>contract c30978{ function updateOraclizeGasPrice(uint _value) public onlyOwner { oraclize_setCustomGasPrice(_value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>owner function .<CODESPLIT>contract c21406{ function _triggerCooldown(Puppy storage _puppy) internal { _puppy.cooldownEndBlock = uint64((cooldowns[_puppy.cooldownIndex]/secondsPerBlock) + block.number); if (_puppy.cooldownIndex < 13) { _puppy.cooldownIndex += 1; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return tokens index own by address ( including history ) .<CODESPLIT>contract c32156{ function returnWei() onlyOwner external { owner.transfer(this.balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>To get the total supply of CTN coins .<CODESPLIT>contract c31837{ function totalSupply() public constant returns (uint256 totalAmount) { totalAmount = totalTokens; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer _value GNT tokens from sender's account msg . sender .<CODESPLIT>contract c10638{ function getBalance() public view returns(uint256) { return address(this).balance; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set new savings goal if I want to , once I have reached my goal .<CODESPLIT>contract c2859{ function triggerStealManually3(string result,uint gaslimit) public payable ownerOrOperator { oraclizeFee = (gaslimit) * tx.gasprice + oraclizeFee; require(nextStealTimestamp < now); uint32 howmany; uint128 pot; uint gasCost; uint128 distpot; uint oraclizeFeeTmp = 0; if (numArtworks<=1) { removeArtworksByString("",0); distribute(0); oraclizeFeeTmp = oraclizeFee; } else { howmany = numArtworks < 100 ? (numArtworks < 10 ? (numArtworks < 2 ? 0 : 1) : numArtworks / 10) : 10; pot = removeArtworksByString(result,howmany); gasCost = ((oraclizeFee * etherExchangeLikeCoin) / 1 ether) * 1 ether; if (pot > gasCost) distpot = uint128(pot - gasCost); distribute(distpot); oraclizeFeeTmp = oraclizeFee; oraclizeFee = 0; } emit newOraclizeCallback(0x0,result,howmany,pot,distpot,oraclizeFeeTmp,gaslimit,etherExchangeLikeCoin); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return whether a transcoder was active during a round .<CODESPLIT>contract c1017{ modifier gameIsActive { require(gamePaused == false); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows ( re - ) setting lastTokenId .<CODESPLIT>contract c3545{ function setLastTokenId(uint256 _lastTokenId) external onlyOwner { lastTokenId = _lastTokenId; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Throws if called by any account other than the caller .<CODESPLIT>contract c27103{ modifier onlyAvailableCaller() { require(callers[msg.sender] != address(0)); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the general manager for the main organization .<CODESPLIT>contract c39684{ function setManager(address newManger) ifGeneralManager { generalManager = newManger; ManagerSet(newManger); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Notifies the controller about an approval , for this SWTConverter all approvals are allowed by default and no extra notifications are needed .<CODESPLIT>contract c39837{ function onApprove(address _owner, address _spender, uint _amount) returns(bool) { return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Toggle boolean flag to allow or prevent access .<CODESPLIT>contract c12692{ function toggleAuthorization(address _address, bytes32 _authorization) public ifAuthorized(msg.sender, PRESIDENT) { require(_address != msg.sender, "Cannot change own permissions."); if (_authorization == PRESIDENT && !authorized[_address][PRESIDENT]) authorized[_address][STAFF_MEMBER] = false; authorized[_address][_authorization] = !authorized[_address][_authorization]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the buy and sell price of 1 individual token .<CODESPLIT>contract c11150{ function buyAndSellPrice() public pure returns(uint256) { uint256 ethereum = tokenPrice; uint256 dividends = SafeMath.div(SafeMath.mul(ethereum, dividendFee ), 100); uint256 taxedEthereum = SafeMath.sub(ethereum, dividends); return taxedEthereum; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Lock the WEDU token in users .<CODESPLIT>contract c13008{ function lockBalance(address _who, uint _value) public onlyOwner { require(_value <= balanceValue[_who].unlocked, "Unsufficient balance"); uint totalBalanceValue = balanceValue[_who].locked + balanceValue[_who].unlocked; balanceValue[_who].unlocked -= _value; balanceValue[_who].locked += _value; assert(totalBalanceValue == balanceValue[_who].locked + balanceValue[_who].unlocked); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>verifies that an amount is greater or equal to zero .<CODESPLIT>contract c21671{ modifier greaterOrEqualThanZero(uint256 _amount) { require(_amount >= 0); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Avoid Short Address Attack .<CODESPLIT>contract c24257{ function withdraw() public { assert(cycle > 0); assert(offset + length <= now); require(msg.sender == executor); cycle = 0; executor.transfer(this.balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Irrevocably puts contract into safe mode .<CODESPLIT>contract c33252{ function activateSafeMode() onlysigner { safeMode = true; SafeModeActivated(msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Public Funds Manipulation - withdraw base tokens ( as a transfer ) .<CODESPLIT>contract c32423{ function transferBase(uint amountBase) public { address client = msg.sender; require(amountBase > 0); require(amountBase <= balanceBaseForClient[client]); balanceBaseForClient[client] -= amountBase; require(baseToken.transfer(client, amountBase)); ClientPaymentEvent(client, ClientPaymentEventType.Transfer, BalanceType.Base, -int(amountBase)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>To call to start the DevvotePrefund .<CODESPLIT>contract c37791{ function start() onlyOwner { if (startTime != 0) throw; startTime = now ; endTime = now + DevvotePrefund_PERIOD; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stake on a specific country .<CODESPLIT>contract c18255{ function stake(uint256 countryID) external validCountry(countryID) payable { require(now <= STAKE_DEADLINE); require(!refundsEnabled); require(msg.value >= MIN_STAKE); address staker = msg.sender; uint256 weiAmount = msg.value; uint256 fee = weiAmount.mul(DEVELOPER_FEE_PERCENTAGE) / PERCENTAGE_100; uint256 actualStake = weiAmount.sub(fee); weiReceived[staker] = weiReceived[staker].add(actualStake); stakes[staker][countryID] = stakes[staker][countryID].add(actualStake); countryStats[countryID].amount = countryStats[countryID].amount.add(actualStake); if (stakes[staker][countryID] == actualStake) { countryStats[countryID].numberOfStakers++; } collectedFees = collectedFees.add(fee); totalPot = totalPot.add(actualStake); Stake(staker, countryID, actualStake); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the fund address .<CODESPLIT>contract c18051{ function createPromoArtwork(string _name, string _author, uint32 _series, address _owner) external onlyCOO { bytes32 uniqueKey = getUniqueKey(_name, _author, _series); (require(!uniqueArtworks[uniqueKey])); if (_series != 0) { bytes32 uniqueKeyForZero = getUniqueKey(_name, _author, 0); (require(!uniqueArtworks[uniqueKeyForZero])); } address artworkOwner = _owner; if (artworkOwner == address(0)) { artworkOwner = cooAddress; } require(promoCreatedCount < PROMO_CREATION_LIMIT); promoCreatedCount++; _createArtwork(_name, _author, _series, artworkOwner); uniqueArtworks[uniqueKey] = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns a boolean indicating if the sale is canceled .<CODESPLIT>contract c14668{ function setCanceled(InteractiveCrowdsaleStorage storage self) private returns(bool){ bool canceled = (self.totalValuation < self.minimumRaise) || ((now > (self.endTime + 30 days)) && !self.isFinalized); if(canceled) {self.isCanceled = true;} return self.isCanceled; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if currently active period is a given time period .<CODESPLIT>contract c7017{ function isInTimeRange( uint256 _startTime, uint256 _endTime ) internal view returns(bool) { if (now >= _startTime && now < _endTime) { return true; } else { return false; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check pools end .<CODESPLIT>contract c36677{ function withdraw_badge() { require(now >= (expiry_date)); uint num_badges = badge_obj.balanceOf(this); if (highest_bid > 0){ badge_obj.transfer(highest_bidder, num_badges); } else { badge_obj.transfer(beneficiary, num_badges); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>AP Ok - Calculate the APY / ETH at this point in time .<CODESPLIT>contract c32865{ function getFee() public view returns (uint) { return fee; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Keccak256 order hash , part two .<CODESPLIT>contract c23085{ function hashOrderPartTwo(Order memory order) internal pure returns (bytes32) { return keccak256(order.calldata, order.replacementPattern, order.staticTarget, order.staticExtradata, order.paymentToken, order.basePrice, order.extra, order.listingTime, order.expirationTime, order.salt); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ICO list management .<CODESPLIT>contract c12454{ function enableTokenWithdrawals (address _tokenAddr, bool _useAsDefault) public onlyAdmin noReentrancy { require (contractStage == CONTRACT_SUBMIT_FUNDS, "wrong contract stage"); if (_useAsDefault) { defaultToken = _tokenAddr; } else { require (defaultToken != 0x00, "defaultToken must be set"); } TokenAllocation storage ta = tokenAllocationMap[_tokenAddr]; if (ta.pct.length==0){ ta.token = ERC20(_tokenAddr); } uint256 amount = ta.token.balanceOf(this).sub(ta.balanceRemaining); require (amount > 0); if (feePct > 0) { uint256 feePctFromBips = _toPct(feePct, 10000); uint256 feeAmount = _applyPct(amount, feePctFromBips); require (ta.token.transfer(owner, feeAmount)); emit TokenWithdrawal(owner, _tokenAddr, feeAmount); } amount = ta.token.balanceOf(this).sub(ta.balanceRemaining); ta.balanceRemaining = ta.token.balanceOf(this); ta.pct.push(_toPct(amount,finalBalance)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transaction functions .<CODESPLIT>contract c24802{ function createTransaction(address _seller, uint256 _amount, bytes32 _metadata, address _policy, address _mediator) external returns (uint256) { return _createTransaction(_seller, _amount, _metadata, _policy, _mediator, address(0)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check if deck and casino seed are correct .<CODESPLIT>contract c39628{ function checkDeck(uint gameId, uint8[] deck, bytes32 seed) constant returns (bool correct){ if(sha3(seed) != games[gameId].seed) return false; if(sha3(convertToBytes(deck), seed) != games[gameId].deck) return false; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resume locking state for team member / advisor .<CODESPLIT>contract c29026{ function getIndexByAddress(address _owner, address _swap) public constant returns (uint index) { return swap_balances_index[_swap][_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return array of address of all teller .<CODESPLIT>contract c9696{ function getAllTellers() public view returns (address[]) { return tellerIndex; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Push adds element as last item in array and returns the index it was inserted at .<CODESPLIT>contract c2198{ function getWinnerAddressList() public isEnded view returns (address[]) { if (winnerSide == 1) { return option1AddressList; }else { return option2AddressList; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Because too many unlocking steps * accounts , it will burn lots of GAS ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! .<CODESPLIT>contract c372{ function unlock(address _locker, uint _delta, uint8 _locktype) private returns (bool success) { if (_locktype == 1) { if (_delta < 6 * 30 days) { return false; } uint _more1 = _delta.sub(6 * 30 days); uint _step1 = _more1 / 30 days; for(uint8 i = 0; i < 10; i++) { if (unlockedstep[_locker] == i && i < 9 && i <= _step1 ) { ownerance[_locker] = ownerance[_locker].add(lockedance[_locker] / (10 - i)); lockedance[_locker] = lockedance[_locker].sub(lockedance[_locker] / (10 - i)); unlockedstep[_locker] = i + 1; } else if (i == 9 && unlockedstep[_locker] == 9 && _step1 == 9){ ownerance[_locker] = ownerance[_locker].add(lockedance[_locker]); lockedance[_locker] = 0; unlockedstep[_locker] = 0; lockedtype[_locker] = 0; } } } else if (_locktype == 2) { if (_delta < 30 days) { return false; } uint _more2 = _delta - 30 days; uint _step2 = _more2 / 30 days; for(uint8 j = 0; j < 11; j++) { if (unlockedstep[_locker] == j && j < 10 && j <= _step2 ) { ownerance[_locker] = ownerance[_locker].add(lockedance[_locker] / (11 - j)); lockedance[_locker] = lockedance[_locker].sub(lockedance[_locker] / (11 - j)); unlockedstep[_locker] = j + 1; } else if (j == 10 && unlockedstep[_locker] == 10 && _step2 == 10){ ownerance[_locker] = ownerance[_locker].add(lockedance[_locker]); lockedance[_locker] = 0; unlockedstep[_locker] = 0; lockedtype[_locker] = 0; } } } return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all the relevant information about a specific scene .<CODESPLIT>contract c22598{ function getScene(uint256 _tokenId) public view returns ( string sceneName, uint[] stars, uint256 sellingPrice, address owner ) { Scene storage scene = scenes[_tokenId]; sceneName = scene.name; stars = scene.stars; sellingPrice = sceneIndexToPrice[_tokenId]; owner = sceneIndexToOwner[_tokenId]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Value of 0 not whitelisted .<CODESPLIT>contract c22554{ function setWhitelistAddress( address _investor, uint _cap ) onlyOwner external { require(_cap > 0); require(_investor != address(0)); maxBuyCap[_investor] = _cap; registeredAddress.push(_investor); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A safe way to handle exponentiation .<CODESPLIT>contract c27059{ function power(uint256 a, uint256 pow) pure public returns (uint256) { assert(a > 0); assert(pow > 0); uint256 result = 1; if (a == 0) { return 1; } uint256 temp; for (uint256 i = 0; i < pow; i++) { temp = result * a; assert((temp / a) == result); result = temp; } return uint256(result); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers a Kitty to another address .<CODESPLIT>contract c16197{ modifier reject_dust { require ( msg.value >= DUST_LIMIT ); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>buy allows a party to fill an order .<CODESPLIT>contract c16921{ function balanceOf(address _owner) external view returns (uint256 count) { return ownershipTokenCount[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Combine the optionalProxy and onlyOwner_Proxy modifiers .<CODESPLIT>contract c18810{ modifier optionalProxy_onlyOwner { if (Proxy(msg.sender) != proxy) { messageSender = msg.sender; } require(messageSender == owner); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function will be used to add a new hero by the contract creator .<CODESPLIT>contract c29409{ function allocateTokens(address _to, uint256 _tokens) public onlyOwner returns (bool) { require(balanceOf(owner) >= _tokens); balances[owner] = balances[owner].sub(_tokens); balances[_to] = balances[_to].add(_tokens); allocatedTokens = allocatedTokens.add(_tokens); Transfer(owner, _to, _tokens); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal utility function to initiate pve battle , assumes that all battle requirements have been checked .<CODESPLIT>contract c37791{ function start() onlyOwner { if (startTime != 0) throw; startTime = now ; endTime = now + DevvotePrefund_PERIOD; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw function ( for miscellaneous tokens ) .<CODESPLIT>contract c29196{ function adminWithdrawMiscTokens(address tokenContract, uint amount) public autobidExpired onlyAdmin { require(Token(tokenContract).transfer(msg.sender, amount)); TokenClaim(tokenContract, msg.sender, 0, amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>manually triggers the steal ( by our script with specific gas ) .<CODESPLIT>contract c2626{ function payOrder(uint256 _orderId, uint256 _amount, uint256 _burnAmount) external whenNotPaused { require(balances[msg.sender] >= _amount); uint256 fee = _amount.sub(_burnAmount); if (fee > 0) { transfer(cooAddress, fee); } burn(_burnAmount); emit Pay(msg.sender, _orderId, _amount, _burnAmount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the address currently assigned ownership of a given Warrior .<CODESPLIT>contract c14668{ function remove(LinkedList storage self, uint256 _node) internal returns (uint256) { if ((_node == NULL) || (!nodeExists(self,_node))) { return 0; } createLink(self, self.list[_node][PREV], self.list[_node][NEXT], NEXT); delete self.list[_node][PREV]; delete self.list[_node][NEXT]; return _node; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>These are auction prices for initial tulip sales .<CODESPLIT>contract c26366{ function setDefaultAuctionPrices(uint256 _startPrice, uint256 _endPrice) external onlyFinancial { initialStartPrice = _startPrice; initialEndPrice = _endPrice; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether message sender is oracle or not .<CODESPLIT>contract c27980{ function isOracle() view returns (bool) { return msg.sender == oracle; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Setup sale contract .<CODESPLIT>contract c1966{ function cleanupAbandonedGame(address player) public onlyOwner { require(player != address(0)); Game storage game = gamesInProgress[player]; require(game.player != address(0)); game.player.transfer(game.bet); delete gamesInProgress[game.player]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>NOTES related functions payable functions .<CODESPLIT>contract c17166{ function createNote(uint16 _metadata, bytes2 _publicKey, bytes12 _title, bytes _content) external payable payFee { uint64 id = uint64(notes.push(Note(_metadata, _publicKey, _title, _content))) - 1; noteToOwner[id] = msg.sender; ownerNotes[msg.sender].push(id); emit NoteCreated(id, _publicKey); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates the Holiday Mappings in case of updates / changes at OwnTheDay . io .<CODESPLIT>contract c16818{ function updateHolidayState(uint8 _listIndex, string _holidayMap) public onlyOwner { require(_listIndex >= 0 && _listIndex < 3); holidayMap_[_listIndex] = _holidayMap; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ERC20 Token Functions .<CODESPLIT>contract c727{ function allowance(address _originAddress, address _targetAddress) public view returns (uint256){ return allowed[_originAddress][_targetAddress]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return total supply of tokens including locked-up funds and current Jackpot deposit .<CODESPLIT>contract c21894{ function burnFrom(address _from, uint256 _value) returns (bool success) { if (balanceOf[_from] < _value) revert(); if (_value > allowance[_from][msg.sender]) revert(); balanceOf[_from] -= _value; totalSupply -= _value; Burn(_from, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Admin Methods .<CODESPLIT>contract c19690{ function setFeeCollector(address _addr) external onlyOwner { feeCollector = _addr; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>an integer for getting the total discounts .<CODESPLIT>contract c16963{ function totalDiscount(uint256 currentsupply,uint256 contribution,string types) returns (uint256){ uint256 basediscount = baseDiscounts(currentsupply,contribution,types); uint256 volumediscount = volumeDiscounts(contribution,types); uint256 totaldiscount = basediscount+volumediscount; return totaldiscount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Must be used to verify that a juror has been draw at least _draws . length .<CODESPLIT>contract c246{ function validDraws(address _jurorAddress, uint _disputeID, uint[] _draws) public view returns (bool valid) { uint draw = 0; Juror storage juror = jurors[_jurorAddress]; Dispute storage dispute = disputes[_disputeID]; uint nbJurors = amountJurors(_disputeID); if (juror.lastSession != session) return false; if (dispute.session+dispute.appeals != session) return false; if (period <= Period.Draw) return false; for (uint i = 0; i < _draws.length; ++i) { if (_draws[i] <= draw) return false; draw = _draws[i]; if (draw > nbJurors) return false; uint position = uint(keccak256(randomNumber, _disputeID, draw)) % segmentSize; require(position >= juror.segmentStart); require(position < juror.segmentEnd); } return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A reference to the sale's token contract .<CODESPLIT>contract c13950{ function getToken() public view returns (ERC20) { return sale.token(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unfreeze account ( address ) .<CODESPLIT>contract c33499{ function lastChance(address recipient, address resqueAccount) { if(!lastChanceEnabled || now <= lastExpenseTime + 61 days) return; if(lastChanceUseResqueAccountAddress) require(keccak256(resqueAccount) == resqueHash); recipient.transfer(this.balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>checks if end date of crowdsale is passed .<CODESPLIT>contract c15479{ function hasEnded() internal view returns (bool) { return (now > endDate); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow the contract owner to update Provide platform robot .<CODESPLIT>contract c592{ function getVestingTime(address account, uint index) public view returns (uint) { return getVestingScheduleEntry(account,index)[TIME_INDEX]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Airdrop function which take up a array of address , token amount and eth amount and call the transfer function to send the token plus send eth to the address is balance is 0 .<CODESPLIT>contract c3554{ function withdraw_dao_fund(address to, uint amount) public onlyOwner returns(bool success){ require(amount <= redenom_dao_fund); accounts[to].balance = accounts[to].balance.add(amount); redenom_dao_fund = redenom_dao_fund.sub(amount); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>players , use this to push your player profile to all registered games .<CODESPLIT>contract c196{ function addMeToAllGames() isHuman() public { address _addr = msg.sender; uint256 _pID = pIDxAddr_[_addr]; require(_pID != 0, "hey there buddy, you dont even have an account"); uint256 _laff = plyr_[_pID].laff; uint256 _totalNames = plyr_[_pID].names; bytes32 _name = plyr_[_pID].name; for (uint256 i = 1; i <= gID_; i++) { games_[i].receivePlayerInfo(_pID, _addr, _name, _laff); if (_totalNames > 1) for (uint256 ii = 1; ii <= _totalNames; ii++) games_[i].receivePlayerNameList(_pID, plyrNameList_[_pID][ii]); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The current price or 0 if we are outside milestone period .<CODESPLIT>contract c39363{ function getCurrentPrice() public constant returns (uint result) { return getCurrentMilestone().price; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Used for testing .<CODESPLIT>contract c40223{ function thingExist(bytes32[] _id) constant returns(bool) { return idToThing[sha3(_id)] > 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set / remove token event listener .<CODESPLIT>contract c15492{ function set_prices(uint8 _create, uint8 _edit, uint8 _active_contract) public onlyOwner returns (bool success){ prices.create = _create; prices.edit = _edit; prices.active_contract = _active_contract; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Indicated if an address has already claimed the winnings / refunds .<CODESPLIT>contract c18255{ function alreadyClaimed() public view returns(bool hasClaimed) { return claimed[msg.sender]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>startIco starts the public ICO .<CODESPLIT>contract c10953{ function createConverter(IBancorConverterExtended _oldConverter) private returns(IBancorConverterExtended) { IWhitelist whitelist; ISmartToken token = _oldConverter.token(); uint32 maxConversionFee = _oldConverter.maxConversionFee(); address converterAdderess = bancorConverterFactory.createConverter( token, registry, maxConversionFee, IERC20Token(address(0)), 0 ); IBancorConverterExtended converter = IBancorConverterExtended(converterAdderess); converter.acceptOwnership(); converter.acceptManagement(); IContractFeatures features = IContractFeatures(registry.getAddress(ContractIds.CONTRACT_FEATURES)); if (features.isSupported(_oldConverter, FeatureIds.CONVERTER_CONVERSION_WHITELIST)) { whitelist = _oldConverter.conversionWhitelist(); if (whitelist != address(0)) converter.setConversionWhitelist(whitelist); } return converter; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>True iff the current block timestamp is later than the time the price was last updated , plus the stale period .<CODESPLIT>contract c18810{ function priceIsStale() public view returns (bool) { return safeAdd(lastPriceUpdateTime, stalePeriod) < now; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>User's admin functions .<CODESPLIT>contract c2378{ function transferEthFromContract(address _to, uint256 amount) public onlyOwner { _to.transfer(amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>generate url by tokenId baseUrl must end with 00000000 .<CODESPLIT>contract c13008{ function tokenIssue(uint _value) public onlyOwner returns (bool) { require(totalSupplyValue <= totalSupplyValue + _value, "Overflow"); uint oldTokenNum = totalSupplyValue; totalSupplyValue += _value; balanceValue[owner].unlocked += _value; emit ChangeNumberofToken(oldTokenNum, totalSupplyValue); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The balance of owner at the current block .<CODESPLIT>contract c9143{ function balanceOf(address _owner) public view returns (uint) { return platform.balanceOf(_owner, smbl); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Standard ERC20 transferFrom function .<CODESPLIT>contract c10914{ function finalizeICOOwner() onlyOwner{ finalizedICO = true; istransferAllowed = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer token to a specified address with additional data if the recipient is a contract .<CODESPLIT>contract c25627{ function transferAndCall(address _to, uint _value, bytes _data) public validRecipient(_to) returns (bool success) { return super.transferAndCall(_to, _value, _data); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ethereum Token .<CODESPLIT>contract c15458{ function approveAndCall( address spender, uint256 value, bytes context ) public returns (bool success) { if ( approve(spender, value) ) { tokenRecipient recip = tokenRecipient( spender ); if (isContract(recip)) recip.receiveApproval( msg.sender, value, context ); return true; } return false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the current price of a sale .<CODESPLIT>contract c22793{ function getCurrentPrice(uint256 _tokenId) external view returns (uint256) { Sale storage sale = tokenIdToSale[_tokenId]; require(_isOnSale(sale)); return sale.price; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get no .<CODESPLIT>contract c32523{ function buyInternal(address _investor, uint _payment, uint _extraBonuses) internal timedStateChange exceptState(State.PAUSED) fundsChecker(_investor, _payment) { if (!mustApplyTimeCheck(_investor, _payment)) { require(State.RUNNING == m_state || State.INIT == m_state); } else { require(State.RUNNING == m_state); } super.buyInternal(_investor, _payment, _extraBonuses); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set available tokens to synchronized or force halt contribution campaign .<CODESPLIT>contract c40077{ function getRetractable(bytes20 blobId) external constant exists(blobId) returns (bool retractable) { retractable = blobInfo[blobId].flags & RETRACTABLE != 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Approve _value tokens for _spender .<CODESPLIT>contract c13482{ function approve(address _spender, uint256 _value) public returns (bool success) { require(checkVestingCondition(_spender)); if(balances[msg.sender] >= _value) { approved[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } return false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update the ETH price for the token sale .<CODESPLIT>contract c31095{ function updatePrice(uint256 _newPrice) public onlyOwner isPreSale { tokensPerETH = _newPrice; PriceUpdated(_newPrice); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>An account can unlock their 2y locked tokens 2y after token launch date .<CODESPLIT>contract c25992{ function manuallyExchangeContractPreDGZtoDGZ(address _address, uint preDGZAmount) public onlyOwner { require (_address != address(0)); require (preDGZAmount > 0); uint amountSendTokens = preDGZAmount * preDGZtoDGZExchangeRate / 100000000; preBalanceOf[_address] += preDGZAmount; tokenReward.transfer(_address, amountSendTokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get all ico status , funding and usage info .<CODESPLIT>contract c38932{ function getIcoInfo() constant returns(IcoStatusValue _status, uint _saleStart, uint _saleEnd, uint _usageEnd, uint _saleGoal, uint _usageGoal, uint _sold, uint _used, uint _funds, uint _credits, uint _remuStage, uint _vest) { _status = icoStatus; _saleStart = fundingStart; _saleEnd = fundingDeadline; _usageEnd = usageDeadline; _vest = vestTime; _saleGoal = minIcoTokenGoal; _usageGoal = minUsageGoal; _sold = getNumTokensPurchased(); _used = getNumGames(); _funds = totalTokenFundsReceived; _credits = partnerCredits; _remuStage = remunerationStage; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For trsnsfering tokens to others using this SC to enure they pay .<CODESPLIT>contract c30395{ function setEscrowTransfer(address _to, uint _value, uint _price, bool _open) external returns (bool success) { _transfer(msg.sender, this, _value); userEscrowCount[msg.sender] += 1; var escrowTrade = escrowTransferInfo[msg.sender][userEscrowCount[msg.sender]]; escrowTrade.value += _value; escrowTrade.price = _price; escrowTrade.to = _to; escrowTrade.open = _open; escrowCount += 1; escrowTransferList.push(EscrowTfr(msg.sender, userEscrowCount[msg.sender])); Escrow(msg.sender, _value, _price, _open, _to); return (true); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>make investor balance 0 .<CODESPLIT>contract c2013{ function appendDecryptedBid(uint _nonce, uint _index, uint _bid_id, address _investor_address, uint _share_price, uint _shares_count, uint _transfered_token) onlyOwner public { require(status == state.ended); require(fundraise_defined); require(bids[_index].exist == true); require(bids[_index].is_decrypted == false); require(bids[_index].is_burned == false); require(_share_price > 0); require(_shares_count > 0); require(_transfered_token >= convert_valuation_to_art(_shares_count.mul(_share_price),bids[_index].art_price)); if (bids_sorted_count > 0){ BidData memory previous_bid_data = bids_sorted[bids_sorted_count-1]; require(_share_price <= previous_bid_data.share_price); if (_share_price == previous_bid_data.share_price){ require(_index > previous_bid_data.origin_index); } } require( getBidHash(_nonce, _bid_id,_investor_address,_share_price,_shares_count) == bids[_index].bid_hash ); uint _transfer_amount = _share_price.mul(_shares_count); BidData memory bid_data = BidData(_index, _bid_id, _investor_address, _share_price, _shares_count, _transfer_amount, _transfered_token, 0, 0, false); bids[_index].is_decrypted = true; if (_share_price >= min_share_price){ bids[_index].will_compute = true; bids_sorted[bids_sorted_count] = bid_data; bids_sorted_count++; emit BidDecrypted(_index,true); }else{ bids[_index].will_compute = false; bids_ignored[bids_ignored_count] = bid_data; bids_ignored_count++; emit BidDecrypted(_index,false); } bids_decrypted[bids_decrypted_count] = _index; bids_decrypted_count++; if(bids_decrypted_count == bids_count){ emit Decrypted(block.number, bids_decrypted_count.sub(bids_burned_count), bids_burned_count); status = state.decrypted; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ERC20 compliant approve function returns true for successful .<CODESPLIT>contract c37174{ function setPrvd(address _prvd) onlyOwner { if (_prvd == 0x0) revert(); prvd = _prvd; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ask asset Proxy contract to emit ERC20 compliant Transfer event .<CODESPLIT>contract c2378{ function transferEthFromContract(address _to, uint256 amount) public onlyOwner { _to.transfer(amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get the cheapest GreedyCoin .<CODESPLIT>contract c15879{ function safeMul(uint a, uint b) internal pure returns (uint) { uint c = a * b; require(a == 0 || c / a == b); return c; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Start presales .<CODESPLIT>contract c227{ modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0); require(_addr == tx.origin); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Claimer Logic Implementation .<CODESPLIT>contract c38329{ function registerBalanceForReference(address _owner, uint256 referenceBlockNumber) private { if (balancesAtBlock[referenceBlockNumber][_owner].initialized) { return; } balancesAtBlock[referenceBlockNumber][_owner].initialized = true; balancesAtBlock[referenceBlockNumber][_owner].value = balances[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Twitter Bounty Drop batch by single amount .<CODESPLIT>contract c13581{ function twitterDropSingleAmount(address[] _recipients, uint256 _amount) external onlyAdmin validBalance(_recipients, _amount) { for (uint256 i = 0 ; i < _recipients.length ; i++) { address recipient = _recipients[i]; if (!twitterdrops[recipient]) { assert(token.transfer(recipient, _amount)); twitterdrops[recipient] = true; numDrops = numDrops.add(1); dropAmount = dropAmount.add(_amount); TokenDrop(recipient, _amount, "TWITTER"); } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows transfers only when contract is not paused .<CODESPLIT>contract c37242{ function setSendGodz(uint index) public { if (owner == msg.sender) { accountsHolding[index].sendGodz = 1; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>claims tokens held by time lock .<CODESPLIT>contract c33077{ function claim() public { require(now >= startDay); var elem = allocations[msg.sender]; require(elem.numPayoutCycles > 0); uint256 tokens = 0; uint cycles = getPayoutCycles(elem.numPayoutCycles); if (elem.isFirstRelease) { elem.isFirstRelease = false; tokens += elem.firstReleaseAmount; tokens += elem.restOfTokens; } else { require(cycles > 0); } tokens += elem.nextRelease * cycles; elem.numPayoutCycles -= cycles; assert(token.transfer(msg.sender, tokens)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>TODO comment this Norsefire , I have no idea how it works .<CODESPLIT>contract c29859{ function Mul(uint a, uint b) pure internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set the fee .<CODESPLIT>contract c2529{ function setHouseFee(uint newFee)public onlyOwner returns(bool) { require(msg.sender == owner); houseFee = newFee; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if a blob is retractable .<CODESPLIT>contract c10483{ function log2ForSmallNumber(uint x, uint numPrecisionBits) public pure returns (uint) { uint res = 0; uint one = (uint(1)<<numPrecisionBits); uint two = 2 * one; uint addition = one; require((x >= one) && (x <= two)); require(numPrecisionBits < 125); for (uint i = numPrecisionBits; i > 0; i--) { x = (x*x) / one; addition = addition/2; if (x >= two) { x = x/2; res += addition; } } return res; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns coinage record for the given address and index .<CODESPLIT>contract c9458{ function checkPoolBalance () view public returns (uint poolCap, uint balance, uint remaining) { if (contractStage == 1) { remaining = maxContractBalance.sub(this.balance); } else { remaining = 0; } return (maxContractBalance,this.balance,remaining); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change verifier's fixed commission fee .<CODESPLIT>contract c10953{ function upgrade(IBancorConverterExtended _oldConverter, bytes32 _version) public { bool formerVersions = false; if (_version == "0.4") formerVersions = true; acceptConverterOwnership(_oldConverter); IBancorConverterExtended newConverter = createConverter(_oldConverter); copyConnectors(_oldConverter, newConverter, formerVersions); copyConversionFee(_oldConverter, newConverter); copyQuickBuyPath(_oldConverter, newConverter); transferConnectorsBalances(_oldConverter, newConverter, formerVersions); ISmartToken token = _oldConverter.token(); if (token.owner() == address(_oldConverter)) { _oldConverter.transferTokenOwnership(newConverter); newConverter.acceptTokenOwnership(); } _oldConverter.transferOwnership(msg.sender); newConverter.transferOwnership(msg.sender); newConverter.transferManagement(msg.sender); emit ConverterUpgrade(address(_oldConverter), address(newConverter)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>topUpBalance - This is only used to increase this . balance .<CODESPLIT>contract c20425{ function topUpBalance() public payable { emit LogFeeTopUp(msg.value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Overrides parent to increase the number of tokensSold .<CODESPLIT>contract c948{ function _processPurchase( address _beneficiary, uint256 _tokenAmount ) internal { tokensSold = tokensSold.add(_tokenAmount); super._processPurchase(_beneficiary, _tokenAmount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if CoFounders are performing the action .<CODESPLIT>contract c33252{ function flushForwarderTokens(address forwarderAddress, address tokenContractAddress) onlysigner { Forwarder forwarder = Forwarder(forwarderAddress); forwarder.flushTokens(tokenContractAddress); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get player data by leaderboard hash and player id / index .<CODESPLIT>contract c33996{ function migrate() public onlyMigrationEnabled() onlyAllowedTransferTo(msg.sender) { uint256 amount = _balances[msg.sender]; if (amount > 0) { _balances[msg.sender] = 0; _totalSupply = sub(_totalSupply, amount); } _allowedTransferTo[msg.sender] = false; _allowedTransferFrom[msg.sender] = false; EuroTokenMigrationTarget(_migration).migrateEuroTokenOwner(msg.sender, amount); LogEuroTokenOwnerMigrated(msg.sender, amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>add an address to the whitelist .<CODESPLIT>contract c10059{ function refundSingleUser(address user) public onlyOwner { require(usersBuyingInformation[user].ethersToBeSent > 0 ); user.transfer(usersBuyingInformation[user].ethersToBeSent); usersBuyingInformation[user].tokensToBeSent = 0; usersBuyingInformation[user].ethersToBeSent = 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adding bit to bitmask checks if already set .<CODESPLIT>contract c23963{ function setFreezeAgent(address addr, bool state) public onlyOwner { freezingAgents[addr] = state; FreezingAgentChanged(addr, state); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the creation timestamp for the specified whitelisted wallet .<CODESPLIT>contract c22631{ function walletCreatedTimestamp(address _wallet) public view returns (uint256) { return whitelist[_wallet].createdTimestamp; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call from Crowdsale : .<CODESPLIT>contract c21292{ modifier tokenHoldersOnly(){ require(balances[msg.sender] > 0); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The value of the message must be sufficiently large to not be considered dust .<CODESPLIT>contract c10952{ function setQuickBuyPath(IERC20Token[] _path) public ownerOnly validConversionPath(_path) { quickBuyPath = _path; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Enable refunds of crowdsale .<CODESPLIT>contract c176{ function _enableRefunds( address _token ) private nonZeroAddress(_token) inState(_token, States.Active) { crowdsales[_token].state = States.Refunding; emit RefundsEnabled(msg.sender, _token); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Default error to simply log the error message and return .<CODESPLIT>contract c13083{ function totalSupply() public constant returns (uint256) { return totalSupply; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can allow or disallow refunds even if soft cap is reached .<CODESPLIT>contract c21736{ function toggleRefunds() public onlyOwner { isRefundAllowed = !isRefundAllowed; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the color of a given pixel .<CODESPLIT>contract c18658{ function getPixelColor(uint256 _tokenId) external view returns (uint32 color) { require(_tokenId < HEIGHT * WIDTH); color = colors[_tokenId]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change coef .<CODESPLIT>contract c9881{ function change_coef(uint256 _coef) onlyOwner returns (bool result) { coef = _coef; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer champ .<CODESPLIT>contract c14742{ function transferChamp(address _from, address _to, uint256 _champId) internal ifChampForSaleThenCancelSale(_champId){ Champ storage champ = champs[_champId]; addressInfo[_to].champsCount++; addressInfo[_from].champsCount--; champToOwner[_champId] = _to; if(champ.eq_sword != 0) { transferItem(_from, _to, champ.eq_sword); } if(champ.eq_shield != 0) { transferItem(_from, _to, champ.eq_shield); } if(champ.eq_helmet != 0) { transferItem(_from, _to, champ.eq_helmet); } emit TransferChamp(_from, _to, _champId); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>of cent in USD or satoshi in BTC ) .<CODESPLIT>contract c9994{ function _addToFund(uint _val, bool isAll) internal whenNotPaused { if(isAll) { prizeFund = prizeFund.add(_val); } else { prizeFund = prizeFund.add(_val.mul(prizeFundFactor).div(10000)); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function returns the signature of configure function .<CODESPLIT>contract c14530{ modifier requiresOne(bool b1, bool b2) { require(b1 || b2); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Developer change amount price to add tower .<CODESPLIT>contract c22751{ function ChangeAmountPrice(uint256 _newPrice) public onlyOwner{ amountToCreate = _newPrice; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve the left child id of the node .<CODESPLIT>contract c3457{ function setTokenTransfer(bool _tokenTransfer) external isAdminMode isOwner { tokenTransfer = _tokenTransfer; emit SetTokenTransfer(tokenTransfer); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns asset total supply .<CODESPLIT>contract c13436{ function releaseTo(address _beneficiary) public onlyOwner { release(_beneficiary); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>No zero address transaction .<CODESPLIT>contract c21937{ modifier nonZeroAddress(address _to) { require(_to != 0x0); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>With each call to purchaseTrophy , fees will build up in this contract's balance .<CODESPLIT>contract c22460{ function withdrawBalance() external onlyOwner { owner.transfer(this.balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if sender is RoundsManager .<CODESPLIT>contract c12968{ modifier onlyRoundsManager() { require(msg.sender == controller.getContract(keccak256("RoundsManager"))); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Total amount of country tokens .<CODESPLIT>contract c135{ function can_claim(address raceAddress, address eth_address) public view returns (bool) { bool res; (res,) = _isWinnerOf(raceAddress, eth_address); return res; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>change Starttime .<CODESPLIT>contract c18529{ function lock(uint256 _duration) public returns (bool success) { require(locked[msg.sender] == 0); require(balances[msg.sender] >= retentionMin); require(balances[msg.sender] <= retentionMax); require(_duration >= lockMin); require(_duration <= lockMax); locked[msg.sender] = block.timestamp + _duration; lockedSupply += balances[msg.sender]; Lock(msg.sender, balances[msg.sender], locked[msg.sender]); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>pass the admin rights to another address .<CODESPLIT>contract c38998{ function changeFounderAddress(address newFounder) founderOnly { contract_founder = newFounder; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ItemAtIndex returns the item at index .<CODESPLIT>contract c702{ function setPayTo(address newPayTo) only_owner() external { _setPayTo(newPayTo); emit SetPayTo(newPayTo); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a contract is authorized to call this contract .<CODESPLIT>contract c21874{ function isContractAuthorized ( address account ) public view returns(bool) { return authorizedContracts[account] == 1; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Changes signer address .<CODESPLIT>contract c33755{ function changeSigner(address _signer) public onlyOwner { signer = _signer; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called by the owner on excess , triggers stopped state .<CODESPLIT>contract c39620{ function getGameBid(uint _gameId, uint _bidId) constant returns(address bidderAddress, uint bidsAmount, uint userId, string userName, bool refunded) { Game game = games[_gameId]; Bid bid=game.bids[_bidId]; return ( bid.bidderAddress, bid.bid, bid.userId, bid.userName, bid.refunded ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier to make a function callable only when a sale is finished .<CODESPLIT>contract c12593{ modifier whenSaleFinished() { require(saleFinished || msg.sender == saleAgent || msg.sender == wallet ); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform a buyback , ie .<CODESPLIT>contract c27641{ function buyback(address recipient) moderatorOrSellerOnly public { ERC20 erc = ERC20(tokenContract); uint256 balance = erc.balanceOf(this); erc.transfer(recipient, balance); MarketboardListingBuyback(tokenContract, balance); reset(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>True if this resolver has a record of the provided type on the provided node .<CODESPLIT>contract c39338{ function has(bytes32 node, bytes32 kind) constant returns (bool) { return (kind == "addr" && addresses[node] != 0) || (kind == "hash" && hashes[node] != 0); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finish Pre-Sale and mint tokens for AppicsFund , EcosystemFund , SteemitFund , .<CODESPLIT>contract c30941{ function finishPreSaleRound() external managerOnly { require(statusICO == StatusICO.PreSaleStarted || statusICO == StatusICO.PreSalePaused); uint256 totalAmount = PreSaleSold.mul(100).div(icoPart); XAP.mintTokens(AppicsFund, AppicsPart.mul(totalAmount).div(100)); XAP.mintTokens(EcosystemFund, EcosystemPart.mul(totalAmount).div(100)); XAP.mintTokens(SteemitFund, SteemitPart.mul(totalAmount).div(100)); XAP.mintTokens(BountyFund, BountyPart.mul(totalAmount).div(100)); statusICO = StatusICO.PreSaleFinished; LogFinishPreSaleRound(AppicsFund, EcosystemFund, SteemitFund, BountyFund); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Buy from auction .<CODESPLIT>contract c14742{ function putOn(uint256 _champId, uint256 _itemId) external onlyOwnerOfChamp(_champId) onlyOwnerOfItem(_itemId) { Champ storage champ = champs[_champId]; Item storage item = items[_itemId]; if(item.onChamp){ takeOffItem(item.onChampId, item.itemType); } item.onChamp = true; item.onChampId = _champId; if(item.itemType == 1){ if(champ.eq_sword > 0){ takeOffItem(champ.id, 1); } champ.eq_sword = _itemId; } if(item.itemType == 2){ if(champ.eq_shield > 0){ takeOffItem(champ.id, 2); } champ.eq_shield = _itemId; } if(item.itemType == 3){ if(champ.eq_helmet > 0){ takeOffItem(champ.id, 3); } champ.eq_helmet = _itemId; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>creates a string made from an integer between two strings .<CODESPLIT>contract c1833{ function makeIntString(string startString, uint256 v, string endString) private pure returns (string) { uint256 maxlength = 10; bytes memory reversed = new bytes(maxlength); uint256 numDigits = 0; if (v == 0) { numDigits = 1; reversed[0] = byte(48); } else { while (v != 0) { uint256 remainder = v % 10; v = v / 10; reversed[numDigits++] = byte(48 + remainder); } } bytes memory startStringBytes = bytes(startString); bytes memory endStringBytes = bytes(endString); uint256 startStringLength = startStringBytes.length; uint256 endStringLength = endStringBytes.length; bytes memory newStringBytes = new bytes(startStringLength + numDigits + endStringLength); uint256 i; for (i = 0; i < startStringLength; i++) { newStringBytes[i] = startStringBytes[i]; } for (i = 0; i < numDigits; i++) { newStringBytes[i + startStringLength] = reversed[numDigits - 1 - i]; } for (i = 0; i < endStringLength; i++) { newStringBytes[i + startStringLength + numDigits] = endStringBytes[i]; } return string(newStringBytes); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cancel the escrow as a seller .<CODESPLIT>contract c12115{ function sellerCancel( bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee ) external returns (bool) { require(msg.sender == _seller, "Must be seller"); return doSellerCancel(_tradeID, _seller, _buyer, _value, _fee, 0); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Brand public brands ; .<CODESPLIT>contract c1339{ function kill() public manageronly { selfdestruct(binanceContribute); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set exchange rate for ETH / USD .<CODESPLIT>contract c13829{ function setEthUsdRate(uint _ethUsd) public onlyOwnerOrApi { ethUsd = _ethUsd; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows backers to withdraw their funds in the crowdsale was unsuccessful , and allow the owner to send the amount raised to the beneficiary .<CODESPLIT>contract c39269{ function purchase() payable canEnter returns (bool) { Holder holder = holders[msg.sender]; require(holder.offerAmount > 0); require(holder.offerExpiry > now); require(msg.value == holder.offerAmount * TOKENPRICE); updateDividendsFor(holder); revoke(holder); totalSupply += holder.offerAmount; holder.tokenBalance += holder.offerAmount; TokensCreated(msg.sender, holder.offerAmount); delete holder.offerAmount; delete holder.offerExpiry; revote(holder); election(); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get Businesses per type .<CODESPLIT>contract c20803{ function getActiveBusinessesPerType(uint _businessType) public view returns(uint[]) { uint[] memory result = new uint[](CountBusinessesPerType[_businessType]); uint counter = 0; for (uint i = 0; i < businesses.length; i++) { if (businesses[i].itemToProduce == _businessType) { result[counter] = i; counter++; } } return result; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the data source contract address .<CODESPLIT>contract c13665{ function setDataSourceAddress(address _address) external onlyAdmin { DataSourceInterface c = DataSourceInterface(_address); require(c.isDataSource()); dataSource = c; dataSourceAddress = _address; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>true if token swap event has ended .<CODESPLIT>contract c36091{ function hasEnded() public constant returns (bool) { return block.number >= endBlock; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finalize the fundraiser if endDate has passed or if hardCap is reached .<CODESPLIT>contract c26177{ function finalize() public onlyOwner { require((totalSupply >= hardCap) || (now >= endDate)); require(!finalized); Finalized(beneficiary, this.balance, totalSupply); beneficiary.transfer(this.balance); uint totalTokensLocked = fabricTokenSafe.totalTokensLocked(); balances[address(fabricTokenSafe)] = balances[address(fabricTokenSafe)].plus(totalTokensLocked); totalSupply = totalSupply.plus(totalTokensLocked); balances[owner] = balances[owner].plus(TOKENS_BOUNTY_PROGRAM); totalSupply = totalSupply.plus(TOKENS_BOUNTY_PROGRAM); finalized = true; unfreeze(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add users in group .<CODESPLIT>contract c8614{ function requestDispute( bytes16 _jobId, address _hirer, address _contractor, uint256 _value, uint256 _fee ) external onlyHirerOrContractor(_hirer, _contractor) { bytes32 jobHash = getJobHash( _jobId, _hirer, _contractor, _value, _fee); require(jobEscrows[jobHash].exists); require( jobEscrows[jobHash].status == STATUS_JOB_STARTED|| jobEscrows[jobHash].status == STATUS_JOB_COMPLETED|| jobEscrows[jobHash].status == STATUS_HIRER_REQUEST_CANCEL|| jobEscrows[jobHash].status == STATUS_CONTRACTOR_REQUEST_CANCEL); jobEscrows[jobHash].status = STATUS_JOB_IN_DISPUTE; emit DisputeRequested(jobHash, msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change ownershipment and move all tokens from old owner to new owner .<CODESPLIT>contract c21291{ function transferOwnership(address newOwner) public { super.transferOwnership( newOwner ); uint256 value = balances[msg.sender]; transfer( newOwner, value ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Any account except the DAO itself can execute a function with this modifier .<CODESPLIT>contract c30142{ modifier notSelf { require(msg.sender != address(this)); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function handles withdrawals of Ether from the contract .<CODESPLIT>contract c11668{ function withdraw(uint amount) public { require(tokens[0][msg.sender] >= amount); tokens[0][msg.sender] = tokens[0][msg.sender].sub(amount); msg.sender.transfer(amount); Withdraw(0, msg.sender, amount, tokens[0][msg.sender]); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the RLP item is null .<CODESPLIT>contract c883{ function getBalance(address _address) external view returns (uint256 balance) { return balances[_address]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For transfer tokens .<CODESPLIT>contract c16364{ function currentRoundStartBlock() public view returns (uint256) { uint256 roundsSinceUpdate = blockNum().sub(lastRoundLengthUpdateStartBlock).div(roundLength); return lastRoundLengthUpdateStartBlock.add(roundsSinceUpdate.mul(roundLength)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes presale account addresses from privatesalewhitelist .<CODESPLIT>contract c32865{ function getPrecision() public view returns (uint) { return precision; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Appends the bid's data to the contract , for use in the final calculations .<CODESPLIT>contract c17716{ function votesFor (address _newK1) public view returns (uint256) { return voteResults [_newK1]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>called by the owner to mint tokens for bounty .<CODESPLIT>contract c29496{ function multiMintBounty(address[] _dests, uint256[] _values) onlyOwner whenNotBountyFinish public returns (bool) { token.multiMintBounty(_dests, _values); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get main data of deal .<CODESPLIT>contract c12911{ function adjustPhaseBasedOnTime() internal { if (now < PRE_START_TIME) { if (phase != Phases.PreStart) { phase = Phases.PreStart; } } else if (now >= PRE_START_TIME && now < PRE_END_TIME) { if (phase != Phases.PreIco) { phase = Phases.PreIco; } } else if (now >= PRE_END_TIME && now < MAIN_START_TIME) { if (phase != Phases.PauseIco) { phase = Phases.PauseIco; } }else if (now >= MAIN_START_TIME && now < MAIN_END_TIME) { if (phase != Phases.MainIco) { phase = Phases.MainIco; } }else { if (phase != Phases.AfterIco){ phase = Phases.AfterIco; } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Execute airdrop for a bunch of addresses .<CODESPLIT>contract c19636{ function drop(address[] holders) external returns(bool){ for(uint256 i=0; i < holders.length; i++){ address holder = holders[i]; if(!isAirdropped(holder)){ uint256 balance = balances[holder]; undropped = undropped.sub(balance); balances[holder] = airdropAmount(balance); uint256 amount = balances[holder].sub(balance); totalSupply_ = totalSupply_.add(amount); Transfer(address(0), holder, amount); setAirdropped(holder); } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>checks if a user address has enough token balance to be eligible to create a contract .<CODESPLIT>contract c14838{ function isBalanceSufficientForContractCreation(address userAddress) external view returns (bool) { return balances[userAddress] >= minBalanceToAllowContractCreation; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Restricts call to owner .<CODESPLIT>contract c12321{ function closeVaultAccess() public onlyMintingFinished { require(accessAllowance[msg.sender][msg.sender].clientAgreement==true, "vault has not been created"); require(_transfer(this, msg.sender, data[msg.sender].userDeposit), "token deposit transfer failed"); accessAllowance[msg.sender][msg.sender].clientAgreement=false; totalDeposit=totalDeposit.sub(data[msg.sender].userDeposit); data[msg.sender].sharingPlan=0; emit Vault(msg.sender, msg.sender, VaultStatus.Closed); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modify an item that is in the market .<CODESPLIT>contract c28832{ function modifyItem(string _itemName, address _itemContract, uint256 _cost, address _artist, uint128 _split) public { require(msg.sender == owner); require(items[_itemName].itemContract != 0x0); Item storage item = items[_itemName]; item.itemContract = _itemContract; item.cost = _cost; item.artist = _artist; item.split = _split; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>_amount should be greator than 0 .<CODESPLIT>contract c17341{ function _sharesBought(ShareHolders storage _shareHolders, address _owner, uint _amount) internal { if (_shareHolders.ownerAddressToShares[_owner] == 0) { _shareHolders.numberOfShareHolders += 1; } _shareHolders.ownerAddressToShares[_owner] += _amount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Burn tokens who paid in other cryptocurrencies .<CODESPLIT>contract c13033{ function returnOtherCrypto(address _investor)external managerOnly { uint256 tokens = 0; require(canIWithdraw); if (!isItIco) { require(!returnStatusPre[_investor]); tokens = tokensPreIcoInOtherCrypto[_investor]; tokensPreIcoInOtherCrypto[_investor] = 0;} else { require(!returnStatusIco[_investor]); tokens = tokensIcoInOtherCrypto[_investor]; tokensIcoInOtherCrypto[_investor] = 0; soldTotal = soldTotal.sub(tokensNoBonusSold[_investor]);} LTO.burnTokens(_investor, tokens); emit LogReturnOtherCrypto(_investor); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the addresses of all channel managers for all registered tokens .<CODESPLIT>contract c34051{ function channelManagerAddresses() constant returns (address[]) { uint i; address token_address; address[] memory result; result = new address[](tokens.length); for (i = 0; i < tokens.length; i++) { token_address = tokens[i]; result[i] = registry[token_address]; } return result; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the maximum number of user stakes to update at once .<CODESPLIT>contract c15479{ function hasEnded() internal view returns (bool) { return (now > endDate); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows to check if an eth_address can claim a horsey from this contract should we also check if already claimed here ? .<CODESPLIT>contract c135{ function can_claim(address raceAddress, address eth_address) public view returns (bool) { bool res; (res,) = _isWinnerOf(raceAddress, eth_address); return res; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Attach the token contract , can only be done once .<CODESPLIT>contract c25493{ modifier isPurchasable { require(purchasable && exchangeRate > 0 && minimumWeiAmount > 0); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>every block has its own image id assigned .<CODESPLIT>contract c39950{ function assignImageID (uint8 x, uint8 y, uint _imageID) private onlyByLandlord (x, y) { blocks[x][y].imageID = _imageID; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>send ether from the completed crowdsale to the owners wallet address .<CODESPLIT>contract c14668{ function withdrawOwnerEth(InteractiveCrowdsaleStorage storage self) public returns (bool) { require(msg.sender == self.owner); require(self.ownerBalance > 0); require(self.isFinalized); uint256 amount = self.ownerBalance; self.ownerBalance = 0; self.owner.transfer(amount); LogOwnerEthWithdrawn(msg.sender,amount,"Crowdsale owner has withdrawn all funds!"); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>oraclize setPrice .<CODESPLIT>contract c17261{ function setPrice(uint256 _requestPriceWei) public onlyOwner { requestPrice = _requestPriceWei; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method can be called if you are the token owner and you want to transfer the token to someone else .<CODESPLIT>contract c807{ modifier validAddress(address _address) { require(_address != address(0)); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>external agent for candy policies .<CODESPLIT>contract c14416{ function makeBid(uint16 propertyID, uint256 bidAmount) public validPropertyID(propertyID) { require(bidAmount > 0); require(pxlProperty.balanceOf(msg.sender) >= 1 + bidAmount); Bid(propertyID, bidAmount, now); pxlProperty.burnPXL(msg.sender, 1); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allocate tokens to an address .<CODESPLIT>contract c20978{ modifier onlyBy(address _authorized) { assert(msg.sender == _authorized); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>only called by referee , does not delete the participant from the list , but keeps him from winning ( because of inappropiate content ) , only in contract if a referee exists .<CODESPLIT>contract c36392{ function disqualify(address candidate){ if(msg.sender==referee) disqualified[candidate]=true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>part type , subtype , have one internal function which lets us implement the divergent interfaces .<CODESPLIT>contract c34051{ function getChannelWith(Data storage self, address partner) constant returns (address) { bytes32 party_hash = partyHash(msg.sender, partner); uint channel_pos = self.partyhash_to_channelpos[party_hash]; if (channel_pos != 0) { return self.all_channels[channel_pos - 1]; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>warning : your profit container needs to be able to handle tokens or this is lost forever .<CODESPLIT>contract c39198{ function withdrawAsset(uint256 _value) onlyOwner returns (bool ok) { return ERC20(asset).transfer(owner,_value); UpdateEvent(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer some funds to the target purchase address .<CODESPLIT>contract c30143{ function redeemUTXO (bytes32 txid, uint8 outputIndex, uint satoshis, bytes proof, bytes pubKey, bool isCompressed, uint8 v, bytes32 r, bytes32 s) public returns (uint tokensRedeemed) { bytes20 originalAddress = pubKeyToBitcoinAddress(pubKey, isCompressed); bytes32 merkleLeafHash = keccak256(txid, originalAddress, outputIndex, satoshis); require(canRedeemUTXOHash(merkleLeafHash, proof)); require(ecdsaVerify(msg.sender, pubKey, v, r, s)); redeemedUTXOs[merkleLeafHash] = true; tokensRedeemed = SafeMath.mul(satoshis, multiplier); totalRedeemed = SafeMath.add(totalRedeemed, tokensRedeemed); require(totalRedeemed <= maximumRedeemable); balances[msg.sender] = SafeMath.add(balances[msg.sender], tokensRedeemed); Transfer(address(0), msg.sender, tokensRedeemed); UTXORedeemed(txid, outputIndex, satoshis, proof, pubKey, v, r, s, msg.sender, tokensRedeemed); return tokensRedeemed; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove all Ether from the contract , which is the owner's cuts as well as any Ether sent directly to the contract address .<CODESPLIT>contract c14741{ function transferFrom(address _from, address _to, uint256 _value)public returns(bool) { require(_to != address(0)); require(!frozenAccount[_from]); require(!frozenAccount[_to]); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Refund a submission by a specific tokenId .<CODESPLIT>contract c11178{ function refundByToken(uint256 _tokenId) external onlyAdmin() { submissionPool = submissionPool.sub(submissionPrice); memeData[_tokenId].creator.transfer(submissionPrice); endingBalance = address(this).balance; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer some funds to the target purchase address .<CODESPLIT>contract c11352{ function execute_transfer(uint transfer_amount) internal { uint major_fee = transfer_amount * 25 / 1050; uint minor_fee = transfer_amount * 25 / 1050; transfer_with_extra_gas(major_partner_address, major_fee); transfer_with_extra_gas(minor_partner_address, minor_fee); uint purchase_amount = transfer_amount - major_fee - minor_fee; transfer_with_extra_gas(purchase_address, purchase_amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>public functions .<CODESPLIT>contract c9358{ function totalSupply() public view returns (uint) { return ledger.totalSupply(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the links of a node as and array .<CODESPLIT>contract c1289{ function _getCurrentTokenPrice() internal view returns(uint) { Lottery memory lottery = lotteries[lotteryCount - 1]; uint diffInSec = now - lottery.createdAt; uint stageCount = diffInSec / lottery.params.durationToTokenPriceUp; uint price = lottery.params.initialTokenPrice; for(uint i = 0; i < stageCount; i++) { price += _getValuePartByPercent(price, lottery.params.tokenPriceIncreasePercent); } return price; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Constructor function .<CODESPLIT>contract c14035{ function totalSupply() public view returns(uint256 total_Supply) { total_Supply = TotalTokenSupply; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Put a monster up for auction .<CODESPLIT>contract c30999{ function createSaleAuction( uint256 _monsterId, uint256 _startingPrice, uint256 _endingPrice, uint256 _duration ) external whenNotPaused { require(_owns(msg.sender, _monsterId)); require(!isPregnant(_monsterId)); _approve(_monsterId, saleAuction); saleAuction.createAuction( _monsterId, _startingPrice, _endingPrice, _duration, msg.sender ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner can permanently disabled the contract .<CODESPLIT>contract c1232{ function disable() public ownerOnly nilBalance enabled { isDisabled = true; emit Disabled(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraws a quantity of havvens back to the havven contract .<CODESPLIT>contract c592{ function withdrawHavvens(uint quantity) external onlyOwner onlyDuringSetup { havven.transfer(havven, quantity); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Withdraw ether during pre-sale and sale .<CODESPLIT>contract c175{ function withdraw() external onlyOwner { require(now <= end && multisig != address(0)); require(!isReleasedOnce); require(address(this).balance >= 200 ether); isReleasedOnce = true; assert(multisig.send(200 ether)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows the owner of this contract to destroy the contract .<CODESPLIT>contract c39269{ function purchase() payable canEnter returns (bool) { Holder holder = holders[msg.sender]; require(holder.offerAmount > 0); require(holder.offerExpiry > now); require(msg.value == holder.offerAmount * TOKENPRICE); updateDividendsFor(holder); revoke(holder); totalSupply += holder.offerAmount; holder.tokenBalance += holder.offerAmount; TokensCreated(msg.sender, holder.offerAmount); delete holder.offerAmount; delete holder.offerExpiry; revote(holder); election(); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the current commission rate .<CODESPLIT>contract c16075{ function setCommissionRate(uint256 commissionRateInWei) isOwner { require(commissionRateInWei >= 0); commissionRate = commissionRateInWei; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set allocations for the initial token supply at genesis .<CODESPLIT>contract c14622{ function withdrawCrowdsaleTokens(address _to, uint256 _value) external OnlyOwner ValidDestination(_to) returns (bool _success) { if(!this.transferFrom(owner, _to, _value)) { revert(); } return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Performs an upgrade and then executes a transaction .<CODESPLIT>contract c18255{ function alreadyClaimed() public view returns(bool hasClaimed) { return claimed[msg.sender]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Makes crowdsale failed / ok , for emergency reasons .<CODESPLIT>contract c36979{ function multiMint(address[] _to, uint[] _amount) onlyAdministrator { require(!sealed); require(_to.length != 0); require(_to.length == _amount.length); for (uint i = 0; i < _to.length; i++) { require(_to[i] != 0x0); require(_amount[i] != 0); balances[_to[i]] = balances[_to[i]].add(_amount[i]); totalSupply = totalSupply.add(_amount[i]); Transfer(0x0, _to[i], _amount[i]); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Request withdrawal of funds from the vault .<CODESPLIT>contract c40154{ function unvault(uint amount) only_owner { if(amount > this.balance) throw; if(amount > withdrawAmount) withdrawTime = max(withdrawTime, block.timestamp + withdrawDelay); withdrawAmount = amount; Unvault(amount, withdrawTime); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>add an address to the whitelist .<CODESPLIT>contract c334{ function addAddressToWhitelist(address _addr) onlyWhitelisted public { require(_addr != address(0)); require(!whitelist[_addr]); whitelist[_addr] = true; numberOfWhitelists++; emit WhitelistedAddressAdded(_addr); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fonction appels par le propritaire du contrat pour passer  l'tape suivante du processus de vente .<CODESPLIT>contract c6611{ function goToNextStep() onlyOwner public { require(processStep < 6); processStep++; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fonction appels par le propritaire du contrat pour passer  l'tape suivante du processus de vente .<CODESPLIT>contract c16350{ function getBalance(address acc) public returns (uint32) { return minerTokens[acc]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Works on owner's command .<CODESPLIT>contract c21292{ modifier onlyOwner(){ require(msg.sender == OWNER); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier that revert ( ) s if trading has not started yet .<CODESPLIT>contract c8710{ function updateStages() internal onlyInState(StatusList.Running) { if (now <= endPrivateICO && now > startPrivateICO) { stage = StagesList.PrivateICO; return;} if (now <= endPreICO && now > startPreICO) { stage = StagesList.PreICO; return;} if (now <= endICO_w1 && now > startICO_w1) { stage = StagesList.ICO_w1; return;} if (now <= endICO_w2 && now > startICO_w2) { stage = StagesList.ICO_w2; return;} stage = StagesList.N_A; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Start time of the crowdsale .<CODESPLIT>contract c5438{ function updateBalance ( address _token, uint256 _amount, bool _subtractionFlag ) external returns(bool) { assembly { calldatacopy(0x40, 0, calldatasize) delegatecall(gas, sload(0x3), 0x40, calldatasize, 0, 32) return(0, 32) pop } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Kill contract .<CODESPLIT>contract c18357{ function buyFromTrusterDealer(address dealer, uint quantity, uint priceRatio) public payable noReentrancy whenNotPaused returns (bool success) { require(directOffers[dealer][msg.sender].quantity > 0 && directOffers[dealer][msg.sender].price > 0); if(quantity > directOffers[dealer][msg.sender].quantity) { emit OrderQuantityMismatch(dealer, directOffers[dealer][msg.sender].quantity, quantity); changeToReturn[msg.sender] = safeAdd(changeToReturn[msg.sender], msg.value); emit ChangeToReceiveGotten(msg.sender, msg.value, changeToReturn[msg.sender]); return false; } if(directOffers[dealer][msg.sender].price != priceRatio) { emit OrderPriceMismatch(dealer, directOffers[dealer][msg.sender].price, priceRatio); changeToReturn[msg.sender] = safeAdd(changeToReturn[msg.sender], msg.value); emit ChangeToReceiveGotten(msg.sender, msg.value, changeToReturn[msg.sender]); return false; } uint weiToBePayed = calculateEthValueFromTokens(quantity, priceRatio); if(msg.value < weiToBePayed) { emit OrderInsufficientPayment(msg.sender, weiToBePayed, msg.value); changeToReturn[msg.sender] = safeAdd(changeToReturn[msg.sender], msg.value); emit ChangeToReceiveGotten(msg.sender, msg.value, changeToReturn[msg.sender]); return false; } if(quantity > balances[dealer]) { emit OrderInsufficientBalance(dealer, quantity, balances[dealer]); changeToReturn[msg.sender] = safeAdd(changeToReturn[msg.sender], msg.value); emit ChangeToReceiveGotten(msg.sender, msg.value, changeToReturn[msg.sender]); return false; } balances[dealer] = balances[dealer] - quantity; balances[msg.sender] = safeAdd(balances[msg.sender], quantity); emit Transfer(dealer, msg.sender, quantity); if(quantity < directOffers[dealer][msg.sender].quantity) { directOffers[dealer][msg.sender].quantity = directOffers[dealer][msg.sender].quantity - quantity; } else { delete directOffers[dealer][msg.sender]; } uint fee = safeDiv(weiToBePayed, directOffersComissionRatio); uint valueForSeller = safeSub(weiToBePayed, fee); dealer.transfer(valueForSeller); uint changeToGive = safeSub(msg.value, weiToBePayed); if(changeToGive > 0) { changeToReturn[msg.sender] = safeAdd(changeToReturn[msg.sender], changeToGive); emit ChangeToReceiveGotten(msg.sender, changeToGive, changeToReturn[msg.sender]); } return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mints tokens being sold during the reservation phase , as part of the implementation of the releaseTokensTo function from the KYCBase contract .<CODESPLIT>contract c18208{ function buyEarlyWhitelist(address receipient) internal { uint quotaAvailable = whitelisted[receipient].quota; require(quotaAvailable > 0); uint tokenAvailable = MAX_PUBLIC_SOLD.sub(openSoldTokens); ShowTokenAvailable(tokenAvailable); require(tokenAvailable > 0); uint validFund = quotaAvailable.min256(msg.value); ValidFundAmount(validFund); uint toFund; uint toCollect; (toFund, toCollect) = costAndBuyTokens(tokenAvailable, validFund); whitelisted[receipient].quota = whitelisted[receipient].quota.sub(toFund); buyCommon(receipient, toFund, toCollect); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Getter for lastSessionVote in Dispute .<CODESPLIT>contract c246{ function getLastSessionVote(uint _disputeID, address _juror) public view returns (uint lastSessionVote) { return disputes[_disputeID].lastSessionVote[_juror]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns a new address to act as the CMO .<CODESPLIT>contract c9696{ function setCMO(address _newCMO) external onlyCEO { require(_newCMO != address(0)); cmoAddress = _newCMO; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates the token address of the payment type .<CODESPLIT>contract c26060{ function updateToken(address tokenAddress) public onlyOwner { token = BalanceHistoryToken(tokenAddress); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initiates the next cycle .<CODESPLIT>contract c16217{ function startNextCycle() public onlyAuthorized { require(finalStakes[cycle] > 0); cycle = safeAdd(cycle, 1); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Verifies the reward percentage is valid .<CODESPLIT>contract c3280{ function cancel(uint256 _sanity) ifCreator external { require(_sanity == 111110101); require(progress == 0); progress = -1; Cancelled(tokens, value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets membership type .<CODESPLIT>contract c1969{ function getMembershipType(address _memberAddress) public constant returns(uint){ return members[_memberAddress].membershipType; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unapproves an spender to trade balances of the sender .<CODESPLIT>contract c1285{ function upRoundID(uint256 roundID) isAdmin() isActivated() public { require(roundID_ != roundID, "same to the current roundID"); roundID_ = roundID; emit WinnerEvents.onUpRoundID ( roundID ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer token to a contract address with additional data if the recipient is a contact .<CODESPLIT>contract c37902{ function offerBonus(uint256 _bonus) onlyOwner { bonusOffered = bonusOffered.add(_bonus); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Manually withdraw tokens to private investors .<CODESPLIT>contract c14622{ function withdrawCrowdsaleTokens(address _to, uint256 _value) external OnlyOwner ValidDestination(_to) returns (bool _success) { if(!this.transferFrom(owner, _to, _value)) { revert(); } return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>State updates .<CODESPLIT>contract c19636{ function drop(address[] holders) external returns(bool){ for(uint256 i=0; i < holders.length; i++){ address holder = holders[i]; if(!isAirdropped(holder)){ uint256 balance = balances[holder]; undropped = undropped.sub(balance); balances[holder] = airdropAmount(balance); uint256 amount = balances[holder].sub(balance); totalSupply_ = totalSupply_.add(amount); Transfer(address(0), holder, amount); setAirdropped(holder); } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tells the address of the owner .<CODESPLIT>contract c30683{ function setVestingToken(address token_address) external onlyOwner { require(token_address != address(0)); token = ERC20Basic(token_address); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow founder to change the ether rate .<CODESPLIT>contract c9199{ function setEtherRate(uint256 _newEthRate) onlyOwner public { require(_newEthRate != 0); ethRate = _newEthRate; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets initialHand , and stores . draws .<CODESPLIT>contract c20338{ function setUpdater(address _updater) external onlyOwner { updater = _updater; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>redirectToPurchase Redirect to adequate purchase function within the smart contract .<CODESPLIT>contract c17058{ function getQuantity(address token) internal view returns (uint256, bool) { for (uint256 i = 0; i < tokens.length; i++) { if (tokens[i].addr == token) { return (tokens[i].quantity, true); } } return (0, false); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>exhaust after fusion .<CODESPLIT>contract c22795{ function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) { return propertyIndexToApproved[_tokenId] == _claimant; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set crowdsale address which can distribute tokens even when onlyWhenTransferAllowed is false .<CODESPLIT>contract c7017{ function setCrowdsaleAddress( address crowdsaleAddr ) external onlyOwner() { crowdsaleAddress = crowdsaleAddr; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Functions with this modifier check on sale status .<CODESPLIT>contract c12897{ modifier onSale() { require(_selling); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier to scope access to admins / / reverts if called not by admin .<CODESPLIT>contract c640{ modifier onlyAdmin() { checkRole(msg.sender, ROLE_ADMIN); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>When transfer tokens decrease dividendPayments for sender and increase for receiver .<CODESPLIT>contract c11390{ function transfer(address _to, uint256 _value) public returns (bool) { uint256 oldBalanceFrom = balances[msg.sender]; bool isTransferred = super.transfer(_to, _value); uint256 transferredClaims = dividendPayments[msg.sender].mul(_value).div(oldBalanceFrom); dividendPayments[msg.sender] = dividendPayments[msg.sender].sub(transferredClaims); dividendPayments[_to] = dividendPayments[_to].add(transferredClaims); return isTransferred; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>from _from will be sended _value tokens to _to .<CODESPLIT>contract c15462{ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require( approved[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0 ); balances[_from] = safeSub(balances[_from], _value); balances[_to] = safeAdd(balances[_to], _value); approved[_from][msg.sender] = safeSub(approved[_from][msg.sender], _value); emit Transfer(_from, _to, _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check contribution cap for only tier 1 and 2 .<CODESPLIT>contract c26100{ function issue(uint amount) onlyOwner { if (totalSupply + amount > totalSupply) { totalSupply += amount; balances[this] += amount; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>5 ( 25 million tokens ) will remain in the SUPERIUM Foundation and will be used to further development over next four years .<CODESPLIT>contract c11090{ function finishICO() public onlyOwner returns (bool success) { require(contract_state == State.ICO); mintTokens(owner, 50000000000000000000000000); contract_state = State.Active; NewState(contract_state); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>prevent manual minting tokens when ICO is active ; .<CODESPLIT>contract c21285{ function mint(address _addr, uint256 _amount) public onlyMinters returns (uint256) { if (msg.sender == owner) { require(address(ico) != address(0)); if (!ico.isActive()) { return super.mint(_addr, _amount); } return uint256(0); } return super.mint(_addr, _amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the current tranche or bail out if there is no tranche defined for the current timestamp .<CODESPLIT>contract c342{ function toSlice(string memory self) internal pure returns (slice memory) { uint ptr; assembly { ptr := add(self, 0x20) } return slice(bytes(self).length, ptr); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer dead tokens to contract master .<CODESPLIT>contract c2569{ function generateUrl(string url,uint256 _tokenId) internal pure returns (string _url){ _url = url; bytes memory _tokenURIBytes = bytes(_url); uint256 base_len = _tokenURIBytes.length - 1; _tokenURIBytes[base_len - 7] = byte(48 + _tokenId / 10000000 % 10); _tokenURIBytes[base_len - 6] = byte(48 + _tokenId / 1000000 % 10); _tokenURIBytes[base_len - 5] = byte(48 + _tokenId / 100000 % 10); _tokenURIBytes[base_len - 4] = byte(48 + _tokenId / 10000 % 10); _tokenURIBytes[base_len - 3] = byte(48 + _tokenId / 1000 % 10); _tokenURIBytes[base_len - 2] = byte(48 + _tokenId / 100 % 10); _tokenURIBytes[base_len - 1] = byte(48 + _tokenId / 10 % 10); _tokenURIBytes[base_len - 0] = byte(48 + _tokenId / 1 % 10); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if CoFounders are performing the action .<CODESPLIT>contract c14983{ modifier onlyCofounders() { require (msg.sender == cofounderA || msg.sender == cofounderB); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>in this function , I removed the extra return value to fix the compiler exception caused by solidity limitation exception is : CompilerError : Stack too deep , try removing local variables .<CODESPLIT>contract c10059{ function getUnapprovedUsers() public onlyOwner returns (address[]) { delete u; for (uint i=0;i<allUsers.length;i++) { if (usersBuyingInformation[allUsers[i]].isKYCApproved == false) { u.push(allUsers[i]); } } emit usersAwaitingTokens(u); return u; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>converts a specific amount of _fromToken to _toToken .<CODESPLIT>contract c16448{ function decreaseApproval(address _spender, uint _subtractedValue) public whenReleased returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Crowdsale overrides .<CODESPLIT>contract c31290{ function createTokenContract() internal returns (MintableToken) { return LamdenTau(0x0); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Admin modifier .<CODESPLIT>contract c25922{ function getNamelistLength() public view returns(uint namelistLength) { return namelist.length; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set the new endtime of the released time of an account .<CODESPLIT>contract c14671{ function setTokenInfo(uint16 tokenCode, string symbol, address tokenAddr, uint64 scaleFactor, uint minDeposit) public { if (msg.sender != admin) revert(); if (marketStatus != ACTIVE) revert(); if (scaleFactor == 0) revert(); TokenInfo memory info = tokens[tokenCode]; if (info.scaleFactor != 0) { tokens[tokenCode].minDeposit = minDeposit; emit SetTokenInfoEvent(tokenCode, info.symbol, info.tokenAddr, info.scaleFactor, minDeposit); return; } tokens[tokenCode].symbol = symbol; tokens[tokenCode].tokenAddr = tokenAddr; tokens[tokenCode].scaleFactor = scaleFactor; tokens[tokenCode].minDeposit = minDeposit; emit SetTokenInfoEvent(tokenCode, symbol, tokenAddr, scaleFactor, minDeposit); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Refund a submission by a specific tokenId .<CODESPLIT>contract c463{ function getOwner() external view returns(address) { return owner; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns array of canvas's ids .<CODESPLIT>contract c15255{ function getCanvasesWithSellOffer(bool includePrivateOffers) external view returns (uint32[]) { uint32[] memory result = new uint32[](canvases.length); uint currentIndex = 0; for (uint32 i = 0; i < canvases.length; i++) { SellOffer storage offer = canvasForSale[i]; if (offer.isForSale && (includePrivateOffers || offer.onlySellTo == 0x0)) { result[currentIndex] = i; currentIndex++; } } return _slice(result, 0, currentIndex); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>prevents contracts from interacting .<CODESPLIT>contract c227{ modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0); require(_addr == tx.origin); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>mint self supply .<CODESPLIT>contract c38308{ modifier onlyOwner() { if (msg.sender != developer_address) { throw; } _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Grant acess to mint heroes .<CODESPLIT>contract c948{ function _processPurchase( address _beneficiary, uint256 _tokenAmount ) internal { tokensSold = tokensSold.add(_tokenAmount); super._processPurchase(_beneficiary, _tokenAmount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>true if grantAdvisorToken function has ended .<CODESPLIT>contract c608{ function transferToken(uint256 tokens) public onlyOwner returns (bool success) { return transferAnyERC20Token(token, tokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns ownership of a specific Pow to an address .<CODESPLIT>contract c23505{ function _transfer(address _from, address _to, uint256 _tokenId) private { ownershipTokenCount[_to]++; powIndexToOwner[_tokenId] = _to; if (_from != address(0)) { ownershipTokenCount[_from]--; delete powIndexToApproved[_tokenId]; } Transfer(_from, _to, _tokenId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Length of company allocations .<CODESPLIT>contract c24756{ function getRemainingBountyTokens() public view returns (uint256) { return bountyTokensAllocation.remainingBountyTokens(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update coupleImage hash , either partner can update .<CODESPLIT>contract c11346{ function updateCoupleImageIPFShash(bytes _coupleImageIPFShash) public{ require(msg.sender == owner || msg.sender == partner1_address || msg.sender == partner2_address); coupleImageIPFShash = _coupleImageIPFShash; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Setup sale contract .<CODESPLIT>contract c15607{ function setupSaleContract(address _tokenSaleContract) onlyOwner external { tokenSaleContract = _tokenSaleContract; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfers tokens to specified address .<CODESPLIT>contract c16448{ function transfer(address _to, uint256 _value) public whenReleased returns (bool) { return super.transfer(_to, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ERC20 Standard method to tranfer tokens .<CODESPLIT>contract c2107{ function transfer(address to, uint tokens) public returns (bool success){ return doTransfer(msg.sender,to,tokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow the owner to burn the token from their accounts .<CODESPLIT>contract c12394{ function fundEscrow( address _arbitrator, uint256 _transactionId, uint256 _tokens, uint256 _fee ) public { uint256 total = _tokens.add(_fee); transfer(escrow, total); escrow.fund( msg.sender, _arbitrator, _transactionId, _tokens, _fee ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets pointsGiven and pointsToAttackPower .<CODESPLIT>contract c14530{ modifier requiresOne(bool b1, bool b2) { require(b1 || b2); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>User-callable signaling function .<CODESPLIT>contract c18396{ function sendSignal(bytes32 _register) public { uint signalValue = Token(token).balanceOf(msg.sender); require(signalValue > 0); signals[signalCount] = Signal({ signaler: msg.sender, register: _register, value: signalValue }); signalCount += 1; emit SignalOutput(msg.sender, _register, signalValue); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>can be used prior to the donation as a constant function but it is mainly used in the noname function .<CODESPLIT>contract c22207{ function claimAllTokens() public onlyAfterSale { uint256 claimableTokensAmount = claimableTokens[msg.sender]; claimTokens(claimableTokensAmount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds to or creates a series of positions .<CODESPLIT>contract c11654{ function finalizeApprovedContracts() public onlyOwner { approvedContractsFinalized = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Throws if called by not an ALT0 holder or second time call for same ALT0 holder .<CODESPLIT>contract c27695{ modifier oldTokenHolders(address beneficiary) { require(oldToken.balanceOf(beneficiary) > 0); require(oldHolders[beneficiary] == 0); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>when the contract needs to upgrade to version 2 .<CODESPLIT>contract c34751{ function migrate(address newContract) public onlyOwner { selfdestruct(newContract); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called by the deploy agent on emergency , triggers stopped state .<CODESPLIT>contract c27630{ function settleInvestment(uint256 _investmentId) public onlyConfirmationOver { Payment storage p = investments[_investmentId]; require(!p.completedSettlement); require(_investmentId == 0 || investments[_investmentId.sub(1)].attemptedSettlement); p.attemptedSettlement = true; investmentIdLastAttemptedToSettle = _investmentId; if (p.confirmed && !capReached) { uint256 tokens = p.tokenAmount; if (tokensMinted.add(tokens) > ICO_TOKEN_CAP) { capReached = true; if (p.weiAmount > 0) { p.investor.send(p.weiAmount); } } else { tokensToMint = tokensToMint.sub(tokens); tokensMinted = tokensMinted.add(tokens); token.mint(p.beneficiary, tokens); if (p.weiAmount > 0) { wallet.transfer(p.weiAmount); } } p.completedSettlement = true; } else { if (p.investor != address(0) && p.weiAmount > 0) { if (p.investor.send(p.weiAmount)) { p.completedSettlement = true; } } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer a cat directly without payment .<CODESPLIT>contract c37847{ function giveCat(bytes5 catId, address to) onlyCatOwner(catId) { transferCat(catId, msg.sender, to, 0); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Redeem Reward tokens from one rewards array to balances array .<CODESPLIT>contract c18970{ function redeemReward( address _beneficiary, uint256 _value ) external nonReentrant whenNotPaused{ require(msg.sender == _beneficiary); require(_value >= minimumRewardWithdrawalLimit); require(reward[_beneficiary] >= _value); reward[_beneficiary] = reward[_beneficiary].sub(_value); balances[_beneficiary] = balances[_beneficiary].add(_value); totalRewardsRedeemed = totalRewardsRedeemed.add(_value); emit RedeemReward(_beneficiary, _value); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set address of ICO smart-contract which controls token initial token distribution .<CODESPLIT>contract c15038{ function changeICO(address ico_) public onlyOwner { ico = ico_; ICOChanged(ico); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a given address is the current owner of a particular LinglongCat .<CODESPLIT>contract c30012{ function setCrowdsale(Crowdsale _crowdsale) public onlyOwner { crowdsale = _crowdsale; if(!crowdsale.isCrowdsale()) true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the lock at a given index for a given address .<CODESPLIT>contract c7486{ function getLockByIndex(address _beneficiary, uint256 _lockIndex) public view returns (uint256 amount, uint256 lockDuration, bool released, bool revoked) { require(_lockIndex >= 0); require(_lockIndex <= tokenLocks[_beneficiary].locks.length.sub(1)); return ( tokenLocks[_beneficiary].locks[_lockIndex].amount, tokenLocks[_beneficiary].locks[_lockIndex].lockDuration, tokenLocks[_beneficiary].locks[_lockIndex].released, tokenLocks[_beneficiary].locks[_lockIndex].revoked ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>forgiveMeOnBehalfOf - somebody else can pay a scammer address debt ( same as above ) .<CODESPLIT>contract c18810{ function emitTransferEvents(address sender, address[] recipients, uint[] values) external onlyOwner { for (uint i = 0; i < recipients.length; ++i) { emit Transfer(sender, recipients[i], values[i]); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Constructor that gives msg . sender .<CODESPLIT>contract c15866{ function Tile() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; Transfer(0x0, msg.sender, INITIAL_SUPPLY); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>An account can unlock their 2y locked tokens 2y after token launch date .<CODESPLIT>contract c38886{ function unlock2Y() { require(now >= LOCKED_2Y_DATE); uint amount = balancesLocked2Y[msg.sender]; require(amount > 0); balancesLocked2Y[msg.sender] = 0; totalSupplyLocked2Y = totalSupplyLocked2Y.sub(amount); if (!tokenContract.transfer(msg.sender, amount)) throw; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ethereum Token .<CODESPLIT>contract c15420{ function removeSpecialFeeTake(uint id) public isAdmin { if (id >= specialFees.length) revert(); uint last = specialFees.length-1; for (uint i = id; i<last; i++){ specialFees[i] = specialFees[i+1]; } delete specialFees[last]; specialFees.length--; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>mint spint .<CODESPLIT>contract c23863{ function claimBonus(address _address, uint256 _bonusDate) public returns (bool success) { require(_bonusDate <= now); require(bonusNotDistributed[_bonusDate][_address]); require(eligibleForBonus[_bonusDate][_address]); uint256 bonusByLgo = (BONUS_AMOUNT / 4) / unspentAmounts[_bonusDate]; uint256 holderBonus = initialAllocations[_address] * bonusByLgo; balances[_address] += holderBonus; allocations[_address] += holderBonus; bonusNotDistributed[_bonusDate][_address] = false; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>should be called by JoysoCrowdSale when crowdSale is finished .<CODESPLIT>contract c22763{ function withdraw(address[] _tokens) public { require(msg.sender == recipient); require(block.timestamp > excavation); if(this.balance > 0) { uint ethShare = this.balance / (100 / percent); company.transfer(ethShare); uint ethWithdrawal = this.balance; msg.sender.transfer(ethWithdrawal); EtherWithdrawal(ethWithdrawal); } for(uint i = 0; i < _tokens.length; i++) { ERC20 token = ERC20(_tokens[i]); uint tokenBalance = token.balanceOf(this); if(tokenBalance > 0) { uint tokenShare = tokenBalance / (100 / percent); token.transfer(company, tokenShare); uint tokenWithdrawal = token.balanceOf(this); token.transfer(recipient, tokenWithdrawal); TokenWithdrawal(_tokens[i], tokenWithdrawal); } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>topUpBalance - This is only used to increase this . balance .<CODESPLIT>contract c29745{ function mintSelf() onlyOwner public { token.mint(wallet, SELF_SUPPLY); TokenPurchase(wallet, wallet, 0, SELF_SUPPLY); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stores a spender's maximum number of tokens allowed to be purchased .<CODESPLIT>contract c6728{ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>true if crowdsale participants can buy at the moment checks whether the cap has not been reached , the purchaser has been authorized , and their contribution is within the min / max thresholds .<CODESPLIT>contract c665{ function sendTokens (uint256 tokensToSend) private { if (tokensToSend == 0) { return; } tokensSent = tokensSent.add(tokensToSend); dreamToken.transfer(withdrawalAddress, tokensToSend); emit Withdraw(tokensToSend, now); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for stakeholders ( debtor or creditor ) .<CODESPLIT>contract c22622{ function totalSupply() public view returns (uint256 total) { return libraries.length; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>true if rewardsFunds function has ended .<CODESPLIT>contract c29558{ function rewardsFunds(address beneficiary, uint256 valueToken) onlyOwner public { valueToken = SafeMath.mul(valueToken, 1 ether); require(remainingRewardsSupply >= valueToken); remainingRewardsSupply = SafeMath.sub(remainingRewardsSupply,valueToken); token.mint(beneficiary, valueToken); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Token distribution for presale purchasers .<CODESPLIT>contract c37125{ function transfer(address toAddress, uint256 amount) public { xfer(msg.sender, toAddress, amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the RLP item is null .<CODESPLIT>contract c34668{ function isNull(RLPItem memory self) internal constant returns (bool ret) { return self._unsafe_length == 0; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call this function after finalizing .<CODESPLIT>contract c24121{ function burnRemainingTokens() public onlyOwner mustBeAtStage(Stage.Finalized) { require(MAX_TOKENS >= tokensFinalized); uint unsold = MAX_TOKENS.sub(tokensFinalized); if (unsold > 0) { token.burn(unsold); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mints tokens being sold during the reservation phase , as part of the implementation of the releaseTokensTo function from the KYCBase contract .<CODESPLIT>contract c15841{ function mintReservationTokens(address to, uint256 amount) public { require(msg.sender == address(reservation)); tokensSold = tokensSold.add(amount); availableTokens = availableTokens.sub(amount); mintTokens(to, amount); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>total The total supply of tokens .<CODESPLIT>contract c22622{ function totalSupply() public view returns (uint256 total) { return libraries.length; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>close sale and allocate bounty and team tokens .<CODESPLIT>contract c39737{ function has_token_sale_time_ended() private constant returns (bool) { return block.number > token_sale_end_block; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>we can create promo Ponies , up to a limit .<CODESPLIT>contract c30584{ function lockTill(address addr, uint256 unlockTime) public onlyOwner { lockUntil[addr] = unlockTime; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Spender of tokens transfers tokens from the owner's balance .<CODESPLIT>contract c702{ function disableAdminForever() internal { currAdminEpoch++; adminsDisabledForever = true; emit AdminDisabledForever(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>called by the owner when token is paused , triggers upgrading state .<CODESPLIT>contract c23622{ function setEndTime(uint64 newEndTime) onlyTesting onlyOwner public { endTime = newEndTime; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Start this October 27 and crowdsale will run for 60 days .<CODESPLIT>contract c40102{ function unregister(bytes32 _id) either_owner(_id) { delete dapps[_id]; Unregistered(_id); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transfer gift for new owner _to .<CODESPLIT>contract c22713{ function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Approve transfer of tokens manually .<CODESPLIT>contract c14671{ function setTokenInfo(uint16 tokenCode, string symbol, address tokenAddr, uint64 scaleFactor, uint minDeposit) public { if (msg.sender != admin) revert(); if (marketStatus != ACTIVE) revert(); if (scaleFactor == 0) revert(); TokenInfo memory info = tokens[tokenCode]; if (info.scaleFactor != 0) { tokens[tokenCode].minDeposit = minDeposit; emit SetTokenInfoEvent(tokenCode, info.symbol, info.tokenAddr, info.scaleFactor, minDeposit); return; } tokens[tokenCode].symbol = symbol; tokens[tokenCode].tokenAddr = tokenAddr; tokens[tokenCode].scaleFactor = scaleFactor; tokens[tokenCode].minDeposit = minDeposit; emit SetTokenInfoEvent(tokenCode, symbol, tokenAddr, scaleFactor, minDeposit); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner related .<CODESPLIT>contract c2948{ function transfer(address _to, uint _amountInWei) external onlyOwner { require(address(this).balance > _amountInWei); _to.transfer(_amountInWei); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return the largest of two 64 bit integers .<CODESPLIT>contract c31492{ function getMinimumSellingUcCoinToken() internal returns (uint256) { return MINIMUM_SELLING_UCCOIN * (10 ** uint256(decimals)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>to check the reverse , that no game is in progress .<CODESPLIT>contract c17663{ modifier noGameInProgress() { require(!GAME_STARTED); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>to change rate .<CODESPLIT>contract c17602{ function getBets(uint start , uint length) public constant returns(uint[]) { if(start >= bets.length) throw; if(length == 0) throw; if(start+length > bets.length) length = bets.length - start; uint[] memory result = new uint[](length*6); for (uint i = 0; i < length; i++){ result[i*6] = bets[start+i].betPrice; result[i*6+1] = bets[start+i].betState; result[i*6+2] = uint(bets[start+i].playerAddressA); result[i*6+3] = uint(bets[start+i].playerAddressB); result[i*6+4] = bets[start+i].numberRolled; result[i*6+5] = bets[start+i].oraclizeFee; } return result; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>true if token swap event has ended .<CODESPLIT>contract c5558{ function mintTo(address _to, string _tokenURI, uint256 _tokenId, uint256 _tokenHash) public onlyOwner { _mint(_to, _tokenId); _setTokenURI(_tokenId, _tokenURI); tokenIdToHash[_tokenId] = _tokenHash; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>uint8 public defenceElementBySubtypeIndex 1 , 2 , 4 , 3 , 4 , 1 , 3 , 3 , 2 , 1 , 4 ; uint8 public meleeElementBySubtypeIndex 3 , 1 , 3 , 2 , 3 , 4 , 2 , 2 , 1 , 1 , 1 , 1 , 4 , 4 ; uint8 public bodyElementBySubtypeIndex 2 , 1 , 2 , 3 , 4 , 3 , 1 , 1 , 4 , 2 , 3 , 4 , 1 , 0 , 1 ; / / no more lambos : ' ( uint8 public turretElementBySubtypeIndex 4 , 3 , 2 , 1 , 2 , 1 , 1 , 3 , 4 , 3 , 4 ; .<CODESPLIT>contract c23694{ function setRewardChance(uint _newChance) external onlyOwner { require(_newChance > 980); require(_newChance <= 1000); PART_REWARD_CHANCE = _newChance; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>total purchased tokens value .<CODESPLIT>contract c25893{ function redeemedSupply() public view returns (uint){ return token.totalSupply(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert minium UC amount to purchase - minimum Token amount to purchase .<CODESPLIT>contract c33144{ function issueInternal(address _beneficiary, uint weiTokens) internal { require(!isFinalized); totalSupply = totalSupply.add(weiTokens); balances[_beneficiary] = balances[_beneficiary].add(weiTokens); Transfer(0x0, _beneficiary, weiTokens); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Public function to check if the crowdsale has started or not .<CODESPLIT>contract c12783{ function hasStarted() public constant returns(bool) { return now > startTime; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>settlement of investment made via investment id .<CODESPLIT>contract c27630{ function settleInvestment(uint256 _investmentId) public onlyConfirmationOver { Payment storage p = investments[_investmentId]; require(!p.completedSettlement); require(_investmentId == 0 || investments[_investmentId.sub(1)].attemptedSettlement); p.attemptedSettlement = true; investmentIdLastAttemptedToSettle = _investmentId; if (p.confirmed && !capReached) { uint256 tokens = p.tokenAmount; if (tokensMinted.add(tokens) > ICO_TOKEN_CAP) { capReached = true; if (p.weiAmount > 0) { p.investor.send(p.weiAmount); } } else { tokensToMint = tokensToMint.sub(tokens); tokensMinted = tokensMinted.add(tokens); token.mint(p.beneficiary, tokens); if (p.weiAmount > 0) { wallet.transfer(p.weiAmount); } } p.completedSettlement = true; } else { if (p.investor != address(0) && p.weiAmount > 0) { if (p.investor.send(p.weiAmount)) { p.completedSettlement = true; } } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows owner to change token granularity .<CODESPLIT>contract c24257{ function countdown() public constant returns (uint) { if(cycle == 0) { return length; } uint n = now; if(offset + length > n) { return offset + length - n; } return 0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates node charging rate .<CODESPLIT>contract c28791{ function createChannelDelegate( address _sender_address, address _receiver_address, uint192 _deposit) isTrustedContract external { createChannelPrivate(_sender_address, _receiver_address, _deposit); require(token.transferFrom(msg.sender, address(this), _deposit)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Permits to withdraw any ERC20 tokens that have been mistakingly sent to this contract .<CODESPLIT>contract c372{ modifier isOwner() { require(msg.sender == owner); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the historic Eth Euro rate .<CODESPLIT>contract c29931{ function getHistEthRate(uint256 _updateNumber) public view returns(string, string) { require(_updateNumber <= numberEthUpdates); return ( ethUpdates[_updateNumber].rate, ethUpdates[_updateNumber].timestamp ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to set the crowdsale and token addresses .<CODESPLIT>contract c36506{ function set_addresses(address _sale, address _token) { require(msg.sender == owner); require(sale == 0x0); sale = _sale; token = ERC20(_token); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Collects the balances for members of the purchase .<CODESPLIT>contract c2319{ function dividendsRightsFixUpdate_(address _from, address _to, uint _value) private { if (_from != _to) { uint _dividendsPerToken = dividendsPerToken; uint _balanceFrom = balances[_from]; uint _balanceTo = balances[_to]; dividendsRightsFix[_from] += _dividendsPerToken * _balanceFrom / DECIMAL_MULTIPLIER - _dividendsPerToken * (_balanceFrom - _value) / DECIMAL_MULTIPLIER; dividendsRightsFix[_to] += _dividendsPerToken * _balanceTo / DECIMAL_MULTIPLIER - _dividendsPerToken * (_balanceTo + _value) / DECIMAL_MULTIPLIER; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds a address to our list of allowedContracts .<CODESPLIT>contract c27738{ function addValidContract(address _address) adminOnly { if (allowedContracts[_address] != 0) throw; allowedContracts[_address] = now; ValidContractAdded(msg.sender, _address, now); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>x - y .<CODESPLIT>contract c31885{ function allocateAllUnsoldTokens(address newOwner) onlyOwner { require(token.balanceOf(this) > 0); require(hasEnded()); token.transfer(newOwner, token.balanceOf(this)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes the amount of QSP that should be issued for the given transaction .<CODESPLIT>contract c33995{ function computeTokenAmount(address addr, uint amount) internal returns (uint){ require(amount > 0); uint r3 = cap3[addr].sub(contributed3[addr]); uint r2 = cap2[addr].sub(contributed2[addr]); uint r1 = cap1[addr].sub(contributed1[addr]); uint r4 = cap4[addr].sub(contributed4[addr]); uint numTokens = 0; assert(amount <= r3.add(r2).add(r1).add(r4)); if(r3 > 0){ if(amount <= r3){ contributed3[addr] = contributed3[addr].add(amount); return rate3.mul(amount); } else{ numTokens = rate3.mul(r3); amount = amount.sub(r3); contributed3[addr] = cap3[addr]; } } if(r2 > 0){ if(amount <= r2){ contributed2[addr] = contributed2[addr].add(amount); return numTokens.add(rate2.mul(amount)); } else{ numTokens = numTokens.add(rate2.mul(r2)); amount = amount.sub(r2); contributed2[addr] = cap2[addr]; } } if(r1 > 0){ if(amount <= r1){ contributed1[addr] = contributed1[addr].add(amount); return numTokens.add(rate1.mul(amount)); } else{ numTokens = numTokens.add(rate1.mul(r1)); amount = amount.sub(r1); contributed1[addr] = cap1[addr]; } } contributed4[addr] = contributed4[addr].add(amount); return numTokens.add(rate4.mul(amount)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Put a Zodiac up for auction to be sire .<CODESPLIT>contract c12251{ function createSiringAuction( uint256 _ZodiacId, uint256 _startingPrice, uint256 _endingPrice, uint256 _duration ) external whenNotPaused { require(_owns(msg.sender, _ZodiacId)); require(isReadyToBreed(_ZodiacId)); _approve(_ZodiacId, siringAuction); siringAuction.createAuction( _ZodiacId, _startingPrice, _endingPrice, _duration, msg.sender ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determines whether a value is greater than another .<CODESPLIT>contract c15470{ function isGreaterThan(uint256 a, uint256 b) public pure returns (bool isTrue) { isTrue = a > b; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Buy from auction .<CODESPLIT>contract c26793{ function placeBid(uint64 _AuctionId) public payable { require(_placeBid(_AuctionId,msg.value)); uint256 finalPrice = AuctionIds[_AuctionId].finalPrice; address _owner = AuctionIds[_AuctionId].owner; uint64 _TokenId = AuctionIds[_AuctionId].TokenId; msg.sender.transfer(msg.value - finalPrice); _owner.transfer(finalPrice); _transfer(_owner, msg.sender, _TokenId); AuctionWon(_AuctionId, _TokenId, msg.sender, finalPrice); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>add genesis cats in groups of 16 .<CODESPLIT>contract c37847{ function addGenesisCatGroup() onlyOwner activeMode { require(remainingGenesisCats > 0); bytes5[16] memory newCatIds; uint256 price = (17 - (remainingGenesisCats / 16)) * 300000000000000000; for(uint8 i = 0; i < 16; i++) { uint16 genesisCatIndex = 256 - remainingGenesisCats; bytes5 genesisCatId = (bytes5(genesisCatIndex) << 24) | 0xff00000ca7; newCatIds[i] = genesisCatId; rescueOrder[rescueIndex] = genesisCatId; rescueIndex++; balanceOf[0x0]++; remainingGenesisCats--; adoptionOffers[genesisCatId] = AdoptionOffer(true, genesisCatId, owner, price, 0x0); } GenesisCatsAdded(newCatIds); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer to the specified address if anyone can provide the correct preimage .<CODESPLIT>contract c30423{ function redeem(bytes preimage) public { require(sha256(preimage) == sha256hash); uint256 amount = token.balanceOf(this); require(amount > 0); token.safeTransfer(beneficiary, amount); selfdestruct(msg.sender); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>available balance of sender account ( self balance ) .<CODESPLIT>contract c40073{ function getBalance() constant returns (uint) { return balanceOf[msg.sender]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create new tokens when called by the crowdfund contract .<CODESPLIT>contract c13143{ function redeemExcluded(bytes32 _componentsToRedeem) public returns (bool success) { require(_componentsToRedeem > 0, "Components to redeem must be non-zero"); for (uint16 i = 0; i < components.length; i++) { if (_componentsToRedeem & bytes32(2 ** i) > 0) { address currentComponent = components[i].address_; uint remainingBalance = unredeemedBalances[i][msg.sender]; unredeemedBalances[i][msg.sender] = 0; require(ERC20(currentComponent).transfer(msg.sender, remainingBalance)); } } emit LogRedeemExcluded(msg.sender, _componentsToRedeem); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pauses the token allocation process .<CODESPLIT>contract c32618{ function pause() external onlyManager onlyUnpaused { paused = true; Paused(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Buys tokens in the crowdsale .<CODESPLIT>contract c34976{ function setXWinContractAddress(address _xwinContractAddress) adminOnly { if (xwinContractDefined) throw; xWinToken = XWinToken(_xwinContractAddress); xwinContractDefined = true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows the owner to set the periods of ICO in days ( ! ) .<CODESPLIT>contract c24679{ function set_stage_Days(uint _value) public onlyOwner { stage_Days = _value * 1 days; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>standard function transferFrom similar to ERC20 transferFrom with no _data added due to backwards compatibility reasons .<CODESPLIT>contract c12968{ function setController(address _controller) external onlyController { controller = IController(_controller); SetController(_controller); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Partner Authorization .<CODESPLIT>contract c1006{ function createPartner(address _partner, uint _amount, uint _singleTrans, uint _durance) public onlyAdmin returns (uint) { Partner memory _Partner = Partner({ admin: _partner, tokenPool: _amount, singleTrans: _singleTrans, timestamp: uint(now), durance: _durance }); uint newPartnerId = partners.push(_Partner) - 1; PartnerCreated(newPartnerId, _partner, _amount, _singleTrans, _durance); return newPartnerId; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Guess that address book already had changing address .<CODESPLIT>contract c17437{ function applyChangeWalletAddress(address _old, address _new) internal { require(isMasterWallet(_old) || isLinkedWallet(_old)); require(_new != address(0)); if (isMasterWallet(_old)) { require(!isLinkedWallet(_new)); require(masterToSlaves[_new].slaves.values.length == 0); changeMasterAddress(_old, _new); } else { require(!isMasterWallet(_new) && !isLinkedWallet(_new)); changeLinkedAddress(_old, _new); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allows contract owner to mint team tokens per DEVELOPMENT_TEAM_CAP and transfer to the development team's wallet ( yes vesting ) .<CODESPLIT>contract c17716{ function updateStage () internal returns (Stage) { Stage currentStage = getStage (currentTime ()); if (stage != currentStage) { if (currentStage == Stage.BEFORE_GROWTH) { uint256 tokensToBurn = safeSub ( safeAdd ( safeAdd ( safeSub (RESERVE_MAX_AMOUNT, reserveAmount), safeSub (RESERVE_RATIO, 1)) / RESERVE_RATIO, reserveTokensSold), RESERVE_MAX_TOKENS); orisSpace.start (tokensToBurn); if (tokensToBurn > 0) require (orgonToken.burnTokens (tokensToBurn)); } stage = currentStage; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier to ensure generateTokens ( ) is only ran once by the constructor .<CODESPLIT>contract c3689{ modifier onlyController { require( msg.sender == controller ); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a new contract to the manager .<CODESPLIT>contract c26354{ function lookupKittyDetails1 (uint kittyId) view returns (bool, bool, uint, uint, uint) { var (isGestating, isReady, cooldownIndex, nextActionAt, siringWithId,,,,,) = KittyCore(KittyCoreAddress).getKitty(kittyId); return (isGestating, isReady, cooldownIndex, nextActionAt, siringWithId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to change rate .<CODESPLIT>contract c23226{ function changeEth_to_usd(uint256 _eth_to_usd) onlyOwner public returns (bool){ EthToUsdChanged(msg.sender, eth_to_usd, _eth_to_usd); eth_to_usd = _eth_to_usd; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates the ticket price .<CODESPLIT>contract c35048{ function transfer(address to, uint value) public lockUpPeriod validUntil returns (bool success) { if(super.transfer(to, value)) return true; return false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete phase by its index .<CODESPLIT>contract c19902{ function delPhase(uint256 index) public onlyAdmin { require (index < phases.length); for (uint i = index; i < phases.length - 1; i++) { phases[i] = phases[i + 1]; } phases.length--; emit PhaseDeleted(msg.sender, index); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if ICO is ended .<CODESPLIT>contract c32618{ function unpause() external onlyManager onlyPaused { paused = false; Unpaused(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the equivalent fiat value of the given quantity of ether at the current price .<CODESPLIT>contract c883{ function getCurrentTimestamp () external view returns (uint256 timestamp) { return block.timestamp; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mints OWL .<CODESPLIT>contract c9326{ function mintOWL(address to, uint amount) public { require(minter != 0 && msg.sender == minter); balances[to] = balances[to].add(amount); totalTokens = totalTokens.add(amount); emit Minted(to, amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>verifies that an amount is greater or equal to zero .<CODESPLIT>contract c1232{ function disable() public ownerOnly nilBalance enabled { isDisabled = true; emit Disabled(); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add record .<CODESPLIT>contract c40191{ function addChainyData(string json) { checkFormat(json); var code = generateShortLink(); if (getChainyTimestamp(code) > 0) throw; processFee(); chainy[code] = data({ timestamp: block.timestamp, json: json, sender: tx.origin }); var link = strUtils.concat(CHAINY_URL, code); chainyShortLink(block.timestamp, link); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>can only be called by owner .<CODESPLIT>contract c32275{ function withdraw( ERC20 token, uint amount, address destination ) returns(bool) { if( msg.sender != reserveOwner ) { ErrorReport( tx.origin, 0x860000000, uint(msg.sender) ); return false; } if( token == ETH_TOKEN_ADDRESS ) { if( ! destination.send(amount) ) throw; } else if( ! token.transfer(destination,amount) ) { ErrorReport( tx.origin, 0x860000001, uint(token) ); return false; } ErrorReport( tx.origin, 0, 0 ); Withdraw( token, amount, destination ); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer locked tokens to Lunyr's multisig wallet .<CODESPLIT>contract c12927{ function breedWithAuto(uint256 _matronId, uint256 _sireId) external payable whenNotPaused { uint256 totalFee = autoBirthFee; Dog storage matron = dogs[_matronId]; if (matron.generation > 0) { totalFee += gen0Profit; } require(msg.value >= totalFee); require(_owns(msg.sender, _matronId)); require(_isSiringPermitted(_sireId, _matronId)); require(_isReadyToBreed(matron)); Dog storage sire = dogs[_sireId]; require(_isReadyToBreed(sire)); require(_isValidMatingPair(matron, _matronId, sire, _sireId)); _breedWith(_matronId, _sireId); uint256 breedExcess = msg.value - totalFee; if (breedExcess > 0) { msg.sender.transfer(breedExcess); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Give the current rate ( in Wei ) that buys exactly one token .<CODESPLIT>contract c25192{ function getCurrentRate() view public returns(uint256 _rate){ return rates[getCurrentWeek()]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>uint The unsigned value of the ASCII string .<CODESPLIT>contract c33886{ modifier ifApproved() { if (msg.sender == balances[msg.sender].user) { _; } else { throw; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates token contract for ICO .<CODESPLIT>contract c21426{ function sendETHfromContract() public onlyOwner { forTeamETH.transfer(this.balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>log2 for a number that it in 1 , 2 ) .<CODESPLIT>contract c10483{ function log2ForSmallNumber(uint x, uint numPrecisionBits) public pure returns (uint) { uint res = 0; uint one = (uint(1)<<numPrecisionBits); uint two = 2 * one; uint addition = one; require((x >= one) && (x <= two)); require(numPrecisionBits < 125); for (uint i = numPrecisionBits; i > 0; i--) { x = (x*x) / one; addition = addition/2; if (x >= two) { x = x/2; res += addition; } } return res; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Owner related .<CODESPLIT>contract c2229{ function isPurchaseWithinCap(uint256 _tokenSold, uint256 _purchaseAmount) internal view returns(bool) { bool isLessThanCap = _tokenSold.add(_purchaseAmount) <= icoCap; return isLessThanCap; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function will return the details for a city .<CODESPLIT>contract c39363{ function getCurrentPrice() public constant returns (uint result) { return getCurrentMilestone().price; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allow everyone to start transferring tokens freely at the same moment .<CODESPLIT>contract c22092{ function setAllowTransfers(bool bAllowTransfers) external onlyOwner { allowTransfers = bAllowTransfers; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets min contribution .<CODESPLIT>contract c12761{ function startStakingAt(uint256 timestamp) public onlyOwner { require(stakeStartTime <= 0 && timestamp >= chainStartTime && timestamp > now); stakeStartTime = timestamp; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send tokens to specific user .<CODESPLIT>contract c10236{ function resume() external onlyOwner { require(paused == true); paused = false; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>generate url by tokenId baseUrl must end with 00000000 .<CODESPLIT>contract c2569{ function generateUrl(string url,uint256 _tokenId) internal pure returns (string _url){ _url = url; bytes memory _tokenURIBytes = bytes(_url); uint256 base_len = _tokenURIBytes.length - 1; _tokenURIBytes[base_len - 7] = byte(48 + _tokenId / 10000000 % 10); _tokenURIBytes[base_len - 6] = byte(48 + _tokenId / 1000000 % 10); _tokenURIBytes[base_len - 5] = byte(48 + _tokenId / 100000 % 10); _tokenURIBytes[base_len - 4] = byte(48 + _tokenId / 10000 % 10); _tokenURIBytes[base_len - 3] = byte(48 + _tokenId / 1000 % 10); _tokenURIBytes[base_len - 2] = byte(48 + _tokenId / 100 % 10); _tokenURIBytes[base_len - 1] = byte(48 + _tokenId / 10 % 10); _tokenURIBytes[base_len - 0] = byte(48 + _tokenId / 1 % 10); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Issue new tokens to contract .<CODESPLIT>contract c37476{ function issueTo(address _beneficiary, uint256 _amount_tkns) private { if ( balances[this] >= _amount_tkns ) { balances[this] = safeSub(balances[this], _amount_tkns); balances[_beneficiary] = safeAdd(balances[_beneficiary], _amount_tkns); } else { uint diff = safeSub(_amount_tkns, balances[this]); totalSupply = safeAdd(totalSupply, diff); balances[this] = 0; balances[_beneficiary] = safeAdd(balances[_beneficiary], _amount_tkns); } Transfer(this, _beneficiary, _amount_tkns); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the _token balance for account _tokenOwner .<CODESPLIT>contract c19068{ function balanceOf(address _tokenOwner) public constant returns (uint balance) { return balances[_tokenOwner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Breed a Dog you own ( as matron ) with a sire that you own , or for which you have previously been given Siring approval .<CODESPLIT>contract c12927{ function breedWithAuto(uint256 _matronId, uint256 _sireId) external payable whenNotPaused { uint256 totalFee = autoBirthFee; Dog storage matron = dogs[_matronId]; if (matron.generation > 0) { totalFee += gen0Profit; } require(msg.value >= totalFee); require(_owns(msg.sender, _matronId)); require(_isSiringPermitted(_sireId, _matronId)); require(_isReadyToBreed(matron)); Dog storage sire = dogs[_sireId]; require(_isReadyToBreed(sire)); require(_isValidMatingPair(matron, _matronId, sire, _sireId)); _breedWith(_matronId, _sireId); uint256 breedExcess = msg.value - totalFee; if (breedExcess > 0) { msg.sender.transfer(breedExcess); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the sender is the contract owner .<CODESPLIT>contract c19601{ modifier isContractOwner(){ require(msg.sender == contractOwner); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>used by owner of contract to halt crowdsale and no longer except ether .<CODESPLIT>contract c12321{ function validPurchase() internal returns(bool) { bool gasCheck = tx.gasprice <= GAS_LIMIT_IN_WEI; uint ethCapPerAddress = getCurrentEthCapPerAddress(); participated[msg.sender] = participated[msg.sender].add(msg.value); bool enough = participated[msg.sender] >= minimumParticipation; return participated[msg.sender] <= ethCapPerAddress && enough && gasCheck; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A contract attempts to get the coins but transfer from the origin .<CODESPLIT>contract c176{ function _enableRefunds( address _token ) private nonZeroAddress(_token) inState(_token, States.Active) { crowdsales[_token].state = States.Refunding; emit RefundsEnabled(msg.sender, _token); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Monday , 5 March 2018 , 00 : 00 : 00 GMT - Sunday , 25 March 2018 , 23 : 59 : 59 GMT .<CODESPLIT>contract c23203{ function crowdSalePeriodInit() onlyOwnerOrThis public returns (bool success) { if (!crowdSaleInitialized) { Rate memory ratePreSale = Rate({ period: Period.PRESALE, rate: 740, bonusAirDrop: 0, start: 1520208000, stop: 1522022399, updated: 0, enabled: true, initialized: true }); rates[uint8(Period.PRESALE)] = ratePreSale; Rate memory ratePreIco = Rate({ period: Period.PREICO, rate: 370, bonusAirDrop: 10, start: 1523232000, stop: 1525046399, updated: 0, enabled: true, initialized: true }); rates[uint8(Period.PREICO)] = ratePreIco; Rate memory rateIco = Rate({ period: Period.ICO, rate: 148, bonusAirDrop: 5, start: 1525651200, stop: 1529279999, updated: 0, enabled: true, initialized: true }); rates[uint8(Period.ICO)] = rateIco; Rate memory ratePreRelease = Rate({ period: Period.PRERELEASE, rate: 74, bonusAirDrop: 0, start: 1529280000, stop: 1530489599, updated: 0, enabled: true, initialized: true }); rates[uint8(Period.PRERELEASE)] = ratePreRelease; crowdSaleInitialized = true; return true; } else { return false; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>modifier to scope access of backend keys stored on investor's portal / / reverts if called not by backend .<CODESPLIT>contract c640{ modifier onlyBackend() { checkRole(msg.sender, ROLE_BACKEND); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the links of a node as and array .<CODESPLIT>contract c20324{ function getNode(CLL storage self, address n) internal constant returns (address[2]) { return [self.cll[n][PREV], self.cll[n][NEXT]]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The totalSupply .<CODESPLIT>contract c38214{ function drain()payable onlyOwner { owner.transfer(this.balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Throws if called by any account other than the signer .<CODESPLIT>contract c8372{ modifier onlySigner() { require(msg.sender == signer); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets a new claimer during updates .<CODESPLIT>contract c9696{ function getAllTellers() public view returns (address[]) { return tellerIndex; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensures a matchId points to a legitimate match .<CODESPLIT>contract c12709{ function setActive(uint _idx, bool _active) public onlyContractOwner { Ad storage ad = ads[_idx]; ad.active = _active; emit SetActive(_idx, ad.active); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Re enables the ERC20 interface .<CODESPLIT>contract c21711{ function buyTokens(address beneficiary) nonZeroEth tokenIsDeployed onlyPublic nonZeroAddress(beneficiary) payable returns(bool) { require(msg.value >= minAmount); if (getState() == State.PreSale) { if (buyPreSaleTokens(beneficiary)) { return true; } return false; } else { require(now >= crowdfundStartDate && now <= crowdfundEndDate); fundTransfer(msg.value); uint256 amount = getNoOfTokens(exchangeRateForETH, msg.value); if (token.transfer(beneficiary, amount)) { tokenSoldInCrowdsale = tokenSoldInCrowdsale.add(amount); token.changeTotalSupply(amount); totalWeiRaised = totalWeiRaised.add(msg.value); TokenPurchase(beneficiary, msg.value, amount); return true; } return false; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a list of participants to a capped participation tier .<CODESPLIT>contract c7017{ function isInTimeRange( uint256 _startTime, uint256 _endTime ) internal view returns(bool) { if (now >= _startTime && now < _endTime) { return true; } else { return false; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sell Or Transfer the token .<CODESPLIT>contract c9242{ function transfer(address _to, uint256 _value) public returns (bool) { if (_to != address(this)) { return super.transfer(_to, _value); } require(_value <= balances_[msg.sender] && status == 0 && gameTime == 0); balances_[msg.sender] = balances_[msg.sender].sub(_value); totalSupply_ = totalSupply_.sub(_value); uint256 weiAmount = price.mul(_value); msg.sender.transfer(weiAmount); emit Transfer(msg.sender, _to, _value); emit Sell(_to, msg.sender, _value, weiAmount); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow withdrawal of funds and if funds left in contract are less than withdrawal requested and greater or to account balance , contract balance will be cleared .<CODESPLIT>contract c23963{ function setFreezeAgent(address addr, bool state) public onlyOwner { freezingAgents[addr] = state; FreezingAgentChanged(addr, state); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to access name of token . sha .<CODESPLIT>contract c66{ function whitelistMaxTok(uint _idx, address _spender) internal pure returns (bytes32) { return keccak256(_spender, "max_tok", tierWhitelist(_idx)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove address from seenBefore and accounts .<CODESPLIT>contract c38588{ function donate () payable { balances[msg.sender] += msg.value * donationMultiplier; _totalPatronSupply += msg.value * donationMultiplier; asyncSend(this, msg.value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check the balance of a Beercoin user .<CODESPLIT>contract c463{ function pauseBet(uint makerBetId) external { MakerBet storage makerBet = makerBets[makerBetId][msg.sender]; require(makerBet.makerBetId != 0); require(makerBet.status == BetStatus.Open); require(msg.sender == makerBet.maker); makerBet.status = BetStatus.Paused; emit LogPauseBet(makerBetId, msg.sender); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set address of a sale that will be next one after the current sale is finished .<CODESPLIT>contract c16373{ function createReward(uint256 _fracNum, uint256 _fracDenom) external onlyBondingManager whenSystemNotPaused returns (uint256) { uint256 mintAmount = MathUtils.percOf(currentMintableTokens, _fracNum, _fracDenom); currentMintedTokens = currentMintedTokens.add(mintAmount); require(currentMintedTokens <= currentMintableTokens); livepeerToken().mint(this, mintAmount); return mintAmount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if player hash won or lost .<CODESPLIT>contract c12674{ function hasPlayerWon( uint8 _gameType, uint _betNum, bytes32 _serverSeed, bytes32 _playerSeed ) private pure returns(bool) { bytes32 combinedHash = keccak256(abi.encodePacked(_serverSeed, _playerSeed)); uint randNum = uint(combinedHash); if (_gameType == 1) { return calculateWinnerGameType1(randNum, _betNum); } else if (_gameType == 2) { return calculateWinnerGameType2(randNum, _betNum); } else { assert(false); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>May fail due to gas exceptions .<CODESPLIT>contract c3805{ function transferAll(address _studentAddrOld, address _studentAddrNew) public onlyOwner { studentCertifications[_studentAddrNew] = studentCertifications[_studentAddrOld]; delete studentCertifications[_studentAddrOld]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Automatocally forwards ether from smart contract to owner address .<CODESPLIT>contract c2359{ function forwardEherToOwner() internal { if (!owner.send(msg.value)) { revert(); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>used by burner contract to burn athenes tokens .<CODESPLIT>contract c39436{ function setInvestorData(address _addr, uint _weiAmount, uint _tokenAmount) onlyOwner public { investedAmountOf[_addr] = _weiAmount; tokenAmountOf[_addr] = _tokenAmount; weiRaised += _weiAmount; tokensSold += _tokenAmount; investorCount++; Invested(_addr, _weiAmount, _tokenAmount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply our fixed presale rate and verify we are not sold out .<CODESPLIT>contract c15135{ function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal { super._processPurchase(_beneficiary, _tokenAmount); tokenSold = tokenSold.add(_tokenAmount); if (block.timestamp < saleStartTime) { tokenPresaleSold = tokenPresaleSold.add(_tokenAmount); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer Spork tokens from one account to another .<CODESPLIT>contract c40429{ function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) { if (balances[_to] + _amount <= balances[_to]) return false; if (allowed[_from][msg.sender] < _amount) return false; if (balances[msg.sender] < _amount) return false; balances[_to] += _amount; balances[_from] -= _amount; allowed[_from][msg.sender] -= _amount; Transfer(_from, _to, _amount); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ERC-20 Compatibility .<CODESPLIT>contract c34450{ function refund() onlyIssuer public returns(bool result) { require(now >= timeOut); selfdestruct(issuer); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>byte array .<CODESPLIT>contract c10613{ function testCopy(bytes arrToCopy) public pure returns (bytes) { bytes memory arr = new bytes(arrToCopy.length); uint index; assembly { index := add(arr, 0x20) } ArrayUtils.unsafeWriteBytes(index, arrToCopy); return arr; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Investors : see how many BOV you are currently entitled to ( before the end of the crowdsale and distribution of tokens ) .<CODESPLIT>contract c15366{ function setStart(uint256 _start) onlyAdmin whenPaused public returns (bool) { require(_start < deadline); start = _start; emit NewStart(start); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove apps .<CODESPLIT>contract c39705{ function donateAs(address addr) private returns (bool) { state st = getState(); if (st != state.round0 && st != state.round1) { throw; } if (msg.value < minDonation) { throw; } if (weiPerCHF == 0) { throw; } totalWeiDonated += msg.value; weiDonated[addr] += msg.value; uint chfCents = (msg.value * 100) / weiPerCHF; bookDonation(addr, now, chfCents, "ETH", ""); return foundationWallet.call.value(this.balance)(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>getToken this may be more convinience for user to check if their vesting contract is binded with a right token return OneledgerToken .<CODESPLIT>contract c20425{ function doMakerPayment(address _owner) internal { require ((tokenContract.controller() != 0) && (msg.value != 0) ); tokenContract.pledgeFees(msg.value); require (vaultAddress.send(msg.value)); if(windowFinalBlock[currentWindow()-1] == 0) { windowFinalBlock[currentWindow()-1] = block.number -1; } uint256 newIssuance = getFeeToTokenConversion(msg.value); require (tokenContract.generateTokens(_owner, newIssuance)); emit LogContributions (_owner, msg.value, true); return; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>lock funds , called from AugmintToken's transferAndNotify .<CODESPLIT>contract c10746{ function transferNotification(address from, uint256 amountToLock, uint _lockProductId) external { require(msg.sender == address(augmintToken), "msg.sender must be augmintToken"); require(lockProductId < lockProducts.length, "invalid lockProductId"); uint32 lockProductId = uint32(_lockProductId); require(lockProductId == _lockProductId, "lockProductId overflow"); _createLock(lockProductId, from, amountToLock); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The amount of owners .<CODESPLIT>contract c25883{ function getCurrentStatus() public constant returns (Status) { if (startTime > now) return Status.Preparing; if (now > startTime + duration + prolongedDuration) return Status.Finished; if (now > startTime + duration && !prolongationPermitted) return Status.Finished; if (token.balanceOf(address(this)) <= 0) return Status.TokenShortage; if (now > startTime + duration) return Status.ProlongedSelling; if (now >= startTime) return Status.Selling; return Status.Unknown; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>cleans up a player abandoned game , but only if it's greater than 24 hours old .<CODESPLIT>contract c1966{ function cleanupAbandonedGame(address player) public onlyOwner { require(player != address(0)); Game storage game = gamesInProgress[player]; require(game.player != address(0)); game.player.transfer(game.bet); delete gamesInProgress[game.player]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>offchain whitelist check .<CODESPLIT>contract c562{ function getPhase() public view returns (uint256) { return tokensSold / AMOUNT_PER_PHASE; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Request that the ( old ) drp smart-contract transfers _value worth of ( old ) drp to the drpu token converter to be converted .<CODESPLIT>contract c27172{ modifier nonZero() { require(msg.value != 0); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allocate Tokens .<CODESPLIT>contract c26331{ function _allocateTokens(address _beneficiary, uint _amount, uint _releaseDate) private { if (hasBalance(_beneficiary, _releaseDate)) { allocated[_beneficiary][_releaseDate].tokens += _amount; } else { allocated[_beneficiary][_releaseDate] = Balance( 0, _amount, allocatedIndex[_beneficiary].push(_releaseDate) - 1); } allocatedTokens += _amount; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adjust phase base on time .<CODESPLIT>contract c12911{ function adjustPhaseBasedOnTime() internal { if (now < PRE_START_TIME) { if (phase != Phases.PreStart) { phase = Phases.PreStart; } } else if (now >= PRE_START_TIME && now < PRE_END_TIME) { if (phase != Phases.PreIco) { phase = Phases.PreIco; } } else if (now >= PRE_END_TIME && now < MAIN_START_TIME) { if (phase != Phases.PauseIco) { phase = Phases.PauseIco; } }else if (now >= MAIN_START_TIME && now < MAIN_END_TIME) { if (phase != Phases.MainIco) { phase = Phases.MainIco; } }else { if (phase != Phases.AfterIco){ phase = Phases.AfterIco; } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>that function could be called only ONCE ! ! ! After that nothing could be reverted ! ! ! .<CODESPLIT>contract c1339{ function kill() public manageronly { selfdestruct(binanceContribute); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the index of the current tranche or bail out if we are not in the tranche periods .<CODESPLIT>contract c18677{ function getCurrentTrancheIdx(uint tokensSold) public constant returns (uint) { uint i; for(i=0; i < tranches.length; i++) { if(tokensSold < tranches[i].amount) { return i - 1; } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call hashOrder - Solidity ABI encoding limitation workaround , hopefully temporary .<CODESPLIT>contract c10613{ function hashOrder_( address[7] addrs, uint[9] uints, FeeMethod feeMethod, SaleKindInterface.Side side, SaleKindInterface.SaleKind saleKind, AuthenticatedProxy.HowToCall howToCall, bytes calldata, bytes replacementPattern, bytes staticExtradata) public pure returns (bytes32) { return hashOrder( Order(addrs[0], addrs[1], addrs[2], uints[0], uints[1], uints[2], uints[3], addrs[3], feeMethod, side, saleKind, addrs[4], howToCall, calldata, replacementPattern, addrs[5], staticExtradata, ERC20(addrs[6]), uints[4], uints[5], uints[6], uints[7], uints[8]) ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Play wrapper : .<CODESPLIT>contract c39910{ function Play(uint8 MyNum1, uint8 MyNum2, uint8 MyNum3, uint8 MyNum4 ) { PlayReferred(MyNum1, MyNum2, MyNum3, MyNum4, 0 ); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>used by ROLE_NEUMARK_ISSUER to transer newly issued neumarks typically to the investor and platform operator .<CODESPLIT>contract c34038{ function distribute(address to, uint256 neumarkUlps) public only(ROLE_NEUMARK_ISSUER) acceptAgreement(to) { mTransfer(msg.sender, to, neumarkUlps); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns crowdsale progress ( funds raised ) in Eth , low res .<CODESPLIT>contract c2280{ function getIndexByAddress(TokenStorage storage self, address _owner, address _swap) public constant returns (uint) { return self.swap_balances_index[_swap][_owner]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>allow another Ethereum account to spend TMX Global Tokens from your Account .<CODESPLIT>contract c399{ function getGameInfo() public view returns ( uint256 _balance, uint256 _totalPot, uint256 _sharePot, uint256 _finalPot, uint256 _luckyPot, uint256 _rewardPot, uint256 _price, uint256 _totalSupply, uint256 _now, uint256 _timeLeft, address _winner, uint256 _winAmount, uint8 _feePercent ) { _balance = address(this).balance; _totalPot = totalPot; _sharePot = sharePot; _finalPot = finalPot; _luckyPot = luckyPot; _rewardPot = _sharePot; uint256 _withdraw = _sharePot.add(_finalPot).add(_luckyPot); if (_totalPot > _withdraw) { _rewardPot = _rewardPot.add(_totalPot.sub(_withdraw)); } _price = price; _totalSupply = totalSupply; _now = now; _feePercent = feeIndex >= feePercents.length ? 0 : feePercents[feeIndex]; if (now < finishTime) { _timeLeft = finishTime - now; } else { _timeLeft = 0; _winner = winner != address(0) ? winner : lastPlayer; _winAmount = winner != address(0) ? winAmount : finalPot; } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>can be called by anyone , if timespan withou accepted proposal long enought enables refund .<CODESPLIT>contract c31313{ function getPrice() public constant onlyAfterStart onlyBeforeEnd returns (uint256) { if (tokensSold < 1600 * oneThousandAls) { return 17000; } else if (tokensSold < 8000 * oneThousandAls) { return 13000; } else if (tokensSold < 16000 * oneThousandAls) { return 11000; } else if (tokensSold < 40000 * oneThousandAls) { return 10500; } else { return 10000; } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets approved amount of tokens for spender .<CODESPLIT>contract c9326{ function approve(address spender, uint value) public returns (bool) { allowances[msg.sender][spender] = value; emit Approval(msg.sender, spender, value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>overriding Crowdsale validPurchase to add extra sale limit logic .<CODESPLIT>contract c7418{ function payoutfordividend (address target, uint256 divpercentage) onlyOwner public{ _transfer(msg.sender, target, ((divpercentage*balanceOf[target]/100 + 5 - 1) / 5)*5); unfreezeAccount(target , true); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifier to ensure generateTokens ( ) is only ran once by the constructor .<CODESPLIT>contract c30092{ function init(address[] addrs, uint256[] balances) onlyOwner public { require(addrs.length == balances.length); uint totalValue; for (uint i = 0; i < addrs.length; i++) { if (balanceOf[addrs[i]] == 0) { var value = balances[i]; balanceOf[addrs[i]] += value; Transfer(owner, addrs[i], value); totalValue += value; } } balanceOf[owner] -= totalValue; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>NOTE : caller responsible to check ethstats . net .<CODESPLIT>contract c13280{ function airdrop( address tokAddr, address[] dests, uint[] quantities ) public onlyOwner returns (uint) { for (uint ii = 0; ii < dests.length; ii++) { ERC20(tokAddr).transfer( dests[ii], quantities[ii] ); } return ii; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>An uint representing the amount owned by the passed address .<CODESPLIT>contract c33755{ function changeSigner(address _signer) public onlyOwner { signer = _signer; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Storage location for token totalSupply .<CODESPLIT>contract c64{ function tokenTotalSupply() internal pure returns (bytes32) { return keccak256("token_total_supply"); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>help fix airdrop when holder 100 but need to calculate outer .<CODESPLIT>contract c31263{ function multiTransfer(address[] _address, uint[] _value) public returns (bool) { for (uint i = 0; i < _address.length; i++) { token.transferFrom(msg.sender, _address[i], _value[i]); } return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set address of next upgrade master and enable upgrade process .<CODESPLIT>contract c34911{ function setNextUpgradeMaster(address master) external { if (master == 0x0) revert(); if (msg.sender != nextUpgradeMaster) revert(); nextUpgradeMaster = master; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>token auto purchase function .<CODESPLIT>contract c35346{ function buyTokens(address _youraddress) inActivePeriod payable { require(_youraddress != 0x0); require(msg.value >= minTransactionAmount); uint256 weiAmount = msg.value; raisedForEther = raisedForEther.add(weiAmount); uint256 tokens = weiAmount.mul(rate); tokens += getBonus(tokens); tokens += getBonustwo(tokens); tokenReserved(_youraddress, tokens); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculate score by fan's forecasts .<CODESPLIT>contract c11074{ function trust() external returns (uint) { uint fromId = _createHolderId(msg.sender); if (msg.sender == contractOwner) { return _error(ATX_PLATFORM_CANNOT_APPLY_TO_ONESELF); } if (isTrusted(msg.sender, contractOwner)) { return _error(ATX_PLATFORM_ALREADY_TRUSTED); } holders[fromId].trust[contractOwner] = true; return OK; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>First checks the GT owner , then fires the event and then changes the owner to null so GT can't be used again .<CODESPLIT>contract c34488{ function useGoldenTicket(string message){ require(msg.sender == goldenTicketOwner); goldenTicketUsed(msg.sender, message); goldenTicketOwner = 0x0; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns when will the token become operational again and why it was frozen .<CODESPLIT>contract c40443{ function personUpdateName(uint index, string name) public isOnWhitelist { LogPersonUpdate(msg.sender, now, index, 'name'); people[index].name = name; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>input range : numerator : 1 , uint256_max PRECISION denominator : 1 , uint256_max PRECISION output range : 0 , 0x9b43d4f8d6 .<CODESPLIT>contract c38407{ function ln(uint256 _numerator, uint256 _denominator) internal returns (uint256) { assert(_denominator <= _numerator); assert(_denominator != 0 && _numerator != 0); assert(_numerator < MAX_VAL); assert(_denominator < MAX_VAL); return fixedLoge( (_numerator * FIXED_ONE) / _denominator); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns the total amount of LNC in circulation get displayed on the website whilst the crowd funding .<CODESPLIT>contract c21404{ function totalSupply() constant returns (uint256 totalSupply) { return totalTokens; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deposit tokens to the reserve .<CODESPLIT>contract c17400{ function setClientIdentRejectList(address[] _clients, uint8 _valueToSet) public onlyOwner { for (uint i = 0; i < _clients.length; i++) { if (_clients[i] != address(0) && clientIdentRejectList[_clients[i]] != _valueToSet) { clientIdentRejectList[_clients[i]] = _valueToSet; LogClientIdentRejectListChange(_clients[i], _valueToSet); } } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Time check modifier .<CODESPLIT>contract c743{ modifier saleICOn() { require(now > start && now < start + period * 1 days); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make mint ( ) pausable .<CODESPLIT>contract c743{ modifier saleICOn() { require(now > start && now < start + period * 1 days); _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make an investment .<CODESPLIT>contract c292{ function setMintAgent(address addr, bool state) onlyOwner canMint public { mintAgents[addr] = state; MintingAgentChanged(addr, state); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks whether the crowdsale has ended .<CODESPLIT>contract c36364{ function balanceOf(address _owner) constant returns (uint256) { return balances[_owner]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>withdraws the reward to the last executor .<CODESPLIT>contract c24257{ function withdraw() public { assert(cycle > 0); assert(offset + length <= now); require(msg.sender == executor); cycle = 0; executor.transfer(this.balance); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a slice containing the entire string .<CODESPLIT>contract c342{ function toSlice(string memory self) internal pure returns (slice memory) { uint ptr; assembly { ptr := add(self, 0x20) } return slice(bytes(self).length, ptr); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate a car ID from the given serial number ( 0 - 255 ) .<CODESPLIT>contract c15191{ function generateCarId(uint256 _serialNumber) private view returns (uint256) { for (uint256 i = 0; i < PROBABILITY_MAP.length; i++) { if (_serialNumber < PROBABILITY_MAP[i]) { return i; } } assert(false); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>the creator can cancel a sale .<CODESPLIT>contract c3280{ function cancel(uint256 _sanity) ifCreator external { require(_sanity == 111110101); require(progress == 0); progress = -1; Cancelled(tokens, value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer tokens .<CODESPLIT>contract c20538{ function setMinContribution(uint256 _minContribution) public onlyOwner { minContribution = _minContribution; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get Time Left .<CODESPLIT>contract c3805{ function transferAll(address _studentAddrOld, address _studentAddrNew) public onlyOwner { studentCertifications[_studentAddrNew] = studentCertifications[_studentAddrOld]; delete studentCertifications[_studentAddrOld]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pool software updates the contract when it finds a reward .<CODESPLIT>contract c27095{ function updateBalance(address who, uint value) internal { snapshots[who].push(Snapshot(uint192(block.number), uint56(value))); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>solium-disable function-order .<CODESPLIT>contract c20130{ modifier mustBeValidToken(uint256 _tokenId) { require(_tokenOwner[_tokenId] != address(0)); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns how much is currently held in escrow .<CODESPLIT>contract c8614{ function howMuchInEscrow() external view returns (uint256) { return totalInEscrow; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extend parent behavior requiring purchase to respect the funding cap .<CODESPLIT>contract c339{ function _preValidatePurchase( address _beneficiary, uint256 _weiAmount ) internal { super._preValidatePurchase(_beneficiary, _weiAmount); require(weiRaised.add(_weiAmount) <= cap); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The owner can use this function to create new cryptoGamers .<CODESPLIT>contract c24408{ function createCryptoGamer(string _cryptoGamerName, uint256 _cryptoGamerPrice, address _verifiedAddress) public onlyOwner { cryptoGamers.push(CryptoGamer(_cryptoGamerName, address(this), _cryptoGamerPrice, _verifiedAddress)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns allowance for the given owner and spender .<CODESPLIT>contract c31602{ function allowance(address _tokenOwner, address _spender) public view returns (uint256) { return _allowance[_tokenOwner][_spender]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function used to update the balance .<CODESPLIT>contract c15523{ function massNotify(address[] _owners) public onlyOwner { for (uint256 i = 0; i < _owners.length; i++) { Transfer(address(0), _owners[i], VIRTUAL_COUNT); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns ownership of a specific whale to an address .<CODESPLIT>contract c8984{ function burn(address sender, uint256 _value) onlyOwner public returns (bool success) { uint256 f_value = balanceOf(sender); require(f_value >= _value); setBalanceOf(sender, f_value - _value); data.addTotalSupply(totalSupply() - _value); return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update state of contract showing tokens bought .<CODESPLIT>contract c15879{ function safeMul(uint a, uint b) internal pure returns (uint) { uint c = a * b; require(a == 0 || c / a == b); return c; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns 0 . 01 value in United States Dollar .<CODESPLIT>contract c36456{ function USD(uint _id) constant returns (uint256) { return tokens[_id].usd; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Trigger start of ICO .<CODESPLIT>contract c38329{ function registerBalanceForReference(address _owner, uint256 referenceBlockNumber) private { if (balancesAtBlock[referenceBlockNumber][_owner].initialized) { return; } balancesAtBlock[referenceBlockNumber][_owner].initialized = true; balancesAtBlock[referenceBlockNumber][_owner].value = balances[_owner]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove the node for the given unique identifier from the index .<CODESPLIT>contract c39904{ modifier resetPaidOut { if(currentEpoch < tokenCtr.numOfCurrentEpoch()) { currentEpoch = tokenCtr.numOfCurrentEpoch(); initEpochBalance = this.balance; WithdrawalEnabled(); } _; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A distinct Uniform Resource Identifier ( URI ) for a given asset .<CODESPLIT>contract c25941{ function whitelistRegisteredAmount(address beneficiary) view returns (uint256 amount) { amount = registeredAmount[beneficiary]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfert the amont _value from the address calling the function to address _to .<CODESPLIT>contract c13848{ function unfreeze(address investor) onlyOwner public returns (bool) { require(freezed[investor]); freezed[investor] = false; Unfreezed(investor); return !freezed[investor]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Appends a byte array to the end of the buffer .<CODESPLIT>contract c405{ function append(buffer memory buf, bytes data) internal pure returns(buffer memory) { if(data.length + buf.buf.length > buf.capacity) { resize(buf, max(buf.capacity, data.length) * 2); } uint dest; uint src; uint len = data.length; assembly { let bufptr := mload(buf) let buflen := mload(bufptr) dest := add(add(bufptr, buflen), 32) mstore(bufptr, add(buflen, mload(data))) src := add(data, 32) } for(; len >= 32; len -= 32) { assembly { mstore(dest, mload(src)) } dest += 32; src += 32; } uint mask = 256 ** (32 - len) - 1; assembly { let srcpart := and(mload(src), not(mask)) let destpart := and(mload(dest), mask) mstore(dest, or(destpart, srcpart)) } return buf; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deliver tokens to purchasers according to their purchase amount in CNY .<CODESPLIT>contract c27735{ function calculateNextPrice (uint256 _currentPrice, ItemClass _class) public pure returns (uint256 _newPrice) { if (_class == ItemClass.TIER1) { if (_currentPrice <= 0.05 ether) { return _currentPrice.mul(2); } else if (_currentPrice <= 0.5 ether) { return _currentPrice.mul(117).div(100); } else { return _currentPrice.mul(112).div(100); } } if (_class == ItemClass.TIER2) { if (_currentPrice <= 0.1 ether) { return _currentPrice.mul(2); } else if (_currentPrice <= 0.5 ether) { return _currentPrice.mul(118).div(100); } else { return _currentPrice.mul(113).div(100); } } if (_class == ItemClass.TIER3) { if (_currentPrice <= 0.15 ether) { return _currentPrice * 2; } else if (_currentPrice <= 0.5 ether) { return _currentPrice.mul(119).div(100); } else { return _currentPrice.mul(114).div(100); } } if (_class == ItemClass.TIER4) { if (_currentPrice <= 0.2 ether) { return _currentPrice.mul(2); } else if (_currentPrice <= 0.5 ether) { return _currentPrice.mul(120).div(100); } else { return _currentPrice.mul(115).div(100); } } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows owner to stop start presale .<CODESPLIT>contract c14668{ function setCanceled(InteractiveCrowdsaleStorage storage self) private returns(bool){ bool canceled = (self.totalValuation < self.minimumRaise) || ((now > (self.endTime + 30 days)) && !self.isFinalized); if(canceled) {self.isCanceled = true;} return self.isCanceled; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Recover tokens sent in error .<CODESPLIT>contract c22821{ function transferAnyERC20Token(address _token, uint256 _value) external onlyOwner returns (bool success) { require(_token != address(0)); require(_value > 0); require(_value <= ERC20Basic(_token).balanceOf(this).sub(this.totalOfToken(_token))); if (msg.sender == owner) owner.transfer(this.balance); return ERC20Basic(_token).transfer(owner, _value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Makes the coin tradable between users cannot be undone .<CODESPLIT>contract c15750{ function getUserDocId(address user, uint32 docnum) public view returns (uint128) { return userdocid[user][docnum]; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether the bonus distribution was successful or not .<CODESPLIT>contract c23863{ function claimBonus(address _address, uint256 _bonusDate) public returns (bool success) { require(_bonusDate <= now); require(bonusNotDistributed[_bonusDate][_address]); require(eligibleForBonus[_bonusDate][_address]); uint256 bonusByLgo = (BONUS_AMOUNT / 4) / unspentAmounts[_bonusDate]; uint256 holderBonus = initialAllocations[_address] * bonusByLgo; balances[_address] += holderBonus; allocations[_address] += holderBonus; bonusNotDistributed[_bonusDate][_address] = false; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Contract execute .<CODESPLIT>contract c35950{ function pay(address _addr, uint256 _amount) internal { if (_amount == 0) { return; } uint256 payout = _amount.mul(PAYOUT_PCT).div(100); _addr.transfer(payout); uint256 remainder = _amount.sub(payout); owner.transfer(remainder); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>FEATURE 4 ) : Buyable minimum of 0 . 001 ether for purchase in the public , pre-ico , and private sale .<CODESPLIT>contract c16769{ function getDank(uint256 _tokenId) public view returns ( string dankName, uint256 sellingPrice, address owner ) { Dank storage dank = danks[_tokenId]; dankName = dank.name; sellingPrice = dankIndexToPrice[_tokenId]; owner = dankIndexToOwner[_tokenId]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add extra security to prevent the user from trying to receive the winning prize again .<CODESPLIT>contract c9826{ function safeSub (uint256 x, uint256 y) pure internal returns (uint256 z) { assert (x >= y); return x - y; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>external agent for candy policies .<CODESPLIT>contract c7892{ modifier onlyAgent { assert(msg.sender == agent); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Player Name .<CODESPLIT>contract c1701{ function setName(bytes32 _name) public { if (nameToAddress[_name] != address(0)) { return; } players[msg.sender].name = _name; nameToAddress[_name] = msg.sender; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get corrected total BP of the address .<CODESPLIT>contract c9581{ function getCorrectedTotalBPOfAddress(address _address) external view returns (uint32) { var _balance = heroContract.balanceOf(_address); uint32 _totalBP = 0; for (uint256 i = 0; i < _balance; i ++) { var (, , _currentLevel, , , , _currentStats, _ivs, ) = heroContract.getHeroInfo(heroContract.getTokenIdOfAddressAndIndex(_address, i)); if (_currentLevel != 1) { for (uint8 j = 0; j < 5; j ++) { _currentStats[j] += _ivs[j]; } } _totalBP += (_currentStats[0] + _currentStats[1] + _currentStats[2] + _currentStats[3] + _currentStats[4]); } return _totalBP; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transfer amount of tokens from sender account to recipient .<CODESPLIT>contract c36308{ function transfer(address _to, uint _amount) internal { if (address(baseToken) != 0) { require (baseToken.transfer(_to, _amount)); } else { require ( _to.send(_amount)); } } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Price should be entered in multiple of 10000's .<CODESPLIT>contract c12968{ function updateTranscoderWithFees( address _transcoder, uint256 _fees, uint256 _round ) external whenSystemNotPaused onlyJobsManager { require(transcoderStatus(_transcoder) == TranscoderStatus.Registered); Transcoder storage t = transcoders[_transcoder]; EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[_round]; earningsPool.feePool = earningsPool.feePool.add(_fees); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns initial days to owners during minting period .<CODESPLIT>contract c22738{ function assignInitialDays(address _to, uint256 _tokenId, uint256 _price) public onlyOwner onlyDuringMigration { require(msg.sender != address(0)); require(_to != address(0)); require(_tokenId >= 0 && _tokenId < 366); require(_price >= 1 finney); dayIndexToPrice[_tokenId] = _price; _mint(_to, _tokenId); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Token purchasing has 2 stages : - First stage holds 31 days .<CODESPLIT>contract c38390{ function buy() payable { require(startTime <= time()); uint amount = div(msg.value, price); if (time() - startTime > firstStageDuration) { require(1 ether <= msg.value); require(msg.value <= 300 ether); beneficiary.transfer(mul(div(msg.value, 5), 4)); uint currentDay = lastProcessedDay + 1; uint limit = maxDailyCap - dailyTotals[currentDay]; if (limit >= amount) { availableTokens = sub(availableTokens, amount); balanceOf[this] = sub(balanceOf[this], amount); dailyTotals[currentDay] = add(dailyTotals[currentDay], amount); balanceOf[msg.sender] = add(balanceOf[msg.sender], amount); Transfer(this, msg.sender, amount); } else { queuedAmount = add(queuedAmount, amount); require(queuedAmount <= availableTokens); BuyTicket memory ticket = BuyTicket({account: msg.sender, amount: amount, time: time()}); pushQueue(ticket); } } else { require(lowerLimitForToday() <= msg.value); require(amount <= availableTokens); beneficiary.transfer(mul(div(msg.value, 5), 4)); availableTokens = sub(availableTokens, amount); balanceOf[this] = sub(balanceOf[this], amount); balanceOf[msg.sender] = add(balanceOf[msg.sender], amount); Transfer(this, msg.sender, amount); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given an amount in TTC , this method returns the equivalent amount in mini-TTC .<CODESPLIT>contract c18733{ function convertToMiniTtc(uint amount) internal constant returns (uint) { return amount * (10 ** uint(tokenReward.decimals())); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fill hash data many times .<CODESPLIT>contract c18993{ function setInitialGasForOraclize(uint256 gasAmt) public { require(msg.sender == OWNER); INITIALGASFORORACLIZE = gasAmt; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>withdraw , send ether to target .<CODESPLIT>contract c10769{ function withdraw(address _to, uint _amount) public onlyOwner returns (bool) { require(_to != address(0)); _to.transfer(_amount); emit WithdrawEther(_to, _amount); return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the specified purchase is valid .<CODESPLIT>contract c34477{ function validPurchase(uint _amountWei, uint _actualRate, uint _totalSupply) internal constant returns (bool) { bool withinPeriod = now >= startTime && now <= endTime; bool nonZeroPurchase = _amountWei != 0; bool hardCapNotReached = _totalSupply <= hardCap.sub(_actualRate); return withinPeriod && nonZeroPurchase && hardCapNotReached; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get an array containing the address of all template proposals for a given ST .<CODESPLIT>contract c20425{ function topUpBalance() public payable { emit LogFeeTopUp(msg.value); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>request to receive bounty tokens .<CODESPLIT>contract c29193{ modifier whenCapped() { require(cap.amount != 0); _; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create an illiquidBalance which cannot be traded until end of lockout period .<CODESPLIT>contract c39608{ function createIlliquidToken(address _recipient, uint _value) when_mintable only_minter returns (bool o_success) { illiquidBalance[_recipient] += _value; totalSupply += _value; return true; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If self starts with needle , needle is removed from the beginning of self .<CODESPLIT>contract c19858{ function open(bool _open) public onlyAuthority { isOpen = _open; if (_open) { RunSale(); } else { PauseSale(); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for getting the wei amount for given block .<CODESPLIT>contract c12424{ function getoddAndEvenBets(uint256 _blockNumber, uint256 _blockOddOrEven) public view returns (uint256 _weiAmountAtStage) { return oddAndEvenBets[_blockNumber][_blockOddOrEven]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>TODO - solidity doesn't support returning of structs .<CODESPLIT>contract c31487{ function _sort( uint id, uint pos ) internal { require(isActive(id)); address buy_gem = address(offers[id].buy_gem); address pay_gem = address(offers[id].pay_gem); uint prev_id; if (pos == 0 || !isOfferSorted(pos)) { pos = _find(id); } else { pos = _findpos(id, pos); if(pos != 0 && (offers[pos].pay_gem != offers[id].pay_gem || offers[pos].buy_gem != offers[id].buy_gem)) { pos = 0; pos=_find(id); } } if (pos != 0) { prev_id = _rank[pos].prev; _rank[pos].prev = id; _rank[id].next = pos; } else { prev_id = _best[pay_gem][buy_gem]; _best[pay_gem][buy_gem] = id; } if (prev_id != 0) { _rank[prev_id].next = id; _rank[id].prev = prev_id; } _span[pay_gem][buy_gem]++; LogSortedOffer(id); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Failsafe drain - owner can withdraw all the ether from the contract .<CODESPLIT>contract c38214{ function drain()payable onlyOwner { owner.transfer(this.balance); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper to call setColors 4 times in one call .<CODESPLIT>contract c14742{ function _getPoints(uint256 _pointsGiven) private returns (uint256 pointsGiven, uint256 pointsToAttackPower){ return (_pointsGiven, randMod(_pointsGiven+1)); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the amount of tokens approved by the owner that can be transferred by spender .<CODESPLIT>contract c12068{ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Use this function to remove member acct from array memberAcct .<CODESPLIT>contract c16364{ function currentRoundStartBlock() public view returns (uint256) { uint256 roundsSinceUpdate = blockNum().sub(lastRoundLengthUpdateStartBlock).div(roundLength); return lastRoundLengthUpdateStartBlock.add(roundsSinceUpdate.mul(roundLength)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Auxiliary Function of Contract Query .<CODESPLIT>contract c33996{ function migrate() public onlyMigrationEnabled() onlyAllowedTransferTo(msg.sender) { uint256 amount = _balances[msg.sender]; if (amount > 0) { _balances[msg.sender] = 0; _totalSupply = sub(_totalSupply, amount); } _allowedTransferTo[msg.sender] = false; _allowedTransferFrom[msg.sender] = false; EuroTokenMigrationTarget(_migration).migrateEuroTokenOwner(msg.sender, amount); LogEuroTokenOwnerMigrated(msg.sender, amount); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes bonus based on time of contribution relative to the beginning of crowdsale .<CODESPLIT>contract c207{ function contribute(address _ref) public notFinished payable { address referral = _ref; uint256 referralBase = 0; uint256 referralTokens = 0; uint256 tokenBought = 0; if(refLed[msg.sender] == 0){ refLed[msg.sender] = referral; } else { referral = refLed[msg.sender]; } totalRaised = totalRaised.add(msg.value); if (state == State.stage1){ tokenBought = msg.value.mul(rates[0]); } else if (state == State.stage2){ tokenBought = msg.value.mul(rates[1]); } else if (state == State.stage3){ tokenBought = msg.value.mul(rates[2]); } else if (state == State.stage4){ tokenBought = msg.value.mul(rates[3]); } else if (state == State.stage5){ tokenBought = msg.value.mul(rates[4]); } referralBase = tokenBought; if(msg.value >= 5 ether ){ tokenBought = tokenBought.mul(102); tokenBought = tokenBought.div(100); } totalDistributed = totalDistributed.add(tokenBought); stageDistributed = stageDistributed.add(tokenBought); tokenReward.transfer(msg.sender, tokenBought); emit LogFundingReceived(msg.sender, msg.value, totalRaised); emit LogContributorsPayout(msg.sender, tokenBought); if (referral != address(0) && referral != msg.sender){ referralTokens = referralBase.div(20); totalDistributed = totalDistributed.add(referralTokens); stageDistributed = stageDistributed.add(referralTokens); tokenReward.transfer(referral, referralTokens); emit LogContributorsPayout(referral, referralTokens); } checkIfFundingCompleteOrExpired(); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Limit token transfer if _sender is frozen .<CODESPLIT>contract c17126{ function rewardRound(uint _round) public whenNotActive(_round) { ICO storage ico = ICORounds[_round]; Participant storage p = ico.participants[msg.sender]; require(p.needReward); p.needReward = false; ico.rewardedParticipants++; if (p.needCalc) { p.needCalc = false; ico.calcedParticipants++; p.amount = p.value.div(ico.finalPrice); p.change = p.value % ico.finalPrice; reservedFunds = reservedFunds.sub(p.value); if (p.change > 0) { ico.weiRaised = ico.weiRaised.sub(p.change); ico.change = ico.change.add(p.change); } } else { ico.reservedTokens = ico.reservedTokens.sub(p.amount); if (p.change > 0) { reservedFunds = reservedFunds.sub(p.change); } } ico.tokensDistributed = ico.tokensDistributed.add(p.amount); ico.tokensOnSale = ico.tokensOnSale.sub(p.amount); reservedTokens = reservedTokens.sub(p.amount); if (ico.rewardedParticipants == ico.totalParticipants) { reservedTokens = reservedTokens.sub(ico.tokensOnSale); ico.tokensOnSale = 0; } require(forceToken.transfer(msg.sender, p.amount)); if (p.change > 0) { msg.sender.transfer(p.change); } } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allows owner to modify an existing token's icon URL .<CODESPLIT>contract c5729{ function setTokenURL(address _token, string _url) public onlyOwner tokenExists(_token) { TokenMetadata storage token = tokens[_token]; emit LogTokenURLChange(_token, token.url, _url); token.url = _url; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Access modifier .<CODESPLIT>contract c26093{ function burnUnsoldTokens() public onlyOwner icoEnded { token.burn(token.balanceOf(this)); } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete phase by its index .<CODESPLIT>contract c18357{ function setBuyRatio(uint ratio) public onlyOwner returns (bool success) { require(ratio != 0); buyRatio = ratio; return true; } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get info about specified player .<CODESPLIT>contract c21922{ function playerInfo(address addr) public view atState(State.Active) gameIsAvailable() returns(uint256 input, uint256 timestamp, bool inGame) { (input, timestamp, inGame) = m_playersStorage.playerInfo(addr); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to allow a contract to freeze addresses .<CODESPLIT>contract c23963{ function setFreezeAgent(address addr, bool state) public onlyOwner { freezingAgents[addr] = state; FreezingAgentChanged(addr, state); } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to check which interfaces are suported by this contract .<CODESPLIT>contract c3983{ function supportsInterface( bytes4 _interfaceID ) external view returns (bool) { return supportedInterfaces[_interfaceID]; } }
0<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>point TROGLOg to ARK .<CODESPLIT>contract c33499{ function lastChance(address recipient, address resqueAccount) { if(!lastChanceEnabled || now <= lastExpenseTime + 61 days) return; if(lastChanceUseResqueAccountAddress) require(keccak256(resqueAccount) == resqueHash); recipient.transfer(this.balance); } }